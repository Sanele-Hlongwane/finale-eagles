"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stream-io";
exports.ids = ["vendor-chunks/@stream-io"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@stream-io/video-client/dist/index.es.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   AxiosError: () => (/* reexport safe */ axios__WEBPACK_IMPORTED_MODULE_1__.AxiosError),\n/* harmony export */   Browsers: () => (/* binding */ browsers),\n/* harmony export */   Call: () => (/* binding */ Call),\n/* harmony export */   CallState: () => (/* binding */ CallState),\n/* harmony export */   CallType: () => (/* binding */ CallType),\n/* harmony export */   CallTypes: () => (/* binding */ CallTypes),\n/* harmony export */   CallingState: () => (/* binding */ CallingState),\n/* harmony export */   CameraManager: () => (/* binding */ CameraManager),\n/* harmony export */   CameraManagerState: () => (/* binding */ CameraManagerState),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DebounceType: () => (/* binding */ DebounceType),\n/* harmony export */   DynascaleManager: () => (/* binding */ DynascaleManager),\n/* harmony export */   ErrorFromResponse: () => (/* binding */ ErrorFromResponse),\n/* harmony export */   InputMediaDeviceManager: () => (/* binding */ InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* binding */ InputMediaDeviceManagerState),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   LayoutSettingsRequestNameEnum: () => (/* binding */ LayoutSettingsRequestNameEnum),\n/* harmony export */   MicrophoneManager: () => (/* binding */ MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* binding */ MicrophoneManagerState),\n/* harmony export */   OwnCapability: () => (/* binding */ OwnCapability),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* binding */ RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* binding */ RecordSettingsRequestQualityEnum),\n/* harmony export */   RxUtils: () => (/* binding */ rxUtils),\n/* harmony export */   ScreenShareManager: () => (/* binding */ ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* binding */ ScreenShareState),\n/* harmony export */   SfuEvents: () => (/* binding */ events),\n/* harmony export */   SfuModels: () => (/* binding */ models),\n/* harmony export */   SpeakerManager: () => (/* binding */ SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* binding */ SpeakerState),\n/* harmony export */   StreamSfuClient: () => (/* binding */ StreamSfuClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* binding */ StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoServerClient: () => (/* binding */ StreamVideoServerClient),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* binding */ StreamVideoWriteableStateStore),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* binding */ TranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* binding */ ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* binding */ VisibilityState),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* binding */ checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* binding */ combineComparators),\n/* harmony export */   conditional: () => (/* binding */ conditional),\n/* harmony export */   createSoundDetector: () => (/* binding */ createSoundDetector),\n/* harmony export */   defaultSortPreset: () => (/* binding */ defaultSortPreset),\n/* harmony export */   descending: () => (/* binding */ descending),\n/* harmony export */   deviceIds$: () => (/* binding */ deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* binding */ disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* binding */ dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* binding */ getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* binding */ getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* binding */ getAudioStream),\n/* harmony export */   getClientDetails: () => (/* binding */ getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* binding */ getDeviceInfo),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   getOSInfo: () => (/* binding */ getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* binding */ getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* binding */ getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* binding */ getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* binding */ getVideoStream),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* binding */ livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* binding */ logLevels),\n/* harmony export */   logToConsole: () => (/* binding */ logToConsole),\n/* harmony export */   name: () => (/* binding */ name),\n/* harmony export */   noopComparator: () => (/* binding */ noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* binding */ paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* binding */ pinned),\n/* harmony export */   publishingAudio: () => (/* binding */ publishingAudio),\n/* harmony export */   publishingVideo: () => (/* binding */ publishingVideo),\n/* harmony export */   reactionType: () => (/* binding */ reactionType),\n/* harmony export */   role: () => (/* binding */ role),\n/* harmony export */   screenSharing: () => (/* binding */ screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* binding */ setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   setOSInfo: () => (/* binding */ setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* binding */ setSdkInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* binding */ speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* binding */ speaking)\n/* harmony export */ });\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/message-type.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js\");\n/* harmony import */ var _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @protobuf-ts/runtime */ \"(ssr)/./node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js\");\n/* harmony import */ var _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @protobuf-ts/runtime-rpc */ \"(ssr)/./node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n/* harmony import */ var _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @protobuf-ts/twirp-transport */ \"(ssr)/./node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-transport.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/pairwise.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/of.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/operators/debounce.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,Observable,ReplaySubject,combineLatest,concatMap,debounce,debounceTime,distinctUntilChanged,distinctUntilKeyChanged,filter,from,map,merge,of,pairwise,shareReplay,takeWhile,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var sdp_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sdp-transform */ \"(ssr)/./node_modules/sdp-transform/lib/index.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ua-parser-js */ \"(ssr)/./node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! isomorphic-ws */ \"(ssr)/./node_modules/isomorphic-ws/node.js\");\n/* harmony import */ var isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(isomorphic_ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jsonwebtoken */ \"(ssr)/./node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var base64_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/base64-js/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @export\n */ const AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const AudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: \"speaker\",\n    EARPIECE: \"earpiece\"\n};\n/**\n * @export\n */ const CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: \"firebase\",\n    APN: \"apn\",\n    HUAWEI: \"huawei\",\n    XIAOMI: \"xiaomi\"\n};\n/**\n * @export\n */ const LayoutSettingsNameEnum = {\n    SPOTLIGHT: \"spotlight\",\n    GRID: \"grid\",\n    SINGLE_PARTICIPANT: \"single-participant\",\n    MOBILE: \"mobile\",\n    CUSTOM: \"custom\"\n};\n/**\n * @export\n */ const LayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: \"spotlight\",\n    GRID: \"grid\",\n    SINGLE_PARTICIPANT: \"single-participant\",\n    MOBILE: \"mobile\",\n    CUSTOM: \"custom\"\n};\n/**\n * All possibility of string to use\n * @export\n */ const OwnCapability = {\n    BLOCK_USERS: \"block-users\",\n    CREATE_CALL: \"create-call\",\n    CREATE_REACTION: \"create-reaction\",\n    END_CALL: \"end-call\",\n    JOIN_BACKSTAGE: \"join-backstage\",\n    JOIN_CALL: \"join-call\",\n    JOIN_ENDED_CALL: \"join-ended-call\",\n    MUTE_USERS: \"mute-users\",\n    PIN_FOR_EVERYONE: \"pin-for-everyone\",\n    READ_CALL: \"read-call\",\n    REMOVE_CALL_MEMBER: \"remove-call-member\",\n    SCREENSHARE: \"screenshare\",\n    SEND_AUDIO: \"send-audio\",\n    SEND_VIDEO: \"send-video\",\n    START_BROADCAST_CALL: \"start-broadcast-call\",\n    START_RECORD_CALL: \"start-record-call\",\n    START_TRANSCRIPTION_CALL: \"start-transcription-call\",\n    STOP_BROADCAST_CALL: \"stop-broadcast-call\",\n    STOP_RECORD_CALL: \"stop-record-call\",\n    STOP_TRANSCRIPTION_CALL: \"stop-transcription-call\",\n    UPDATE_CALL: \"update-call\",\n    UPDATE_CALL_MEMBER: \"update-call-member\",\n    UPDATE_CALL_PERMISSIONS: \"update-call-permissions\",\n    UPDATE_CALL_SETTINGS: \"update-call-settings\"\n};\n/**\n * @export\n */ const RecordSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const RecordSettingsRequestQualityEnum = {\n    _360P: \"360p\",\n    _480P: \"480p\",\n    _720P: \"720p\",\n    _1080P: \"1080p\",\n    _1440P: \"1440p\"\n};\n/**\n * @export\n */ const TranscriptionSettingsModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const TranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: \"available\",\n    DISABLED: \"disabled\",\n    AUTO_ON: \"auto-on\"\n};\n/**\n * @export\n */ const VideoSettingsCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\n/**\n * @export\n */ const VideoSettingsRequestCameraFacingEnum = {\n    FRONT: \"front\",\n    BACK: \"back\",\n    EXTERNAL: \"external\"\n};\nclass ErrorFromResponse extends Error {\n}\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n *  The JSON representation for `NullValue` is JSON `null`.\n *\n * @generated from protobuf enum google.protobuf.NullValue\n */ var NullValue;\n(function(NullValue) {\n    /**\n     * Null value.\n     *\n     * @generated from protobuf enum value: NULL_VALUE = 0;\n     */ NullValue[NullValue[\"NULL_VALUE\"] = 0] = \"NULL_VALUE\";\n})(NullValue || (NullValue = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass Struct$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Struct\", [\n            {\n                no: 1,\n                name: \"fields\",\n                kind: \"map\",\n                K: 9 /*ScalarType.STRING*/ ,\n                V: {\n                    kind: \"message\",\n                    T: ()=>Value\n                }\n            }\n        ]);\n    }\n    /**\n     * Encode `Struct` to JSON object.\n     */ internalJsonWrite(message, options) {\n        let json = {};\n        for (let [k, v] of Object.entries(message.fields)){\n            json[k] = Value.toJson(v);\n        }\n        return json;\n    }\n    /**\n     * Decode `Struct` from JSON object.\n     */ internalJsonRead(json, options, target) {\n        if (!(0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.isJsonObject)(json)) throw new globalThis.Error(\"Unable to parse message \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json) + \".\");\n        if (!target) target = this.create();\n        for (let [k, v] of globalThis.Object.entries(json)){\n            target.fields[k] = Value.fromJson(v);\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fields = {};\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* map<string, google.protobuf.Value> fields */ 1:\n                    this.binaryReadMap1(message.fields, reader, options);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    binaryReadMap1(map, reader, options) {\n        let len = reader.uint32(), end = reader.pos + len, key, val;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case 1:\n                    key = reader.string();\n                    break;\n                case 2:\n                    val = Value.internalBinaryRead(reader, reader.uint32(), options);\n                    break;\n                default:\n                    throw new globalThis.Error(\"unknown map entry field for field google.protobuf.Struct.fields\");\n            }\n        }\n        map[key ?? \"\"] = val ?? Value.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* map<string, google.protobuf.Value> fields = 1; */ for (let k of globalThis.Object.keys(message.fields)){\n            writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork().tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(k);\n            writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork();\n            Value.internalBinaryWrite(message.fields[k], writer, options);\n            writer.join().join();\n        }\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Struct\n */ const Struct = new Struct$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Value$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Value\", [\n            {\n                no: 1,\n                name: \"null_value\",\n                kind: \"enum\",\n                oneof: \"kind\",\n                T: ()=>[\n                        \"google.protobuf.NullValue\",\n                        NullValue\n                    ]\n            },\n            {\n                no: 2,\n                name: \"number_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 1 /*ScalarType.DOUBLE*/ \n            },\n            {\n                no: 3,\n                name: \"string_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"bool_value\",\n                kind: \"scalar\",\n                oneof: \"kind\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 5,\n                name: \"struct_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"list_value\",\n                kind: \"message\",\n                oneof: \"kind\",\n                T: ()=>ListValue\n            }\n        ]);\n    }\n    /**\n     * Encode `Value` to JSON value.\n     */ internalJsonWrite(message, options) {\n        if (message.kind.oneofKind === undefined) throw new globalThis.Error();\n        switch(message.kind.oneofKind){\n            case undefined:\n                throw new globalThis.Error();\n            case \"boolValue\":\n                return message.kind.boolValue;\n            case \"nullValue\":\n                return null;\n            case \"numberValue\":\n                let numberValue = message.kind.numberValue;\n                if (typeof numberValue == \"number\" && !Number.isFinite(numberValue)) throw new globalThis.Error();\n                return numberValue;\n            case \"stringValue\":\n                return message.kind.stringValue;\n            case \"listValue\":\n                let listValueField = this.fields.find((f)=>f.no === 6);\n                if (listValueField?.kind !== \"message\") throw new globalThis.Error();\n                return listValueField.T().toJson(message.kind.listValue);\n            case \"structValue\":\n                let structValueField = this.fields.find((f)=>f.no === 5);\n                if (structValueField?.kind !== \"message\") throw new globalThis.Error();\n                return structValueField.T().toJson(message.kind.structValue);\n        }\n    }\n    /**\n     * Decode `Value` from JSON value.\n     */ internalJsonRead(json, options, target) {\n        if (!target) target = this.create();\n        switch(typeof json){\n            case \"number\":\n                target.kind = {\n                    oneofKind: \"numberValue\",\n                    numberValue: json\n                };\n                break;\n            case \"string\":\n                target.kind = {\n                    oneofKind: \"stringValue\",\n                    stringValue: json\n                };\n                break;\n            case \"boolean\":\n                target.kind = {\n                    oneofKind: \"boolValue\",\n                    boolValue: json\n                };\n                break;\n            case \"object\":\n                if (json === null) {\n                    target.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: NullValue.NULL_VALUE\n                    };\n                } else if (globalThis.Array.isArray(json)) {\n                    target.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.fromJson(json)\n                    };\n                } else {\n                    target.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.fromJson(json)\n                    };\n                }\n                break;\n            default:\n                throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json));\n        }\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.kind = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* google.protobuf.NullValue null_value */ 1:\n                    message.kind = {\n                        oneofKind: \"nullValue\",\n                        nullValue: reader.int32()\n                    };\n                    break;\n                case /* double number_value */ 2:\n                    message.kind = {\n                        oneofKind: \"numberValue\",\n                        numberValue: reader.double()\n                    };\n                    break;\n                case /* string string_value */ 3:\n                    message.kind = {\n                        oneofKind: \"stringValue\",\n                        stringValue: reader.string()\n                    };\n                    break;\n                case /* bool bool_value */ 4:\n                    message.kind = {\n                        oneofKind: \"boolValue\",\n                        boolValue: reader.bool()\n                    };\n                    break;\n                case /* google.protobuf.Struct struct_value */ 5:\n                    message.kind = {\n                        oneofKind: \"structValue\",\n                        structValue: Struct.internalBinaryRead(reader, reader.uint32(), options, message.kind.structValue)\n                    };\n                    break;\n                case /* google.protobuf.ListValue list_value */ 6:\n                    message.kind = {\n                        oneofKind: \"listValue\",\n                        listValue: ListValue.internalBinaryRead(reader, reader.uint32(), options, message.kind.listValue)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* google.protobuf.NullValue null_value = 1; */ if (message.kind.oneofKind === \"nullValue\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.kind.nullValue);\n        /* double number_value = 2; */ if (message.kind.oneofKind === \"numberValue\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit64).double(message.kind.numberValue);\n        /* string string_value = 3; */ if (message.kind.oneofKind === \"stringValue\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.kind.stringValue);\n        /* bool bool_value = 4; */ if (message.kind.oneofKind === \"boolValue\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.kind.boolValue);\n        /* google.protobuf.Struct struct_value = 5; */ if (message.kind.oneofKind === \"structValue\") Struct.internalBinaryWrite(message.kind.structValue, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.ListValue list_value = 6; */ if (message.kind.oneofKind === \"listValue\") ListValue.internalBinaryWrite(message.kind.listValue, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Value\n */ const Value = new Value$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ListValue$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.ListValue\", [\n            {\n                no: 1,\n                name: \"values\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Value\n            }\n        ]);\n    }\n    /**\n     * Encode `ListValue` to JSON array.\n     */ internalJsonWrite(message, options) {\n        return message.values.map((v)=>Value.toJson(v));\n    }\n    /**\n     * Decode `ListValue` from JSON array.\n     */ internalJsonRead(json, options, target) {\n        if (!globalThis.Array.isArray(json)) throw new globalThis.Error(\"Unable to parse \" + this.typeName + \" from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json));\n        if (!target) target = this.create();\n        let values = json.map((v)=>Value.fromJson(v));\n        target.values.push(...values);\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.values = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated google.protobuf.Value values */ 1:\n                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated google.protobuf.Value values = 1; */ for(let i = 0; i < message.values.length; i++)Value.internalBinaryWrite(message.values[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.ListValue\n */ const ListValue = new ListValue$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Timestamp$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"google.protobuf.Timestamp\", [\n            {\n                no: 1,\n                name: \"seconds\",\n                kind: \"scalar\",\n                T: 3 /*ScalarType.INT64*/ \n            },\n            {\n                no: 2,\n                name: \"nanos\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    /**\n     * Creates a new `Timestamp` for the current time.\n     */ now() {\n        const msg = this.create();\n        const ms = Date.now();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * Converts a `Timestamp` to a JavaScript Date.\n     */ toDate(message) {\n        return new Date(_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1000000));\n    }\n    /**\n     * Converts a JavaScript Date to a `Timestamp`.\n     */ fromDate(date) {\n        const msg = this.create();\n        const ms = date.getTime();\n        msg.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(Math.floor(ms / 1000)).toString();\n        msg.nanos = ms % 1000 * 1000000;\n        return msg;\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonWrite(message, options) {\n        let ms = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(message.seconds).toNumber() * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new Error(\"Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (message.nanos < 0) throw new Error(\"Unable to encode invalid Timestamp to JSON. Nanos must not be negative.\");\n        let z = \"Z\";\n        if (message.nanos > 0) {\n            let nanosStr = (message.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            else if (nanosStr.substring(6) === \"000\") z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            else z = \".\" + nanosStr + \"Z\";\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    /**\n     * In JSON format, the `Timestamp` type is encoded as a string\n     * in the RFC 3339 format.\n     */ internalJsonRead(json, options, target) {\n        if (typeof json !== \"string\") throw new Error(\"Unable to parse Timestamp from JSON \" + (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_10__.typeofJsonValue)(json) + \".\");\n        let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) throw new Error(\"Unable to parse Timestamp from JSON. Invalid format.\");\n        let ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) throw new Error(\"Unable to parse Timestamp from JSON. Invalid value.\");\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) throw new globalThis.Error(\"Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.\");\n        if (!target) target = this.create();\n        target.seconds = _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_13__.PbLong.from(ms / 1000).toString();\n        target.nanos = 0;\n        if (matches[7]) target.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        return target;\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.seconds = \"0\";\n        message.nanos = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int64 seconds */ 1:\n                    message.seconds = reader.int64().toString();\n                    break;\n                case /* int32 nanos */ 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int64 seconds = 1; */ if (message.seconds !== \"0\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int64(message.seconds);\n        /* int32 nanos = 2; */ if (message.nanos !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.nanos);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.Timestamp\n */ const Timestamp = new Timestamp$Type();\n/**\n * @generated from protobuf enum stream.video.sfu.models.PeerType\n */ var PeerType;\n(function(PeerType) {\n    /**\n     * todo fix me (marcelo)\n     *\n     * @generated from protobuf enum value: PEER_TYPE_PUBLISHER_UNSPECIFIED = 0;\n     */ PeerType[PeerType[\"PUBLISHER_UNSPECIFIED\"] = 0] = \"PUBLISHER_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PEER_TYPE_SUBSCRIBER = 1;\n     */ PeerType[PeerType[\"SUBSCRIBER\"] = 1] = \"SUBSCRIBER\";\n})(PeerType || (PeerType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ConnectionQuality\n */ var ConnectionQuality;\n(function(ConnectionQuality) {\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_UNSPECIFIED = 0;\n     */ ConnectionQuality[ConnectionQuality[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_POOR = 1;\n     */ ConnectionQuality[ConnectionQuality[\"POOR\"] = 1] = \"POOR\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_GOOD = 2;\n     */ ConnectionQuality[ConnectionQuality[\"GOOD\"] = 2] = \"GOOD\";\n    /**\n     * @generated from protobuf enum value: CONNECTION_QUALITY_EXCELLENT = 3;\n     */ ConnectionQuality[ConnectionQuality[\"EXCELLENT\"] = 3] = \"EXCELLENT\";\n})(ConnectionQuality || (ConnectionQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.VideoQuality\n */ var VideoQuality;\n(function(VideoQuality) {\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_LOW_UNSPECIFIED = 0;\n     */ VideoQuality[VideoQuality[\"LOW_UNSPECIFIED\"] = 0] = \"LOW_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_MID = 1;\n     */ VideoQuality[VideoQuality[\"MID\"] = 1] = \"MID\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_HIGH = 2;\n     */ VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n    /**\n     * @generated from protobuf enum value: VIDEO_QUALITY_OFF = 3;\n     */ VideoQuality[VideoQuality[\"OFF\"] = 3] = \"OFF\";\n})(VideoQuality || (VideoQuality = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackType\n */ var TrackType;\n(function(TrackType) {\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_UNSPECIFIED = 0;\n     */ TrackType[TrackType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_AUDIO = 1;\n     */ TrackType[TrackType[\"AUDIO\"] = 1] = \"AUDIO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_VIDEO = 2;\n     */ TrackType[TrackType[\"VIDEO\"] = 2] = \"VIDEO\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE = 3;\n     */ TrackType[TrackType[\"SCREEN_SHARE\"] = 3] = \"SCREEN_SHARE\";\n    /**\n     * @generated from protobuf enum value: TRACK_TYPE_SCREEN_SHARE_AUDIO = 4;\n     */ TrackType[TrackType[\"SCREEN_SHARE_AUDIO\"] = 4] = \"SCREEN_SHARE_AUDIO\";\n})(TrackType || (TrackType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.ErrorCode\n */ var ErrorCode;\n(function(ErrorCode) {\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;\n     */ ErrorCode[ErrorCode[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_NOT_FOUND = 100;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_NOT_FOUND\"] = 100] = \"PUBLISH_TRACK_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACKS_MISMATCH = 101;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACKS_MISMATCH\"] = 101] = \"PUBLISH_TRACKS_MISMATCH\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_OUT_OF_ORDER = 102;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_OUT_OF_ORDER\"] = 102] = \"PUBLISH_TRACK_OUT_OF_ORDER\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND = 103;\n     */ ErrorCode[ErrorCode[\"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\"] = 103] = \"PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_LIVE_ENDED = 104;\n     */ ErrorCode[ErrorCode[\"LIVE_ENDED\"] = 104] = \"LIVE_ENDED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_NOT_FOUND = 200;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_NOT_FOUND\"] = 200] = \"PARTICIPANT_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING_OUT = 201;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING_OUT\"] = 201] = \"PARTICIPANT_MIGRATING_OUT\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATION_FAILED = 202;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATION_FAILED\"] = 202] = \"PARTICIPANT_MIGRATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MIGRATING = 203;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MIGRATING\"] = 203] = \"PARTICIPANT_MIGRATING\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_RECONNECT_FAILED = 204;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_RECONNECT_FAILED\"] = 204] = \"PARTICIPANT_RECONNECT_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PARTICIPANT_MEDIA_TRANSPORT_FAILURE = 205;\n     */ ErrorCode[ErrorCode[\"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\"] = 205] = \"PARTICIPANT_MEDIA_TRANSPORT_FAILURE\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_CALL_NOT_FOUND = 300;\n     */ ErrorCode[ErrorCode[\"CALL_NOT_FOUND\"] = 300] = \"CALL_NOT_FOUND\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_REQUEST_VALIDATION_FAILED = 400;\n     */ ErrorCode[ErrorCode[\"REQUEST_VALIDATION_FAILED\"] = 400] = \"REQUEST_VALIDATION_FAILED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_UNAUTHENTICATED = 401;\n     */ ErrorCode[ErrorCode[\"UNAUTHENTICATED\"] = 401] = \"UNAUTHENTICATED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_PERMISSION_DENIED = 403;\n     */ ErrorCode[ErrorCode[\"PERMISSION_DENIED\"] = 403] = \"PERMISSION_DENIED\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_TOO_MANY_REQUESTS = 429;\n     */ ErrorCode[ErrorCode[\"TOO_MANY_REQUESTS\"] = 429] = \"TOO_MANY_REQUESTS\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_INTERNAL_SERVER_ERROR = 500;\n     */ ErrorCode[ErrorCode[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_SHUTTING_DOWN = 600;\n     */ ErrorCode[ErrorCode[\"SFU_SHUTTING_DOWN\"] = 600] = \"SFU_SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: ERROR_CODE_SFU_FULL = 700;\n     */ ErrorCode[ErrorCode[\"SFU_FULL\"] = 700] = \"SFU_FULL\";\n})(ErrorCode || (ErrorCode = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.SdkType\n */ var SdkType;\n(function(SdkType) {\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNSPECIFIED = 0;\n     */ SdkType[SdkType[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT = 1;\n     */ SdkType[SdkType[\"REACT\"] = 1] = \"REACT\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANGULAR = 2;\n     */ SdkType[SdkType[\"ANGULAR\"] = 2] = \"ANGULAR\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_ANDROID = 3;\n     */ SdkType[SdkType[\"ANDROID\"] = 3] = \"ANDROID\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_IOS = 4;\n     */ SdkType[SdkType[\"IOS\"] = 4] = \"IOS\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_FLUTTER = 5;\n     */ SdkType[SdkType[\"FLUTTER\"] = 5] = \"FLUTTER\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_REACT_NATIVE = 6;\n     */ SdkType[SdkType[\"REACT_NATIVE\"] = 6] = \"REACT_NATIVE\";\n    /**\n     * @generated from protobuf enum value: SDK_TYPE_UNITY = 7;\n     */ SdkType[SdkType[\"UNITY\"] = 7] = \"UNITY\";\n})(SdkType || (SdkType = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.TrackUnpublishReason\n */ var TrackUnpublishReason;\n(function(TrackUnpublishReason) {\n    /**\n     * Default value which is used when the specific reason\n     * for muting the track is not known.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_UNSPECIFIED = 0;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * Represents user muting their tracks.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_USER_MUTED = 1;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"USER_MUTED\"] = 1] = \"USER_MUTED\";\n    /**\n     * Represents muting the track because the permission to\n     * publish the track has been revoked.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_PERMISSION_REVOKED = 2;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"PERMISSION_REVOKED\"] = 2] = \"PERMISSION_REVOKED\";\n    /**\n     * Represents muting the track due to moderation actions.\n     * This is different from permission revoked because the\n     * participant can unmute themselves here whereas in case\n     * of \"permission revoke\" it is not possible until the\n     * call permissions are updated.\n     *\n     * @generated from protobuf enum value: TRACK_UNPUBLISH_REASON_MODERATION = 3;\n     */ TrackUnpublishReason[TrackUnpublishReason[\"MODERATION\"] = 3] = \"MODERATION\";\n})(TrackUnpublishReason || (TrackUnpublishReason = {}));\n/**\n * @generated from protobuf enum stream.video.sfu.models.GoAwayReason\n */ var GoAwayReason;\n(function(GoAwayReason) {\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_UNSPECIFIED = 0;\n     */ GoAwayReason[GoAwayReason[\"UNSPECIFIED\"] = 0] = \"UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_SHUTTING_DOWN = 1;\n     */ GoAwayReason[GoAwayReason[\"SHUTTING_DOWN\"] = 1] = \"SHUTTING_DOWN\";\n    /**\n     * @generated from protobuf enum value: GO_AWAY_REASON_REBALANCE = 2;\n     */ GoAwayReason[GoAwayReason[\"REBALANCE\"] = 2] = \"REBALANCE\";\n})(GoAwayReason || (GoAwayReason = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallState\", [\n            {\n                no: 1,\n                name: \"participants\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Participant\n            },\n            {\n                no: 2,\n                name: \"started_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 3,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            },\n            {\n                no: 4,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.participants = [];\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Participant participants */ 1:\n                    message.participants.push(Participant.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* google.protobuf.Timestamp started_at */ 2:\n                    message.startedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startedAt);\n                    break;\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 3:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                case /* repeated stream.video.sfu.models.Pin pins */ 4:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Participant participants = 1; */ for(let i = 0; i < message.participants.length; i++)Participant.internalBinaryWrite(message.participants[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp started_at = 2; */ if (message.startedAt) Timestamp.internalBinaryWrite(message.startedAt, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ParticipantCount participant_count = 3; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.models.Pin pins = 4; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallState\n */ const CallState$1 = new CallState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantCount$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ParticipantCount\", [\n            {\n                no: 1,\n                name: \"total\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"anonymous\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.total = 0;\n        message.anonymous = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 total */ 1:\n                    message.total = reader.uint32();\n                    break;\n                case /* uint32 anonymous */ 2:\n                    message.anonymous = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 total = 1; */ if (message.total !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.total);\n        /* uint32 anonymous = 2; */ if (message.anonymous !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.anonymous);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ParticipantCount\n */ const ParticipantCount = new ParticipantCount$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Pin$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Pin\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Pin\n */ const Pin = new Pin$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Participant$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Participant\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"published_tracks\",\n                kind: \"enum\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"joined_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 5,\n                name: \"track_lookup_prefix\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            },\n            {\n                no: 7,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"is_dominant_speaker\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"audio_level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 10,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 11,\n                name: \"image\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 12,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 13,\n                name: \"roles\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.publishedTracks = [];\n        message.trackLookupPrefix = \"\";\n        message.connectionQuality = 0;\n        message.isSpeaking = false;\n        message.isDominantSpeaker = false;\n        message.audioLevel = 0;\n        message.name = \"\";\n        message.image = \"\";\n        message.roles = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackType published_tracks */ 3:\n                    if (wireType === _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited) for(let e = reader.int32() + reader.pos; reader.pos < e;)message.publishedTracks.push(reader.int32());\n                    else message.publishedTracks.push(reader.int32());\n                    break;\n                case /* google.protobuf.Timestamp joined_at */ 4:\n                    message.joinedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.joinedAt);\n                    break;\n                case /* string track_lookup_prefix */ 5:\n                    message.trackLookupPrefix = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 6:\n                    message.connectionQuality = reader.int32();\n                    break;\n                case /* bool is_speaking */ 7:\n                    message.isSpeaking = reader.bool();\n                    break;\n                case /* bool is_dominant_speaker */ 8:\n                    message.isDominantSpeaker = reader.bool();\n                    break;\n                case /* float audio_level */ 9:\n                    message.audioLevel = reader.float();\n                    break;\n                case /* string name */ 10:\n                    message.name = reader.string();\n                    break;\n                case /* string image */ 11:\n                    message.image = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 12:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* repeated string roles */ 13:\n                    message.roles.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackType published_tracks = 3; */ if (message.publishedTracks.length) {\n            writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork();\n            for(let i = 0; i < message.publishedTracks.length; i++)writer.int32(message.publishedTracks[i]);\n            writer.join();\n        }\n        /* google.protobuf.Timestamp joined_at = 4; */ if (message.joinedAt) Timestamp.internalBinaryWrite(message.joinedAt, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string track_lookup_prefix = 5; */ if (message.trackLookupPrefix !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.trackLookupPrefix);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 6; */ if (message.connectionQuality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.connectionQuality);\n        /* bool is_speaking = 7; */ if (message.isSpeaking !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isSpeaking);\n        /* bool is_dominant_speaker = 8; */ if (message.isDominantSpeaker !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isDominantSpeaker);\n        /* float audio_level = 9; */ if (message.audioLevel !== 0) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.audioLevel);\n        /* string name = 10; */ if (message.name !== \"\") writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string image = 11; */ if (message.image !== \"\") writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.image);\n        /* google.protobuf.Struct custom = 12; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated string roles = 13; */ for(let i = 0; i < message.roles.length; i++)writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.roles[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Participant\n */ const Participant = new Participant$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass StreamQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.StreamQuality\", [\n            {\n                no: 1,\n                name: \"video_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.videoQuality = 0;\n        message.userId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.VideoQuality video_quality */ 1:\n                    message.videoQuality = reader.int32();\n                    break;\n                case /* string user_id */ 2:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.VideoQuality video_quality = 1; */ if (message.videoQuality !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.videoQuality);\n        /* string user_id = 2; */ if (message.userId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.StreamQuality\n */ const StreamQuality = new StreamQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoDimension$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoDimension\", [\n            {\n                no: 1,\n                name: \"width\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"height\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.width = 0;\n        message.height = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 width */ 1:\n                    message.width = reader.uint32();\n                    break;\n                case /* uint32 height */ 2:\n                    message.height = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 width = 1; */ if (message.width !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.width);\n        /* uint32 height = 2; */ if (message.height !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.height);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoDimension\n */ const VideoDimension = new VideoDimension$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.VideoLayer\", [\n            {\n                no: 1,\n                name: \"rid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"video_dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            },\n            {\n                no: 4,\n                name: \"bitrate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"fps\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 6,\n                name: \"quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.VideoQuality\",\n                        VideoQuality,\n                        \"VIDEO_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.rid = \"\";\n        message.bitrate = 0;\n        message.fps = 0;\n        message.quality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string rid */ 1:\n                    message.rid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension video_dimension */ 2:\n                    message.videoDimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.videoDimension);\n                    break;\n                case /* uint32 bitrate */ 4:\n                    message.bitrate = reader.uint32();\n                    break;\n                case /* uint32 fps */ 5:\n                    message.fps = reader.uint32();\n                    break;\n                case /* stream.video.sfu.models.VideoQuality quality */ 6:\n                    message.quality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string rid = 1; */ if (message.rid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.rid);\n        /* stream.video.sfu.models.VideoDimension video_dimension = 2; */ if (message.videoDimension) VideoDimension.internalBinaryWrite(message.videoDimension, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 bitrate = 4; */ if (message.bitrate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.bitrate);\n        /* uint32 fps = 5; */ if (message.fps !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.fps);\n        /* stream.video.sfu.models.VideoQuality quality = 6; */ if (message.quality !== 0) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.quality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.VideoLayer\n */ const VideoLayer = new VideoLayer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Codec$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Codec\", [\n            {\n                no: 1,\n                name: \"payload_type\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 2,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"fmtp_line\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"clock_rate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            },\n            {\n                no: 5,\n                name: \"encoding_parameters\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 6,\n                name: \"feedbacks\",\n                kind: \"scalar\",\n                repeat: 2 /*RepeatType.UNPACKED*/ ,\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.payloadType = 0;\n        message.name = \"\";\n        message.fmtpLine = \"\";\n        message.clockRate = 0;\n        message.encodingParameters = \"\";\n        message.feedbacks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* uint32 payload_type */ 1:\n                    message.payloadType = reader.uint32();\n                    break;\n                case /* string name */ 2:\n                    message.name = reader.string();\n                    break;\n                case /* string fmtp_line */ 3:\n                    message.fmtpLine = reader.string();\n                    break;\n                case /* uint32 clock_rate */ 4:\n                    message.clockRate = reader.uint32();\n                    break;\n                case /* string encoding_parameters */ 5:\n                    message.encodingParameters = reader.string();\n                    break;\n                case /* repeated string feedbacks */ 6:\n                    message.feedbacks.push(reader.string());\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* uint32 payload_type = 1; */ if (message.payloadType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.payloadType);\n        /* string name = 2; */ if (message.name !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string fmtp_line = 3; */ if (message.fmtpLine !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.fmtpLine);\n        /* uint32 clock_rate = 4; */ if (message.clockRate !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.clockRate);\n        /* string encoding_parameters = 5; */ if (message.encodingParameters !== \"\") writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.encodingParameters);\n        /* repeated string feedbacks = 6; */ for(let i = 0; i < message.feedbacks.length; i++)writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.feedbacks[i]);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Codec\n */ const Codec = new Codec$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet ICETrickle$Type$1 = class ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.iceCandidate);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ICETrickle\n */ const ICETrickle$1 = new ICETrickle$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.TrackInfo\", [\n            {\n                no: 1,\n                name: \"track_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayer\n            },\n            {\n                no: 6,\n                name: \"mid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 7,\n                name: \"dtx\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 8,\n                name: \"stereo\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 9,\n                name: \"red\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackId = \"\";\n        message.trackType = 0;\n        message.layers = [];\n        message.mid = \"\";\n        message.dtx = false;\n        message.stereo = false;\n        message.red = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string track_id */ 1:\n                    message.trackId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 2:\n                    message.trackType = reader.int32();\n                    break;\n                case /* repeated stream.video.sfu.models.VideoLayer layers */ 5:\n                    message.layers.push(VideoLayer.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* string mid */ 6:\n                    message.mid = reader.string();\n                    break;\n                case /* bool dtx */ 7:\n                    message.dtx = reader.bool();\n                    break;\n                case /* bool stereo */ 8:\n                    message.stereo = reader.bool();\n                    break;\n                case /* bool red */ 9:\n                    message.red = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string track_id = 1; */ if (message.trackId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.trackId);\n        /* stream.video.sfu.models.TrackType track_type = 2; */ if (message.trackType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* repeated stream.video.sfu.models.VideoLayer layers = 5; */ for(let i = 0; i < message.layers.length; i++)VideoLayer.internalBinaryWrite(message.layers[i], writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string mid = 6; */ if (message.mid !== \"\") writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.mid);\n        /* bool dtx = 7; */ if (message.dtx !== false) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.dtx);\n        /* bool stereo = 8; */ if (message.stereo !== false) writer.tag(8, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.stereo);\n        /* bool red = 9; */ if (message.red !== false) writer.tag(9, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.red);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.TrackInfo\n */ const TrackInfo = new TrackInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Call$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Call\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"created_by_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"host_user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 5,\n                name: \"custom\",\n                kind: \"message\",\n                T: ()=>Struct\n            },\n            {\n                no: 6,\n                name: \"created_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            },\n            {\n                no: 7,\n                name: \"updated_at\",\n                kind: \"message\",\n                T: ()=>Timestamp\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = \"\";\n        message.id = \"\";\n        message.createdByUserId = \"\";\n        message.hostUserId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string type */ 1:\n                    message.type = reader.string();\n                    break;\n                case /* string id */ 2:\n                    message.id = reader.string();\n                    break;\n                case /* string created_by_user_id */ 3:\n                    message.createdByUserId = reader.string();\n                    break;\n                case /* string host_user_id */ 4:\n                    message.hostUserId = reader.string();\n                    break;\n                case /* google.protobuf.Struct custom */ 5:\n                    message.custom = Struct.internalBinaryRead(reader, reader.uint32(), options, message.custom);\n                    break;\n                case /* google.protobuf.Timestamp created_at */ 6:\n                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);\n                    break;\n                case /* google.protobuf.Timestamp updated_at */ 7:\n                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string type = 1; */ if (message.type !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.type);\n        /* string id = 2; */ if (message.id !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.id);\n        /* string created_by_user_id = 3; */ if (message.createdByUserId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.createdByUserId);\n        /* string host_user_id = 4; */ if (message.hostUserId !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.hostUserId);\n        /* google.protobuf.Struct custom = 5; */ if (message.custom) Struct.internalBinaryWrite(message.custom, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp created_at = 6; */ if (message.createdAt) Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* google.protobuf.Timestamp updated_at = 7; */ if (message.updatedAt) Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Call\n */ const Call$1 = new Call$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nlet Error$Type$1 = class Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Error\", [\n            {\n                no: 1,\n                name: \"code\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ErrorCode\",\n                        ErrorCode,\n                        \"ERROR_CODE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"should_retry\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.code = 0;\n        message.message = \"\";\n        message.shouldRetry = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ErrorCode code */ 1:\n                    message.code = reader.int32();\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                case /* bool should_retry */ 3:\n                    message.shouldRetry = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ErrorCode code = 1; */ if (message.code !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.code);\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.message);\n        /* bool should_retry = 3; */ if (message.shouldRetry !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.shouldRetry);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n};\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Error\n */ const Error$2 = new Error$Type$1();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ClientDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.ClientDetails\", [\n            {\n                no: 1,\n                name: \"sdk\",\n                kind: \"message\",\n                T: ()=>Sdk\n            },\n            {\n                no: 2,\n                name: \"os\",\n                kind: \"message\",\n                T: ()=>OS\n            },\n            {\n                no: 3,\n                name: \"browser\",\n                kind: \"message\",\n                T: ()=>Browser\n            },\n            {\n                no: 4,\n                name: \"device\",\n                kind: \"message\",\n                T: ()=>Device\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Sdk sdk */ 1:\n                    message.sdk = Sdk.internalBinaryRead(reader, reader.uint32(), options, message.sdk);\n                    break;\n                case /* stream.video.sfu.models.OS os */ 2:\n                    message.os = OS.internalBinaryRead(reader, reader.uint32(), options, message.os);\n                    break;\n                case /* stream.video.sfu.models.Browser browser */ 3:\n                    message.browser = Browser.internalBinaryRead(reader, reader.uint32(), options, message.browser);\n                    break;\n                case /* stream.video.sfu.models.Device device */ 4:\n                    message.device = Device.internalBinaryRead(reader, reader.uint32(), options, message.device);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Sdk sdk = 1; */ if (message.sdk) Sdk.internalBinaryWrite(message.sdk, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.OS os = 2; */ if (message.os) OS.internalBinaryWrite(message.os, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Browser browser = 3; */ if (message.browser) Browser.internalBinaryWrite(message.browser, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Device device = 4; */ if (message.device) Device.internalBinaryWrite(message.device, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.ClientDetails\n */ const ClientDetails = new ClientDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Sdk$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Sdk\", [\n            {\n                no: 1,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.SdkType\",\n                        SdkType,\n                        \"SDK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"major\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"minor\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"patch\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.type = 0;\n        message.major = \"\";\n        message.minor = \"\";\n        message.patch = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.SdkType type */ 1:\n                    message.type = reader.int32();\n                    break;\n                case /* string major */ 2:\n                    message.major = reader.string();\n                    break;\n                case /* string minor */ 3:\n                    message.minor = reader.string();\n                    break;\n                case /* string patch */ 4:\n                    message.patch = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.SdkType type = 1; */ if (message.type !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* string major = 2; */ if (message.major !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.major);\n        /* string minor = 3; */ if (message.minor !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.minor);\n        /* string patch = 4; */ if (message.patch !== \"\") writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.patch);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Sdk\n */ const Sdk = new Sdk$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass OS$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.OS\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"architecture\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        message.architecture = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                case /* string architecture */ 3:\n                    message.architecture = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        /* string architecture = 3; */ if (message.architecture !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.architecture);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.OS\n */ const OS = new OS$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Browser$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Browser\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Browser\n */ const Browser = new Browser$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Device$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.Device\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"version\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.version = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* string version */ 2:\n                    message.version = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* string version = 2; */ if (message.version !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.version);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.Device\n */ const Device = new Device$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrants$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.models.CallGrants\", [\n            {\n                no: 1,\n                name: \"can_publish_audio\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"can_publish_video\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"can_screenshare\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.canPublishAudio = false;\n        message.canPublishVideo = false;\n        message.canScreenshare = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool can_publish_audio */ 1:\n                    message.canPublishAudio = reader.bool();\n                    break;\n                case /* bool can_publish_video */ 2:\n                    message.canPublishVideo = reader.bool();\n                    break;\n                case /* bool can_screenshare */ 3:\n                    message.canScreenshare = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool can_publish_audio = 1; */ if (message.canPublishAudio !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canPublishAudio);\n        /* bool can_publish_video = 2; */ if (message.canPublishVideo !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canPublishVideo);\n        /* bool can_screenshare = 3; */ if (message.canScreenshare !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.canScreenshare);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.models.CallGrants\n */ const CallGrants = new CallGrants$Type();\nvar models = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Browser: Browser,\n    Call: Call$1,\n    CallGrants: CallGrants,\n    CallState: CallState$1,\n    ClientDetails: ClientDetails,\n    Codec: Codec,\n    get ConnectionQuality () {\n        return ConnectionQuality;\n    },\n    Device: Device,\n    Error: Error$2,\n    get ErrorCode () {\n        return ErrorCode;\n    },\n    get GoAwayReason () {\n        return GoAwayReason;\n    },\n    ICETrickle: ICETrickle$1,\n    OS: OS,\n    Participant: Participant,\n    ParticipantCount: ParticipantCount,\n    get PeerType () {\n        return PeerType;\n    },\n    Pin: Pin,\n    Sdk: Sdk,\n    get SdkType () {\n        return SdkType;\n    },\n    StreamQuality: StreamQuality,\n    TrackInfo: TrackInfo,\n    get TrackType () {\n        return TrackType;\n    },\n    get TrackUnpublishReason () {\n        return TrackUnpublishReason;\n    },\n    VideoDimension: VideoDimension,\n    VideoLayer: VideoLayer,\n    get VideoQuality () {\n        return VideoQuality;\n    }\n});\n/* eslint-disable */ // @generated by protobuf-ts 2.9.3 with parameter long_type_string,client_generic,server_none,eslint_disable\n// @generated from protobuf file \"video/sfu/signal_rpc/signal.proto\" (package \"stream.video.sfu.signal\", syntax proto3)\n// tslint:disable\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.PeerType peer_type */ 2:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.PeerType peer_type = 2; */ if (message.peerType !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartRequest\n */ const ICERestartRequest = new ICERestartRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestartResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICERestartResponse\", [\n            {\n                no: 1,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 1:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 1; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICERestartResponse\n */ const ICERestartResponse = new ICERestartResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesRequest\", [\n            {\n                no: 1,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"mute_states\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackMuteState\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.muteStates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 1:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackMuteState mute_states */ 3:\n                    message.muteStates.push(TrackMuteState.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 1; */ if (message.sessionId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackMuteState mute_states = 3; */ for(let i = 0; i < message.muteStates.length; i++)TrackMuteState.internalBinaryWrite(message.muteStates[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesRequest\n */ const UpdateMuteStatesRequest = new UpdateMuteStatesRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateMuteStatesResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateMuteStatesResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateMuteStatesResponse\n */ const UpdateMuteStatesResponse = new UpdateMuteStatesResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackMuteState$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackMuteState\", [\n            {\n                no: 1,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.trackType = 0;\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.TrackType track_type */ 1:\n                    message.trackType = reader.int32();\n                    break;\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.TrackType track_type = 1; */ if (message.trackType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackMuteState\n */ const TrackMuteState = new TrackMuteState$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.AudioMuteChanged\", [\n            {\n                no: 1,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 1:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 1; */ if (message.muted !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.AudioMuteChanged\n */ new AudioMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMuteChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.VideoMuteChanged\", [\n            {\n                no: 2,\n                name: \"muted\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.muted = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool muted */ 2:\n                    message.muted = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool muted = 2; */ if (message.muted !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.muted);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.VideoMuteChanged\n */ new VideoMuteChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsRequest\", [\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks */ 3:\n                    message.tracks.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsRequest\n */ const UpdateSubscriptionsRequest = new UpdateSubscriptionsRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass UpdateSubscriptionsResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.UpdateSubscriptionsResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.UpdateSubscriptionsResponse\n */ const UpdateSubscriptionsResponse = new UpdateSubscriptionsResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackSubscriptionDetails$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.TrackSubscriptionDetails\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"track_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"dimension\",\n                kind: \"message\",\n                T: ()=>VideoDimension\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.trackType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType track_type */ 3:\n                    message.trackType = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.VideoDimension dimension */ 4:\n                    message.dimension = VideoDimension.internalBinaryRead(reader, reader.uint32(), options, message.dimension);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType track_type = 3; */ if (message.trackType !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.trackType);\n        /* stream.video.sfu.models.VideoDimension dimension = 4; */ if (message.dimension) VideoDimension.internalBinaryWrite(message.dimension, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.TrackSubscriptionDetails\n */ const TrackSubscriptionDetails = new TrackSubscriptionDetails$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerRequest\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 3:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 3; */ if (message.sessionId !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerRequest\n */ const SendAnswerRequest = new SendAnswerRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SendAnswerResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SendAnswerResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SendAnswerResponse\n */ const SendAnswerResponse = new SendAnswerResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickleResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.ICETrickleResponse\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.ICETrickleResponse\n */ const ICETrickleResponse = new ICETrickleResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherRequest\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.tracks = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo tracks */ 3:\n                    message.tracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* repeated stream.video.sfu.models.TrackInfo tracks = 3; */ for(let i = 0; i < message.tracks.length; i++)TrackInfo.internalBinaryWrite(message.tracks[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherRequest\n */ const SetPublisherRequest = new SetPublisherRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SetPublisherResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.signal.SetPublisherResponse\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        message.sessionId = \"\";\n        message.iceRestart = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* bool ice_restart */ 3:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* bool ice_restart = 3; */ if (message.iceRestart !== false) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.iceRestart);\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.signal.SetPublisherResponse\n */ const SetPublisherResponse = new SetPublisherResponse$Type();\n/**\n * @generated ServiceType for protobuf service stream.video.sfu.signal.SignalServer\n */ const SignalServer = new _protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_14__.ServiceType(\"stream.video.sfu.signal.SignalServer\", [\n    {\n        name: \"SetPublisher\",\n        options: {},\n        I: SetPublisherRequest,\n        O: SetPublisherResponse\n    },\n    {\n        name: \"SendAnswer\",\n        options: {},\n        I: SendAnswerRequest,\n        O: SendAnswerResponse\n    },\n    {\n        name: \"IceTrickle\",\n        options: {},\n        I: ICETrickle$1,\n        O: ICETrickleResponse\n    },\n    {\n        name: \"UpdateSubscriptions\",\n        options: {},\n        I: UpdateSubscriptionsRequest,\n        O: UpdateSubscriptionsResponse\n    },\n    {\n        name: \"UpdateMuteStates\",\n        options: {},\n        I: UpdateMuteStatesRequest,\n        O: UpdateMuteStatesResponse\n    },\n    {\n        name: \"IceRestart\",\n        options: {},\n        I: ICERestartRequest,\n        O: ICERestartResponse\n    }\n]);\n/**\n * @generated from protobuf enum stream.video.sfu.event.VideoLayerSetting.Priority\n */ var VideoLayerSetting_Priority;\n(function(VideoLayerSetting_Priority) {\n    /**\n     * @generated from protobuf enum value: PRIORITY_HIGH_UNSPECIFIED = 0;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"HIGH_UNSPECIFIED\"] = 0] = \"HIGH_UNSPECIFIED\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_LOW = 1;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"LOW\"] = 1] = \"LOW\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_MEDIUM = 2;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"MEDIUM\"] = 2] = \"MEDIUM\";\n    /**\n     * @generated from protobuf enum value: PRIORITY_VERY_LOW = 3;\n     */ VideoLayerSetting_Priority[VideoLayerSetting_Priority[\"VERY_LOW\"] = 3] = \"VERY_LOW\";\n})(VideoLayerSetting_Priority || (VideoLayerSetting_Priority = {}));\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuEvent$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuEvent\", [\n            {\n                no: 1,\n                name: \"subscriber_offer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>SubscriberOffer\n            },\n            {\n                no: 2,\n                name: \"publisher_answer\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PublisherAnswer\n            },\n            {\n                no: 3,\n                name: \"connection_quality_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ConnectionQualityChanged\n            },\n            {\n                no: 4,\n                name: \"audio_level_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>AudioLevelChanged\n            },\n            {\n                no: 5,\n                name: \"ice_trickle\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICETrickle$1\n            },\n            {\n                no: 6,\n                name: \"change_publish_quality\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ChangePublishQuality\n            },\n            {\n                no: 10,\n                name: \"participant_joined\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantJoined\n            },\n            {\n                no: 11,\n                name: \"participant_left\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ParticipantLeft\n            },\n            {\n                no: 12,\n                name: \"dominant_speaker_changed\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>DominantSpeakerChanged\n            },\n            {\n                no: 13,\n                name: \"join_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>JoinResponse\n            },\n            {\n                no: 14,\n                name: \"health_check_response\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>HealthCheckResponse\n            },\n            {\n                no: 16,\n                name: \"track_published\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackPublished\n            },\n            {\n                no: 17,\n                name: \"track_unpublished\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>TrackUnpublished\n            },\n            {\n                no: 18,\n                name: \"error\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>Error$1\n            },\n            {\n                no: 19,\n                name: \"call_grants_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>CallGrantsUpdated\n            },\n            {\n                no: 20,\n                name: \"go_away\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>GoAway\n            },\n            {\n                no: 21,\n                name: \"ice_restart\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>ICERestart\n            },\n            {\n                no: 22,\n                name: \"pins_updated\",\n                kind: \"message\",\n                oneof: \"eventPayload\",\n                T: ()=>PinsChanged\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.eventPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.SubscriberOffer subscriber_offer */ 1:\n                    message.eventPayload = {\n                        oneofKind: \"subscriberOffer\",\n                        subscriberOffer: SubscriberOffer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.subscriberOffer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PublisherAnswer publisher_answer */ 2:\n                    message.eventPayload = {\n                        oneofKind: \"publisherAnswer\",\n                        publisherAnswer: PublisherAnswer.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.publisherAnswer)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed */ 3:\n                    message.eventPayload = {\n                        oneofKind: \"connectionQualityChanged\",\n                        connectionQualityChanged: ConnectionQualityChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.connectionQualityChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.AudioLevelChanged audio_level_changed */ 4:\n                    message.eventPayload = {\n                        oneofKind: \"audioLevelChanged\",\n                        audioLevelChanged: AudioLevelChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.audioLevelChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.models.ICETrickle ice_trickle */ 5:\n                    message.eventPayload = {\n                        oneofKind: \"iceTrickle\",\n                        iceTrickle: ICETrickle$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceTrickle)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ChangePublishQuality change_publish_quality */ 6:\n                    message.eventPayload = {\n                        oneofKind: \"changePublishQuality\",\n                        changePublishQuality: ChangePublishQuality.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.changePublishQuality)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantJoined participant_joined */ 10:\n                    message.eventPayload = {\n                        oneofKind: \"participantJoined\",\n                        participantJoined: ParticipantJoined.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantJoined)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ParticipantLeft participant_left */ 11:\n                    message.eventPayload = {\n                        oneofKind: \"participantLeft\",\n                        participantLeft: ParticipantLeft.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.participantLeft)\n                    };\n                    break;\n                case /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed */ 12:\n                    message.eventPayload = {\n                        oneofKind: \"dominantSpeakerChanged\",\n                        dominantSpeakerChanged: DominantSpeakerChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.dominantSpeakerChanged)\n                    };\n                    break;\n                case /* stream.video.sfu.event.JoinResponse join_response */ 13:\n                    message.eventPayload = {\n                        oneofKind: \"joinResponse\",\n                        joinResponse: JoinResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.joinResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckResponse health_check_response */ 14:\n                    message.eventPayload = {\n                        oneofKind: \"healthCheckResponse\",\n                        healthCheckResponse: HealthCheckResponse.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.healthCheckResponse)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackPublished track_published */ 16:\n                    message.eventPayload = {\n                        oneofKind: \"trackPublished\",\n                        trackPublished: TrackPublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackPublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.TrackUnpublished track_unpublished */ 17:\n                    message.eventPayload = {\n                        oneofKind: \"trackUnpublished\",\n                        trackUnpublished: TrackUnpublished.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.trackUnpublished)\n                    };\n                    break;\n                case /* stream.video.sfu.event.Error error */ 18:\n                    message.eventPayload = {\n                        oneofKind: \"error\",\n                        error: Error$1.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.error)\n                    };\n                    break;\n                case /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated */ 19:\n                    message.eventPayload = {\n                        oneofKind: \"callGrantsUpdated\",\n                        callGrantsUpdated: CallGrantsUpdated.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.callGrantsUpdated)\n                    };\n                    break;\n                case /* stream.video.sfu.event.GoAway go_away */ 20:\n                    message.eventPayload = {\n                        oneofKind: \"goAway\",\n                        goAway: GoAway.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.goAway)\n                    };\n                    break;\n                case /* stream.video.sfu.event.ICERestart ice_restart */ 21:\n                    message.eventPayload = {\n                        oneofKind: \"iceRestart\",\n                        iceRestart: ICERestart.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.iceRestart)\n                    };\n                    break;\n                case /* stream.video.sfu.event.PinsChanged pins_updated */ 22:\n                    message.eventPayload = {\n                        oneofKind: \"pinsUpdated\",\n                        pinsUpdated: PinsChanged.internalBinaryRead(reader, reader.uint32(), options, message.eventPayload.pinsUpdated)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.SubscriberOffer subscriber_offer = 1; */ if (message.eventPayload.oneofKind === \"subscriberOffer\") SubscriberOffer.internalBinaryWrite(message.eventPayload.subscriberOffer, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PublisherAnswer publisher_answer = 2; */ if (message.eventPayload.oneofKind === \"publisherAnswer\") PublisherAnswer.internalBinaryWrite(message.eventPayload.publisherAnswer, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ConnectionQualityChanged connection_quality_changed = 3; */ if (message.eventPayload.oneofKind === \"connectionQualityChanged\") ConnectionQualityChanged.internalBinaryWrite(message.eventPayload.connectionQualityChanged, writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.AudioLevelChanged audio_level_changed = 4; */ if (message.eventPayload.oneofKind === \"audioLevelChanged\") AudioLevelChanged.internalBinaryWrite(message.eventPayload.audioLevelChanged, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.ICETrickle ice_trickle = 5; */ if (message.eventPayload.oneofKind === \"iceTrickle\") ICETrickle$1.internalBinaryWrite(message.eventPayload.iceTrickle, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ChangePublishQuality change_publish_quality = 6; */ if (message.eventPayload.oneofKind === \"changePublishQuality\") ChangePublishQuality.internalBinaryWrite(message.eventPayload.changePublishQuality, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantJoined participant_joined = 10; */ if (message.eventPayload.oneofKind === \"participantJoined\") ParticipantJoined.internalBinaryWrite(message.eventPayload.participantJoined, writer.tag(10, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ParticipantLeft participant_left = 11; */ if (message.eventPayload.oneofKind === \"participantLeft\") ParticipantLeft.internalBinaryWrite(message.eventPayload.participantLeft, writer.tag(11, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.DominantSpeakerChanged dominant_speaker_changed = 12; */ if (message.eventPayload.oneofKind === \"dominantSpeakerChanged\") DominantSpeakerChanged.internalBinaryWrite(message.eventPayload.dominantSpeakerChanged, writer.tag(12, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.JoinResponse join_response = 13; */ if (message.eventPayload.oneofKind === \"joinResponse\") JoinResponse.internalBinaryWrite(message.eventPayload.joinResponse, writer.tag(13, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckResponse health_check_response = 14; */ if (message.eventPayload.oneofKind === \"healthCheckResponse\") HealthCheckResponse.internalBinaryWrite(message.eventPayload.healthCheckResponse, writer.tag(14, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackPublished track_published = 16; */ if (message.eventPayload.oneofKind === \"trackPublished\") TrackPublished.internalBinaryWrite(message.eventPayload.trackPublished, writer.tag(16, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.TrackUnpublished track_unpublished = 17; */ if (message.eventPayload.oneofKind === \"trackUnpublished\") TrackUnpublished.internalBinaryWrite(message.eventPayload.trackUnpublished, writer.tag(17, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Error error = 18; */ if (message.eventPayload.oneofKind === \"error\") Error$1.internalBinaryWrite(message.eventPayload.error, writer.tag(18, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.CallGrantsUpdated call_grants_updated = 19; */ if (message.eventPayload.oneofKind === \"callGrantsUpdated\") CallGrantsUpdated.internalBinaryWrite(message.eventPayload.callGrantsUpdated, writer.tag(19, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.GoAway go_away = 20; */ if (message.eventPayload.oneofKind === \"goAway\") GoAway.internalBinaryWrite(message.eventPayload.goAway, writer.tag(20, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.ICERestart ice_restart = 21; */ if (message.eventPayload.oneofKind === \"iceRestart\") ICERestart.internalBinaryWrite(message.eventPayload.iceRestart, writer.tag(21, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.PinsChanged pins_updated = 22; */ if (message.eventPayload.oneofKind === \"pinsUpdated\") PinsChanged.internalBinaryWrite(message.eventPayload.pinsUpdated, writer.tag(22, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuEvent\n */ const SfuEvent = new SfuEvent$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PinsChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PinsChanged\", [\n            {\n                no: 1,\n                name: \"pins\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>Pin\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.pins = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.models.Pin pins */ 1:\n                    message.pins.push(Pin.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.models.Pin pins = 1; */ for(let i = 0; i < message.pins.length; i++)Pin.internalBinaryWrite(message.pins[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PinsChanged\n */ const PinsChanged = new PinsChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Error$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Error\", [\n            {\n                no: 4,\n                name: \"error\",\n                kind: \"message\",\n                T: ()=>Error$2\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.Error error */ 4:\n                    message.error = Error$2.internalBinaryRead(reader, reader.uint32(), options, message.error);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.Error error = 4; */ if (message.error) Error$2.internalBinaryWrite(message.error, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Error\n */ const Error$1 = new Error$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICETrickle$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICETrickle\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            },\n            {\n                no: 2,\n                name: \"ice_candidate\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        message.iceCandidate = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                case /* string ice_candidate */ 2:\n                    message.iceCandidate = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        /* string ice_candidate = 2; */ if (message.iceCandidate !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.iceCandidate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICETrickle\n */ const ICETrickle = new ICETrickle$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ICERestart$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ICERestart\", [\n            {\n                no: 1,\n                name: \"peer_type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.PeerType\",\n                        PeerType,\n                        \"PEER_TYPE_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.peerType = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.PeerType peer_type */ 1:\n                    message.peerType = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.PeerType peer_type = 1; */ if (message.peerType !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.peerType);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ICERestart\n */ const ICERestart = new ICERestart$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SfuRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SfuRequest\", [\n            {\n                no: 1,\n                name: \"join_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>JoinRequest\n            },\n            {\n                no: 2,\n                name: \"health_check_request\",\n                kind: \"message\",\n                oneof: \"requestPayload\",\n                T: ()=>HealthCheckRequest\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.requestPayload = {\n            oneofKind: undefined\n        };\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.JoinRequest join_request */ 1:\n                    message.requestPayload = {\n                        oneofKind: \"joinRequest\",\n                        joinRequest: JoinRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.joinRequest)\n                    };\n                    break;\n                case /* stream.video.sfu.event.HealthCheckRequest health_check_request */ 2:\n                    message.requestPayload = {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: HealthCheckRequest.internalBinaryRead(reader, reader.uint32(), options, message.requestPayload.healthCheckRequest)\n                    };\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.JoinRequest join_request = 1; */ if (message.requestPayload.oneofKind === \"joinRequest\") JoinRequest.internalBinaryWrite(message.requestPayload.joinRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.HealthCheckRequest health_check_request = 2; */ if (message.requestPayload.oneofKind === \"healthCheckRequest\") HealthCheckRequest.internalBinaryWrite(message.requestPayload.healthCheckRequest, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SfuRequest\n */ const SfuRequest = new SfuRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckRequest\", []);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        return target ?? this.create();\n    }\n    internalBinaryWrite(message, writer, options) {\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckRequest\n */ const HealthCheckRequest = new HealthCheckRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass HealthCheckResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.HealthCheckResponse\", [\n            {\n                no: 1,\n                name: \"participant_count\",\n                kind: \"message\",\n                T: ()=>ParticipantCount\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.ParticipantCount participant_count */ 1:\n                    message.participantCount = ParticipantCount.internalBinaryRead(reader, reader.uint32(), options, message.participantCount);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.ParticipantCount participant_count = 1; */ if (message.participantCount) ParticipantCount.internalBinaryWrite(message.participantCount, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.HealthCheckResponse\n */ const HealthCheckResponse = new HealthCheckResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackPublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackPublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 4:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.Participant participant = 4; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackPublished\n */ const TrackPublished = new TrackPublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass TrackUnpublished$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.TrackUnpublished\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"type\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackType\",\n                        TrackType,\n                        \"TRACK_TYPE_\"\n                    ]\n            },\n            {\n                no: 4,\n                name: \"cause\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.TrackUnpublishReason\",\n                        TrackUnpublishReason,\n                        \"TRACK_UNPUBLISH_REASON_\"\n                    ]\n            },\n            {\n                no: 5,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.type = 0;\n        message.cause = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.TrackType type */ 3:\n                    message.type = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.TrackUnpublishReason cause */ 4:\n                    message.cause = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 5:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.TrackType type = 3; */ if (message.type !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.type);\n        /* stream.video.sfu.models.TrackUnpublishReason cause = 4; */ if (message.cause !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.cause);\n        /* stream.video.sfu.models.Participant participant = 5; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.TrackUnpublished\n */ const TrackUnpublished = new TrackUnpublished$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinRequest\", [\n            {\n                no: 1,\n                name: \"token\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"subscriber_sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 4,\n                name: \"client_details\",\n                kind: \"message\",\n                T: ()=>ClientDetails\n            },\n            {\n                no: 5,\n                name: \"migration\",\n                kind: \"message\",\n                T: ()=>Migration\n            },\n            {\n                no: 6,\n                name: \"fast_reconnect\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.token = \"\";\n        message.sessionId = \"\";\n        message.subscriberSdp = \"\";\n        message.fastReconnect = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string token */ 1:\n                    message.token = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* string subscriber_sdp */ 3:\n                    message.subscriberSdp = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ClientDetails client_details */ 4:\n                    message.clientDetails = ClientDetails.internalBinaryRead(reader, reader.uint32(), options, message.clientDetails);\n                    break;\n                case /* stream.video.sfu.event.Migration migration */ 5:\n                    message.migration = Migration.internalBinaryRead(reader, reader.uint32(), options, message.migration);\n                    break;\n                case /* bool fast_reconnect */ 6:\n                    message.fastReconnect = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string token = 1; */ if (message.token !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.token);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* string subscriber_sdp = 3; */ if (message.subscriberSdp !== \"\") writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.subscriberSdp);\n        /* stream.video.sfu.models.ClientDetails client_details = 4; */ if (message.clientDetails) ClientDetails.internalBinaryWrite(message.clientDetails, writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.event.Migration migration = 5; */ if (message.migration) Migration.internalBinaryWrite(message.migration, writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* bool fast_reconnect = 6; */ if (message.fastReconnect !== false) writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.fastReconnect);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinRequest\n */ const JoinRequest = new JoinRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass Migration$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.Migration\", [\n            {\n                no: 1,\n                name: \"from_sfu_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"announced_tracks\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackInfo\n            },\n            {\n                no: 3,\n                name: \"subscriptions\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>TrackSubscriptionDetails\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.fromSfuId = \"\";\n        message.announcedTracks = [];\n        message.subscriptions = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string from_sfu_id */ 1:\n                    message.fromSfuId = reader.string();\n                    break;\n                case /* repeated stream.video.sfu.models.TrackInfo announced_tracks */ 2:\n                    message.announcedTracks.push(TrackInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions */ 3:\n                    message.subscriptions.push(TrackSubscriptionDetails.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string from_sfu_id = 1; */ if (message.fromSfuId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.fromSfuId);\n        /* repeated stream.video.sfu.models.TrackInfo announced_tracks = 2; */ for(let i = 0; i < message.announcedTracks.length; i++)TrackInfo.internalBinaryWrite(message.announcedTracks[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.signal.TrackSubscriptionDetails subscriptions = 3; */ for(let i = 0; i < message.subscriptions.length; i++)TrackSubscriptionDetails.internalBinaryWrite(message.subscriptions[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.Migration\n */ const Migration = new Migration$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass JoinResponse$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.JoinResponse\", [\n            {\n                no: 1,\n                name: \"call_state\",\n                kind: \"message\",\n                T: ()=>CallState$1\n            },\n            {\n                no: 2,\n                name: \"reconnected\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reconnected = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallState call_state */ 1:\n                    message.callState = CallState$1.internalBinaryRead(reader, reader.uint32(), options, message.callState);\n                    break;\n                case /* bool reconnected */ 2:\n                    message.reconnected = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallState call_state = 1; */ if (message.callState) CallState$1.internalBinaryWrite(message.callState, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* bool reconnected = 2; */ if (message.reconnected !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.reconnected);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.JoinResponse\n */ const JoinResponse = new JoinResponse$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantJoined$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantJoined\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantJoined\n */ const ParticipantJoined = new ParticipantJoined$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ParticipantLeft$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ParticipantLeft\", [\n            {\n                no: 1,\n                name: \"call_cid\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"participant\",\n                kind: \"message\",\n                T: ()=>Participant\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.callCid = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string call_cid */ 1:\n                    message.callCid = reader.string();\n                    break;\n                case /* stream.video.sfu.models.Participant participant */ 2:\n                    message.participant = Participant.internalBinaryRead(reader, reader.uint32(), options, message.participant);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string call_cid = 1; */ if (message.callCid !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.callCid);\n        /* stream.video.sfu.models.Participant participant = 2; */ if (message.participant) Participant.internalBinaryWrite(message.participant, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ParticipantLeft\n */ const ParticipantLeft = new ParticipantLeft$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass SubscriberOffer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.SubscriberOffer\", [\n            {\n                no: 1,\n                name: \"ice_restart\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 2,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.iceRestart = false;\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* bool ice_restart */ 1:\n                    message.iceRestart = reader.bool();\n                    break;\n                case /* string sdp */ 2:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* bool ice_restart = 1; */ if (message.iceRestart !== false) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.iceRestart);\n        /* string sdp = 2; */ if (message.sdp !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.SubscriberOffer\n */ const SubscriberOffer = new SubscriberOffer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass PublisherAnswer$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.PublisherAnswer\", [\n            {\n                no: 1,\n                name: \"sdp\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.sdp = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string sdp */ 1:\n                    message.sdp = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string sdp = 1; */ if (message.sdp !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sdp);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.PublisherAnswer\n */ const PublisherAnswer = new PublisherAnswer$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityChanged\", [\n            {\n                no: 1,\n                name: \"connection_quality_updates\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>ConnectionQualityInfo\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.connectionQualityUpdates = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates */ 1:\n                    message.connectionQualityUpdates.push(ConnectionQualityInfo.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.ConnectionQualityInfo connection_quality_updates = 1; */ for(let i = 0; i < message.connectionQualityUpdates.length; i++)ConnectionQualityInfo.internalBinaryWrite(message.connectionQualityUpdates[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityChanged\n */ const ConnectionQualityChanged = new ConnectionQualityChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ConnectionQualityInfo$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ConnectionQualityInfo\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"connection_quality\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.ConnectionQuality\",\n                        ConnectionQuality,\n                        \"CONNECTION_QUALITY_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.connectionQuality = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* stream.video.sfu.models.ConnectionQuality connection_quality */ 3:\n                    message.connectionQuality = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* stream.video.sfu.models.ConnectionQuality connection_quality = 3; */ if (message.connectionQuality !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.connectionQuality);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ConnectionQualityInfo\n */ const ConnectionQualityInfo = new ConnectionQualityInfo$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass DominantSpeakerChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.DominantSpeakerChanged\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.DominantSpeakerChanged\n */ const DominantSpeakerChanged = new DominantSpeakerChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevel$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevel\", [\n            {\n                no: 1,\n                name: \"user_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"session_id\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 3,\n                name: \"level\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 4,\n                name: \"is_speaking\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.userId = \"\";\n        message.sessionId = \"\";\n        message.level = 0;\n        message.isSpeaking = false;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string user_id */ 1:\n                    message.userId = reader.string();\n                    break;\n                case /* string session_id */ 2:\n                    message.sessionId = reader.string();\n                    break;\n                case /* float level */ 3:\n                    message.level = reader.float();\n                    break;\n                case /* bool is_speaking */ 4:\n                    message.isSpeaking = reader.bool();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string user_id = 1; */ if (message.userId !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.userId);\n        /* string session_id = 2; */ if (message.sessionId !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.sessionId);\n        /* float level = 3; */ if (message.level !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.level);\n        /* bool is_speaking = 4; */ if (message.isSpeaking !== false) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.isSpeaking);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevel\n */ const AudioLevel = new AudioLevel$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioLevelChanged$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioLevelChanged\", [\n            {\n                no: 1,\n                name: \"audio_levels\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioLevel\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioLevels = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioLevel audio_levels */ 1:\n                    message.audioLevels.push(AudioLevel.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioLevel audio_levels = 1; */ for(let i = 0; i < message.audioLevels.length; i++)AudioLevel.internalBinaryWrite(message.audioLevels[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioLevelChanged\n */ const AudioLevelChanged = new AudioLevelChanged$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioMediaRequest\", [\n            {\n                no: 1,\n                name: \"channel_count\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.channelCount = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 channel_count */ 1:\n                    message.channelCount = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 channel_count = 1; */ if (message.channelCount !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.channelCount);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioMediaRequest\n */ const AudioMediaRequest = new AudioMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass AudioSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.AudioSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>AudioMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.AudioMediaRequest media_request */ 1:\n                    message.mediaRequest = AudioMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.AudioMediaRequest media_request = 1; */ if (message.mediaRequest) AudioMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.AudioSender\n */ const AudioSender = new AudioSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoMediaRequest$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoMediaRequest\", [\n            {\n                no: 1,\n                name: \"ideal_height\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 2,\n                name: \"ideal_width\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 3,\n                name: \"ideal_frame_rate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.idealHeight = 0;\n        message.idealWidth = 0;\n        message.idealFrameRate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* int32 ideal_height */ 1:\n                    message.idealHeight = reader.int32();\n                    break;\n                case /* int32 ideal_width */ 2:\n                    message.idealWidth = reader.int32();\n                    break;\n                case /* int32 ideal_frame_rate */ 3:\n                    message.idealFrameRate = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* int32 ideal_height = 1; */ if (message.idealHeight !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealHeight);\n        /* int32 ideal_width = 2; */ if (message.idealWidth !== 0) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealWidth);\n        /* int32 ideal_frame_rate = 3; */ if (message.idealFrameRate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.idealFrameRate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoMediaRequest\n */ const VideoMediaRequest = new VideoMediaRequest$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoLayerSetting$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoLayerSetting\", [\n            {\n                no: 1,\n                name: \"name\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            },\n            {\n                no: 2,\n                name: \"active\",\n                kind: \"scalar\",\n                T: 8 /*ScalarType.BOOL*/ \n            },\n            {\n                no: 3,\n                name: \"max_bitrate\",\n                kind: \"scalar\",\n                T: 5 /*ScalarType.INT32*/ \n            },\n            {\n                no: 4,\n                name: \"scale_resolution_down_by\",\n                kind: \"scalar\",\n                T: 2 /*ScalarType.FLOAT*/ \n            },\n            {\n                no: 5,\n                name: \"priority\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.event.VideoLayerSetting.Priority\",\n                        VideoLayerSetting_Priority,\n                        \"PRIORITY_\"\n                    ]\n            },\n            {\n                no: 6,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 7,\n                name: \"max_framerate\",\n                kind: \"scalar\",\n                T: 13 /*ScalarType.UINT32*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.name = \"\";\n        message.active = false;\n        message.maxBitrate = 0;\n        message.scaleResolutionDownBy = 0;\n        message.priority = 0;\n        message.maxFramerate = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* string name */ 1:\n                    message.name = reader.string();\n                    break;\n                case /* bool active */ 2:\n                    message.active = reader.bool();\n                    break;\n                case /* int32 max_bitrate */ 3:\n                    message.maxBitrate = reader.int32();\n                    break;\n                case /* float scale_resolution_down_by */ 4:\n                    message.scaleResolutionDownBy = reader.float();\n                    break;\n                case /* stream.video.sfu.event.VideoLayerSetting.Priority priority */ 5:\n                    message.priority = reader.int32();\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 6:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* uint32 max_framerate */ 7:\n                    message.maxFramerate = reader.uint32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* string name = 1; */ if (message.name !== \"\") writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.name);\n        /* bool active = 2; */ if (message.active !== false) writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).bool(message.active);\n        /* int32 max_bitrate = 3; */ if (message.maxBitrate !== 0) writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.maxBitrate);\n        /* float scale_resolution_down_by = 4; */ if (message.scaleResolutionDownBy !== 0) writer.tag(4, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Bit32).float(message.scaleResolutionDownBy);\n        /* stream.video.sfu.event.VideoLayerSetting.Priority priority = 5; */ if (message.priority !== 0) writer.tag(5, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.priority);\n        /* stream.video.sfu.models.Codec codec = 6; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(6, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* uint32 max_framerate = 7; */ if (message.maxFramerate !== 0) writer.tag(7, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).uint32(message.maxFramerate);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoLayerSetting\n */ const VideoLayerSetting = new VideoLayerSetting$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass VideoSender$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.VideoSender\", [\n            {\n                no: 1,\n                name: \"media_request\",\n                kind: \"message\",\n                T: ()=>VideoMediaRequest\n            },\n            {\n                no: 2,\n                name: \"codec\",\n                kind: \"message\",\n                T: ()=>Codec\n            },\n            {\n                no: 3,\n                name: \"layers\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoLayerSetting\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.layers = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.event.VideoMediaRequest media_request */ 1:\n                    message.mediaRequest = VideoMediaRequest.internalBinaryRead(reader, reader.uint32(), options, message.mediaRequest);\n                    break;\n                case /* stream.video.sfu.models.Codec codec */ 2:\n                    message.codec = Codec.internalBinaryRead(reader, reader.uint32(), options, message.codec);\n                    break;\n                case /* repeated stream.video.sfu.event.VideoLayerSetting layers */ 3:\n                    message.layers.push(VideoLayerSetting.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.event.VideoMediaRequest media_request = 1; */ if (message.mediaRequest) VideoMediaRequest.internalBinaryWrite(message.mediaRequest, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* stream.video.sfu.models.Codec codec = 2; */ if (message.codec) Codec.internalBinaryWrite(message.codec, writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoLayerSetting layers = 3; */ for(let i = 0; i < message.layers.length; i++)VideoLayerSetting.internalBinaryWrite(message.layers[i], writer.tag(3, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.VideoSender\n */ const VideoSender = new VideoSender$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass ChangePublishQuality$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.ChangePublishQuality\", [\n            {\n                no: 1,\n                name: \"audio_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>AudioSender\n            },\n            {\n                no: 2,\n                name: \"video_senders\",\n                kind: \"message\",\n                repeat: 1 /*RepeatType.PACKED*/ ,\n                T: ()=>VideoSender\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.audioSenders = [];\n        message.videoSenders = [];\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* repeated stream.video.sfu.event.AudioSender audio_senders */ 1:\n                    message.audioSenders.push(AudioSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                case /* repeated stream.video.sfu.event.VideoSender video_senders */ 2:\n                    message.videoSenders.push(VideoSender.internalBinaryRead(reader, reader.uint32(), options));\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* repeated stream.video.sfu.event.AudioSender audio_senders = 1; */ for(let i = 0; i < message.audioSenders.length; i++)AudioSender.internalBinaryWrite(message.audioSenders[i], writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* repeated stream.video.sfu.event.VideoSender video_senders = 2; */ for(let i = 0; i < message.videoSenders.length; i++)VideoSender.internalBinaryWrite(message.videoSenders[i], writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.ChangePublishQuality\n */ const ChangePublishQuality = new ChangePublishQuality$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass CallGrantsUpdated$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.CallGrantsUpdated\", [\n            {\n                no: 1,\n                name: \"current_grants\",\n                kind: \"message\",\n                T: ()=>CallGrants\n            },\n            {\n                no: 2,\n                name: \"message\",\n                kind: \"scalar\",\n                T: 9 /*ScalarType.STRING*/ \n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.message = \"\";\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.CallGrants current_grants */ 1:\n                    message.currentGrants = CallGrants.internalBinaryRead(reader, reader.uint32(), options, message.currentGrants);\n                    break;\n                case /* string message */ 2:\n                    message.message = reader.string();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.CallGrants current_grants = 1; */ if (message.currentGrants) CallGrants.internalBinaryWrite(message.currentGrants, writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).fork(), options).join();\n        /* string message = 2; */ if (message.message !== \"\") writer.tag(2, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.LengthDelimited).string(message.message);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.CallGrantsUpdated\n */ const CallGrantsUpdated = new CallGrantsUpdated$Type();\n// @generated message type with reflection information, may provide speed optimized methods\nclass GoAway$Type extends _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_9__.MessageType {\n    constructor(){\n        super(\"stream.video.sfu.event.GoAway\", [\n            {\n                no: 1,\n                name: \"reason\",\n                kind: \"enum\",\n                T: ()=>[\n                        \"stream.video.sfu.models.GoAwayReason\",\n                        GoAwayReason,\n                        \"GO_AWAY_REASON_\"\n                    ]\n            }\n        ]);\n    }\n    create(value) {\n        const message = globalThis.Object.create(this.messagePrototype);\n        message.reason = 0;\n        if (value !== undefined) (0,_protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_11__.reflectionMergePartial)(this, message, value);\n        return message;\n    }\n    internalBinaryRead(reader, length, options, target) {\n        let message = target ?? this.create(), end = reader.pos + length;\n        while(reader.pos < end){\n            let [fieldNo, wireType] = reader.tag();\n            switch(fieldNo){\n                case /* stream.video.sfu.models.GoAwayReason reason */ 1:\n                    message.reason = reader.int32();\n                    break;\n                default:\n                    let u = options.readUnknownField;\n                    if (u === \"throw\") throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);\n                    let d = reader.skip(wireType);\n                    if (u !== false) (u === true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);\n            }\n        }\n        return message;\n    }\n    internalBinaryWrite(message, writer, options) {\n        /* stream.video.sfu.models.GoAwayReason reason = 1; */ if (message.reason !== 0) writer.tag(1, _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.WireType.Varint).int32(message.reason);\n        let u = options.writeUnknownFields;\n        if (u !== false) (u == true ? _protobuf_ts_runtime__WEBPACK_IMPORTED_MODULE_12__.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);\n        return writer;\n    }\n}\n/**\n * @generated MessageType for protobuf message stream.video.sfu.event.GoAway\n */ const GoAway = new GoAway$Type();\nvar events = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AudioLevel: AudioLevel,\n    AudioLevelChanged: AudioLevelChanged,\n    AudioMediaRequest: AudioMediaRequest,\n    AudioSender: AudioSender,\n    CallGrantsUpdated: CallGrantsUpdated,\n    ChangePublishQuality: ChangePublishQuality,\n    ConnectionQualityChanged: ConnectionQualityChanged,\n    ConnectionQualityInfo: ConnectionQualityInfo,\n    DominantSpeakerChanged: DominantSpeakerChanged,\n    Error: Error$1,\n    GoAway: GoAway,\n    HealthCheckRequest: HealthCheckRequest,\n    HealthCheckResponse: HealthCheckResponse,\n    ICERestart: ICERestart,\n    ICETrickle: ICETrickle,\n    JoinRequest: JoinRequest,\n    JoinResponse: JoinResponse,\n    Migration: Migration,\n    ParticipantJoined: ParticipantJoined,\n    ParticipantLeft: ParticipantLeft,\n    PinsChanged: PinsChanged,\n    PublisherAnswer: PublisherAnswer,\n    SfuEvent: SfuEvent,\n    SfuRequest: SfuRequest,\n    SubscriberOffer: SubscriberOffer,\n    TrackPublished: TrackPublished,\n    TrackUnpublished: TrackUnpublished,\n    VideoLayerSetting: VideoLayerSetting,\n    get VideoLayerSetting_Priority () {\n        return VideoLayerSetting_Priority;\n    },\n    VideoMediaRequest: VideoMediaRequest,\n    VideoSender: VideoSender\n});\nvar VisibilityState;\n(function(VisibilityState) {\n    VisibilityState[\"UNKNOWN\"] = \"UNKNOWN\";\n    VisibilityState[\"VISIBLE\"] = \"VISIBLE\";\n    VisibilityState[\"INVISIBLE\"] = \"INVISIBLE\";\n})(VisibilityState || (VisibilityState = {}));\nvar DebounceType;\n(function(DebounceType) {\n    DebounceType[DebounceType[\"IMMEDIATE\"] = 20] = \"IMMEDIATE\";\n    DebounceType[DebounceType[\"FAST\"] = 100] = \"FAST\";\n    DebounceType[DebounceType[\"MEDIUM\"] = 600] = \"MEDIUM\";\n    DebounceType[DebounceType[\"SLOW\"] = 1200] = \"SLOW\";\n})(DebounceType || (DebounceType = {}));\n/**\n * @generated from protobuf service stream.video.sfu.signal.SignalServer\n */ class SignalServerClient {\n    constructor(_transport){\n        this._transport = _transport;\n        this.typeName = SignalServer.typeName;\n        this.methods = SignalServer.methods;\n        this.options = SignalServer.options;\n    }\n    /**\n     * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V\n     *\n     * @generated from protobuf rpc: SetPublisher(stream.video.sfu.signal.SetPublisherRequest) returns (stream.video.sfu.signal.SetPublisherResponse);\n     */ setPublisher(input, options) {\n        const method = this.methods[0], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * answer is sent by the client to the SFU after receiving a subscriber_offer.\n     *\n     * @generated from protobuf rpc: SendAnswer(stream.video.sfu.signal.SendAnswerRequest) returns (stream.video.sfu.signal.SendAnswerResponse);\n     */ sendAnswer(input, options) {\n        const method = this.methods[1], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * SendICECandidate sends an ICE candidate to the client\n     *\n     * @generated from protobuf rpc: IceTrickle(stream.video.sfu.models.ICETrickle) returns (stream.video.sfu.signal.ICETrickleResponse);\n     */ iceTrickle(input, options) {\n        const method = this.methods[2], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * UpdateSubscribers is used to notify the SFU about the list of video subscriptions\n     * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user\n     *\n     * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.signal.UpdateSubscriptionsRequest) returns (stream.video.sfu.signal.UpdateSubscriptionsResponse);\n     */ updateSubscriptions(input, options) {\n        const method = this.methods[3], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: UpdateMuteStates(stream.video.sfu.signal.UpdateMuteStatesRequest) returns (stream.video.sfu.signal.UpdateMuteStatesResponse);\n     */ updateMuteStates(input, options) {\n        const method = this.methods[4], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n    /**\n     * @generated from protobuf rpc: IceRestart(stream.video.sfu.signal.ICERestartRequest) returns (stream.video.sfu.signal.ICERestartResponse);\n     */ iceRestart(input, options) {\n        const method = this.methods[5], opt = this._transport.mergeOptions(options);\n        return (0,_protobuf_ts_runtime_rpc__WEBPACK_IMPORTED_MODULE_15__.stackIntercept)(\"unary\", this._transport, method, opt, input);\n    }\n}\nconst defaultOptions = {\n    baseUrl: \"\",\n    sendJson: true,\n    timeout: 5 * 1000,\n    jsonOptions: {\n        ignoreUnknownFields: true\n    }\n};\nconst withHeaders = (headers)=>{\n    return {\n        interceptUnary (next, method, input, options) {\n            options.meta = {\n                ...options.meta,\n                ...headers\n            };\n            return next(method, input, options);\n        }\n    };\n};\n/**\n * Creates new SignalServerClient instance.\n *\n * @param options the twirp options.\n */ const createSignalClient = (options)=>{\n    const transport = new _protobuf_ts_twirp_transport__WEBPACK_IMPORTED_MODULE_16__.TwirpFetchTransport({\n        ...defaultOptions,\n        ...options\n    });\n    return new SignalServerClient(transport);\n};\n/**\n * Checks whether we are using React Native\n */ const isReactNative = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.product?.toLowerCase() === \"reactnative\";\n};\n// log levels, sorted by verbosity\nconst logLevels = Object.freeze({\n    trace: 0,\n    debug: 1,\n    info: 2,\n    warn: 3,\n    error: 4\n});\nlet logger$4;\nlet level = \"info\";\nconst logToConsole = (logLevel, message, ...args)=>{\n    let logMethod;\n    switch(logLevel){\n        case \"error\":\n            logMethod = console.error;\n            break;\n        case \"warn\":\n            if (isReactNative()) {\n                message = `WARN: ${message}`;\n                logMethod = console.info;\n                break;\n            }\n            logMethod = console.warn;\n            break;\n        case \"info\":\n            logMethod = console.info;\n            break;\n        case \"trace\":\n            logMethod = console.trace;\n            break;\n        default:\n            logMethod = console.log;\n            break;\n    }\n    logMethod(message, ...args);\n};\nconst setLogger = (l, lvl)=>{\n    logger$4 = l;\n    if (lvl) {\n        setLogLevel(lvl);\n    }\n};\nconst setLogLevel = (l)=>{\n    level = l;\n};\nconst getLogger = (withTags)=>{\n    const loggerMethod = logger$4 || logToConsole;\n    const tags = (withTags || []).join(\":\");\n    const result = (logLevel, message, ...args)=>{\n        if (logLevels[logLevel] >= logLevels[level]) {\n            loggerMethod(logLevel, `[${tags}]: ${message}`, ...args);\n        }\n    };\n    return result;\n};\nconst getPreferredCodecs = (kind, preferredCodec, codecToRemove)=>{\n    const logger = getLogger([\n        \"codecs\"\n    ]);\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        logger?.(\"warn\", \"RTCRtpSender.getCapabilities is not supported\");\n        return;\n    }\n    const cap = RTCRtpSender.getCapabilities(kind);\n    if (!cap) return;\n    const matched = [];\n    const partialMatched = [];\n    const unmatched = [];\n    cap.codecs.forEach((c)=>{\n        const codec = c.mimeType.toLowerCase();\n        logger?.(\"debug\", `Found supported codec: ${codec}`);\n        const shouldRemoveCodec = codecToRemove && codec === `${kind}/${codecToRemove.toLowerCase()}`;\n        if (shouldRemoveCodec) return;\n        const matchesCodec = codec === `${kind}/${preferredCodec.toLowerCase()}`;\n        if (!matchesCodec) {\n            unmatched.push(c);\n            return;\n        }\n        // for h264 codecs that have sdpFmtpLine available, use only if the\n        // profile-level-id is 42e01f for cross-browser compatibility\n        if (codec === \"h264\") {\n            if (c.sdpFmtpLine && c.sdpFmtpLine.includes(\"profile-level-id=42e01f\")) {\n                matched.push(c);\n            } else {\n                partialMatched.push(c);\n            }\n            return;\n        }\n        matched.push(c);\n    });\n    const result = [\n        ...matched,\n        ...partialMatched,\n        ...unmatched\n    ];\n    logger?.(\"info\", `Preffered codecs: `, result);\n    return result;\n};\nconst getGenericSdp = async (direction)=>{\n    const tempPc = new RTCPeerConnection();\n    tempPc.addTransceiver(\"video\", {\n        direction\n    });\n    tempPc.addTransceiver(\"audio\", {\n        direction\n    });\n    const offer = await tempPc.createOffer();\n    let sdp = offer.sdp ?? \"\";\n    tempPc.getTransceivers().forEach((t)=>{\n        t.stop();\n    });\n    tempPc.close();\n    return sdp;\n};\nconst sfuEventKinds = {\n    subscriberOffer: undefined,\n    publisherAnswer: undefined,\n    connectionQualityChanged: undefined,\n    audioLevelChanged: undefined,\n    iceTrickle: undefined,\n    changePublishQuality: undefined,\n    participantJoined: undefined,\n    participantLeft: undefined,\n    dominantSpeakerChanged: undefined,\n    joinResponse: undefined,\n    healthCheckResponse: undefined,\n    trackPublished: undefined,\n    trackUnpublished: undefined,\n    error: undefined,\n    callGrantsUpdated: undefined,\n    goAway: undefined,\n    iceRestart: undefined,\n    pinsUpdated: undefined\n};\nconst isSfuEvent = (eventName)=>{\n    return Object.prototype.hasOwnProperty.call(sfuEventKinds, eventName);\n};\nclass Dispatcher {\n    constructor(){\n        this.logger = getLogger([\n            \"Dispatcher\"\n        ]);\n        this.subscribers = {};\n        this.dispatch = (message)=>{\n            const eventKind = message.eventPayload.oneofKind;\n            if (!eventKind) return;\n            const payload = message.eventPayload[eventKind];\n            this.logger(\"debug\", `Dispatching ${eventKind}`, payload);\n            const listeners = this.subscribers[eventKind];\n            if (!listeners) return;\n            for (const fn of listeners){\n                try {\n                    fn(payload);\n                } catch (e) {\n                    this.logger(\"warn\", \"Listener failed with error\", e);\n                }\n            }\n        };\n        this.on = (eventName, fn)=>{\n            var _a;\n            ((_a = this.subscribers)[eventName] ?? (_a[eventName] = [])).push(fn);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        this.off = (eventName, fn)=>{\n            this.subscribers[eventName] = (this.subscribers[eventName] || []).filter((f)=>f !== fn);\n        };\n        this.offAll = (eventName)=>{\n            if (eventName) {\n                this.subscribers[eventName] = [];\n            } else {\n                this.subscribers = {};\n            }\n        };\n    }\n}\n/**\n * A buffer for ICE Candidates. Used for ICE Trickle:\n * - https://bloggeek.me/webrtcglossary/trickle-ice/\n */ class IceTrickleBuffer {\n    constructor(){\n        this.subscriberCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.ReplaySubject();\n        this.publisherCandidates = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.ReplaySubject();\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        this.push = (iceTrickle)=>{\n            if (iceTrickle.peerType === PeerType.SUBSCRIBER) {\n                this.subscriberCandidates.next(iceTrickle);\n            } else if (iceTrickle.peerType === PeerType.PUBLISHER_UNSPECIFIED) {\n                this.publisherCandidates.next(iceTrickle);\n            } else {\n                this.logger(\"warn\", `ICETrickle, Unknown peer type`, iceTrickle);\n            }\n        };\n    }\n}\nfunction getIceCandidate(candidate) {\n    if (!candidate.usernameFragment) {\n        // react-native-webrtc doesn't include usernameFragment in the candidate\n        const splittedCandidate = candidate.candidate.split(\" \");\n        const ufragIndex = splittedCandidate.findIndex((s)=>s === \"ufrag\") + 1;\n        const usernameFragment = splittedCandidate[ufragIndex];\n        return JSON.stringify({\n            ...candidate,\n            usernameFragment\n        });\n    } else {\n        return JSON.stringify(candidate.toJSON());\n    }\n}\nlet sdkInfo;\nlet osInfo;\nlet deviceInfo;\nconst setSdkInfo = (info)=>{\n    sdkInfo = info;\n};\nconst getSdkInfo = ()=>{\n    return sdkInfo;\n};\nconst setOSInfo = (info)=>{\n    osInfo = info;\n};\nconst getOSInfo = ()=>{\n    return osInfo;\n};\nconst setDeviceInfo = (info)=>{\n    deviceInfo = info;\n};\nconst getDeviceInfo = ()=>{\n    return deviceInfo;\n};\nconst getClientDetails = ()=>{\n    if (isReactNative()) {\n        // Since RN doesn't support web, sharing browser info is not required\n        return {\n            sdk: getSdkInfo(),\n            os: getOSInfo(),\n            device: getDeviceInfo()\n        };\n    }\n    const userAgent = new ua_parser_js__WEBPACK_IMPORTED_MODULE_3__.UAParser(navigator.userAgent);\n    const { browser, os, device, cpu } = userAgent.getResult();\n    return {\n        sdk: getSdkInfo(),\n        browser: {\n            name: browser.name || navigator.userAgent,\n            version: browser.version || \"\"\n        },\n        os: {\n            name: os.name || \"\",\n            version: os.version || \"\",\n            architecture: cpu.architecture || \"\"\n        },\n        device: {\n            name: `${device.vendor || \"\"} ${device.model || \"\"} ${device.type || \"\"}`,\n            version: \"\"\n        }\n    };\n};\nconst DEFAULT_BITRATE = 1250000;\nconst defaultTargetResolution = {\n    bitrate: DEFAULT_BITRATE,\n    width: 1280,\n    height: 720\n};\n/**\n * Determines the most optimal video layers for simulcasting\n * for the given track.\n *\n * @param videoTrack the video track to find optimal layers for.\n * @param targetResolution the expected target resolution.\n */ const findOptimalVideoLayers = (videoTrack, targetResolution = defaultTargetResolution)=>{\n    const optimalVideoLayers = [];\n    const settings = videoTrack.getSettings();\n    const { width: w = 0, height: h = 0 } = settings;\n    const isRNIos = isReactNative() && getOSInfo()?.name.toLowerCase() === \"ios\";\n    const maxBitrate = getComputedMaxBitrate(targetResolution, w, h);\n    let downscaleFactor = 1;\n    [\n        \"f\",\n        \"h\",\n        \"q\"\n    ].forEach((rid)=>{\n        // Reversing the order [f, h, q] to [q, h, f] as Chrome uses encoding index\n        // when deciding which layer to disable when CPU or bandwidth is constrained.\n        // Encodings should be ordered in increasing spatial resolution order.\n        optimalVideoLayers.unshift({\n            active: true,\n            rid,\n            width: Math.round(w / downscaleFactor),\n            height: Math.round(h / downscaleFactor),\n            maxBitrate: Math.round(maxBitrate / downscaleFactor),\n            scaleResolutionDownBy: downscaleFactor,\n            // Simulcast on iOS React-Native requires all encodings to share the same framerate\n            maxFramerate: {\n                f: 30,\n                h: isRNIos ? 30 : 25,\n                q: isRNIos ? 30 : 20\n            }[rid]\n        });\n        downscaleFactor *= 2;\n    });\n    // for simplicity, we start with all layers enabled, then this function\n    // will clear/reassign the layers that are not needed\n    return withSimulcastConstraints(settings, optimalVideoLayers);\n};\n/**\n * Computes the maximum bitrate for a given resolution.\n * If the current resolution is lower than the target resolution,\n * we want to proportionally reduce the target bitrate.\n * If the current resolution is higher than the target resolution,\n * we want to use the target bitrate.\n *\n * @param targetResolution the target resolution.\n * @param currentWidth the current width of the track.\n * @param currentHeight the current height of the track.\n */ const getComputedMaxBitrate = (targetResolution, currentWidth, currentHeight)=>{\n    // if the current resolution is lower than the target resolution,\n    // we want to proportionally reduce the target bitrate\n    const { width: targetWidth, height: targetHeight } = targetResolution;\n    if (currentWidth < targetWidth || currentHeight < targetHeight) {\n        const currentPixels = currentWidth * currentHeight;\n        const targetPixels = targetWidth * targetHeight;\n        const reductionFactor = currentPixels / targetPixels;\n        return Math.round(targetResolution.bitrate * reductionFactor);\n    }\n    return targetResolution.bitrate;\n};\n/**\n * Browsers have different simulcast constraints for different video resolutions.\n *\n * This function modifies the provided list of video layers according to the\n * current implementation of simulcast constraints in the Chromium based browsers.\n *\n * https://chromium.googlesource.com/external/webrtc/+/refs/heads/main/media/engine/simulcast.cc#90\n */ const withSimulcastConstraints = (settings, optimalVideoLayers)=>{\n    let layers;\n    const size = Math.max(settings.width || 0, settings.height || 0);\n    if (size <= 320) {\n        // provide only one layer 320x240 (q), the one with the highest quality\n        layers = optimalVideoLayers.filter((layer)=>layer.rid === \"f\");\n    } else if (size <= 640) {\n        // provide two layers, 160x120 (q) and 640x480 (h)\n        layers = optimalVideoLayers.filter((layer)=>layer.rid !== \"h\");\n    } else {\n        // provide three layers for sizes > 640x480\n        layers = optimalVideoLayers;\n    }\n    const ridMapping = [\n        \"q\",\n        \"h\",\n        \"f\"\n    ];\n    return layers.map((layer, index)=>({\n            ...layer,\n            rid: ridMapping[index]\n        }));\n};\nconst findOptimalScreenSharingLayers = (videoTrack, preferences)=>{\n    const settings = videoTrack.getSettings();\n    return [\n        {\n            active: true,\n            rid: \"q\",\n            width: settings.width || 0,\n            height: settings.height || 0,\n            scaleResolutionDownBy: 1,\n            maxBitrate: preferences?.maxBitrate ?? 3000000,\n            maxFramerate: preferences?.maxFramerate ?? 30\n        }\n    ];\n};\nconst trackTypeToParticipantStreamKey = (trackType)=>{\n    switch(trackType){\n        case TrackType.SCREEN_SHARE:\n            return \"screenShareStream\";\n        case TrackType.SCREEN_SHARE_AUDIO:\n            return \"screenShareAudioStream\";\n        case TrackType.VIDEO:\n            return \"videoStream\";\n        case TrackType.AUDIO:\n            return \"audioStream\";\n        case TrackType.UNSPECIFIED:\n            throw new Error(\"Track type is unspecified\");\n        default:\n            const exhaustiveTrackTypeCheck = trackType;\n            throw new Error(`Unknown track type: ${exhaustiveTrackTypeCheck}`);\n    }\n};\nconst muteTypeToTrackType = (muteType)=>{\n    switch(muteType){\n        case \"audio\":\n            return TrackType.AUDIO;\n        case \"video\":\n            return TrackType.VIDEO;\n        case \"screenshare\":\n            return TrackType.SCREEN_SHARE;\n        case \"screenshare_audio\":\n            return TrackType.SCREEN_SHARE_AUDIO;\n        default:\n            const exhaustiveMuteTypeCheck = muteType;\n            throw new Error(`Unknown mute type: ${exhaustiveMuteTypeCheck}`);\n    }\n};\n/**\n * Checks if the provided update is a function patch.\n *\n * @param update the value to check.\n */ const isFunctionPatch = (update)=>typeof update === \"function\";\n/**\n * Gets the current value of an observable, or undefined if the observable has\n * not emitted a value yet.\n *\n * @param observable$ the observable to get the value from.\n */ const getCurrentValue = (observable$)=>{\n    let value;\n    let err = undefined;\n    (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n        observable$\n    ]).subscribe({\n        next: ([v])=>{\n            value = v;\n        },\n        error: (e)=>{\n            err = e;\n        }\n    }).unsubscribe();\n    if (err) throw err;\n    return value;\n};\n/**\n * Updates the value of the provided Subject.\n * An `update` can either be a new value or a function which takes\n * the current value and returns a new value.\n *\n * @param subject the subject to update.\n * @param update the update to apply to the subject.\n * @return the updated value.\n */ const setCurrentValue = (subject, update)=>{\n    const next = isFunctionPatch(update) ? update(getCurrentValue(subject)) : update;\n    subject.next(next);\n    return next;\n};\n/**\n * Creates a subscription and returns a function to unsubscribe.\n *\n * @param observable the observable to subscribe to.\n * @param handler the handler to call when the observable emits a value.\n */ const createSubscription = (observable, handler)=>{\n    const subscription = observable.subscribe(handler);\n    return ()=>{\n        subscription.unsubscribe();\n    };\n};\nvar rxUtils = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    createSubscription: createSubscription,\n    getCurrentValue: getCurrentValue,\n    setCurrentValue: setCurrentValue\n});\n/**\n * Creates a new combined {@link Comparator<T>} which sorts items by the given comparators.\n * The comparators are applied in the order they are given (left -> right).\n *\n * @param comparators the comparators to use for sorting.\n * @returns a combined {@link Comparator<T>}.\n */ const combineComparators = (...comparators)=>{\n    return (a, b)=>{\n        for (const comparator of comparators){\n            const result = comparator(a, b);\n            if (result !== 0) return result;\n        }\n        return 0;\n    };\n};\n/**\n * Creates a new comparator which sorts items in descending order.\n *\n * @example\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const byValueDesc = descending(byValue);\n *\n * @param comparator the comparator to wrap.\n */ const descending = (comparator)=>{\n    return (a, b)=>comparator(b, a);\n};\n/**\n * Creates a new comparator which conditionally applies the given comparator.\n *\n * @example\n * const shouldSortByValue = (a, b) => a % 2 === 0; // return false to turn it off\n * const byValue = (a, b) => a < b ? - 1 : a > b ? 1 : 0;\n * const comparator = conditional(shouldSortByValue)(byValue);\n *\n * @param predicate the predicate to use for determining whether to apply the comparator.\n */ const conditional = (predicate)=>{\n    return (comparator)=>{\n        return (a, b)=>{\n            if (!predicate(a, b)) return 0;\n            return comparator(a, b);\n        };\n    };\n};\n/**\n * A no-op comparator which always returns 0.\n */ const noopComparator = ()=>{\n    return ()=>0;\n};\n/**\n * A comparator which sorts participants by the fact that they are the dominant speaker or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const dominantSpeaker = (a, b)=>{\n    if (a.isDominantSpeaker && !b.isDominantSpeaker) return -1;\n    if (!a.isDominantSpeaker && b.isDominantSpeaker) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by the fact that they are speaking or not.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const speaking = (a, b)=>{\n    if (a.isSpeaking && !b.isSpeaking) return -1;\n    if (!a.isSpeaking && b.isSpeaking) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by screen sharing status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const screenSharing = (a, b)=>{\n    if (hasScreenShare(a) && !hasScreenShare(b)) return -1;\n    if (!hasScreenShare(a) && hasScreenShare(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by video status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingVideo = (a, b)=>{\n    if (hasVideo(a) && !hasVideo(b)) return -1;\n    if (!hasVideo(a) && hasVideo(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which sorts participants by audio status.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const publishingAudio = (a, b)=>{\n    if (hasAudio(a) && !hasAudio(b)) return -1;\n    if (!hasAudio(a) && hasAudio(b)) return 1;\n    return 0;\n};\n/**\n * A comparator which prioritizes participants who are pinned.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const pinned = (a, b)=>{\n    if (a.pin && b.pin) {\n        if (!a.pin.isLocalPin && b.pin.isLocalPin) return -1;\n        if (a.pin.isLocalPin && !b.pin.isLocalPin) return 1;\n        if (a.pin.pinnedAt > b.pin.pinnedAt) return -1;\n        if (a.pin.pinnedAt < b.pin.pinnedAt) return 1;\n    }\n    if (a.pin && !b.pin) return -1;\n    if (!a.pin && b.pin) return 1;\n    return 0;\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific reaction.\n *\n * @param type the reaction type.\n */ const reactionType = (type)=>{\n    return (a, b)=>{\n        if (a.reaction?.type === type && b.reaction?.type !== type) return -1;\n        if (a.reaction?.type !== type && b.reaction?.type === type) return 1;\n        return 0;\n    };\n};\n/**\n * A comparator creator which will set up a comparator which prioritizes\n * participants who have a specific role.\n *\n * @param roles the roles to prioritize.\n */ const role = (...roles)=>(a, b)=>{\n        if (hasAnyRole(a, roles) && !hasAnyRole(b, roles)) return -1;\n        if (!hasAnyRole(a, roles) && hasAnyRole(b, roles)) return 1;\n        return 0;\n    };\n/**\n * A comparator which sorts participants by name.\n *\n * @param a the first participant.\n * @param b the second participant.\n */ const name = (a, b)=>{\n    if (a.name < b.name) return -1;\n    if (a.name > b.name) return 1;\n    return 0;\n};\nconst hasAnyRole = (p, roles)=>(p.roles || []).some((r)=>roles.includes(r));\nconst hasScreenShare = (p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE);\nconst hasVideo = (p)=>p.publishedTracks.includes(TrackType.VIDEO);\nconst hasAudio = (p)=>p.publishedTracks.includes(TrackType.AUDIO);\n// a comparator decorator which applies the decorated comparator only if the\n// participant is invisible.\n// This ensures stable sorting when all participants are visible.\nconst ifInvisibleBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE);\n/**\n * A comparator that applies the decorated comparator when a participant is\n * either invisible or its visibility state isn't known.\n * For visible participants, it ensures stable sorting.\n */ const ifInvisibleOrUnknownBy = conditional((a, b)=>a.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || a.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN || b.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN);\n/**\n * The default sorting preset.\n */ const defaultSortPreset = combineComparators(pinned, screenSharing, ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for speaker layout.\n */ const speakerLayoutSortPreset = combineComparators(pinned, screenSharing, dominantSpeaker, ifInvisibleBy(combineComparators(speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for layouts that don't render all participants but\n * instead, render them in pages.\n */ const paginatedLayoutSortPreset = combineComparators(pinned, ifInvisibleOrUnknownBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)));\n/**\n * The sorting preset for livestreams and audio rooms.\n */ const livestreamOrAudioRoomSortPreset = combineComparators(ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType(\"raised-hand\"), publishingVideo, publishingAudio)), role(\"admin\", \"host\", \"speaker\"));\n/**\n * Represents the state of the current call.\n */ var CallingState;\n(function(CallingState) {\n    /**\n     * The call is in an unknown state.\n     */ CallingState[\"UNKNOWN\"] = \"unknown\";\n    /**\n     * The call is in an idle state.\n     */ CallingState[\"IDLE\"] = \"idle\";\n    /**\n     * The call is in the process of ringing.\n     * (User hasn't accepted nor rejected the call yet.)\n     */ CallingState[\"RINGING\"] = \"ringing\";\n    /**\n     * The call is in the process of joining.\n     */ CallingState[\"JOINING\"] = \"joining\";\n    /**\n     * The call is currently active.\n     */ CallingState[\"JOINED\"] = \"joined\";\n    /**\n     * The call has been left.\n     */ CallingState[\"LEFT\"] = \"left\";\n    /**\n     * The call is in the process of reconnecting.\n     */ CallingState[\"RECONNECTING\"] = \"reconnecting\";\n    /**\n     * The call is in the process of migrating from one node to another.\n     */ CallingState[\"MIGRATING\"] = \"migrating\";\n    /**\n     * The call has failed to reconnect.\n     */ CallingState[\"RECONNECTING_FAILED\"] = \"reconnecting-failed\";\n    /**\n     * The call is in offline mode.\n     */ CallingState[\"OFFLINE\"] = \"offline\";\n})(CallingState || (CallingState = {}));\n/**\n * Holds the state of the current call.\n * @react You don't have to use this class directly, as we are exposing the state through Hooks.\n */ class CallState {\n    /**\n     * Creates a new instance of the CallState class.\n     *\n     */ constructor(){\n        this.backstageSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(true);\n        this.blockedUserIdsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.createdAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(new Date());\n        this.endedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.startsAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.updatedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(new Date());\n        this.createdBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.customSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject({});\n        this.egressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.ingressSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.recordingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.sessionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.transcribingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.endedBySubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.thumbnailsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.membersSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.ownCapabilitiesSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.callingStateSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(CallingState.UNKNOWN);\n        this.startedAtSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.participantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(0);\n        this.anonymousParticipantCountSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(0);\n        this.participantsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        this.callStatsReportSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * A list of comparators that are used to sort the participants.\n         *\n         * @private\n         */ this.sortParticipantsBy = defaultSortPreset;\n        /**\n         * Sets the list of criteria that are used to sort the participants.\n         * To disable sorting, you can pass `noopComparator()`.\n         *\n         * @param comparator the comparator to use to sort the participants.\n         */ this.setSortParticipantsBy = (comparator)=>{\n            this.sortParticipantsBy = comparator;\n            // trigger re-sorting of participants\n            this.setCurrentValue(this.participantsSubject, (ps)=>ps);\n        };\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the number of participants in the current call.\n         *\n         * @internal\n         * @param count the number of participants.\n         */ this.setParticipantCount = (count)=>{\n            return this.setCurrentValue(this.participantCountSubject, count);\n        };\n        /**\n         * Sets the time the call session actually started.\n         *\n         * @internal\n         * @param startedAt the time the call session actually started.\n         */ this.setStartedAt = (startedAt)=>{\n            return this.setCurrentValue(this.startedAtSubject, startedAt);\n        };\n        /**\n         * Sets the number of anonymous participants in the current call.\n         *\n         * @internal\n         * @param count the number of anonymous participants.\n         */ this.setAnonymousParticipantCount = (count)=>{\n            return this.setCurrentValue(this.anonymousParticipantCountSubject, count);\n        };\n        /**\n         * Sets the list of participants in the current call.\n         *\n         * @internal\n         *\n         * @param participants the list of participants.\n         */ this.setParticipants = (participants)=>{\n            return this.setCurrentValue(this.participantsSubject, participants);\n        };\n        /**\n         * Sets the calling state.\n         *\n         * @internal\n         * @param state the new calling state.\n         */ this.setCallingState = (state)=>{\n            return this.setCurrentValue(this.callingStateSubject, state);\n        };\n        /**\n         * Sets the call stats report.\n         *\n         * @internal\n         * @param report the report to set.\n         */ this.setCallStatsReport = (report)=>{\n            return this.setCurrentValue(this.callStatsReportSubject, report);\n        };\n        /**\n         * Sets the members of the current call.\n         *\n         * @internal\n         * @param members the members to set.\n         */ this.setMembers = (members)=>{\n            this.setCurrentValue(this.membersSubject, members);\n        };\n        /**\n         * Sets the own capabilities.\n         *\n         * @internal\n         * @param capabilities the capabilities to set.\n         */ this.setOwnCapabilities = (capabilities)=>{\n            return this.setCurrentValue(this.ownCapabilitiesSubject, capabilities);\n        };\n        /**\n         * Will try to find the participant with the given sessionId in the current call.\n         *\n         * @param sessionId the sessionId of the participant to find.\n         * @returns the participant with the given sessionId or undefined if not found.\n         */ this.findParticipantBySessionId = (sessionId)=>{\n            return this.participants.find((p)=>p.sessionId === sessionId);\n        };\n        /**\n         * Returns a new lookup table of participants indexed by their session ID.\n         */ this.getParticipantLookupBySessionId = ()=>{\n            return this.participants.reduce((lookupTable, participant)=>{\n                lookupTable[participant.sessionId] = participant;\n                return lookupTable;\n            }, {});\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If the participant can't be found, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param patch the patch to apply to the participant.\n         * @returns the updated participant or `undefined` if the participant couldn't be found.\n         */ this.updateParticipant = (sessionId, patch)=>{\n            const participant = this.findParticipantBySessionId(sessionId);\n            if (!participant) {\n                this.logger(\"warn\", `Participant with sessionId ${sessionId} not found`);\n                return;\n            }\n            const thePatch = typeof patch === \"function\" ? patch(participant) : patch;\n            const updatedParticipant = {\n                // FIXME OL: this is not a deep merge, we might want to revisit this\n                ...participant,\n                ...thePatch\n            };\n            return this.setParticipants((participants)=>participants.map((p)=>p.sessionId === sessionId ? updatedParticipant : p));\n        };\n        /**\n         * Updates a participant in the current call identified by the given `sessionId`.\n         * If a participant with matching `sessionId` can't be found, the provided\n         * `participant` is added to the list of participants.\n         *\n         * @param sessionId the session ID of the participant to update.\n         * @param participant the participant to update or add.\n         */ this.updateOrAddParticipant = (sessionId, participant)=>{\n            if (!this.findParticipantBySessionId(sessionId)) {\n                return this.setParticipants((participants)=>[\n                        ...participants,\n                        participant\n                    ]);\n            }\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    if (p.sessionId === sessionId) {\n                        return {\n                            ...p,\n                            ...participant\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates all participants in the current call whose session ID is in the given `sessionIds`.\n         * If no patches are provided, this operation is no-op.\n         *\n         * @internal\n         *\n         * @param patch the patch to apply to the participants.\n         * @returns all participants, with all patch applied.\n         */ this.updateParticipants = (patch)=>{\n            if (Object.keys(patch).length === 0) return;\n            return this.setParticipants((participants)=>participants.map((p)=>{\n                    const thePatch = patch[p.sessionId];\n                    if (thePatch) {\n                        return {\n                            ...p,\n                            ...thePatch\n                        };\n                    }\n                    return p;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param event the video event that our backend sent us.\n         */ this.updateFromEvent = (event)=>{\n            const update = this.eventHandlers[event.type];\n            if (update) {\n                update(event);\n            }\n        };\n        /**\n         * Updates the participant pinned state with server side pinning data.\n         *\n         * @param pins the latest pins from the server.\n         */ this.setServerSidePins = (pins)=>{\n            const pinsLookup = pins.reduce((lookup, pin)=>{\n                lookup[pin.sessionId] = Date.now();\n                return lookup;\n            }, {});\n            return this.setParticipants((participants)=>participants.map((participant)=>{\n                    const serverSidePinnedAt = pinsLookup[participant.sessionId];\n                    // the participant is newly pinned\n                    if (serverSidePinnedAt) {\n                        return {\n                            ...participant,\n                            pin: {\n                                isLocalPin: false,\n                                pinnedAt: serverSidePinnedAt\n                            }\n                        };\n                    }\n                    // the participant is no longer pinned server side\n                    // we need to reset the pin\n                    if (participant.pin && !participant.pin.isLocalPin) {\n                        return {\n                            ...participant,\n                            pin: undefined\n                        };\n                    }\n                    // no changes to be applied\n                    return participant;\n                }));\n        };\n        /**\n         * Updates the call state with the data received from the server.\n         *\n         * @internal\n         *\n         * @param call the call response from the server.\n         */ this.updateFromCallResponse = (call)=>{\n            this.setCurrentValue(this.backstageSubject, call.backstage);\n            this.setCurrentValue(this.blockedUserIdsSubject, call.blocked_user_ids);\n            this.setCurrentValue(this.createdAtSubject, new Date(call.created_at));\n            this.setCurrentValue(this.updatedAtSubject, new Date(call.updated_at));\n            this.setCurrentValue(this.startsAtSubject, call.starts_at ? new Date(call.starts_at) : undefined);\n            this.setCurrentValue(this.endedAtSubject, call.ended_at ? new Date(call.ended_at) : undefined);\n            this.setCurrentValue(this.createdBySubject, call.created_by);\n            this.setCurrentValue(this.customSubject, call.custom);\n            this.setCurrentValue(this.egressSubject, call.egress);\n            this.setCurrentValue(this.ingressSubject, call.ingress);\n            this.setCurrentValue(this.recordingSubject, call.recording);\n            this.setCurrentValue(this.sessionSubject, call.session);\n            this.setCurrentValue(this.settingsSubject, call.settings);\n            this.setCurrentValue(this.transcribingSubject, call.transcribing);\n            this.setCurrentValue(this.thumbnailsSubject, call.thumbnails);\n        };\n        this.updateFromMemberRemoved = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.filter((m)=>event.members.indexOf(m.user_id) === -1));\n        };\n        this.updateFromMemberAdded = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>[\n                    ...members,\n                    ...event.members\n                ]);\n        };\n        this.updateFromHLSBroadcastStopped = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastingFailed = ()=>{\n            this.setCurrentValue(this.egressSubject, (egress)=>({\n                    ...egress,\n                    broadcasting: false\n                }));\n        };\n        this.updateFromHLSBroadcastStarted = (event)=>{\n            this.setCurrentValue(this.egressSubject, (egress)=>({\n                    ...egress,\n                    broadcasting: true,\n                    hls: {\n                        ...egress.hls,\n                        playlist_url: event.hls_playlist_url\n                    }\n                }));\n        };\n        this.updateFromSessionParticipantLeft = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_left event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                return {\n                    ...session,\n                    participants: participants.filter((p)=>p.user_session_id !== user_session_id),\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: Math.max(0, (participants_count_by_role[user.role] || 0) - 1)\n                    }\n                };\n            });\n        };\n        this.updateFromSessionParticipantJoined = (event)=>{\n            this.setCurrentValue(this.sessionSubject, (session)=>{\n                if (!session) {\n                    this.logger(\"warn\", `Received call.session_participant_joined event but no session is available.`, event);\n                    return session;\n                }\n                const { participants, participants_count_by_role } = session;\n                const { user, user_session_id } = event.participant;\n                // It could happen that the backend delivers the same participant more than once.\n                // Once with the call.session_started event and once again with the\n                // call.session_participant_joined event. In this case,\n                // we should update the existing participant and prevent duplicating it.\n                let shouldInsertParticipant = true;\n                const updatedParticipants = participants.map((p)=>{\n                    if (p.user_session_id === user_session_id) {\n                        shouldInsertParticipant = false;\n                        return event.participant;\n                    }\n                    return p;\n                });\n                if (shouldInsertParticipant) {\n                    // this is a new array, we can safely push the new participant\n                    updatedParticipants.push(event.participant);\n                }\n                // If we are updating an existing participant, we don't want to increment\n                // the participant_by_role count.\n                const increment = shouldInsertParticipant ? 1 : 0;\n                return {\n                    ...session,\n                    participants: updatedParticipants,\n                    participants_count_by_role: {\n                        ...participants_count_by_role,\n                        [user.role]: (participants_count_by_role[user.role] || 0) + increment\n                    }\n                };\n            });\n        };\n        this.updateMembers = (event)=>{\n            this.setCurrentValue(this.membersSubject, (members)=>members.map((member)=>{\n                    const memberUpdate = event.members.find((m)=>m.user_id === member.user_id);\n                    return memberUpdate ? memberUpdate : member;\n                }));\n        };\n        this.updateParticipantReaction = (event)=>{\n            const { user, custom, type, emoji_code } = event.reaction;\n            this.setParticipants((participants)=>{\n                return participants.map((p)=>{\n                    // skip if the reaction is not for this participant\n                    if (p.userId !== user.id) return p;\n                    // update the participant with the new reaction\n                    return {\n                        ...p,\n                        reaction: {\n                            type,\n                            emoji_code,\n                            custom\n                        }\n                    };\n                });\n            });\n        };\n        this.unblockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>{\n                if (!current) return current;\n                return current.filter((id)=>id !== event.user.id);\n            });\n        };\n        this.blockUser = (event)=>{\n            this.setCurrentValue(this.blockedUserIdsSubject, (current)=>[\n                    ...current || [],\n                    event.user.id\n                ]);\n        };\n        this.updateOwnCapabilities = (event)=>{\n            if (event.user.id === this.localParticipant?.userId) {\n                this.setCurrentValue(this.ownCapabilitiesSubject, event.own_capabilities);\n            }\n        };\n        this.logger = getLogger([\n            \"CallState\"\n        ]);\n        this.participants$ = this.participantsSubject.asObservable().pipe(// maintain stable-sort by mutating the participants stored\n        // in the original subject\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((ps)=>ps.sort(this.sortParticipantsBy)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.localParticipant$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.remoteParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.filter((p)=>!p.isLocalParticipant)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.pinnedParticipants$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.filter((p)=>!!p.pin)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.dominantSpeaker$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.isDominantSpeaker)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.hasOngoingScreenShare$ = this.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.some((p)=>p.publishedTracks.includes(TrackType.SCREEN_SHARE))), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n            bufferSize: 1,\n            refCount: true\n        }));\n        this.startedAt$ = this.startedAtSubject.asObservable();\n        this.participantCount$ = this.participantCountSubject.asObservable();\n        this.anonymousParticipantCount$ = this.anonymousParticipantCountSubject.asObservable();\n        this.callStatsReport$ = this.callStatsReportSubject.asObservable();\n        this.members$ = this.membersSubject.asObservable();\n        this.ownCapabilities$ = this.ownCapabilitiesSubject.asObservable();\n        this.callingState$ = this.callingStateSubject.asObservable();\n        this.backstage$ = this.backstageSubject.asObservable();\n        this.blockedUserIds$ = this.blockedUserIdsSubject.asObservable();\n        this.createdAt$ = this.createdAtSubject.asObservable();\n        this.endedAt$ = this.endedAtSubject.asObservable();\n        this.startsAt$ = this.startsAtSubject.asObservable();\n        this.updatedAt$ = this.updatedAtSubject.asObservable();\n        this.createdBy$ = this.createdBySubject.asObservable();\n        this.custom$ = this.customSubject.asObservable();\n        this.egress$ = this.egressSubject.asObservable();\n        this.ingress$ = this.ingressSubject.asObservable();\n        this.recording$ = this.recordingSubject.asObservable();\n        this.session$ = this.sessionSubject.asObservable();\n        this.settings$ = this.settingsSubject.asObservable();\n        this.transcribing$ = this.transcribingSubject.asObservable();\n        this.endedBy$ = this.endedBySubject.asObservable();\n        this.thumbnails$ = this.thumbnailsSubject.asObservable();\n        this.eventHandlers = {\n            // these events are not updating the call state:\n            \"call.permission_request\": undefined,\n            \"call.recording_failed\": undefined,\n            \"call.recording_ready\": undefined,\n            \"call.user_muted\": undefined,\n            \"connection.error\": undefined,\n            \"connection.ok\": undefined,\n            \"health.check\": undefined,\n            custom: undefined,\n            // events that update call state:\n            \"call.accepted\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.blocked_user\": this.blockUser,\n            \"call.created\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ended\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setCurrentValue(this.endedBySubject, e.user);\n            },\n            \"call.hls_broadcasting_failed\": this.updateFromHLSBroadcastingFailed,\n            \"call.hls_broadcasting_started\": this.updateFromHLSBroadcastStarted,\n            \"call.hls_broadcasting_stopped\": this.updateFromHLSBroadcastStopped,\n            \"call.live_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.member_added\": this.updateFromMemberAdded,\n            \"call.member_removed\": this.updateFromMemberRemoved,\n            \"call.member_updated_permission\": this.updateMembers,\n            \"call.member_updated\": this.updateMembers,\n            \"call.notification\": (e)=>{\n                this.updateFromCallResponse(e.call);\n                this.setMembers(e.members);\n            },\n            \"call.permissions_updated\": this.updateOwnCapabilities,\n            \"call.reaction_new\": this.updateParticipantReaction,\n            \"call.recording_started\": ()=>this.setCurrentValue(this.recordingSubject, true),\n            \"call.recording_stopped\": ()=>this.setCurrentValue(this.recordingSubject, false),\n            \"call.rejected\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.ring\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_ended\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.session_participant_joined\": this.updateFromSessionParticipantJoined,\n            \"call.session_participant_left\": this.updateFromSessionParticipantLeft,\n            \"call.session_started\": (e)=>this.updateFromCallResponse(e.call),\n            \"call.unblocked_user\": this.unblockUser,\n            \"call.updated\": (e)=>this.updateFromCallResponse(e.call)\n        };\n    }\n    /**\n     * The server-side counted number of participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get participantCount() {\n        return this.getCurrentValue(this.participantCount$);\n    }\n    /**\n     * The time the call session actually started.\n     * Useful for displaying the call duration.\n     */ get startedAt() {\n        return this.getCurrentValue(this.startedAt$);\n    }\n    /**\n     * The server-side counted number of anonymous participants connected to the current call.\n     * This number includes the anonymous participants as well.\n     */ get anonymousParticipantCount() {\n        return this.getCurrentValue(this.anonymousParticipantCount$);\n    }\n    /**\n     * The list of participants in the current call.\n     */ get participants() {\n        return this.getCurrentValue(this.participants$);\n    }\n    /**\n     * The local participant in the current call.\n     */ get localParticipant() {\n        return this.getCurrentValue(this.localParticipant$);\n    }\n    /**\n     * The list of remote participants in the current call.\n     */ get remoteParticipants() {\n        return this.getCurrentValue(this.remoteParticipants$);\n    }\n    /**\n     * The dominant speaker in the current call.\n     */ get dominantSpeaker() {\n        return this.getCurrentValue(this.dominantSpeaker$);\n    }\n    /**\n     * The list of pinned participants in the current call.\n     */ get pinnedParticipants() {\n        return this.getCurrentValue(this.pinnedParticipants$);\n    }\n    /**\n     * Tell if there is an ongoing screen share in this call.\n     */ get hasOngoingScreenShare() {\n        return this.getCurrentValue(this.hasOngoingScreenShare$);\n    }\n    /**\n     * The calling state.\n     */ get callingState() {\n        return this.getCurrentValue(this.callingState$);\n    }\n    /**\n     * The call stats report.\n     */ get callStatsReport() {\n        return this.getCurrentValue(this.callStatsReport$);\n    }\n    /**\n     * The members of the current call.\n     */ get members() {\n        return this.getCurrentValue(this.members$);\n    }\n    /**\n     * The capabilities of the current user for the current call.\n     */ get ownCapabilities() {\n        return this.getCurrentValue(this.ownCapabilities$);\n    }\n    /**\n     * The backstage state.\n     */ get backstage() {\n        return this.getCurrentValue(this.backstage$);\n    }\n    /**\n     * Will provide the list of blocked user IDs.\n     */ get blockedUserIds() {\n        return this.getCurrentValue(this.blockedUserIds$);\n    }\n    /**\n     * Will provide the time when this call has been created.\n     */ get createdAt() {\n        return this.getCurrentValue(this.createdAt$);\n    }\n    /**\n     * Will provide the time when this call has been ended.\n     */ get endedAt() {\n        return this.getCurrentValue(this.endedAt$);\n    }\n    /**\n     * Will provide the time when this call has been scheduled to start.\n     */ get startsAt() {\n        return this.getCurrentValue(this.startsAt$);\n    }\n    /**\n     * Will provide the time when this call has been updated.\n     */ get updatedAt() {\n        return this.getCurrentValue(this.updatedAt$);\n    }\n    /**\n     * Will provide the user who created this call.\n     */ get createdBy() {\n        return this.getCurrentValue(this.createdBy$);\n    }\n    /**\n     * Will provide the custom data of this call.\n     */ get custom() {\n        return this.getCurrentValue(this.custom$);\n    }\n    /**\n     * Will provide the egress data of this call.\n     */ get egress() {\n        return this.getCurrentValue(this.egress$);\n    }\n    /**\n     * Will provide the ingress data of this call.\n     */ get ingress() {\n        return this.getCurrentValue(this.ingress$);\n    }\n    /**\n     * Will provide the recording state of this call.\n     */ get recording() {\n        return this.getCurrentValue(this.recording$);\n    }\n    /**\n     * Will provide the session data of this call.\n     */ get session() {\n        return this.getCurrentValue(this.session$);\n    }\n    /**\n     * Will provide the settings of this call.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Will provide the transcribing state of this call.\n     */ get transcribing() {\n        return this.getCurrentValue(this.transcribing$);\n    }\n    /**\n     * Will provide the user who ended this call.\n     */ get endedBy() {\n        return this.getCurrentValue(this.endedBy$);\n    }\n    /**\n     * Will provide the thumbnails of this call, if enabled in the call settings.\n     */ get thumbnails() {\n        return this.getCurrentValue(this.thumbnails$);\n    }\n}\nclass StreamVideoWriteableStateStore {\n    constructor(){\n        /**\n         * A store keeping data of a successfully connected user over WS to the coordinator server.\n         */ this.connectedUserSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * A list of {@link Call} objects created/tracked by this client.\n         */ this.callsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject([]);\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        /**\n         * Sets the currently connected user.\n         *\n         * @internal\n         * @param user the user to set as connected.\n         */ this.setConnectedUser = (user)=>{\n            return this.setCurrentValue(this.connectedUserSubject, user);\n        };\n        /**\n         * Sets the list of {@link Call} objects created/tracked by this client.\n         * @param calls\n         */ this.setCalls = (calls)=>{\n            return this.setCurrentValue(this.callsSubject, calls);\n        };\n        /**\n         * Adds a {@link Call} object to the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to add.\n         */ this.registerCall = (call)=>{\n            if (!this.calls.find((c)=>c.cid === call.cid)) {\n                this.setCalls((calls)=>[\n                        ...calls,\n                        call\n                    ]);\n            }\n        };\n        /**\n         * Removes a {@link Call} object from the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param call the call to remove\n         */ this.unregisterCall = (call)=>{\n            return this.setCalls((calls)=>calls.filter((c)=>c !== call));\n        };\n        /**\n         * Finds a {@link Call} object in the list of {@link Call} objects created/tracked by this client.\n         *\n         * @param type the type of call to find.\n         * @param id the id of the call to find.\n         */ this.findCall = (type, id)=>{\n            return this.calls.find((c)=>c.type === type && c.id === id);\n        };\n        this.connectedUserSubject.subscribe(async (user)=>{\n            // leave all calls when the user disconnects.\n            if (!user) {\n                const logger = getLogger([\n                    \"client-state\"\n                ]);\n                for (const call of this.calls){\n                    if (call.state.callingState === CallingState.LEFT) continue;\n                    logger(\"info\", `User disconnected, leaving call: ${call.cid}`);\n                    await call.leave().catch((err)=>{\n                        logger(\"error\", `Error leaving call: ${call.cid}`, err);\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * The currently connected user.\n     */ get connectedUser() {\n        return this.getCurrentValue(this.connectedUserSubject);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return this.getCurrentValue(this.callsSubject);\n    }\n}\n/**\n * A reactive store that exposes state variables in a reactive manner.\n * You can subscribe to changes of the different state variables.\n * This central store contains all the state variables related to [`StreamVideoClient`](./StreamVideClient.md) and [`Call`](./Call.md).\n */ class StreamVideoReadOnlyStateStore {\n    constructor(store){\n        /**\n         * This method allows you the get the current value of a state variable.\n         *\n         * @param observable the observable to get the current value of.\n         * @returns the current value of the observable.\n         */ this.getCurrentValue = getCurrentValue;\n        // convert and expose subjects as observables\n        this.connectedUser$ = store.connectedUserSubject.asObservable();\n        this.calls$ = store.callsSubject.asObservable();\n    }\n    /**\n     * The current user connected over WS to the backend.\n     */ get connectedUser() {\n        return getCurrentValue(this.connectedUser$);\n    }\n    /**\n     * A list of {@link Call} objects created/tracked by this client.\n     */ get calls() {\n        return getCurrentValue(this.calls$);\n    }\n}\nconst getRtpMap = (line)=>{\n    // Example: a=rtpmap:110 opus/48000/2\n    const rtpRegex = /^a=rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/;\n    // The first captured group is the payload type number, the second captured group is the encoding name, the third captured group is the clock rate, and the fourth captured group is any additional parameters.\n    const rtpMatch = rtpRegex.exec(line);\n    if (rtpMatch) {\n        return {\n            original: rtpMatch[0],\n            payload: rtpMatch[1],\n            codec: rtpMatch[2]\n        };\n    }\n};\nconst getFmtp = (line)=>{\n    // Example: a=fmtp:111 minptime=10; useinbandfec=1\n    const fmtpRegex = /^a=fmtp:(\\d*) (.*)/;\n    const fmtpMatch = fmtpRegex.exec(line);\n    // The first captured group is the payload type number, the second captured group is any additional parameters.\n    if (fmtpMatch) {\n        return {\n            original: fmtpMatch[0],\n            payload: fmtpMatch[1],\n            config: fmtpMatch[2]\n        };\n    }\n};\n/**\n * gets the media section for the specified media type.\n * The media section contains the media type, port, codec, and payload type.\n * Example: m=video 9 UDP/TLS/RTP/SAVPF 100 101 96 97 35 36 102 125 127\n */ const getMedia = (line, mediaType)=>{\n    const regex = new RegExp(`(m=${mediaType} \\\\d+ [\\\\w/]+) ([\\\\d\\\\s]+)`);\n    const match = regex.exec(line);\n    if (match) {\n        return {\n            original: match[0],\n            mediaWithPorts: match[1],\n            codecOrder: match[2]\n        };\n    }\n};\nconst getMediaSection = (sdp, mediaType)=>{\n    let media;\n    const rtpMap = [];\n    const fmtp = [];\n    let isTheRequiredMediaSection = false;\n    sdp.split(/(\\r\\n|\\r|\\n)/).forEach((line)=>{\n        const isValidLine = /^([a-z])=(.*)/.test(line);\n        if (!isValidLine) return;\n        /*\n          NOTE: according to https://www.rfc-editor.org/rfc/rfc8866.pdf\n          Each media description starts with an \"m=\" line and continues to the next media description or the end of the whole session description, whichever comes first\n        */ const type = line[0];\n        if (type === \"m\") {\n            const _media = getMedia(line, mediaType);\n            isTheRequiredMediaSection = !!_media;\n            if (_media) {\n                media = _media;\n            }\n        } else if (isTheRequiredMediaSection && type === \"a\") {\n            const rtpMapLine = getRtpMap(line);\n            const fmtpLine = getFmtp(line);\n            if (rtpMapLine) {\n                rtpMap.push(rtpMapLine);\n            } else if (fmtpLine) {\n                fmtp.push(fmtpLine);\n            }\n        }\n    });\n    if (media) {\n        return {\n            media,\n            rtpMap,\n            fmtp\n        };\n    }\n};\n/**\n * Gets the fmtp line corresponding to opus\n */ const getOpusFmtp = (sdp)=>{\n    const section = getMediaSection(sdp, \"audio\");\n    const rtpMap = section?.rtpMap.find((r)=>r.codec.toLowerCase() === \"opus\");\n    const codecId = rtpMap?.payload;\n    if (codecId) {\n        return section?.fmtp.find((f)=>f.payload === codecId);\n    }\n};\n/**\n * Returns an SDP with DTX enabled or disabled.\n */ const toggleDtx = (sdp, enable)=>{\n    const opusFmtp = getOpusFmtp(sdp);\n    if (opusFmtp) {\n        const matchDtx = /usedtx=(\\d)/.exec(opusFmtp.config);\n        const requiredDtxConfig = `usedtx=${enable ? \"1\" : \"0\"}`;\n        if (matchDtx) {\n            const newFmtp = opusFmtp.original.replace(/usedtx=(\\d)/, requiredDtxConfig);\n            return sdp.replace(opusFmtp.original, newFmtp);\n        } else {\n            const newFmtp = `${opusFmtp.original};${requiredDtxConfig}`;\n            return sdp.replace(opusFmtp.original, newFmtp);\n        }\n    }\n    return sdp;\n};\n/**\n * Enables high-quality audio through SDP munging for the given trackMid.\n *\n * @param sdp the SDP to munge.\n * @param trackMid the trackMid.\n * @param maxBitrate the max bitrate to set.\n */ const enableHighQualityAudio = (sdp, trackMid, maxBitrate = 510000)=>{\n    maxBitrate = Math.max(Math.min(maxBitrate, 510000), 96000);\n    const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n    const audioMedia = parsedSdp.media.find((m)=>m.type === \"audio\" && String(m.mid) === trackMid);\n    if (!audioMedia) return sdp;\n    const opusRtp = audioMedia.rtp.find((r)=>r.codec === \"opus\");\n    if (!opusRtp) return sdp;\n    const opusFmtp = audioMedia.fmtp.find((f)=>f.payload === opusRtp.payload);\n    if (!opusFmtp) return sdp;\n    // enable stereo, if not already enabled\n    if (opusFmtp.config.match(/stereo=(\\d)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/stereo=(\\d)/, \"stereo=1\");\n    } else {\n        opusFmtp.config = `${opusFmtp.config};stereo=1`;\n    }\n    // set maxaveragebitrate, to the given value\n    if (opusFmtp.config.match(/maxaveragebitrate=(\\d*)/)) {\n        opusFmtp.config = opusFmtp.config.replace(/maxaveragebitrate=(\\d*)/, `maxaveragebitrate=${maxBitrate}`);\n    } else {\n        opusFmtp.config = `${opusFmtp.config};maxaveragebitrate=${maxBitrate}`;\n    }\n    return sdp_transform__WEBPACK_IMPORTED_MODULE_2__.write(parsedSdp);\n};\nconst logger$3 = getLogger([\n    \"Publisher\"\n]);\n/**\n * The `Publisher` is responsible for publishing/unpublishing media streams to/from the SFU\n * @internal\n */ class Publisher {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Publisher` instance.\n     *\n     * @param connectionConfig the connection configuration to use.\n     * @param sfuClient the SFU client to use.\n     * @param state the call state to use.\n     * @param dispatcher the dispatcher to use.\n     * @param isDtxEnabled whether DTX is enabled.\n     * @param isRedEnabled whether RED is enabled.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE once connection goes to `disconnected` state.\n     */ constructor({ connectionConfig, sfuClient, dispatcher, state, isDtxEnabled, isRedEnabled, iceRestartDelay = 2500 }){\n        this.transceiverRegistry = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.publishOptionsPerTrackType = new Map();\n        /**\n         * An array maintaining the order how transceivers were added to the peer connection.\n         * This is needed because some browsers (Firefox) don't reliably report\n         * trackId and `mid` parameters.\n         *\n         * @private\n         */ this.transceiverInitOrder = [];\n        this.trackKindMapping = {\n            [TrackType.AUDIO]: \"audio\",\n            [TrackType.VIDEO]: \"video\",\n            [TrackType.SCREEN_SHARE]: \"video\",\n            [TrackType.SCREEN_SHARE_AUDIO]: \"audio\",\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.trackLayersCache = {\n            [TrackType.AUDIO]: undefined,\n            [TrackType.VIDEO]: undefined,\n            [TrackType.SCREEN_SHARE]: undefined,\n            [TrackType.SCREEN_SHARE_AUDIO]: undefined,\n            [TrackType.UNSPECIFIED]: undefined\n        };\n        this.isIceRestarting = false;\n        this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            pc.addEventListener(\"signalingstatechange\", this.onSignalingStateChange);\n            return pc;\n        };\n        /**\n         * Closes the publisher PeerConnection and cleans up the resources.\n         */ this.close = ({ stopTracks = true } = {})=>{\n            if (stopTracks) {\n                this.stopPublishing();\n                Object.keys(this.transceiverRegistry).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.transceiverRegistry[trackType] = undefined;\n                });\n                Object.keys(this.trackLayersCache).forEach((trackType)=>{\n                    // @ts-ignore\n                    this.trackLayersCache[trackType] = undefined;\n                });\n            }\n            clearTimeout(this.iceRestartTimeout);\n            this.unsubscribeOnIceRestart();\n            this.pc.removeEventListener(\"negotiationneeded\", this.onNegotiationNeeded);\n            this.pc.close();\n        };\n        /**\n         * Starts publishing the given track of the given media stream.\n         *\n         * Consecutive calls to this method will replace the stream.\n         * The previous stream will be stopped.\n         *\n         * @param mediaStream the media stream to publish.\n         * @param track the track to publish.\n         * @param trackType the track type to publish.\n         * @param opts the optional publish options to use.\n         */ this.publishStream = async (mediaStream, track, trackType, opts = {})=>{\n            if (track.readyState === \"ended\") {\n                throw new Error(`Can't publish a track that has ended already.`);\n            }\n            let transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track && t.sender.track?.kind === this.trackKindMapping[trackType]);\n            /**\n             * An event handler which listens for the 'ended' event on the track.\n             * Once the track has ended, it will notify the SFU and update the state.\n             */ const handleTrackEnded = async ()=>{\n                logger$3(\"info\", `Track ${TrackType[trackType]} has ended, notifying the SFU`);\n                await this.notifyTrackMuteStateChanged(mediaStream, trackType, true);\n                // clean-up, this event listener needs to run only once.\n                track.removeEventListener(\"ended\", handleTrackEnded);\n            };\n            if (!transceiver) {\n                const { settings } = this.state;\n                const targetResolution = settings?.video.target_resolution;\n                const videoEncodings = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, opts.screenShareSettings) : undefined;\n                let preferredCodec = opts.preferredCodec;\n                if (!preferredCodec && trackType === TrackType.VIDEO) {\n                    if (isReactNative()) {\n                        const osName = getOSInfo()?.name.toLowerCase();\n                        if (osName === \"ipados\") {\n                            // in ipads it was noticed that if vp8 codec is used\n                            // then the bytes sent is 0 in the outbound-rtp\n                            // so we are forcing h264 codec for ipads\n                            preferredCodec = \"H264\";\n                        } else if (osName === \"android\") {\n                            preferredCodec = \"VP8\";\n                        }\n                    }\n                }\n                const codecPreferences = this.getCodecPreferences(trackType, preferredCodec);\n                // listen for 'ended' event on the track as it might be ended abruptly\n                // by an external factor as permission revokes, device disconnected, etc.\n                // keep in mind that `track.stop()` doesn't trigger this event.\n                track.addEventListener(\"ended\", handleTrackEnded);\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                transceiver = this.pc.addTransceiver(track, {\n                    direction: \"sendonly\",\n                    streams: trackType === TrackType.VIDEO || trackType === TrackType.SCREEN_SHARE ? [\n                        mediaStream\n                    ] : undefined,\n                    sendEncodings: videoEncodings\n                });\n                logger$3(\"debug\", `Added ${TrackType[trackType]} transceiver`);\n                this.transceiverInitOrder.push(trackType);\n                this.transceiverRegistry[trackType] = transceiver;\n                this.publishOptionsPerTrackType.set(trackType, opts);\n                if (\"setCodecPreferences\" in transceiver && codecPreferences) {\n                    logger$3(\"info\", `Setting ${TrackType[trackType]} codec preferences`, codecPreferences);\n                    transceiver.setCodecPreferences(codecPreferences);\n                }\n            } else {\n                const previousTrack = transceiver.sender.track;\n                // don't stop the track if we are re-publishing the same track\n                if (previousTrack && previousTrack !== track) {\n                    previousTrack.stop();\n                    previousTrack.removeEventListener(\"ended\", handleTrackEnded);\n                    track.addEventListener(\"ended\", handleTrackEnded);\n                }\n                if (!track.enabled) {\n                    track.enabled = true;\n                }\n                await transceiver.sender.replaceTrack(track);\n            }\n            await this.notifyTrackMuteStateChanged(mediaStream, trackType, false);\n        };\n        /**\n         * Stops publishing the given track type to the SFU, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         * @param trackType the track type to unpublish.\n         * @param stopTrack specifies whether track should be stopped or just disabled\n         */ this.unpublishStream = async (trackType, stopTrack)=>{\n            const transceiver = this.pc.getTransceivers().find((t)=>t === this.transceiverRegistry[trackType] && t.sender.track);\n            if (transceiver && transceiver.sender.track && (stopTrack ? transceiver.sender.track.readyState === \"live\" : transceiver.sender.track.enabled)) {\n                stopTrack ? transceiver.sender.track.stop() : transceiver.sender.track.enabled = false;\n                // We don't need to notify SFU if unpublishing in response to remote soft mute\n                if (this.state.localParticipant?.publishedTracks.includes(trackType)) {\n                    await this.notifyTrackMuteStateChanged(undefined, trackType, true);\n                }\n            }\n        };\n        /**\n         * Returns true if the given track type is currently being published to the SFU.\n         *\n         * @param trackType the track type to check.\n         */ this.isPublishing = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\" && sender.track.enabled;\n            }\n            return false;\n        };\n        /**\n         * Returns true if the given track type is currently live\n         *\n         * @param trackType the track type to check.\n         */ this.isLive = (trackType)=>{\n            const transceiverForTrackType = this.transceiverRegistry[trackType];\n            if (transceiverForTrackType && transceiverForTrackType.sender) {\n                const sender = transceiverForTrackType.sender;\n                return !!sender.track && sender.track.readyState === \"live\";\n            }\n            return false;\n        };\n        this.notifyTrackMuteStateChanged = async (mediaStream, trackType, isMuted)=>{\n            await this.sfuClient.updateMuteState(trackType, isMuted);\n            const audioOrVideoOrScreenShareStream = trackTypeToParticipantStreamKey(trackType);\n            if (isMuted) {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>({\n                        publishedTracks: p.publishedTracks.filter((t)=>t !== trackType),\n                        [audioOrVideoOrScreenShareStream]: undefined\n                    }));\n            } else {\n                this.state.updateParticipant(this.sfuClient.sessionId, (p)=>{\n                    return {\n                        publishedTracks: p.publishedTracks.includes(trackType) ? p.publishedTracks : [\n                            ...p.publishedTracks,\n                            trackType\n                        ],\n                        [audioOrVideoOrScreenShareStream]: mediaStream\n                    };\n                });\n            }\n        };\n        /**\n         * Stops publishing all tracks and stop all tracks.\n         */ this.stopPublishing = ()=>{\n            logger$3(\"debug\", \"Stopping publishing all tracks\");\n            this.pc.getSenders().forEach((s)=>{\n                s.track?.stop();\n                if (this.pc.signalingState !== \"closed\") {\n                    this.pc.removeTrack(s);\n                }\n            });\n        };\n        this.updateVideoPublishQuality = async (enabledLayers)=>{\n            logger$3(\"info\", \"Update publish quality, requested layers by SFU:\", enabledLayers);\n            const videoSender = this.transceiverRegistry[TrackType.VIDEO]?.sender;\n            if (!videoSender) {\n                logger$3(\"warn\", \"Update publish quality, no video sender found.\");\n                return;\n            }\n            const params = videoSender.getParameters();\n            if (params.encodings.length === 0) {\n                logger$3(\"warn\", \"Update publish quality, No suitable video encoding quality found\");\n                return;\n            }\n            let changed = false;\n            let enabledRids = enabledLayers.filter((ly)=>ly.active).map((ly)=>ly.name);\n            params.encodings.forEach((enc)=>{\n                // flip 'active' flag only when necessary\n                const shouldEnable = enabledRids.includes(enc.rid);\n                if (shouldEnable !== enc.active) {\n                    enc.active = shouldEnable;\n                    changed = true;\n                }\n                if (shouldEnable) {\n                    let layer = enabledLayers.find((vls)=>vls.name === enc.rid);\n                    if (layer !== undefined) {\n                        if (layer.scaleResolutionDownBy >= 1 && layer.scaleResolutionDownBy !== enc.scaleResolutionDownBy) {\n                            logger$3(\"debug\", \"[dynascale]: setting scaleResolutionDownBy from server\", \"layer\", layer.name, \"scale-resolution-down-by\", layer.scaleResolutionDownBy);\n                            enc.scaleResolutionDownBy = layer.scaleResolutionDownBy;\n                            changed = true;\n                        }\n                        if (layer.maxBitrate > 0 && layer.maxBitrate !== enc.maxBitrate) {\n                            logger$3(\"debug\", \"[dynascale] setting max-bitrate from the server\", \"layer\", layer.name, \"max-bitrate\", layer.maxBitrate);\n                            enc.maxBitrate = layer.maxBitrate;\n                            changed = true;\n                        }\n                        if (layer.maxFramerate > 0 && layer.maxFramerate !== enc.maxFramerate) {\n                            logger$3(\"debug\", \"[dynascale]: setting maxFramerate from server\", \"layer\", layer.name, \"max-framerate\", layer.maxFramerate);\n                            enc.maxFramerate = layer.maxFramerate;\n                            changed = true;\n                        }\n                    }\n                }\n            });\n            const activeLayers = params.encodings.filter((e)=>e.active);\n            if (changed) {\n                await videoSender.setParameters(params);\n                logger$3(\"info\", `Update publish quality, enabled rids: `, activeLayers);\n            } else {\n                logger$3(\"info\", `Update publish quality, no change: `, activeLayers);\n            }\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        this.getCodecPreferences = (trackType, preferredCodec)=>{\n            if (trackType === TrackType.VIDEO) {\n                return getPreferredCodecs(\"video\", preferredCodec || \"vp8\");\n            }\n            if (trackType === TrackType.AUDIO) {\n                const defaultAudioCodec = this.isRedEnabled ? \"red\" : \"opus\";\n                const codecToRemove = !this.isRedEnabled ? \"red\" : undefined;\n                return getPreferredCodecs(\"audio\", preferredCodec ?? defaultAudioCodec, codecToRemove);\n            }\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$3(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.PUBLISHER_UNSPECIFIED\n            });\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Performs a migration of this publisher instance to a new SFU.\n         *\n         * Initiates a new `iceRestart` offer/answer exchange with the new SFU.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = async (sfuClient, connectionConfig)=>{\n            this.sfuClient = sfuClient;\n            this.pc.setConfiguration(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            const shouldRestartIce = this.pc.iceConnectionState === \"connected\";\n            if (shouldRestartIce) {\n                // negotiate only if there are tracks to publish\n                await this.negotiate({\n                    iceRestart: true\n                });\n            }\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$3(\"debug\", \"Restarting ICE connection\");\n            const signalingState = this.pc.signalingState;\n            if (this.isIceRestarting || signalingState === \"have-local-offer\") {\n                logger$3(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            await this.negotiate({\n                iceRestart: true\n            });\n        };\n        this.onNegotiationNeeded = async ()=>{\n            await this.negotiate();\n        };\n        /**\n         * Initiates a new offer/answer exchange with the currently connected SFU.\n         *\n         * @param options the optional offer options to use.\n         */ this.negotiate = async (options)=>{\n            this.isIceRestarting = options?.iceRestart ?? false;\n            const offer = await this.pc.createOffer(options);\n            let sdp = this.mungeCodecs(offer.sdp);\n            if (sdp && this.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n                const transceiver = this.transceiverRegistry[TrackType.SCREEN_SHARE_AUDIO];\n                if (transceiver && transceiver.sender.track) {\n                    const mid = transceiver.mid ?? this.extractMid(sdp, transceiver.sender.track, TrackType.SCREEN_SHARE_AUDIO);\n                    sdp = enableHighQualityAudio(sdp, mid);\n                }\n            }\n            // set the munged SDP back to the offer\n            offer.sdp = sdp;\n            const trackInfos = this.getCurrentTrackInfos(offer.sdp);\n            if (trackInfos.length === 0) {\n                throw new Error(`Can't initiate negotiation without announcing any tracks`);\n            }\n            await this.pc.setLocalDescription(offer);\n            const { response } = await this.sfuClient.setPublisher({\n                sdp: offer.sdp || \"\",\n                tracks: trackInfos\n            });\n            try {\n                await this.pc.setRemoteDescription({\n                    type: \"answer\",\n                    sdp: response.sdp\n                });\n            } catch (e) {\n                logger$3(\"error\", `setRemoteDescription error`, {\n                    sdp: response.sdp,\n                    error: e\n                });\n            }\n            this.isIceRestarting = false;\n            this.sfuClient.iceTrickleBuffer.publisherCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$3(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n        };\n        this.mungeCodecs = (sdp)=>{\n            if (sdp) {\n                sdp = toggleDtx(sdp, this.isDtxEnabled);\n            }\n            return sdp;\n        };\n        this.extractMid = (sdp, track, trackType)=>{\n            if (!sdp) {\n                logger$3(\"warn\", \"No SDP found. Returning empty mid\");\n                return \"\";\n            }\n            logger$3(\"debug\", `No 'mid' found for track. Trying to find it from the Offer SDP`);\n            const parsedSdp = sdp_transform__WEBPACK_IMPORTED_MODULE_2__.parse(sdp);\n            const media = parsedSdp.media.find((m)=>{\n                return m.type === track.kind && // if `msid` is not present, we assume that the track is the first one\n                (m.msid?.includes(track.id) ?? true);\n            });\n            if (typeof media?.mid === \"undefined\") {\n                logger$3(\"debug\", `No mid found in SDP for track type ${track.kind} and id ${track.id}. Attempting to find a heuristic mid`);\n                const heuristicMid = this.transceiverInitOrder.indexOf(trackType);\n                if (heuristicMid !== -1) {\n                    return String(heuristicMid);\n                }\n                logger$3(\"debug\", \"No heuristic mid found. Returning empty mid\");\n                return \"\";\n            }\n            return String(media.mid);\n        };\n        this.getCurrentTrackInfos = (sdp)=>{\n            sdp = sdp || this.pc.localDescription?.sdp;\n            const { settings } = this.state;\n            const targetResolution = settings?.video.target_resolution;\n            return this.pc.getTransceivers().filter((t)=>t.direction === \"sendonly\" && t.sender.track).map((transceiver)=>{\n                const trackType = Number(Object.keys(this.transceiverRegistry).find((key)=>this.transceiverRegistry[key] === transceiver));\n                const track = transceiver.sender.track;\n                let optimalLayers;\n                if (track.readyState === \"live\") {\n                    const publishOpts = this.publishOptionsPerTrackType.get(trackType);\n                    optimalLayers = trackType === TrackType.VIDEO ? findOptimalVideoLayers(track, targetResolution) : trackType === TrackType.SCREEN_SHARE ? findOptimalScreenSharingLayers(track, publishOpts?.screenShareSettings) : [];\n                    this.trackLayersCache[trackType] = optimalLayers;\n                } else {\n                    // we report the last known optimal layers for ended tracks\n                    optimalLayers = this.trackLayersCache[trackType] || [];\n                    logger$3(\"debug\", `Track ${TrackType[trackType]} is ended. Announcing last known optimal layers`, optimalLayers);\n                }\n                const layers = optimalLayers.map((optimalLayer)=>({\n                        rid: optimalLayer.rid || \"\",\n                        bitrate: optimalLayer.maxBitrate || 0,\n                        fps: optimalLayer.maxFramerate || 0,\n                        quality: this.ridToVideoQuality(optimalLayer.rid || \"\"),\n                        videoDimension: {\n                            width: optimalLayer.width,\n                            height: optimalLayer.height\n                        }\n                    }));\n                const isAudioTrack = [\n                    TrackType.AUDIO,\n                    TrackType.SCREEN_SHARE_AUDIO\n                ].includes(trackType);\n                const trackSettings = track.getSettings();\n                const isStereo = isAudioTrack && trackSettings.channelCount === 2;\n                return {\n                    trackId: track.id,\n                    layers: layers,\n                    trackType,\n                    mid: transceiver.mid ?? this.extractMid(sdp, track, trackType),\n                    stereo: isStereo,\n                    dtx: isAudioTrack && this.isDtxEnabled,\n                    red: isAudioTrack && this.isRedEnabled\n                };\n            });\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const logLevel = this.pc.iceConnectionState === \"connected\" ? \"debug\" : \"error\";\n            logger$3(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$3(\"debug\", `ICE Connection state changed to`, state);\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$3(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$3(\"error\", `ICE restart error`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$3(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$3(\"error\", `ICE restart error`, e);\n                        });\n                    } else {\n                        logger$3(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, this.iceRestartDelay);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$3(\"debug\", `ICE Gathering State`, this.pc.iceGatheringState);\n        };\n        this.onSignalingStateChange = ()=>{\n            logger$3(\"debug\", `Signaling state changed`, this.pc.signalingState);\n        };\n        this.ridToVideoQuality = (rid)=>{\n            return rid === \"q\" ? VideoQuality.LOW_UNSPECIFIED : rid === \"h\" ? VideoQuality.MID : VideoQuality.HIGH; // default to HIGH\n        };\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.isDtxEnabled = isDtxEnabled;\n        this.isRedEnabled = isRedEnabled;\n        this.iceRestartDelay = iceRestartDelay;\n        this.unsubscribeOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.PUBLISHER_UNSPECIFIED) return;\n            await this.restartIce();\n        });\n    }\n}\nconst logger$2 = getLogger([\n    \"Subscriber\"\n]);\n/**\n * A wrapper around the `RTCPeerConnection` that handles the incoming\n * media streams from the SFU.\n */ class Subscriber {\n    /**\n     * Returns the current connection configuration.\n     *\n     * @internal\n     */ get connectionConfiguration() {\n        if (this.pc.getConfiguration) return this.pc.getConfiguration();\n        return this._connectionConfiguration;\n    }\n    /**\n     * Constructs a new `Subscriber` instance.\n     *\n     * @param sfuClient the SFU client to use.\n     * @param dispatcher the dispatcher to use.\n     * @param state the state of the call.\n     * @param connectionConfig the connection configuration to use.\n     * @param iceRestartDelay the delay in milliseconds to wait before restarting ICE when connection goes to `disconnected` state.\n     */ constructor({ sfuClient, dispatcher, state, connectionConfig, iceRestartDelay = 2500 }){\n        this.isIceRestarting = false;\n        /**\n         * Creates a new `RTCPeerConnection` instance with the given configuration.\n         *\n         * @param connectionConfig the connection configuration to use.\n         */ this.createPeerConnection = (connectionConfig)=>{\n            const pc = new RTCPeerConnection(connectionConfig);\n            this._connectionConfiguration = connectionConfig;\n            pc.addEventListener(\"icecandidate\", this.onIceCandidate);\n            pc.addEventListener(\"track\", this.handleOnTrack);\n            pc.addEventListener(\"icecandidateerror\", this.onIceCandidateError);\n            pc.addEventListener(\"iceconnectionstatechange\", this.onIceConnectionStateChange);\n            pc.addEventListener(\"icegatheringstatechange\", this.onIceGatheringStateChange);\n            return pc;\n        };\n        /**\n         * Closes the `RTCPeerConnection` and unsubscribes from the dispatcher.\n         */ this.close = ()=>{\n            clearTimeout(this.iceRestartTimeout);\n            this.unregisterOnSubscriberOffer();\n            this.unregisterOnIceRestart();\n            this.pc.close();\n        };\n        /**\n         * Returns the result of the `RTCPeerConnection.getStats()` method\n         * @param selector\n         * @returns\n         */ this.getStats = (selector)=>{\n            return this.pc.getStats(selector);\n        };\n        /**\n         * Sets the SFU client to use.\n         *\n         * @param sfuClient the SFU client to use.\n         */ this.setSfuClient = (sfuClient)=>{\n            this.sfuClient = sfuClient;\n        };\n        /**\n         * Migrates the subscriber to a new SFU client.\n         *\n         * @param sfuClient the new SFU client to migrate to.\n         * @param connectionConfig the new connection configuration to use.\n         */ this.migrateTo = (sfuClient, connectionConfig)=>{\n            this.setSfuClient(sfuClient);\n            // when migrating, we want to keep the previous subscriber open\n            // until the new one is connected\n            const previousPC = this.pc;\n            // we keep a record of previously available video tracks\n            // so that we can monitor when they become available on the new\n            // subscriber and close the previous one.\n            const trackIdsToMigrate = new Set();\n            previousPC.getReceivers().forEach((r)=>{\n                if (r.track.kind === \"video\") {\n                    trackIdsToMigrate.add(r.track.id);\n                }\n            });\n            // set up a new subscriber peer connection, configured to connect\n            // to the new SFU node\n            const pc = this.createPeerConnection(connectionConfig);\n            let migrationTimeoutId;\n            const cleanupMigration = ()=>{\n                previousPC.close();\n                clearTimeout(migrationTimeoutId);\n            };\n            // When migrating, we want to keep track of the video tracks\n            // that are migrating to the new subscriber.\n            // Once all of them are available, we can close the previous subscriber.\n            const handleTrackMigration = (e)=>{\n                logger$2(\"debug\", `[Migration]: Migrated track: ${e.track.id}, ${e.track.kind}`);\n                trackIdsToMigrate.delete(e.track.id);\n                if (trackIdsToMigrate.size === 0) {\n                    logger$2(\"debug\", `[Migration]: Migration complete`);\n                    pc.removeEventListener(\"track\", handleTrackMigration);\n                    cleanupMigration();\n                }\n            };\n            // When migrating, we want to keep track of the connection state\n            // of the new subscriber.\n            // Once it is connected, we give it a 2-second grace period to receive\n            // all the video tracks that are migrating from the previous subscriber.\n            // After this threshold, we abruptly close the previous subscriber.\n            const handleConnectionStateChange = ()=>{\n                if (pc.connectionState === \"connected\") {\n                    migrationTimeoutId = setTimeout(()=>{\n                        pc.removeEventListener(\"track\", handleTrackMigration);\n                        cleanupMigration();\n                    }, 2000);\n                    pc.removeEventListener(\"connectionstatechange\", handleConnectionStateChange);\n                }\n            };\n            pc.addEventListener(\"track\", handleTrackMigration);\n            pc.addEventListener(\"connectionstatechange\", handleConnectionStateChange);\n            // replace the PeerConnection instance\n            this.pc = pc;\n        };\n        /**\n         * Restarts the ICE connection and renegotiates with the SFU.\n         */ this.restartIce = async ()=>{\n            logger$2(\"debug\", \"Restarting ICE connection\");\n            if (this.pc.signalingState === \"have-remote-offer\") {\n                logger$2(\"debug\", \"ICE restart is already in progress\");\n                return;\n            }\n            const previousIsIceRestarting = this.isIceRestarting;\n            try {\n                this.isIceRestarting = true;\n                await this.sfuClient.iceRestart({\n                    peerType: PeerType.SUBSCRIBER\n                });\n            } catch (e) {\n                // restore the previous state, as our intent for restarting ICE failed\n                this.isIceRestarting = previousIsIceRestarting;\n                throw e;\n            }\n        };\n        this.handleOnTrack = (e)=>{\n            const [primaryStream] = e.streams;\n            // example: `e3f6aaf8-b03d-4911-be36-83f47d37a76a:TRACK_TYPE_VIDEO`\n            const [trackId, trackType] = primaryStream.id.split(\":\");\n            const participantToUpdate = this.state.participants.find((p)=>p.trackLookupPrefix === trackId);\n            logger$2(\"debug\", `[onTrack]: Got remote ${trackType} track for userId: ${participantToUpdate?.userId}`, e.track.id, e.track);\n            if (!participantToUpdate) {\n                logger$2(\"error\", `[onTrack]: Received track for unknown participant: ${trackId}`, e);\n                return;\n            }\n            e.track.addEventListener(\"mute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track muted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"unmute\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track unmuted: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            e.track.addEventListener(\"ended\", ()=>{\n                logger$2(\"info\", `[onTrack]: Track ended: ${participantToUpdate.userId} ${trackType}:${trackId}`);\n            });\n            const streamKindProp = {\n                TRACK_TYPE_AUDIO: \"audioStream\",\n                TRACK_TYPE_VIDEO: \"videoStream\",\n                TRACK_TYPE_SCREEN_SHARE: \"screenShareStream\",\n                TRACK_TYPE_SCREEN_SHARE_AUDIO: \"screenShareAudioStream\"\n            }[trackType];\n            if (!streamKindProp) {\n                logger$2(\"error\", `Unknown track type: ${trackType}`);\n                return;\n            }\n            const previousStream = participantToUpdate[streamKindProp];\n            if (previousStream) {\n                logger$2(\"info\", `[onTrack]: Cleaning up previous remote ${e.track.kind} tracks for userId: ${participantToUpdate.userId}`);\n                previousStream.getTracks().forEach((t)=>{\n                    t.stop();\n                    previousStream.removeTrack(t);\n                });\n            }\n            this.state.updateParticipant(participantToUpdate.sessionId, {\n                [streamKindProp]: primaryStream\n            });\n        };\n        this.onIceCandidate = async (e)=>{\n            const { candidate } = e;\n            if (!candidate) {\n                logger$2(\"debug\", \"null ice candidate\");\n                return;\n            }\n            await this.sfuClient.iceTrickle({\n                iceCandidate: getIceCandidate(candidate),\n                peerType: PeerType.SUBSCRIBER\n            });\n        };\n        this.negotiate = async (subscriberOffer)=>{\n            logger$2(\"info\", `Received subscriberOffer`, subscriberOffer);\n            await this.pc.setRemoteDescription({\n                type: \"offer\",\n                sdp: subscriberOffer.sdp\n            });\n            this.sfuClient.iceTrickleBuffer.subscriberCandidates.subscribe(async (candidate)=>{\n                try {\n                    const iceCandidate = JSON.parse(candidate.iceCandidate);\n                    await this.pc.addIceCandidate(iceCandidate);\n                } catch (e) {\n                    logger$2(\"warn\", `ICE candidate error`, [\n                        e,\n                        candidate\n                    ]);\n                }\n            });\n            const answer = await this.pc.createAnswer();\n            await this.pc.setLocalDescription(answer);\n            await this.sfuClient.sendAnswer({\n                peerType: PeerType.SUBSCRIBER,\n                sdp: answer.sdp || \"\"\n            });\n            this.isIceRestarting = false;\n        };\n        this.onIceConnectionStateChange = ()=>{\n            const state = this.pc.iceConnectionState;\n            logger$2(\"debug\", `ICE connection state changed`, state);\n            // do nothing when ICE is restarting\n            if (this.isIceRestarting) return;\n            const hasNetworkConnection = this.state.callingState !== CallingState.OFFLINE;\n            if (state === \"failed\") {\n                logger$2(\"warn\", `Attempting to restart ICE`);\n                this.restartIce().catch((e)=>{\n                    logger$2(\"error\", `ICE restart failed`, e);\n                });\n            } else if (state === \"disconnected\" && hasNetworkConnection) {\n                // when in `disconnected` state, the browser may recover automatically,\n                // hence, we delay the ICE restart\n                logger$2(\"warn\", `Scheduling ICE restart in ${this.iceRestartDelay} ms.`);\n                this.iceRestartTimeout = setTimeout(()=>{\n                    // check if the state is still `disconnected` or `failed`\n                    // as the connection may have recovered (or failed) in the meantime\n                    if (this.pc.iceConnectionState === \"disconnected\" || this.pc.iceConnectionState === \"failed\") {\n                        this.restartIce().catch((e)=>{\n                            logger$2(\"error\", `ICE restart failed`, e);\n                        });\n                    } else {\n                        logger$2(\"debug\", `Scheduled ICE restart: connection recovered, canceled.`);\n                    }\n                }, 5000);\n            }\n        };\n        this.onIceGatheringStateChange = ()=>{\n            logger$2(\"debug\", `ICE gathering state changed`, this.pc.iceGatheringState);\n        };\n        this.onIceCandidateError = (e)=>{\n            const errorMessage = e instanceof RTCPeerConnectionIceErrorEvent && `${e.errorCode}: ${e.errorText}`;\n            const logLevel = this.pc.iceConnectionState === \"connected\" ? \"debug\" : \"error\";\n            logger$2(logLevel, `ICE Candidate error`, errorMessage);\n        };\n        this.sfuClient = sfuClient;\n        this.state = state;\n        this.iceRestartDelay = iceRestartDelay;\n        this.pc = this.createPeerConnection(connectionConfig);\n        this.unregisterOnSubscriberOffer = dispatcher.on(\"subscriberOffer\", async (subscriberOffer)=>{\n            await this.negotiate(subscriberOffer);\n        });\n        this.unregisterOnIceRestart = dispatcher.on(\"iceRestart\", async (iceRestart)=>{\n            if (iceRestart.peerType !== PeerType.SUBSCRIBER) return;\n            await this.restartIce();\n        });\n    }\n}\nconst createWebSocketSignalChannel = (opts)=>{\n    const logger = getLogger([\n        \"sfu-client\"\n    ]);\n    const { endpoint, onMessage } = opts;\n    const ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(endpoint);\n    ws.binaryType = \"arraybuffer\"; // do we need this?\n    ws.addEventListener(\"error\", (e)=>{\n        logger(\"error\", \"Signaling WS channel error\", e);\n    });\n    ws.addEventListener(\"close\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is closed\", e);\n    });\n    ws.addEventListener(\"open\", (e)=>{\n        logger(\"info\", \"Signaling WS channel is open\", e);\n    });\n    ws.addEventListener(\"message\", (e)=>{\n        try {\n            const message = e.data instanceof ArrayBuffer ? SfuEvent.fromBinary(new Uint8Array(e.data)) : SfuEvent.fromJsonString(e.data.toString());\n            onMessage(message);\n        } catch (err) {\n            logger(\"error\", \"Failed to decode a message. Check whether the Proto models match.\", {\n                event: e,\n                error: err\n            });\n        }\n    });\n    return ws;\n};\nconst sleep = (m)=>new Promise((r)=>setTimeout(r, m));\nfunction isFunction(value) {\n    return value && (Object.prototype.toString.call(value) === \"[object Function]\" || \"function\" === typeof value || value instanceof Function);\n}\n/**\n * A map of known error codes.\n */ const KnownCodes = {\n    TOKEN_EXPIRED: 40,\n    WS_CLOSED_SUCCESS: 1000,\n    WS_CLOSED_ABRUPTLY: 1006,\n    WS_POLICY_VIOLATION: 1008\n};\n/**\n * retryInterval - A retry interval which increases acc to number of failures\n *\n * @return {number} Duration to wait in milliseconds\n */ function retryInterval(numberOfFailures) {\n    // try to reconnect in 0.25-5 seconds (random to spread out the load from failures)\n    const max = Math.min(500 + numberOfFailures * 2000, 5000);\n    const min = Math.min(Math.max(250, (numberOfFailures - 1) * 2000), 5000);\n    return Math.floor(Math.random() * (max - min) + min);\n}\nfunction randomId() {\n    return generateUUIDv4();\n}\nfunction hex(bytes) {\n    let s = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        s += bytes[i].toString(16).padStart(2, \"0\");\n    }\n    return s;\n}\n// https://tools.ietf.org/html/rfc4122\nfunction generateUUIDv4() {\n    const bytes = getRandomBytes(16);\n    bytes[6] = bytes[6] & 0x0f | 0x40; // version\n    bytes[8] = bytes[8] & 0xbf | 0x80; // variant\n    return hex(bytes.subarray(0, 4)) + \"-\" + hex(bytes.subarray(4, 6)) + \"-\" + hex(bytes.subarray(6, 8)) + \"-\" + hex(bytes.subarray(8, 10)) + \"-\" + hex(bytes.subarray(10, 16));\n}\nfunction getRandomValuesWithMathRandom(bytes) {\n    const max = Math.pow(2, 8 * bytes.byteLength / bytes.length);\n    for(let i = 0; i < bytes.length; i++){\n        bytes[i] = Math.random() * max;\n    }\n}\nconst getRandomValues = (()=>{\n    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues !== \"undefined\") {\n        return crypto.getRandomValues.bind(crypto);\n    } else if (typeof msCrypto !== \"undefined\") {\n        return msCrypto.getRandomValues.bind(msCrypto);\n    } else {\n        return getRandomValuesWithMathRandom;\n    }\n})();\nfunction getRandomBytes(length) {\n    const bytes = new Uint8Array(length);\n    getRandomValues(bytes);\n    return bytes;\n}\nfunction convertErrorToJson(err) {\n    const jsonObj = {};\n    if (!err) return jsonObj;\n    try {\n        Object.getOwnPropertyNames(err).forEach((key)=>{\n            jsonObj[key] = Object.getOwnPropertyDescriptor(err, key);\n        });\n    } catch (_) {\n        return {\n            error: \"failed to serialize the error\"\n        };\n    }\n    return jsonObj;\n}\n/**\n * isOnline safely return the navigator.online value for browser env\n * if navigator is not in global object, it always return true\n */ function isOnline(logger) {\n    const nav = typeof navigator !== \"undefined\" ? navigator :  false ? 0 : undefined;\n    if (!nav) {\n        logger(\"warn\", \"isOnline failed to access window.navigator and assume browser is online\");\n        return true;\n    }\n    // RN navigator has undefined for onLine\n    if (typeof nav.onLine !== \"boolean\") {\n        return true;\n    }\n    return nav.onLine;\n}\n/**\n * listenForConnectionChanges - Adds an event listener fired on browser going online or offline\n */ function addConnectionEventListeners(cb) {\n    if (false) {}\n}\nfunction removeConnectionEventListeners(cb) {\n    if (false) {}\n}\n/**\n * The client used for exchanging information with the SFU.\n */ class StreamSfuClient {\n    /**\n     * Constructs a new SFU client.\n     *\n     * @param dispatcher the event dispatcher to use.\n     * @param sfuServer the SFU server to connect to.\n     * @param token the JWT token to use for authentication.\n     * @param sessionId the `sessionId` of the currently connected participant.\n     */ constructor({ dispatcher, sfuServer, token, sessionId }){\n        /**\n         * A buffer for ICE Candidates that are received before\n         * the PeerConnections are ready to handle them.\n         */ this.iceTrickleBuffer = new IceTrickleBuffer();\n        /**\n         * A flag indicating whether the client is currently migrating away\n         * from this SFU.\n         */ this.isMigratingAway = false;\n        /**\n         * A flag indicating that the client connection is broken for the current\n         * client and that a fast-reconnect with a new client should be attempted.\n         */ this.isFastReconnecting = false;\n        this.pingIntervalInMs = 10 * 1000;\n        this.unhealthyTimeoutInMs = this.pingIntervalInMs + 5 * 1000;\n        this.close = (code = StreamSfuClient.NORMAL_CLOSURE, reason = \"js-client: requested signal connection close\")=>{\n            this.logger(\"debug\", \"Closing SFU WS connection\", code, reason);\n            if (this.signalWs.readyState !== this.signalWs.CLOSED) {\n                this.signalWs.close(code, reason);\n            }\n            this.unsubscribeIceTrickle();\n            clearInterval(this.keepAliveInterval);\n            clearTimeout(this.connectionCheckTimeout);\n        };\n        this.updateSubscriptions = async (subscriptions)=>{\n            return retryable(()=>this.rpc.updateSubscriptions({\n                    sessionId: this.sessionId,\n                    tracks: subscriptions\n                }), this.logger);\n        };\n        this.setPublisher = async (data)=>{\n            return retryable(()=>this.rpc.setPublisher({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.sendAnswer = async (data)=>{\n            return retryable(()=>this.rpc.sendAnswer({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceTrickle = async (data)=>{\n            return retryable(()=>this.rpc.iceTrickle({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.iceRestart = async (data)=>{\n            return retryable(()=>this.rpc.iceRestart({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.updateMuteState = async (trackType, muted)=>{\n            return this.updateMuteStates({\n                muteStates: [\n                    {\n                        trackType,\n                        muted\n                    }\n                ]\n            });\n        };\n        this.updateMuteStates = async (data)=>{\n            return retryable(()=>this.rpc.updateMuteStates({\n                    ...data,\n                    sessionId: this.sessionId\n                }), this.logger);\n        };\n        this.join = async (data)=>{\n            const joinRequest = JoinRequest.create({\n                ...data,\n                sessionId: this.sessionId,\n                token: this.token\n            });\n            return this.send(SfuRequest.create({\n                requestPayload: {\n                    oneofKind: \"joinRequest\",\n                    joinRequest\n                }\n            }));\n        };\n        this.send = async (message)=>{\n            return this.signalReady.then((signal)=>{\n                if (signal.readyState !== signal.OPEN) return;\n                this.logger(\"debug\", `Sending message to: ${this.edgeName}`, SfuRequest.toJson(message));\n                signal.send(SfuRequest.toBinary(message));\n            });\n        };\n        this.keepAlive = ()=>{\n            clearInterval(this.keepAliveInterval);\n            this.keepAliveInterval = setInterval(()=>{\n                this.logger(\"trace\", \"Sending healthCheckRequest to SFU\");\n                const message = SfuRequest.create({\n                    requestPayload: {\n                        oneofKind: \"healthCheckRequest\",\n                        healthCheckRequest: {}\n                    }\n                });\n                this.send(message).catch((e)=>{\n                    this.logger(\"error\", \"Error sending healthCheckRequest to SFU\", e);\n                });\n            }, this.pingIntervalInMs);\n        };\n        this.scheduleConnectionCheck = ()=>{\n            clearTimeout(this.connectionCheckTimeout);\n            this.connectionCheckTimeout = setTimeout(()=>{\n                if (this.lastMessageTimestamp) {\n                    const timeSinceLastMessage = new Date().getTime() - this.lastMessageTimestamp.getTime();\n                    if (timeSinceLastMessage > this.unhealthyTimeoutInMs) {\n                        this.close(StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, `SFU connection unhealthy. Didn't receive any message for ${this.unhealthyTimeoutInMs}ms`);\n                    }\n                }\n            }, this.unhealthyTimeoutInMs);\n        };\n        this.sessionId = sessionId || generateUUIDv4();\n        this.sfuServer = sfuServer;\n        this.edgeName = sfuServer.edge_name;\n        this.token = token;\n        this.logger = getLogger([\n            \"sfu-client\"\n        ]);\n        const logInterceptor = {\n            interceptUnary: (next, method, input, options)=>{\n                this.logger(\"trace\", `Calling SFU RPC method ${method.name}`, {\n                    input,\n                    options\n                });\n                return next(method, input, options);\n            }\n        };\n        this.rpc = createSignalClient({\n            baseUrl: sfuServer.url,\n            interceptors: [\n                withHeaders({\n                    Authorization: `Bearer ${token}`\n                }),\n                logInterceptor\n            ]\n        });\n        // Special handling for the ICETrickle kind of events.\n        // These events might be triggered by the SFU before the initial RTC\n        // connection is established. In that case, those events (ICE candidates)\n        // need to be buffered and later added to the appropriate PeerConnection\n        // once the remoteDescription is known and set.\n        this.unsubscribeIceTrickle = dispatcher.on(\"iceTrickle\", (iceTrickle)=>{\n            this.iceTrickleBuffer.push(iceTrickle);\n        });\n        this.signalWs = createWebSocketSignalChannel({\n            endpoint: sfuServer.ws_endpoint,\n            onMessage: (message)=>{\n                this.lastMessageTimestamp = new Date();\n                this.scheduleConnectionCheck();\n                dispatcher.dispatch(message);\n            }\n        });\n        this.signalReady = new Promise((resolve)=>{\n            const onOpen = ()=>{\n                this.signalWs.removeEventListener(\"open\", onOpen);\n                this.keepAlive();\n                resolve(this.signalWs);\n            };\n            this.signalWs.addEventListener(\"open\", onOpen);\n        });\n    }\n}\n/**\n * The normal closure code. Used for controlled shutdowns.\n */ StreamSfuClient.NORMAL_CLOSURE = 1000;\n/**\n * The error code used when the SFU connection is unhealthy.\n * Usually, this means that no message has been received from the SFU for\n * a certain amount of time (`connectionCheckTimeout`).\n */ StreamSfuClient.ERROR_CONNECTION_UNHEALTHY = 4001;\n/**\n * The error code used when the SFU connection is broken.\n * Usually, this means that the WS connection has been closed unexpectedly.\n * This error code is used to announce a fast-reconnect.\n */ StreamSfuClient.ERROR_CONNECTION_BROKEN = 4002; // used in fast-reconnects\nconst MAX_RETRIES = 5;\n/**\n * Creates a closure which wraps the given RPC call and retries invoking\n * the RPC until it succeeds or the maximum number of retries is reached.\n *\n * Between each retry, there would be a random delay in order to avoid\n * request bursts towards the SFU.\n *\n * @param rpc the closure around the RPC call to execute.\n * @param logger a logger instance to use.\n * @param <I> the type of the request object.\n * @param <O> the type of the response object.\n */ const retryable = async (rpc, logger)=>{\n    let retryAttempt = 0;\n    let rpcCallResult;\n    do {\n        // don't delay the first invocation\n        if (retryAttempt > 0) {\n            await sleep(retryInterval(retryAttempt));\n        }\n        rpcCallResult = await rpc();\n        logger(\"trace\", `SFU RPC response received for ${rpcCallResult.method.name}`, rpcCallResult);\n        // if the RPC call failed, log the error and retry\n        if (rpcCallResult.response.error) {\n            logger(\"error\", `SFU RPC Error (${rpcCallResult.method.name}):`, rpcCallResult.response.error);\n        }\n        retryAttempt++;\n    }while (rpcCallResult.response.error?.shouldRetry && retryAttempt < MAX_RETRIES);\n    if (rpcCallResult.response.error) {\n        throw rpcCallResult.response.error;\n    }\n    return rpcCallResult;\n};\n/**\n * Event handler that watched the delivery of `call.accepted`.\n * Once the event is received, the call is joined.\n */ const watchCallAccepted = (call)=>{\n    return async function onCallAccepted(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { state } = call;\n        if (event.call.created_by.id === call.currentUserId && state.callingState === CallingState.RINGING) {\n            await call.join();\n        }\n    };\n};\n/**\n * Event handler that watches delivery of `call.rejected` Websocket event.\n * Once the event is received, the call is left.\n */ const watchCallRejected = (call)=>{\n    return async function onCallRejected(event) {\n        // We want to discard the event if it's from the current user\n        if (event.user.id === call.currentUserId) return;\n        const { call: eventCall } = event;\n        const { session: callSession } = eventCall;\n        if (!callSession) {\n            call.logger(\"warn\", \"No call session provided. Ignoring call.rejected event.\", event);\n            return;\n        }\n        const rejectedBy = callSession.rejected_by;\n        const { members, callingState } = call.state;\n        if (callingState !== CallingState.RINGING) {\n            call.logger(\"info\", \"Call is not in ringing mode (it is either accepted or rejected already). Ignoring call.rejected event.\", event);\n            return;\n        }\n        if (call.isCreatedByMe) {\n            const everyoneElseRejected = members.filter((m)=>m.user_id !== call.currentUserId).every((m)=>rejectedBy[m.user_id]);\n            if (everyoneElseRejected) {\n                call.logger(\"info\", \"everyone rejected, leaving the call\");\n                await call.leave();\n            }\n        } else {\n            if (rejectedBy[eventCall.created_by.id]) {\n                call.logger(\"info\", \"call creator rejected, leaving call\");\n                await call.leave();\n            }\n        }\n    };\n};\n/**\n * Event handler that watches the delivery of `call.ended` Websocket event.\n */ const watchCallEnded = (call)=>{\n    return async function onCallEnded() {\n        const { callingState } = call.state;\n        if (callingState === CallingState.RINGING || callingState === CallingState.JOINED || callingState === CallingState.JOINING) {\n            await call.leave();\n        }\n    };\n};\n/**\n * Event handler that watches for `callGrantsUpdated` events.\n *\n * @param state the call state to update.\n */ const watchCallGrantsUpdated = (state)=>{\n    return function onCallGrantsUpdated(event) {\n        const { currentGrants } = event;\n        if (currentGrants) {\n            const { canPublishAudio, canPublishVideo, canScreenshare } = currentGrants;\n            const update = {\n                [OwnCapability.SEND_AUDIO]: canPublishAudio,\n                [OwnCapability.SEND_VIDEO]: canPublishVideo,\n                [OwnCapability.SCREENSHARE]: canScreenshare\n            };\n            const nextCapabilities = state.ownCapabilities.filter((capability)=>update[capability] !== false);\n            Object.entries(update).forEach(([capability, value])=>{\n                if (value && !nextCapabilities.includes(capability)) {\n                    nextCapabilities.push(capability);\n                }\n            });\n            state.setOwnCapabilities(nextCapabilities);\n        }\n    };\n};\nconst logger$1 = getLogger([\n    \"events\"\n]);\n/**\n * An event responder which handles the `changePublishQuality` event.\n */ const watchChangePublishQuality = (dispatcher, call)=>{\n    return dispatcher.on(\"changePublishQuality\", (e)=>{\n        const { videoSenders } = e;\n        videoSenders.forEach((videoSender)=>{\n            const { layers } = videoSender;\n            call.updatePublishQuality(layers.filter((l)=>l.active));\n        });\n    });\n};\nconst watchConnectionQualityChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"connectionQualityChanged\", (e)=>{\n        const { connectionQualityUpdates } = e;\n        if (!connectionQualityUpdates) return;\n        state.updateParticipants(connectionQualityUpdates.reduce((patches, update)=>{\n            const { sessionId, connectionQuality } = update;\n            patches[sessionId] = {\n                connectionQuality\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Updates the approximate number of participants in the call by peeking at the\n * health check events that our SFU sends.\n */ const watchParticipantCountChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"healthCheckResponse\", (e)=>{\n        const { participantCount } = e;\n        if (participantCount) {\n            state.setParticipantCount(participantCount.total);\n            state.setAnonymousParticipantCount(participantCount.anonymous);\n        }\n    });\n};\nconst watchLiveEnded = (dispatcher, call)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (e.error && e.error.code !== ErrorCode.LIVE_ENDED) return;\n        if (!call.permissionsContext.hasPermission(OwnCapability.JOIN_BACKSTAGE)) {\n            call.leave().catch((err)=>{\n                logger$1(\"error\", \"Failed to leave call after live ended\", err);\n            });\n        }\n    });\n};\n/**\n * Watches and logs the errors reported by the currently connected SFU.\n */ const watchSfuErrorReports = (dispatcher)=>{\n    return dispatcher.on(\"error\", (e)=>{\n        if (!e.error) return;\n        const { error } = e;\n        logger$1(\"error\", \"SFU reported error\", {\n            code: ErrorCode[error.code],\n            message: error.message,\n            shouldRetry: error.shouldRetry\n        });\n    });\n};\n/**\n * Watches for `pinsUpdated` events and updates the pinned state of participants\n * in the call.\n */ const watchPinsUpdated = (state)=>{\n    return function onPinsUpdated(e) {\n        const { pins } = e;\n        state.setServerSidePins(pins);\n    };\n};\n/**\n * An event handler that handles soft mutes.\n *\n * @param call the call.\n */ const handleRemoteSoftMute = (call)=>{\n    return call.on(\"trackUnpublished\", async (event)=>{\n        const { cause, type, sessionId } = event;\n        const { localParticipant } = call.state;\n        if (cause === TrackUnpublishReason.MODERATION && sessionId === localParticipant?.sessionId) {\n            const logger = call.logger;\n            logger(\"info\", `Local participant's ${TrackType[type]} track is muted remotely`);\n            try {\n                if (type === TrackType.VIDEO) {\n                    await call.camera.disable();\n                } else if (type === TrackType.AUDIO) {\n                    await call.microphone.disable();\n                } else {\n                    logger(\"warn\", \"Unsupported track type to soft mute\", TrackType[type]);\n                }\n                if (call.publisher?.isPublishing(type)) {\n                    await call.stopPublish(type);\n                }\n            } catch (error) {\n                logger(\"error\", \"Failed to stop publishing\", error);\n            }\n        }\n    });\n};\n/**\n * An event responder which handles the `participantJoined` event.\n */ const watchParticipantJoined = (state)=>{\n    return function onParticipantJoined(e) {\n        const { participant } = e;\n        if (!participant) return;\n        // `state.updateOrAddParticipant` acts as a safeguard against\n        // potential duplicate events from the SFU.\n        //\n        // Although the SFU should not send duplicate events, we have seen\n        // some race conditions in the past during the `join-flow` where\n        // the SFU would send participant info as part of the `join`\n        // response and then follow up with a `participantJoined` event for\n        // already announced participants.\n        state.updateOrAddParticipant(participant.sessionId, Object.assign(participant, {\n            viewportVisibilityState: {\n                videoTrack: VisibilityState.UNKNOWN,\n                screenShareTrack: VisibilityState.UNKNOWN\n            }\n        }));\n    };\n};\n/**\n * An event responder which handles the `participantLeft` event.\n */ const watchParticipantLeft = (state)=>{\n    return function onParticipantLeft(e) {\n        const { participant } = e;\n        if (!participant) return;\n        state.setParticipants((participants)=>participants.filter((p)=>p.sessionId !== participant.sessionId));\n    };\n};\n/**\n * An event responder which handles the `trackPublished` event.\n * The SFU will send this event when a participant publishes a track.\n */ const watchTrackPublished = (state)=>{\n    return function onTrackPublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls.\n        // After a certain threshold, the SFU would stop emitting `participantJoined`\n        // events, and instead, it would only provide the participant's information\n        // once they start publishing a track.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: [\n                        ...p.publishedTracks,\n                        type\n                    ].filter(unique)\n                }));\n        }\n    };\n};\n/**\n * An event responder which handles the `trackUnpublished` event.\n * The SFU will send this event when a participant unpublishes a track.\n */ const watchTrackUnpublished = (state)=>{\n    return function onTrackUnpublished(e) {\n        const { type, sessionId, participant } = e;\n        // An optimization for large calls. See `watchTrackPublished`.\n        if (participant) {\n            state.updateOrAddParticipant(sessionId, participant);\n        } else {\n            state.updateParticipant(sessionId, (p)=>({\n                    publishedTracks: p.publishedTracks.filter((t)=>t !== type)\n                }));\n        }\n    };\n};\nconst unique = (v, i, arr)=>arr.indexOf(v) === i;\n/**\n * Watches for `dominantSpeakerChanged` events.\n */ const watchDominantSpeakerChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"dominantSpeakerChanged\", (e)=>{\n        const { sessionId } = e;\n        if (sessionId === state.dominantSpeaker?.sessionId) return;\n        state.setParticipants((participants)=>participants.map((participant)=>{\n                // mark the new dominant speaker\n                if (participant.sessionId === sessionId) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: true\n                    };\n                }\n                // unmark the old dominant speaker\n                if (participant.isDominantSpeaker) {\n                    return {\n                        ...participant,\n                        isDominantSpeaker: false\n                    };\n                }\n                return participant; // no change\n            }));\n    });\n};\n/**\n * Watches for `audioLevelChanged` events.\n */ const watchAudioLevelChanged = (dispatcher, state)=>{\n    return dispatcher.on(\"audioLevelChanged\", (e)=>{\n        const { audioLevels } = e;\n        state.updateParticipants(audioLevels.reduce((patches, current)=>{\n            patches[current.sessionId] = {\n                audioLevel: current.level,\n                isSpeaking: current.isSpeaking\n            };\n            return patches;\n        }, {}));\n    });\n};\n/**\n * Registers the default event handlers for a call during its lifecycle.\n *\n * @param call the call to register event handlers for.\n * @param state the call state.\n * @param dispatcher the dispatcher.\n */ const registerEventHandlers = (call, state, dispatcher)=>{\n    const eventHandlers = [\n        call.on(\"call.ended\", watchCallEnded(call)),\n        watchLiveEnded(dispatcher, call),\n        watchSfuErrorReports(dispatcher),\n        watchChangePublishQuality(dispatcher, call),\n        watchConnectionQualityChanged(dispatcher, state),\n        watchParticipantCountChanged(dispatcher, state),\n        call.on(\"participantJoined\", watchParticipantJoined(state)),\n        call.on(\"participantLeft\", watchParticipantLeft(state)),\n        call.on(\"trackPublished\", watchTrackPublished(state)),\n        call.on(\"trackUnpublished\", watchTrackUnpublished(state)),\n        watchAudioLevelChanged(dispatcher, state),\n        watchDominantSpeakerChanged(dispatcher, state),\n        call.on(\"callGrantsUpdated\", watchCallGrantsUpdated(state)),\n        call.on(\"pinsUpdated\", watchPinsUpdated(state)),\n        handleRemoteSoftMute(call)\n    ];\n    if (call.ringing) {\n        // these events are only relevant when the call is ringing\n        eventHandlers.push(registerRingingCallEventHandlers(call));\n    }\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Registers event handlers for a call that is of ringing type.\n *\n * @param call the call to register event handlers for.\n */ const registerRingingCallEventHandlers = (call)=>{\n    const coordinatorRingEvents = {\n        \"call.accepted\": watchCallAccepted(call),\n        \"call.rejected\": watchCallRejected(call)\n    };\n    const eventHandlers = Object.keys(coordinatorRingEvents).map((event)=>{\n        const eventName = event;\n        return call.on(eventName, coordinatorRingEvents[eventName]);\n    });\n    return ()=>{\n        eventHandlers.forEach((unsubscribe)=>unsubscribe());\n    };\n};\n/**\n * Collects all necessary information to join a call, talks to the coordinator\n * and returns the necessary information to join the call.\n *\n * @param httpClient the http client to use.\n * @param type the type of the call.\n * @param id the id of the call.\n * @param data the data for the call.\n */ const join = async (httpClient, type, id, data)=>{\n    const joinCallResponse = await doJoin(httpClient, type, id, data);\n    const { call, credentials, members, own_capabilities } = joinCallResponse;\n    return {\n        connectionConfig: toRtcConfiguration(credentials.ice_servers),\n        sfuServer: credentials.server,\n        token: credentials.token,\n        metadata: call,\n        members,\n        ownCapabilities: own_capabilities\n    };\n};\nconst doJoin = async (httpClient, type, id, data)=>{\n    const location = await httpClient.getLocationHint();\n    const request = {\n        ...data,\n        location\n    };\n    return httpClient.post(`/call/${type}/${id}/join`, request);\n};\nconst toRtcConfiguration = (config)=>{\n    if (!config || config.length === 0) return undefined;\n    const rtcConfig = {\n        iceServers: config.map((ice)=>({\n                urls: ice.urls,\n                username: ice.username,\n                credential: ice.password\n            }))\n    };\n    return rtcConfig;\n};\n/**\n * Creates a new StatsReporter instance that collects metrics about the ongoing call and reports them to the state store\n */ const createStatsReporter = ({ subscriber, publisher, state, pollingIntervalInMs = 2000 })=>{\n    const logger = getLogger([\n        \"stats\"\n    ]);\n    const getRawStatsForTrack = async (kind, selector)=>{\n        if (kind === \"subscriber\" && subscriber) {\n            return subscriber.getStats(selector);\n        } else if (kind === \"publisher\" && publisher) {\n            return publisher.getStats(selector);\n        } else {\n            logger(\"warn\", `Can't retrieve RTC stats for ${kind}`);\n            return undefined;\n        }\n    };\n    const getStatsForStream = async (kind, mediaStream)=>{\n        const pc = kind === \"subscriber\" ? subscriber : publisher;\n        const statsForStream = [];\n        for (let track of mediaStream.getTracks()){\n            const report = await pc.getStats(track);\n            const stats = transform(report, {\n                // @ts-ignore\n                trackKind: track.kind,\n                kind\n            });\n            statsForStream.push(stats);\n        }\n        return statsForStream;\n    };\n    const startReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.add(sessionId);\n        void run();\n    };\n    const stopReportingStatsFor = (sessionId)=>{\n        sessionIdsToTrack.delete(sessionId);\n        void run();\n    };\n    const sessionIdsToTrack = new Set();\n    /**\n     * The main stats reporting loop.\n     */ const run = async ()=>{\n        const participantStats = {};\n        const sessionIds = new Set(sessionIdsToTrack);\n        if (sessionIds.size > 0) {\n            for (let participant of state.participants){\n                if (!sessionIds.has(participant.sessionId)) continue;\n                const kind = participant.isLocalParticipant ? \"publisher\" : \"subscriber\";\n                try {\n                    const mergedStream = new MediaStream([\n                        ...participant.videoStream?.getVideoTracks() || [],\n                        ...participant.audioStream?.getAudioTracks() || []\n                    ]);\n                    participantStats[participant.sessionId] = await getStatsForStream(kind, mergedStream);\n                    mergedStream.getTracks().forEach((t)=>{\n                        mergedStream.removeTrack(t);\n                    });\n                } catch (e) {\n                    logger(\"error\", `Failed to collect stats for ${kind} if ${participant.userId}`, e);\n                }\n            }\n        }\n        const [subscriberStats, publisherStats] = await Promise.all([\n            subscriber.getStats().then((report)=>transform(report, {\n                    kind: \"subscriber\",\n                    trackKind: \"video\"\n                })).then(aggregate),\n            publisher.getStats().then((report)=>transform(report, {\n                    kind: \"publisher\",\n                    trackKind: \"video\"\n                })).then(aggregate)\n        ]);\n        const [subscriberRawStats, publisherRawStats] = await Promise.all([\n            getRawStatsForTrack(\"subscriber\"),\n            getRawStatsForTrack(\"publisher\")\n        ]);\n        state.setCallStatsReport({\n            datacenter: publisher.sfuClient.edgeName,\n            publisherStats,\n            subscriberStats,\n            subscriberRawStats,\n            publisherRawStats,\n            participants: participantStats,\n            timestamp: Date.now()\n        });\n    };\n    let timeoutId;\n    if (pollingIntervalInMs > 0) {\n        const loop = async ()=>{\n            await run().catch((e)=>{\n                logger(\"debug\", \"Failed to collect stats\", e);\n            });\n            timeoutId = setTimeout(loop, pollingIntervalInMs);\n        };\n        void loop();\n    }\n    const stop = ()=>{\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n    };\n    return {\n        getRawStatsForTrack,\n        getStatsForStream,\n        startReportingStatsFor,\n        stopReportingStatsFor,\n        stop\n    };\n};\n/**\n * Transforms raw RTC stats into a slimmer and uniform across browsers format.\n *\n * @param report the report to transform.\n * @param opts the transform options.\n */ const transform = (report, opts)=>{\n    const { trackKind, kind } = opts;\n    const direction = kind === \"subscriber\" ? \"inbound-rtp\" : \"outbound-rtp\";\n    const stats = flatten$1(report);\n    const streams = stats.filter((stat)=>stat.type === direction && stat.kind === trackKind).map((stat)=>{\n        const rtcStreamStats = stat;\n        const codec = stats.find((s)=>s.type === \"codec\" && s.id === rtcStreamStats.codecId); // FIXME OL: incorrect type!\n        const transport = stats.find((s)=>s.type === \"transport\" && s.id === rtcStreamStats.transportId);\n        let roundTripTime;\n        if (transport && transport.dtlsState === \"connected\") {\n            const candidatePair = stats.find((s)=>s.type === \"candidate-pair\" && s.id === transport.selectedCandidatePairId);\n            roundTripTime = candidatePair?.currentRoundTripTime;\n        }\n        return {\n            bytesSent: rtcStreamStats.bytesSent,\n            bytesReceived: rtcStreamStats.bytesReceived,\n            codec: codec?.mimeType,\n            currentRoundTripTime: roundTripTime,\n            frameHeight: rtcStreamStats.frameHeight,\n            frameWidth: rtcStreamStats.frameWidth,\n            framesPerSecond: rtcStreamStats.framesPerSecond,\n            jitter: rtcStreamStats.jitter,\n            kind: rtcStreamStats.kind,\n            // @ts-ignore: available in Chrome only, TS doesn't recognize this\n            qualityLimitationReason: rtcStreamStats.qualityLimitationReason,\n            rid: rtcStreamStats.rid,\n            ssrc: rtcStreamStats.ssrc\n        };\n    });\n    return {\n        rawStats: report,\n        streams,\n        timestamp: Date.now()\n    };\n};\n/**\n * Aggregates generic stats.\n *\n * @param stats the stats to aggregate.\n */ const aggregate = (stats)=>{\n    const aggregatedStats = {\n        rawReport: stats,\n        totalBytesSent: 0,\n        totalBytesReceived: 0,\n        averageJitterInMs: 0,\n        averageRoundTripTimeInMs: 0,\n        qualityLimitationReasons: \"none\",\n        highestFrameWidth: 0,\n        highestFrameHeight: 0,\n        highestFramesPerSecond: 0,\n        timestamp: Date.now()\n    };\n    let maxArea = -1;\n    const area = (w, h)=>w * h;\n    const qualityLimitationReasons = new Set();\n    const streams = stats.streams;\n    const report = streams.reduce((acc, stream)=>{\n        acc.totalBytesSent += stream.bytesSent || 0;\n        acc.totalBytesReceived += stream.bytesReceived || 0;\n        acc.averageJitterInMs += stream.jitter || 0;\n        acc.averageRoundTripTimeInMs += stream.currentRoundTripTime || 0;\n        // naive calculation of the highest resolution\n        const streamArea = area(stream.frameWidth || 0, stream.frameHeight || 0);\n        if (streamArea > maxArea) {\n            acc.highestFrameWidth = stream.frameWidth || 0;\n            acc.highestFrameHeight = stream.frameHeight || 0;\n            acc.highestFramesPerSecond = stream.framesPerSecond || 0;\n            maxArea = streamArea;\n        }\n        qualityLimitationReasons.add(stream.qualityLimitationReason || \"\");\n        return acc;\n    }, aggregatedStats);\n    if (streams.length > 0) {\n        report.averageJitterInMs = Math.round(report.averageJitterInMs / streams.length * 1000);\n        report.averageRoundTripTimeInMs = Math.round(report.averageRoundTripTimeInMs / streams.length * 1000);\n    }\n    const qualityLimitationReason = [\n        qualityLimitationReasons.has(\"cpu\") && \"cpu\",\n        qualityLimitationReasons.has(\"bandwidth\") && \"bandwidth\",\n        qualityLimitationReasons.has(\"other\") && \"other\"\n    ].filter(Boolean).join(\", \");\n    if (qualityLimitationReason) {\n        report.qualityLimitationReasons = qualityLimitationReason;\n    }\n    return report;\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten$1 = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\nconst DEFAULT_THRESHOLD = 0.35;\nclass ViewportTracker {\n    constructor(){\n        /**\n         * @private\n         */ this.elementHandlerMap = new Map();\n        /**\n         * @private\n         */ this.observer = null;\n        // in React children render before viewport is set, add\n        // them to the queue and observe them once the observer is ready\n        /**\n         * @private\n         */ this.queueSet = new Set();\n        /**\n         * Method to set scrollable viewport as root for the IntersectionObserver, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param viewportElement\n         * @param options\n         * @returns Unobserve\n         */ this.setViewport = (viewportElement, options)=>{\n            const cleanup = ()=>{\n                this.observer?.disconnect();\n                this.observer = null;\n                this.elementHandlerMap.clear();\n            };\n            this.observer = new IntersectionObserver((entries)=>{\n                entries.forEach((entry)=>{\n                    const handler = this.elementHandlerMap.get(entry.target);\n                    handler?.(entry);\n                });\n            }, {\n                root: viewportElement,\n                ...options,\n                threshold: options?.threshold ?? DEFAULT_THRESHOLD\n            });\n            if (this.queueSet.size) {\n                this.queueSet.forEach(([queueElement, queueHandler])=>{\n                    // check if element which requested observation is\n                    // a child of a viewport element, skip if isn't\n                    if (!viewportElement.contains(queueElement)) return;\n                    this.observer.observe(queueElement);\n                    this.elementHandlerMap.set(queueElement, queueHandler);\n                });\n                this.queueSet.clear();\n            }\n            return cleanup;\n        };\n        /**\n         * Method to set element to observe and handler to be triggered whenever IntersectionObserver\n         * detects a possible change in element's visibility within specified viewport, returns\n         * cleanup function to be invoked upon disposing of the DOM element to prevent memory leaks\n         *\n         * @param element\n         * @param handler\n         * @returns Unobserve\n         */ this.observe = (element, handler)=>{\n            const queueItem = [\n                element,\n                handler\n            ];\n            const cleanup = ()=>{\n                this.elementHandlerMap.delete(element);\n                this.observer?.unobserve(element);\n                this.queueSet.delete(queueItem);\n            };\n            if (this.elementHandlerMap.has(element)) return cleanup;\n            if (!this.observer) {\n                this.queueSet.add(queueItem);\n                return cleanup;\n            }\n            if (this.observer.root.contains(element)) {\n                this.elementHandlerMap.set(element, handler);\n                this.observer.observe(element);\n            }\n            return cleanup;\n        };\n    }\n}\n/**\n * Checks whether the current browser is Safari.\n */ const isSafari = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent || \"\");\n};\n/**\n * Checks whether the current browser is Firefox.\n */ const isFirefox = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Firefox\");\n};\n/**\n * Checks whether the current browser is Google Chrome.\n */ const isChrome = ()=>{\n    if (typeof navigator === \"undefined\") return false;\n    return navigator.userAgent?.includes(\"Chrome\");\n};\nvar browsers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    isChrome: isChrome,\n    isFirefox: isFirefox,\n    isSafari: isSafari\n});\nconst DEFAULT_VIEWPORT_VISIBILITY_STATE = {\n    videoTrack: VisibilityState.UNKNOWN,\n    screenShareTrack: VisibilityState.UNKNOWN\n};\n/**\n * A manager class that handles dynascale related tasks like:\n *\n * - binding video elements to session ids\n * - binding audio elements to session ids\n * - tracking element visibility\n * - updating subscriptions based on viewport visibility\n * - updating subscriptions based on video element dimensions\n * - updating subscriptions based on published tracks\n */ class DynascaleManager {\n    /**\n     * Creates a new DynascaleManager instance.\n     *\n     * @param call the call to manage.\n     */ constructor(call){\n        /**\n         * The viewport tracker instance.\n         */ this.viewportTracker = new ViewportTracker();\n        this.logger = getLogger([\n            \"DynascaleManager\"\n        ]);\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         * @returns Untrack.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            const cleanup = this.viewportTracker.observe(element, (entry)=>{\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    // observer triggers when the element is \"moved\" to be a fullscreen element\n                    // keep it VISIBLE if that happens to prevent fullscreen with placeholder\n                    const isVisible = entry.isIntersecting || document.fullscreenElement === element ? VisibilityState.VISIBLE : VisibilityState.INVISIBLE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: isVisible\n                        }\n                    };\n                });\n            });\n            return ()=>{\n                cleanup();\n                // reset visibility state to UNKNOWN upon cleanup\n                // so that the layouts that are not actively observed\n                // can still function normally (runtime layout switching)\n                this.call.state.updateParticipant(sessionId, (participant)=>{\n                    const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;\n                    return {\n                        ...participant,\n                        viewportVisibilityState: {\n                            ...previousVisibilityState,\n                            [trackType]: VisibilityState.UNKNOWN\n                        }\n                    };\n                });\n            };\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.viewportTracker.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const boundParticipant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!boundParticipant) return;\n            const requestTrackWithDimensions = (debounceType, dimension)=>{\n                if (dimension && (dimension.width === 0 || dimension.height === 0)) {\n                    // ignore 0x0 dimensions. this can happen when the video element\n                    // is not visible (e.g., has display: none).\n                    // we treat this as \"unsubscription\" as we don't want to keep\n                    // consuming bandwidth for a video that is not visible on the screen.\n                    this.logger(\"debug\", `Ignoring 0x0 dimension`, boundParticipant);\n                    dimension = undefined;\n                }\n                this.call.updateSubscriptionsPartial(trackType, {\n                    [sessionId]: {\n                        dimension\n                    }\n                }, debounceType);\n            };\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((participant)=>participant.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((participant)=>!!participant), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            /**\n             * Since the video elements are now being removed from the DOM (React SDK) upon\n             * visibility change, this subscription is not in use an stays here only for the\n             * plain JS integrations where integrators might choose not to remove the video\n             * elements from the DOM.\n             */ // keep copy for resize observer handler\n            let viewportVisibilityState;\n            const viewportVisibilityStateSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((p)=>p.viewportVisibilityState?.[trackType]), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)()).subscribe((nextViewportVisibilityState)=>{\n                // skip initial trigger\n                if (!viewportVisibilityState) {\n                    viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                    return;\n                }\n                viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;\n                if (nextViewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return requestTrackWithDimensions(DebounceType.MEDIUM, undefined);\n                }\n                requestTrackWithDimensions(DebounceType.MEDIUM, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n            });\n            let lastDimensions;\n            const resizeObserver = boundParticipant.isLocalParticipant ? null : new ResizeObserver(()=>{\n                const currentDimensions = `${videoElement.clientWidth},${videoElement.clientHeight}`;\n                // skip initial trigger\n                if (!lastDimensions) {\n                    lastDimensions = currentDimensions;\n                    return;\n                }\n                if (lastDimensions === currentDimensions || viewportVisibilityState === VisibilityState.INVISIBLE) {\n                    return;\n                }\n                requestTrackWithDimensions(DebounceType.SLOW, {\n                    width: videoElement.clientWidth,\n                    height: videoElement.clientHeight\n                });\n                lastDimensions = currentDimensions;\n            });\n            resizeObserver?.observe(videoElement);\n            // element renders and gets bound - track subscription gets\n            // triggered first other ones get skipped on initial subscriptions\n            const publishedTracksSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(\"publishedTracks\"), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((p)=>p.publishedTracks.includes(trackType === \"videoTrack\" ? TrackType.VIDEO : TrackType.SCREEN_SHARE)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)()).subscribe((isPublishing)=>{\n                if (isPublishing) {\n                    // the participant just started to publish a track\n                    requestTrackWithDimensions(DebounceType.FAST, {\n                        width: videoElement.clientWidth,\n                        height: videoElement.clientHeight\n                    });\n                } else {\n                    // the participant just stopped publishing a track\n                    requestTrackWithDimensions(DebounceType.FAST, undefined);\n                }\n            });\n            videoElement.autoplay = true;\n            videoElement.playsInline = true;\n            // explicitly marking the element as muted will allow autoplay to work\n            // without prior user interaction:\n            // https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide\n            videoElement.muted = true;\n            const streamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(trackType === \"videoTrack\" ? \"videoStream\" : \"screenShareStream\")).subscribe((p)=>{\n                const source = trackType === \"videoTrack\" ? p.videoStream : p.screenShareStream;\n                if (videoElement.srcObject === source) return;\n                videoElement.srcObject = source ?? null;\n                if (isSafari() || isFirefox()) {\n                    setTimeout(()=>{\n                        videoElement.srcObject = source ?? null;\n                        videoElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                    // we add extra delay until we attempt to force-play\n                    // the participant's media stream in Firefox and Safari,\n                    // as they seem to have some timing issues\n                    }, 25);\n                }\n            });\n            return ()=>{\n                requestTrackWithDimensions(DebounceType.FAST, undefined);\n                viewportVisibilityStateSubscription?.unsubscribe();\n                publishedTracksSubscription?.unsubscribe();\n                streamSubscription.unsubscribe();\n                resizeObserver?.disconnect();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         * @returns a cleanup function that will unbind the audio element.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType)=>{\n            const participant = this.call.state.findParticipantBySessionId(sessionId);\n            if (!participant || participant.isLocalParticipant) return;\n            const participant$ = this.call.state.participants$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((participants)=>participants.find((p)=>p.sessionId === sessionId)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((p)=>!!p), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)(), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)({\n                bufferSize: 1,\n                refCount: true\n            }));\n            const updateMediaStreamSubscription = participant$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_24__.distinctUntilKeyChanged)(trackType === \"screenShareAudioTrack\" ? \"screenShareAudioStream\" : \"audioStream\")).subscribe((p)=>{\n                const source = trackType === \"screenShareAudioTrack\" ? p.screenShareAudioStream : p.audioStream;\n                if (audioElement.srcObject === source) return;\n                setTimeout(()=>{\n                    audioElement.srcObject = source ?? null;\n                    if (audioElement.srcObject) {\n                        audioElement.play().catch((e)=>{\n                            this.logger(\"warn\", `Failed to play stream`, e);\n                        });\n                        // audio output device shall be set after the audio element is played\n                        // otherwise, the browser will not pick it up, and will always\n                        // play audio through the system's default device\n                        const { selectedDevice } = this.call.speaker.state;\n                        if (selectedDevice && \"setSinkId\" in audioElement) {\n                            // @ts-expect-error setSinkId is not yet in the lib\n                            audioElement.setSinkId(selectedDevice);\n                        }\n                    }\n                });\n            });\n            const sinkIdSubscription = !(\"setSinkId\" in audioElement) ? null : this.call.speaker.state.selectedDevice$.subscribe((deviceId)=>{\n                if (deviceId) {\n                    // @ts-expect-error setSinkId is not yet in the lib\n                    audioElement.setSinkId(deviceId);\n                }\n            });\n            const volumeSubscription = this.call.speaker.state.volume$.subscribe((volume)=>{\n                audioElement.volume = volume;\n            });\n            audioElement.autoplay = true;\n            return ()=>{\n                sinkIdSubscription?.unsubscribe();\n                volumeSubscription.unsubscribe();\n                updateMediaStreamSubscription.unsubscribe();\n            };\n        };\n        this.call = call;\n    }\n}\n/**\n * Stores the permissions for the current user and exposes\n * a few helper methods which make it easier to work with permissions.\n *\n * This is an internal class meant to be used in combination with\n * a {@link Call} instance.\n *\n * @internal\n */ class PermissionsContext {\n    constructor(){\n        this.permissions = [];\n        /**\n         * Sets the permissions for the current user.\n         *\n         * @param permissions the permissions to set.\n         */ this.setPermissions = (permissions)=>{\n            this.permissions = permissions || [];\n        };\n        /**\n         * Sets the settings for the bound call.\n         * @param settings\n         */ this.setCallSettings = (settings)=>{\n            this.settings = settings;\n        };\n        /**\n         * Checks if the current user has a specific permission.\n         *\n         * @param permission the permission to check for.\n         */ this.hasPermission = (permission)=>{\n            return this.permissions.includes(permission);\n        };\n        /**\n         * Checks if the current user can request a specific permission\n         * within the call.\n         *\n         * @param permission the permission to check for.\n         * @param settings the call settings to check against (optional).\n         */ this.canRequest = (permission, settings = this.settings)=>{\n            if (!settings) return false;\n            const { audio, video, screensharing } = settings;\n            switch(permission){\n                case OwnCapability.SEND_AUDIO:\n                    return audio.access_request_enabled;\n                case OwnCapability.SEND_VIDEO:\n                    return video.access_request_enabled;\n                case OwnCapability.SCREENSHARE:\n                    return screensharing.access_request_enabled;\n                default:\n                    return false;\n            }\n        };\n    }\n}\n/**\n * Represents a call type.\n */ class CallType {\n    /**\n     * Constructs a new CallType.\n     *\n     * @param name the name of the call type.\n     * @param options the options for the call type.\n     */ constructor(name, options = {\n        sortParticipantsBy: defaultSortPreset\n    }){\n        this.name = name;\n        this.options = options;\n    }\n}\n/**\n * A registry of {@link CallType}s.\n * You can register and unregister call types.\n */ class CallTypesRegistry {\n    /**\n     * Constructs a new CallTypesRegistry.\n     *\n     * @param callTypes the initial call types to register.\n     */ constructor(callTypes){\n        /**\n         * Registers a new call type.\n         *\n         * @param callType the call type to register.\n         */ this.register = (callType)=>{\n            this.callTypes[callType.name] = callType;\n        };\n        /**\n         * Unregisters a call type.\n         *\n         * @param name the name of the call type to unregister.\n         */ this.unregister = (name)=>{\n            delete this.callTypes[name];\n        };\n        /**\n         * Gets a call type by name.\n         *\n         * @param name the name of the call type to get.\n         */ this.get = (name)=>{\n            if (!this.callTypes[name]) {\n                this.register(new CallType(name));\n            }\n            return this.callTypes[name];\n        };\n        this.callTypes = callTypes.reduce((acc, callType)=>{\n            acc[callType.name] = callType;\n            return acc;\n        }, {});\n    }\n}\n/**\n * The default call types registry.\n * You can use this instance to dynamically register and unregister call types.\n */ const CallTypes = new CallTypesRegistry([\n    new CallType(\"default\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"development\", {\n        sortParticipantsBy: defaultSortPreset\n    }),\n    new CallType(\"livestream\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    }),\n    new CallType(\"audio_room\", {\n        sortParticipantsBy: livestreamOrAudioRoomSortPreset\n    })\n]);\n/**\n * Returns an Observable that emits the list of available devices\n * that meet the given constraints.\n *\n * @param constraints the constraints to use when requesting the devices.\n * @param kind the kind of devices to enumerate.\n */ const getDevices = (constraints, kind)=>{\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n        const enumerate = async ()=>{\n            let devices = await navigator.mediaDevices.enumerateDevices();\n            // some browsers report empty device labels (Firefox).\n            // in that case, we need to request permissions (via getUserMedia)\n            // to be able to get the device labels\n            const needsGetUserMedia = devices.some((device)=>device.kind === kind && device.label === \"\");\n            if (needsGetUserMedia) {\n                let mediaStream;\n                try {\n                    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n                    devices = await navigator.mediaDevices.enumerateDevices();\n                } finally{\n                    if (mediaStream) disposeOfMediaStream(mediaStream);\n                }\n            }\n            return devices;\n        };\n        enumerate().then((devices)=>{\n            // notify subscribers and complete\n            subscriber.next(devices);\n            subscriber.complete();\n        }).catch((error)=>{\n            const logger = getLogger([\n                \"devices\"\n            ]);\n            logger(\"error\", \"Failed to enumerate devices\", error);\n            subscriber.error(error);\n        });\n    });\n};\n/**\n * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n *\n *  */ const checkIfAudioOutputChangeSupported = ()=>{\n    if (typeof document === \"undefined\") return false;\n    const element = document.createElement(\"audio\");\n    return \"setSinkId\" in element;\n};\n/**\n * The default constraints used to request audio devices.\n */ const audioDeviceConstraints = {\n    audio: {\n        autoGainControl: true,\n        noiseSuppression: true,\n        echoCancellation: true\n    }\n};\n/**\n * The default constraints used to request video devices.\n */ const videoDeviceConstraints = {\n    video: {\n        width: 1280,\n        height: 720\n    }\n};\n/**\n * Creates a memoized observable instance\n * that will be created only once and shared between all callers.\n *\n * @param create a function that creates an Observable.\n */ const memoizedObservable = (create)=>{\n    let memoized;\n    return ()=>{\n        if (!memoized) memoized = create();\n        return memoized;\n    };\n};\nconst getDeviceChangeObserver = memoizedObservable(()=>{\n    // Audio and video devices are requested in two separate requests.\n    // That way, users will be presented with two separate prompts\n    // -> they can give access to just camera, or just microphone\n    return new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n        // 'addEventListener' is not available in React Native\n        if (!navigator.mediaDevices.addEventListener) return;\n        const notify = ()=>subscriber.next();\n        navigator.mediaDevices.addEventListener(\"devicechange\", notify);\n        return ()=>{\n            navigator.mediaDevices.removeEventListener(\"devicechange\", notify);\n        };\n    }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_26__.debounceTime)(500), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_27__.concatMap)(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.from)(navigator.mediaDevices.enumerateDevices())), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getAudioDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(audioDeviceConstraints, \"audioinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getAudioOutputDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(audioDeviceConstraints, \"audiooutput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\nconst getVideoDevicesObserver = memoizedObservable(()=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)(getDevices(videoDeviceConstraints, \"videoinput\"), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n});\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audioinput' devices, if devices are added/removed the list is updated.\n */ const getAudioDevices = ()=>{\n    return getAudioDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"audioinput\")));\n};\n/**\n * Prompts the user for a permission to use video devices (if not already granted) and lists the available 'videoinput' devices, if devices are added/removed the list is updated.\n */ const getVideoDevices = ()=>{\n    return getVideoDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"videoinput\")));\n};\n/**\n * Prompts the user for a permission to use audio devices (if not already granted) and lists the available 'audiooutput' devices, if devices are added/removed the list is updated. Selecting 'audiooutput' device only makes sense if [the browser has support for changing audio output on 'audio' elements](#checkifaudiooutputchangesupported)\n */ const getAudioOutputDevices = ()=>{\n    return getAudioOutputDevicesObserver().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((values)=>values.filter((d)=>d.kind === \"audiooutput\")));\n};\nconst getStream = async (constraints)=>{\n    try {\n        return await navigator.mediaDevices.getUserMedia(constraints);\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", `Failed get user media`, {\n            error: e,\n            constraints: constraints\n        });\n        throw e;\n    }\n};\n/**\n * Returns an audio media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns the new `MediaStream` fulfilling the given constraints.\n */ const getAudioStream = async (trackConstraints)=>{\n    const constraints = {\n        audio: {\n            ...audioDeviceConstraints.audio,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Returns a video media stream that fulfills the given constraints.\n * If no constraints are provided, it uses the browser's default ones.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n * @param trackConstraints the constraints to use when requesting the stream.\n * @returns a new `MediaStream` fulfilling the given constraints.\n */ const getVideoStream = async (trackConstraints)=>{\n    const constraints = {\n        video: {\n            ...videoDeviceConstraints.video,\n            ...trackConstraints\n        }\n    };\n    return getStream(constraints);\n};\n/**\n * Prompts the user for a permission to share a screen.\n * If the user grants the permission, a screen sharing stream is returned. Throws otherwise.\n *\n * The callers of this API are responsible to handle the possible errors.\n *\n * @angular It's recommended to use the [`DeviceManagerService`](./DeviceManagerService.md) for a higher level API, use this low-level method only if the `DeviceManagerService` doesn't suit your requirements.\n *\n * @param options any additional options to pass to the [`getDisplayMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia) API.\n */ const getScreenShareStream = async (options)=>{\n    try {\n        return await navigator.mediaDevices.getDisplayMedia({\n            video: true,\n            audio: {\n                channelCount: {\n                    ideal: 2\n                },\n                echoCancellation: false,\n                autoGainControl: false,\n                noiseSuppression: false\n            },\n            // @ts-expect-error - not present in types yet\n            systemAudio: \"include\",\n            ...options\n        });\n    } catch (e) {\n        getLogger([\n            \"devices\"\n        ])(\"error\", \"Failed to get screen share stream\", e);\n        throw e;\n    }\n};\nconst deviceIds$ = typeof navigator !== \"undefined\" && typeof navigator.mediaDevices !== \"undefined\" ? memoizedObservable(()=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_29__.merge)((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_28__.from)(navigator.mediaDevices.enumerateDevices()), getDeviceChangeObserver()).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1)))() : undefined;\n/**\n * Deactivates MediaStream (stops and removes tracks) to be later garbage collected\n *\n * @param stream MediaStream\n * @returns void\n */ const disposeOfMediaStream = (stream)=>{\n    if (!stream.active) return;\n    stream.getTracks().forEach((track)=>{\n        track.stop();\n        stream.removeTrack(track);\n    });\n    // @ts-expect-error release() is present in react-native-webrtc and must be called to dispose the stream\n    if (typeof stream.release === \"function\") {\n        // @ts-expect-error\n        stream.release();\n    }\n};\nclass InputMediaDeviceManager {\n    constructor(call, state, trackType){\n        this.call = call;\n        this.state = state;\n        this.trackType = trackType;\n        /**\n         * if true, stops the media stream when call is left\n         */ this.stopOnLeave = true;\n        this.subscriptions = [];\n        this.isTrackStoppedDueToTrackEnd = false;\n        this.removeSubscriptions = ()=>{\n            this.subscriptions.forEach((s)=>s.unsubscribe());\n        };\n        this.logger = getLogger([\n            `${TrackType[trackType].toLowerCase()} manager`\n        ]);\n        if (deviceIds$ && !isReactNative() && (this.trackType === TrackType.AUDIO || this.trackType === TrackType.VIDEO)) {\n            this.handleDisconnectedOrReplacedDevices();\n        }\n    }\n    /**\n     * Lists the available audio/video devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        return this.getDevices();\n    }\n    /**\n     * Starts stream.\n     */ async enable() {\n        if (this.state.status === \"enabled\") return;\n        this.enablePromise = this.unmuteStream();\n        try {\n            await this.enablePromise;\n            this.state.setStatus(\"enabled\");\n            this.enablePromise = undefined;\n        } catch (error) {\n            this.enablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * Stops or pauses the stream based on state.disableMode\n     * @param {boolean} [forceStop=false] when true, stops the tracks regardless of the state.disableMode\n     */ async disable(forceStop = false) {\n        this.state.prevStatus = this.state.status;\n        if (!forceStop && this.state.status === \"disabled\") return;\n        const stopTracks = forceStop || this.state.disableMode === \"stop-tracks\";\n        this.disablePromise = this.muteStream(stopTracks);\n        try {\n            await this.disablePromise;\n            this.state.setStatus(\"disabled\");\n            this.disablePromise = undefined;\n        } catch (error) {\n            this.disablePromise = undefined;\n            throw error;\n        }\n    }\n    /**\n     * If status was previously enabled, it will re-enable the device.\n     */ async resume() {\n        if (this.state.prevStatus === \"enabled\" && this.state.status === \"disabled\") {\n            await this.enable();\n        }\n    }\n    /**\n     * If the current device status is disabled, it will enable the device,\n     * else it will disable it.\n     */ async toggle() {\n        if (this.state.status === \"enabled\") {\n            return this.disable();\n        } else {\n            return this.enable();\n        }\n    }\n    /**\n     * Will set the default constraints for the device.\n     *\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.state.setDefaultConstraints(constraints);\n    }\n    /**\n     * Selects a device.\n     *\n     * Note: this method is not supported in React Native\n     * @param deviceId the device id to select.\n     */ async select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This method is not supported in React Native\");\n        }\n        if (deviceId === this.state.selectedDevice) {\n            return;\n        }\n        this.state.setDevice(deviceId);\n        await this.applySettingsToStream();\n    }\n    async applySettingsToStream() {\n        if (this.state.status === \"enabled\") {\n            await this.muteStream();\n            await this.unmuteStream();\n        }\n    }\n    getTracks() {\n        return this.state.mediaStream?.getTracks() ?? [];\n    }\n    async muteStream(stopTracks = true) {\n        if (!this.state.mediaStream) return;\n        this.logger(\"debug\", `${stopTracks ? \"Stopping\" : \"Disabling\"} stream`);\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.stopPublishStream(stopTracks);\n        }\n        this.muteLocalStream(stopTracks);\n        const allEnded = this.getTracks().every((t)=>t.readyState === \"ended\");\n        if (allEnded) {\n            if (this.state.mediaStream && // @ts-expect-error release() is present in react-native-webrtc\n            typeof this.state.mediaStream.release === \"function\") {\n                // @ts-expect-error called to dispose the stream in RN\n                this.state.mediaStream.release();\n            }\n            this.state.setMediaStream(undefined);\n        }\n    }\n    muteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.enabled) track.enabled = false;\n        });\n    }\n    unmuteTracks() {\n        this.getTracks().forEach((track)=>{\n            if (!track.enabled) track.enabled = true;\n        });\n    }\n    stopTracks() {\n        this.getTracks().forEach((track)=>{\n            if (track.readyState === \"live\") track.stop();\n        });\n    }\n    muteLocalStream(stopTracks) {\n        if (!this.state.mediaStream) {\n            return;\n        }\n        if (stopTracks) {\n            this.stopTracks();\n        } else {\n            this.muteTracks();\n        }\n    }\n    async unmuteStream() {\n        this.logger(\"debug\", \"Starting stream\");\n        let stream;\n        if (this.state.mediaStream && this.getTracks().every((t)=>t.readyState === \"live\")) {\n            stream = this.state.mediaStream;\n            this.unmuteTracks();\n        } else {\n            const defaultConstraints = this.state.defaultConstraints;\n            const constraints = {\n                ...defaultConstraints,\n                deviceId: this.state.selectedDevice\n            };\n            stream = await this.getStream(constraints);\n        }\n        if (this.call.state.callingState === CallingState.JOINED) {\n            await this.publishStream(stream);\n        }\n        if (this.state.mediaStream !== stream) {\n            this.state.setMediaStream(stream);\n            this.getTracks().forEach((track)=>{\n                track.addEventListener(\"ended\", async ()=>{\n                    if (this.enablePromise) {\n                        await this.enablePromise;\n                    }\n                    if (this.disablePromise) {\n                        await this.disablePromise;\n                    }\n                    if (this.state.status === \"enabled\") {\n                        this.isTrackStoppedDueToTrackEnd = true;\n                        setTimeout(()=>{\n                            this.isTrackStoppedDueToTrackEnd = false;\n                        }, 2000);\n                        await this.disable();\n                    }\n                });\n            });\n        }\n    }\n    get mediaDeviceKind() {\n        if (this.trackType === TrackType.AUDIO) {\n            return \"audioinput\";\n        }\n        if (this.trackType === TrackType.VIDEO) {\n            return \"videoinput\";\n        }\n        return \"\";\n    }\n    handleDisconnectedOrReplacedDevices() {\n        this.subscriptions.push((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n            deviceIds$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_30__.pairwise)()),\n            this.state.selectedDevice$\n        ]).subscribe(async ([[prevDevices, currentDevices], deviceId])=>{\n            if (!deviceId) {\n                return;\n            }\n            if (this.enablePromise) {\n                await this.enablePromise;\n            }\n            if (this.disablePromise) {\n                await this.disablePromise;\n            }\n            let isDeviceDisconnected = false;\n            let isDeviceReplaced = false;\n            const currentDevice = this.findDeviceInList(currentDevices, deviceId);\n            const prevDevice = this.findDeviceInList(prevDevices, deviceId);\n            if (!currentDevice && prevDevice) {\n                isDeviceDisconnected = true;\n            } else if (currentDevice && prevDevice && currentDevice.deviceId === prevDevice.deviceId && currentDevice.groupId !== prevDevice.groupId) {\n                isDeviceReplaced = true;\n            }\n            if (isDeviceDisconnected) {\n                await this.disable();\n                this.select(undefined);\n            }\n            if (isDeviceReplaced) {\n                if (this.isTrackStoppedDueToTrackEnd && this.state.status === \"disabled\") {\n                    await this.enable();\n                    this.isTrackStoppedDueToTrackEnd = false;\n                } else {\n                    await this.applySettingsToStream();\n                }\n            }\n        }));\n    }\n    findDeviceInList(devices, deviceId) {\n        return devices.find((d)=>d.deviceId === deviceId && d.kind === this.mediaDeviceKind);\n    }\n}\nclass InputMediaDeviceManagerState {\n    /**\n     * Constructs new InputMediaDeviceManagerState instance.\n     *\n     * @param disableMode the disable mode to use.\n     * @param permissionName the permission name to use for querying.\n     * `undefined` means no permission is required.\n     */ constructor(disableMode = \"stop-tracks\", permissionName = undefined){\n        this.disableMode = disableMode;\n        this.permissionName = permissionName;\n        this.statusSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.mediaStreamSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.defaultConstraintsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current media stream, or `undefined` if the device is currently disabled.\n         *\n         */ this.mediaStream$ = this.mediaStreamSubject.asObservable();\n        /**\n         * An Observable that emits the currently selected device\n         */ this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the device status\n         */ this.status$ = this.statusSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * The default constraints for the device.\n         */ this.defaultConstraints$ = this.defaultConstraintsSubject.asObservable();\n        /**\n         * An observable that will emit `true` if browser/system permission\n         * is granted, `false` otherwise.\n         */ this.hasBrowserPermission$ = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_25__.Observable((subscriber)=>{\n            const notifyGranted = ()=>subscriber.next(true);\n            const permissionsAPIAvailable = !!navigator?.permissions?.query;\n            if (isReactNative() || !this.permissionName || !permissionsAPIAvailable) {\n                getLogger([\n                    \"devices\"\n                ])(\"warn\", `Permissions can't be queried. Assuming granted.`);\n                return notifyGranted();\n            }\n            let permissionState;\n            const notify = ()=>subscriber.next(// In Safari, the `change` event doesn't reliably emit and hence,\n                // permissionState stays in 'prompt' state forever.\n                // Instead of checking if a permission is granted, we check if it isn't denied\n                isSafari() ? permissionState.state !== \"denied\" : permissionState.state === \"granted\");\n            navigator.permissions.query({\n                name: this.permissionName\n            }).then((permissionStatus)=>{\n                permissionState = permissionStatus;\n                permissionState.addEventListener(\"change\", notify);\n                notify();\n            }).catch(()=>{\n                // permission doesn't exist or can't be queried -> assume it's granted\n                // an example would be Firefox,\n                // where neither camera microphone permission can be queried\n                notifyGranted();\n            });\n            return ()=>{\n                permissionState?.removeEventListener(\"change\", notify);\n            };\n        }).pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.shareReplay)(1));\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n    }\n    /**\n     * The device status\n     */ get status() {\n        return this.getCurrentValue(this.status$);\n    }\n    /**\n     * The currently selected device\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The current media stream, or `undefined` if the device is currently disabled.\n     */ get mediaStream() {\n        return this.getCurrentValue(this.mediaStream$);\n    }\n    /**\n     * @internal\n     * @param status\n     */ setStatus(status) {\n        this.setCurrentValue(this.statusSubject, status);\n    }\n    /**\n     * @internal\n     * @param stream the stream to set.\n     */ setMediaStream(stream) {\n        this.setCurrentValue(this.mediaStreamSubject, stream);\n        if (stream) {\n            this.setDevice(this.getDeviceIdFromStream(stream));\n        }\n    }\n    /**\n     * @internal\n     * @param deviceId the device id to set.\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * Gets the default constraints for the device.\n     */ get defaultConstraints() {\n        return this.getCurrentValue(this.defaultConstraints$);\n    }\n    /**\n     * Sets the default constraints for the device.\n     *\n     * @internal\n     * @param constraints the constraints to set.\n     */ setDefaultConstraints(constraints) {\n        this.setCurrentValue(this.defaultConstraintsSubject, constraints);\n    }\n}\nclass CameraManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"stop-tracks\", // `camera` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"camera\");\n        this.directionSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        this.direction$ = this.directionSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * The preferred camera direction\n     * front - means the camera facing the user\n     * back - means the camera facing the environment\n     */ get direction() {\n        return this.getCurrentValue(this.direction$);\n    }\n    /**\n     * @internal\n     */ setDirection(direction) {\n        this.setCurrentValue(this.directionSubject, direction);\n    }\n    /**\n     * @internal\n     */ setMediaStream(stream) {\n        super.setMediaStream(stream);\n        if (stream) {\n            // RN getSettings() doesn't return facingMode, so we don't verify camera direction\n            const direction = isReactNative() ? this.direction : stream.getVideoTracks()[0]?.getSettings().facingMode === \"environment\" ? \"back\" : \"front\";\n            this.setDirection(direction);\n        }\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getVideoTracks()[0]?.getSettings().deviceId;\n    }\n}\nclass CameraManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new CameraManagerState(), TrackType.VIDEO);\n        this.targetResolution = {\n            width: 1280,\n            height: 720\n        };\n    }\n    /**\n     * Select the camera direction.\n     *\n     * @param direction the direction of the camera to select.\n     */ async selectDirection(direction) {\n        this.state.setDirection(direction);\n        // Providing both device id and direction doesn't work, so we deselect the device\n        this.state.setDevice(undefined);\n        await this.applySettingsToStream();\n    }\n    /**\n     * Flips the camera direction: if it's front it will change to back, if it's back, it will change to front.\n     *\n     * Note: if there is no available camera with the desired direction, this method will do nothing.\n     * @returns\n     */ async flip() {\n        const newDirection = this.state.direction === \"front\" ? \"back\" : \"front\";\n        await this.selectDirection(newDirection);\n    }\n    /**\n     * @internal\n     */ async selectTargetResolution(resolution) {\n        this.targetResolution.height = resolution.height;\n        this.targetResolution.width = resolution.width;\n        if (this.enablePromise) {\n            try {\n                await this.enablePromise;\n            } catch (error) {\n                // couldn't enable device, target resolution will be applied the next time user attempts to start the device\n                this.logger(\"warn\", \"could not apply target resolution\", error);\n            }\n        }\n        if (this.state.status === \"enabled\") {\n            const { width, height } = this.state.mediaStream.getVideoTracks()[0]?.getSettings();\n            if (width !== this.targetResolution.width || height !== this.targetResolution.height) {\n                await this.applySettingsToStream();\n                this.logger(\"debug\", `${width}x${height} target resolution applied to media stream`);\n            }\n        }\n    }\n    /**\n     * Sets the preferred codec for encoding the video.\n     *\n     * @internal internal use only, not part of the public API.\n     * @param codec the codec to use for encoding the video.\n     */ setPreferredCodec(codec) {\n        this.preferredCodec = codec;\n    }\n    getDevices() {\n        return getVideoDevices();\n    }\n    getStream(constraints) {\n        constraints.width = this.targetResolution.width;\n        constraints.height = this.targetResolution.height;\n        // We can't set both device id and facing mode\n        // Device id has higher priority\n        if (!constraints.deviceId && this.state.direction) {\n            constraints.facingMode = this.state.direction === \"front\" ? \"user\" : \"environment\";\n        }\n        return getVideoStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishVideoStream(stream, {\n            preferredCodec: this.preferredCodec\n        });\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.VIDEO, stopTracks);\n    }\n}\nclass MicrophoneManagerState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(\"disable-tracks\", // `microphone` is not in the W3C standard yet,\n        // but it's supported by Chrome and Safari.\n        \"microphone\");\n        this.speakingWhileMutedSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(false);\n        this.speakingWhileMuted$ = this.speakingWhileMutedSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * `true` if the user's microphone is muted but they'are speaking.\n     *\n     * This feature is not available in the React Native SDK.\n     */ get speakingWhileMuted() {\n        return this.getCurrentValue(this.speakingWhileMuted$);\n    }\n    /**\n     * @internal\n     */ setSpeakingWhileMuted(isSpeaking) {\n        this.setCurrentValue(this.speakingWhileMutedSubject, isSpeaking);\n    }\n    getDeviceIdFromStream(stream) {\n        return stream.getAudioTracks()[0]?.getSettings().deviceId;\n    }\n}\nconst DETECTION_FREQUENCY_IN_MS = 500;\nconst AUDIO_LEVEL_THRESHOLD$1 = 150;\nconst FFT_SIZE = 128;\n/**\n * Creates a new sound detector.\n *\n * @param audioStream the audio stream to observe. Depending on the provided configuration, this stream might be destroyed when the sound detector is stopped.\n * @param onSoundDetectedStateChanged a callback which is called when the sound state changes.\n * @param options custom options for the sound detector.\n * @returns a clean-up function which once invoked stops the sound detector.\n */ const createSoundDetector = (audioStream, onSoundDetectedStateChanged, options = {})=>{\n    const { detectionFrequencyInMs = DETECTION_FREQUENCY_IN_MS, audioLevelThreshold = AUDIO_LEVEL_THRESHOLD$1, fftSize = FFT_SIZE, destroyStreamOnStop = true } = options;\n    const audioContext = new AudioContext();\n    const analyser = audioContext.createAnalyser();\n    analyser.fftSize = fftSize;\n    const microphone = audioContext.createMediaStreamSource(audioStream);\n    microphone.connect(analyser);\n    const intervalId = setInterval(()=>{\n        const data = new Uint8Array(analyser.frequencyBinCount);\n        analyser.getByteFrequencyData(data);\n        const isSoundDetected = data.some((value)=>value >= audioLevelThreshold);\n        const averagedDataValue = data.reduce((pv, cv)=>pv + cv, 0) / data.length;\n        const percentage = averagedDataValue > audioLevelThreshold ? 100 : Math.round(averagedDataValue / audioLevelThreshold * 100);\n        // When the track is disabled, it takes time for the buffer to empty\n        // This check will ensure that we don't send anything if the track is disabled\n        if (audioStream.getAudioTracks()[0]?.enabled) {\n            onSoundDetectedStateChanged({\n                isSoundDetected,\n                audioLevel: percentage\n            });\n        } else {\n            onSoundDetectedStateChanged({\n                isSoundDetected: false,\n                audioLevel: 0\n            });\n        }\n    }, detectionFrequencyInMs);\n    return async function stop() {\n        clearInterval(intervalId);\n        // clean-up the AudioContext elements\n        microphone.disconnect();\n        analyser.disconnect();\n        await audioContext.close();\n        // stop the stream\n        if (destroyStreamOnStop) {\n            audioStream.getTracks().forEach((track)=>{\n                track.stop();\n                audioStream.removeTrack(track);\n            });\n        }\n    };\n};\n/**\n * Flatten the stats report into an array of stats objects.\n *\n * @param report the report to flatten.\n */ const flatten = (report)=>{\n    const stats = [];\n    report.forEach((s)=>{\n        stats.push(s);\n    });\n    return stats;\n};\nconst AUDIO_LEVEL_THRESHOLD = 0.2;\nclass RNSpeechDetector {\n    constructor(){\n        this.pc1 = new RTCPeerConnection({});\n        this.pc2 = new RTCPeerConnection({});\n    }\n    /**\n     * Starts the speech detection.\n     */ async start() {\n        try {\n            const audioStream = await navigator.mediaDevices.getUserMedia({\n                audio: true\n            });\n            this.pc1.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc2.addIceCandidate(e.candidate);\n            });\n            this.pc2.addEventListener(\"icecandidate\", async (e)=>{\n                await this.pc1.addIceCandidate(e.candidate);\n            });\n            audioStream.getTracks().forEach((track)=>this.pc1.addTrack(track, audioStream));\n            const offer = await this.pc1.createOffer({});\n            await this.pc2.setRemoteDescription(offer);\n            await this.pc1.setLocalDescription(offer);\n            const answer = await this.pc2.createAnswer();\n            await this.pc1.setRemoteDescription(answer);\n            await this.pc2.setLocalDescription(answer);\n            const audioTracks = audioStream.getAudioTracks();\n            // We need to mute the audio track for this temporary stream, or else you will hear yourself twice while in the call.\n            audioTracks.forEach((track)=>track.enabled = false);\n        } catch (error) {\n            console.error(\"Error connecting and negotiating between PeerConnections:\", error);\n        }\n    }\n    /**\n     * Stops the speech detection and releases all allocated resources.\n     */ stop() {\n        this.pc1.close();\n        this.pc2.close();\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n    /**\n     * Public method that detects the audio levels and returns the status.\n     */ onSpeakingDetectedStateChange(onSoundDetectedStateChanged) {\n        this.intervalId = setInterval(async ()=>{\n            const stats = await this.pc1.getStats();\n            const report = flatten(stats);\n            // Audio levels are present inside stats of type `media-source` and of kind `audio`\n            const audioMediaSourceStats = report.find((stat)=>stat.type === \"media-source\" && stat.kind === \"audio\");\n            if (audioMediaSourceStats) {\n                const { audioLevel } = audioMediaSourceStats;\n                if (audioLevel) {\n                    if (audioLevel >= AUDIO_LEVEL_THRESHOLD) {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: true,\n                            audioLevel\n                        });\n                    } else {\n                        onSoundDetectedStateChanged({\n                            isSoundDetected: false,\n                            audioLevel: 0\n                        });\n                    }\n                }\n            }\n        }, 1000);\n        return ()=>{\n            clearInterval(this.intervalId);\n        };\n    }\n}\nclass MicrophoneManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new MicrophoneManagerState(), TrackType.AUDIO);\n        (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n            this.call.state.callingState$,\n            this.call.state.ownCapabilities$,\n            this.state.selectedDevice$,\n            this.state.status$\n        ]).subscribe(async ([callingState, ownCapabilities, deviceId, status])=>{\n            if (callingState !== CallingState.JOINED) {\n                if (callingState === CallingState.LEFT) {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n                return;\n            }\n            if (ownCapabilities.includes(OwnCapability.SEND_AUDIO)) {\n                if (status === \"disabled\") {\n                    await this.startSpeakingWhileMutedDetection(deviceId);\n                } else {\n                    await this.stopSpeakingWhileMutedDetection();\n                }\n            } else {\n                await this.stopSpeakingWhileMutedDetection();\n            }\n        });\n    }\n    getDevices() {\n        return getAudioDevices();\n    }\n    getStream(constraints) {\n        return getAudioStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishAudioStream(stream);\n    }\n    stopPublishStream(stopTracks) {\n        return this.call.stopPublish(TrackType.AUDIO, stopTracks);\n    }\n    async startSpeakingWhileMutedDetection(deviceId) {\n        await this.stopSpeakingWhileMutedDetection();\n        if (isReactNative()) {\n            this.rnSpeechDetector = new RNSpeechDetector();\n            await this.rnSpeechDetector.start();\n            const unsubscribe = this.rnSpeechDetector?.onSpeakingDetectedStateChange((event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n            this.soundDetectorCleanup = ()=>{\n                unsubscribe();\n                this.rnSpeechDetector?.stop();\n                this.rnSpeechDetector = undefined;\n            };\n        } else {\n            // Need to start a new stream that's not connected to publisher\n            const stream = await this.getStream({\n                deviceId\n            });\n            this.soundDetectorCleanup = createSoundDetector(stream, (event)=>{\n                this.state.setSpeakingWhileMuted(event.isSoundDetected);\n            });\n        }\n    }\n    async stopSpeakingWhileMutedDetection() {\n        if (!this.soundDetectorCleanup) {\n            return;\n        }\n        this.state.setSpeakingWhileMuted(false);\n        try {\n            await this.soundDetectorCleanup();\n        } finally{\n            this.soundDetectorCleanup = undefined;\n        }\n    }\n}\nclass ScreenShareState extends InputMediaDeviceManagerState {\n    constructor(){\n        super(...arguments);\n        this.audioEnabledSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(true);\n        this.settingsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(undefined);\n        /**\n         * An Observable that emits the current screen share audio status.\n         */ this.audioEnabled$ = this.audioEnabledSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        /**\n         * An Observable that emits the current screen share settings.\n         */ this.settings$ = this.settingsSubject.asObservable();\n        /**\n         * @internal\n         */ this.getDeviceIdFromStream = (stream)=>{\n            const [track] = stream.getTracks();\n            return track?.getSettings().deviceId;\n        };\n    }\n    /**\n     * The current screen share audio status.\n     */ get audioEnabled() {\n        return this.getCurrentValue(this.audioEnabled$);\n    }\n    /**\n     * Set the current screen share audio status.\n     */ setAudioEnabled(isEnabled) {\n        this.setCurrentValue(this.audioEnabledSubject, isEnabled);\n    }\n    /**\n     * The current screen share settings.\n     */ get settings() {\n        return this.getCurrentValue(this.settings$);\n    }\n    /**\n     * Set the current screen share settings.\n     *\n     * @param settings the screen share settings to set.\n     */ setSettings(settings) {\n        this.setCurrentValue(this.settingsSubject, settings);\n    }\n}\nclass ScreenShareManager extends InputMediaDeviceManager {\n    constructor(call){\n        super(call, new ScreenShareState(), TrackType.SCREEN_SHARE);\n    }\n    /**\n     * Will enable screen share audio options on supported platforms.\n     *\n     * Note: for ongoing screen share, audio won't be enabled until you\n     * re-publish the screen share stream.\n     */ enableScreenShareAudio() {\n        this.state.setAudioEnabled(true);\n    }\n    /**\n     * Will disable screen share audio options on supported platforms.\n     */ async disableScreenShareAudio() {\n        this.state.setAudioEnabled(false);\n        if (this.call.publisher?.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {\n            await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, true);\n        }\n    }\n    /**\n     * Returns the current screen share settings.\n     */ getSettings() {\n        return this.state.settings;\n    }\n    /**\n     * Sets the current screen share settings.\n     *\n     * @param settings the settings to set.\n     */ setSettings(settings) {\n        this.state.setSettings(settings);\n    }\n    getDevices() {\n        return (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_31__.of)([]); // there are no devices to be listed for Screen Share\n    }\n    getStream(constraints) {\n        if (!this.state.audioEnabled) {\n            constraints.audio = false;\n        }\n        return getScreenShareStream(constraints);\n    }\n    publishStream(stream) {\n        return this.call.publishScreenShareStream(stream, {\n            screenShareSettings: this.state.settings\n        });\n    }\n    async stopPublishStream(stopTracks) {\n        await this.call.stopPublish(TrackType.SCREEN_SHARE, stopTracks);\n        await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO, stopTracks);\n    }\n    /**\n     * Overrides the default `select` method to throw an error.\n     *\n     * @param deviceId ignored.\n     */ async select(deviceId) {\n        throw new Error(\"This method is not supported in for Screen Share\");\n    }\n}\nclass SpeakerState {\n    constructor(){\n        this.selectedDeviceSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(\"\");\n        this.volumeSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(1);\n        /**\n         * [Tells if the browser supports audio output change on 'audio' elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n         */ this.isDeviceSelectionSupported = checkIfAudioOutputChangeSupported();\n        /**\n         * Gets the current value of an observable, or undefined if the observable has\n         * not emitted a value yet.\n         *\n         * @param observable$ the observable to get the value from.\n         */ this.getCurrentValue = getCurrentValue;\n        /**\n         * Updates the value of the provided Subject.\n         * An `update` can either be a new value or a function which takes\n         * the current value and returns a new value.\n         *\n         * @internal\n         *\n         * @param subject the subject to update.\n         * @param update the update to apply to the subject.\n         * @return the updated value.\n         */ this.setCurrentValue = setCurrentValue;\n        this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n        this.volume$ = this.volumeSubject.asObservable().pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged)());\n    }\n    /**\n     * The currently selected device\n     *\n     * Note: this feature is not supported in React Native\n     */ get selectedDevice() {\n        return this.getCurrentValue(this.selectedDevice$);\n    }\n    /**\n     * The currently selected volume\n     *\n     * Note: this feature is not supported in React Native\n     */ get volume() {\n        return this.getCurrentValue(this.volume$);\n    }\n    /**\n     * @internal\n     * @param deviceId\n     */ setDevice(deviceId) {\n        this.setCurrentValue(this.selectedDeviceSubject, deviceId);\n    }\n    /**\n     * @internal\n     * @param volume\n     */ setVolume(volume) {\n        this.setCurrentValue(this.volumeSubject, volume);\n    }\n}\nclass SpeakerManager {\n    constructor(){\n        this.state = new SpeakerState();\n        this.subscriptions = [];\n        this.removeSubscriptions = ()=>{\n            this.subscriptions.forEach((s)=>s.unsubscribe());\n        };\n        if (deviceIds$ && !isReactNative()) {\n            this.subscriptions.push((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.combineLatest)([\n                deviceIds$,\n                this.state.selectedDevice$\n            ]).subscribe(([devices, deviceId])=>{\n                if (!deviceId) {\n                    return;\n                }\n                const device = devices.find((d)=>d.deviceId === deviceId && d.kind === \"audiooutput\");\n                if (!device) {\n                    this.select(\"\");\n                }\n            }));\n        }\n    }\n    /**\n     * Lists the available audio output devices\n     *\n     * Note: It prompts the user for a permission to use devices (if not already granted)\n     *\n     * @returns an Observable that will be updated if a device is connected or disconnected\n     */ listDevices() {\n        return getAudioOutputDevices();\n    }\n    /**\n     * Select device\n     *\n     * Note: this method is not supported in React Native\n     *\n     * @param deviceId empty string means the system default\n     */ select(deviceId) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native\");\n        }\n        this.state.setDevice(deviceId);\n    }\n    /**\n     * Set the volume of the audio elements\n     * @param volume a number between 0 and 1\n     *\n     * Note: this method is not supported in React Native\n     */ setVolume(volume) {\n        if (isReactNative()) {\n            throw new Error(\"This feature is not supported in React Native\");\n        }\n        if (volume && (volume < 0 || volume > 1)) {\n            throw new Error(\"Volume must be between 0 and 1\");\n        }\n        this.state.setVolume(volume);\n    }\n}\n/**\n * An object representation of a `Call`.\n */ class Call {\n    /**\n     * Constructs a new `Call` instance.\n     *\n     * NOTE: Don't call the constructor directly, instead\n     * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)\n     * method to construct a `Call` instance.\n     */ constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing = false, watching = false }){\n        /**\n         * The state of this call.\n         */ this.state = new CallState();\n        /**\n         * The DynascaleManager instance.\n         */ this.dynascaleManager = new DynascaleManager(this);\n        /**\n         * The permissions context of this call.\n         */ this.permissionsContext = new PermissionsContext();\n        /**\n         * The event dispatcher instance dedicated to this Call instance.\n         * @private\n         */ this.dispatcher = new Dispatcher();\n        this.trackSubscriptionsSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject({\n            type: DebounceType.MEDIUM,\n            data: []\n        });\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 10;\n        /**\n         * A list hooks/functions to invoke when the call is left.\n         * A typical use case is to clean up some global event handlers.\n         * @private\n         */ this.leaveCallHooks = new Set();\n        this.streamClientEventHandlers = new Map();\n        /**\n         * You can subscribe to WebSocket events provided by the API. To remove a subscription, call the `off` method.\n         * Please note that subscribing to WebSocket events is an advanced use-case.\n         * For most use-cases, it should be enough to watch for state changes.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.on = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.on(eventName, fn);\n            }\n            const offHandler = this.streamClient.on(eventName, (e)=>{\n                const event = e;\n                if (event.call_cid && event.call_cid === this.cid) {\n                    fn(event);\n                }\n            });\n            // keep the 'off' reference returned by the stream client\n            this.streamClientEventHandlers.set(fn, offHandler);\n            return ()=>{\n                this.off(eventName, fn);\n            };\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param fn the event handler.\n         */ this.off = (eventName, fn)=>{\n            if (isSfuEvent(eventName)) {\n                return this.dispatcher.off(eventName, fn);\n            }\n            // unsubscribe from the stream client event by using the 'off' reference\n            const registeredOffHandler = this.streamClientEventHandlers.get(fn);\n            if (registeredOffHandler) {\n                registeredOffHandler();\n            }\n        };\n        /**\n         * Leave the call and stop the media streams that were published by the call.\n         */ this.leave = async ({ reject = false } = {})=>{\n            const callingState = this.state.callingState;\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Cannot leave call that has already been left.\");\n            }\n            if (callingState === CallingState.JOINING) {\n                await this.assertCallJoined();\n            }\n            if (this.ringing) {\n                // I'm the one who started the call, so I should cancel it.\n                const hasOtherParticipants = this.state.remoteParticipants.length > 0;\n                if (this.isCreatedByMe && !hasOtherParticipants) {\n                    // Signals other users that I have cancelled my call to them\n                    // before they accepted it.\n                    await this.reject();\n                } else if (reject && callingState === CallingState.RINGING) {\n                    // Signals other users that I have rejected the incoming call.\n                    await this.reject();\n                }\n            }\n            this.statsReporter?.stop();\n            this.statsReporter = undefined;\n            this.subscriber?.close();\n            this.subscriber = undefined;\n            this.publisher?.close();\n            this.publisher = undefined;\n            this.sfuClient?.close();\n            this.sfuClient = undefined;\n            this.dispatcher.offAll();\n            this.state.setCallingState(CallingState.LEFT);\n            // Call all leave call hooks, e.g. to clean up global event handlers\n            this.leaveCallHooks.forEach((hook)=>hook());\n            this.clientStore.unregisterCall(this);\n            this.camera.removeSubscriptions();\n            this.microphone.removeSubscriptions();\n            this.screenShare.removeSubscriptions();\n            this.speaker.removeSubscriptions();\n            const stopOnLeavePromises = [];\n            if (this.camera.stopOnLeave) {\n                stopOnLeavePromises.push(this.camera.disable(true));\n            }\n            if (this.microphone.stopOnLeave) {\n                stopOnLeavePromises.push(this.microphone.disable(true));\n            }\n            if (this.screenShare.stopOnLeave) {\n                stopOnLeavePromises.push(this.screenShare.disable(true));\n            }\n            await Promise.all(stopOnLeavePromises);\n        };\n        /**\n         * Loads the information about the call.\n         *\n         * @param params.ring if set to true, a `call.ring` event will be sent to the call members.\n         * @param params.notify if set to true, a `call.notification` event will be sent to the call members.\n         * @param params.members_limit the total number of members to return as part of the response.\n         */ this.get = async (params)=>{\n            const response = await this.streamClient.get(this.streamClientBasePath, params);\n            if (params?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Loads the information about the call and creates it if it doesn't exist.\n         *\n         * @param data the data to create the call with.\n         */ this.getOrCreate = async (data)=>{\n            const response = await this.streamClient.post(this.streamClientBasePath, data);\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            this.state.updateFromCallResponse(response.call);\n            this.state.setMembers(response.members);\n            this.state.setOwnCapabilities(response.own_capabilities);\n            if (this.streamClient._hasConnectionID()) {\n                this.watching = true;\n                this.clientStore.registerCall(this);\n            }\n            this.applyDeviceConfig();\n            return response;\n        };\n        /**\n         * Creates a call\n         *\n         * @param data the data to create the call with.\n         */ this.create = async (data)=>{\n            return this.getOrCreate(data);\n        };\n        /**\n         * A shortcut for {@link Call.get} with `ring` parameter set to `true`.\n         * Will send a `call.ring` event to the call members.\n         */ this.ring = async ()=>{\n            return await this.get({\n                ring: true\n            });\n        };\n        /**\n         * A shortcut for {@link Call.get} with `notify` parameter set to `true`.\n         * Will send a `call.notification` event to the call members.\n         */ this.notify = async ()=>{\n            return await this.get({\n                notify: true\n            });\n        };\n        /**\n         * Marks the incoming call as accepted.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.join} invokes this method automatically for you when joining a call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.accept = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/accept`);\n        };\n        /**\n         * Marks the incoming call as rejected.\n         *\n         * This method should be used only for \"ringing\" call flows.\n         * {@link Call.leave} invokes this method automatically for you when you leave or reject this call.\n         * Unless you are implementing a custom \"ringing\" flow, you should not use this method.\n         */ this.reject = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reject`);\n        };\n        /**\n         * Will start to watch for call related WebSocket events and initiate a call session with the server.\n         *\n         * @returns a promise which resolves once the call join-flow has finished.\n         */ this.join = async (data)=>{\n            const callingState = this.state.callingState;\n            if ([\n                CallingState.JOINED,\n                CallingState.JOINING\n            ].includes(callingState)) {\n                this.logger(\"warn\", \"Join method called twice, you should only call this once\");\n                throw new Error(`Illegal State: Already joined.`);\n            }\n            if (callingState === CallingState.LEFT) {\n                throw new Error(\"Illegal State: Cannot join already left call. Create a new Call instance to join a call.\");\n            }\n            const isMigrating = callingState === CallingState.MIGRATING;\n            const isReconnecting = callingState === CallingState.RECONNECTING;\n            this.state.setCallingState(CallingState.JOINING);\n            this.logger(\"debug\", \"Starting join flow\");\n            if (data?.ring && !this.ringing) {\n                this.ringingSubject.next(true);\n            }\n            if (this.ringing && !this.isCreatedByMe) {\n                // signals other users that I have accepted the incoming call.\n                await this.accept();\n            }\n            let sfuServer;\n            let sfuToken;\n            let connectionConfig;\n            try {\n                if (this.sfuClient?.isFastReconnecting) {\n                    // use previous SFU configuration and values\n                    connectionConfig = this.publisher?.connectionConfiguration;\n                    sfuServer = this.sfuClient.sfuServer;\n                    sfuToken = this.sfuClient.token;\n                } else {\n                    // full join flow - let the Coordinator pick a new SFU for us\n                    const call = await join(this.streamClient, this.type, this.id, data);\n                    this.state.updateFromCallResponse(call.metadata);\n                    this.state.setMembers(call.members);\n                    this.state.setOwnCapabilities(call.ownCapabilities);\n                    connectionConfig = call.connectionConfig;\n                    sfuServer = call.sfuServer;\n                    sfuToken = call.token;\n                }\n                if (this.streamClient._hasConnectionID()) {\n                    this.watching = true;\n                    this.clientStore.registerCall(this);\n                }\n            } catch (error) {\n                // restore the previous call state if the join-flow fails\n                this.state.setCallingState(callingState);\n                throw error;\n            }\n            const previousSfuClient = this.sfuClient;\n            const sfuClient = this.sfuClient = new StreamSfuClient({\n                dispatcher: this.dispatcher,\n                sfuServer,\n                token: sfuToken,\n                sessionId: previousSfuClient?.sessionId\n            });\n            /**\n             * A closure which hides away the re-connection logic.\n             */ const reconnect = async (strategy = \"full\")=>{\n                const currentState = this.state.callingState;\n                if (currentState === CallingState.MIGRATING || currentState === CallingState.RECONNECTING) {\n                    // prevent parallel reconnection attempts\n                    return;\n                }\n                this.reconnectAttempts++;\n                this.state.setCallingState(strategy === \"migrate\" ? CallingState.MIGRATING : CallingState.RECONNECTING);\n                if (strategy === \"migrate\") {\n                    this.logger(\"debug\", `[Migration]: migrating call ${this.cid} away from ${sfuServer.edge_name}`);\n                    sfuClient.isMigratingAway = true;\n                } else {\n                    this.logger(\"debug\", `[Rejoin]: ${strategy} rejoin call ${this.cid} (${this.reconnectAttempts})...`);\n                }\n                // take a snapshot of the current \"local participant\" state\n                // we'll need it for restoring the previous publishing state later\n                const localParticipant = this.state.localParticipant;\n                if (strategy === \"fast\") {\n                    sfuClient.close(StreamSfuClient.ERROR_CONNECTION_BROKEN, \"js-client: attempting fast reconnect\");\n                } else if (strategy === \"full\") {\n                    // in migration or recovery scenarios, we don't want to\n                    // wait before attempting to reconnect to an SFU server\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    // in full-reconnect, we need to dispose all Peer Connections\n                    this.subscriber?.close();\n                    this.subscriber = undefined;\n                    this.publisher?.close({\n                        stopTracks: false\n                    });\n                    this.publisher = undefined;\n                    this.statsReporter?.stop();\n                    this.statsReporter = undefined;\n                    // clean up current connection\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, \"js-client: attempting full reconnect\");\n                }\n                await this.join({\n                    ...data,\n                    ...strategy === \"migrate\" && {\n                        migrating_from: sfuServer.edge_name\n                    }\n                });\n                // clean up previous connection\n                if (strategy === \"migrate\") {\n                    sfuClient.close(StreamSfuClient.NORMAL_CLOSURE, \"js-client: attempting migration\");\n                }\n                this.logger(\"info\", `[Rejoin]: Attempt ${this.reconnectAttempts} successful!`);\n                // we shouldn't be republishing the streams if we're migrating\n                // as the underlying peer connection will take care of it as part\n                // of the ice-restart process\n                if (localParticipant && strategy === \"full\") {\n                    const { audioStream, videoStream, screenShareStream, screenShareAudioStream } = localParticipant;\n                    let screenShare;\n                    if (screenShareStream || screenShareAudioStream) {\n                        screenShare = new MediaStream();\n                        screenShareStream?.getVideoTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                        screenShareAudioStream?.getAudioTracks().forEach((track)=>{\n                            screenShare?.addTrack(track);\n                        });\n                    }\n                    // restore previous publishing state\n                    if (audioStream) await this.publishAudioStream(audioStream);\n                    if (videoStream) {\n                        await this.publishVideoStream(videoStream, {\n                            preferredCodec: this.camera.preferredCodec\n                        });\n                    }\n                    if (screenShare) await this.publishScreenShareStream(screenShare);\n                    this.logger(\"info\", `[Rejoin]: State restored. Attempt: ${this.reconnectAttempts}`);\n                }\n            };\n            // reconnect if the connection was closed unexpectedly. example:\n            // - SFU crash or restart\n            // - network change\n            sfuClient.signalReady.then(()=>{\n                // register a handler for the \"goAway\" event\n                const unregisterGoAway = this.dispatcher.on(\"goAway\", (event)=>{\n                    const { reason } = event;\n                    this.logger(\"info\", `[Migration]: Going away from SFU... Reason: ${GoAwayReason[reason]}`);\n                    reconnect(\"migrate\").catch((err)=>{\n                        this.logger(\"warn\", `[Migration]: Failed to migrate to another SFU.`, err);\n                    });\n                });\n                sfuClient.signalWs.addEventListener(\"close\", (e)=>{\n                    // unregister the \"goAway\" handler, as we won't need it anymore for this connection.\n                    // the upcoming re-join will register a new handler anyway\n                    unregisterGoAway();\n                    // do nothing if the connection was closed on purpose\n                    if (e.code === StreamSfuClient.NORMAL_CLOSURE) return;\n                    // do nothing if the connection was closed because of a policy violation\n                    // e.g., the user has been blocked by an admin or moderator\n                    if (e.code === KnownCodes.WS_POLICY_VIOLATION) return;\n                    // When the SFU is being shut down, it sends a goAway message.\n                    // While we migrate to another SFU, we might have the WS connection\n                    // to the old SFU closed abruptly. In this case, we don't want\n                    // to reconnect to the old SFU, but rather to the new one.\n                    const isMigratingAway = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isMigratingAway;\n                    const isFastReconnecting = e.code === KnownCodes.WS_CLOSED_ABRUPTLY && sfuClient.isFastReconnecting;\n                    if (isMigratingAway || isFastReconnecting) return;\n                    // do nothing if the connection was closed because of a fast reconnect\n                    if (e.code === StreamSfuClient.ERROR_CONNECTION_BROKEN) return;\n                    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                        sfuClient.isFastReconnecting = this.reconnectAttempts === 0;\n                        const strategy = sfuClient.isFastReconnecting ? \"fast\" : \"full\";\n                        reconnect(strategy).catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: ${strategy} rejoin failed for ${this.reconnectAttempts} times. Giving up.`, err);\n                            this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                        });\n                    } else {\n                        this.logger(\"error\", \"[Rejoin]: Reconnect attempts exceeded. Giving up...\");\n                        this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    }\n                });\n            });\n            // handlers for connection online/offline events\n            const unsubscribeOnlineEvent = this.streamClient.on(\"connection.changed\", async (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (!e.online) return;\n                unsubscribeOnlineEvent();\n                const currentCallingState = this.state.callingState;\n                const shouldReconnect = currentCallingState === CallingState.OFFLINE || currentCallingState === CallingState.RECONNECTING_FAILED;\n                if (!shouldReconnect) return;\n                this.logger(\"info\", \"[Rejoin]: Going online...\");\n                let isFirstReconnectAttempt = true;\n                do {\n                    try {\n                        sfuClient.isFastReconnecting = isFirstReconnectAttempt;\n                        await reconnect(isFirstReconnectAttempt ? \"fast\" : \"full\");\n                        return; // break the loop if rejoin is successful\n                    } catch (err) {\n                        this.logger(\"error\", `[Rejoin][Network]: Rejoin failed for attempt ${this.reconnectAttempts}`, err);\n                    }\n                    // wait for a bit before trying to reconnect again\n                    await sleep(retryInterval(this.reconnectAttempts));\n                    isFirstReconnectAttempt = false;\n                }while (this.reconnectAttempts < this.maxReconnectAttempts);\n                // if we're here, it means that we've exhausted all the reconnect attempts\n                this.logger(\"error\", `[Rejoin][Network]: Rejoin failed. Giving up.`);\n                this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n            });\n            const unsubscribeOfflineEvent = this.streamClient.on(\"connection.changed\", (e)=>{\n                if (e.type !== \"connection.changed\") return;\n                if (e.online) return;\n                unsubscribeOfflineEvent();\n                this.state.setCallingState(CallingState.OFFLINE);\n            });\n            this.leaveCallHooks.add(()=>{\n                unsubscribeOnlineEvent();\n                unsubscribeOfflineEvent();\n            });\n            if (!this.subscriber) {\n                this.subscriber = new Subscriber({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig\n                });\n            }\n            const audioSettings = this.state.settings?.audio;\n            const isDtxEnabled = !!audioSettings?.opus_dtx_enabled;\n            const isRedEnabled = !!audioSettings?.redundant_coding_enabled;\n            if (!this.publisher) {\n                this.publisher = new Publisher({\n                    sfuClient,\n                    dispatcher: this.dispatcher,\n                    state: this.state,\n                    connectionConfig,\n                    isDtxEnabled,\n                    isRedEnabled\n                });\n            }\n            if (!this.statsReporter) {\n                this.statsReporter = createStatsReporter({\n                    subscriber: this.subscriber,\n                    publisher: this.publisher,\n                    state: this.state\n                });\n            }\n            try {\n                // 1. wait for the signal server to be ready before sending \"joinRequest\"\n                sfuClient.signalReady.catch((err)=>this.logger(\"error\", \"Signal ready failed\", err))// prepare a generic SDP and send it to the SFU.\n                // this is a throw-away SDP that the SFU will use to determine\n                // the capabilities of the client (codec support, etc.)\n                .then(()=>getGenericSdp(\"recvonly\")).then((sdp)=>{\n                    const subscriptions = getCurrentValue(this.trackSubscriptionsSubject);\n                    const migration = isMigrating ? {\n                        fromSfuId: data?.migrating_from || \"\",\n                        subscriptions: subscriptions.data || [],\n                        announcedTracks: this.publisher?.getCurrentTrackInfos() || []\n                    } : undefined;\n                    return sfuClient.join({\n                        subscriberSdp: sdp || \"\",\n                        clientDetails: getClientDetails(),\n                        migration,\n                        fastReconnect: previousSfuClient?.isFastReconnecting ?? false\n                    });\n                });\n                // 2. in parallel, wait for the SFU to send us the \"joinResponse\"\n                // this will throw an error if the SFU rejects the join request or\n                // fails to respond in time\n                const { callState, reconnected } = await this.waitForJoinResponse();\n                if (isReconnecting) {\n                    this.logger(\"debug\", \"[Rejoin] fast reconnected:\", reconnected);\n                }\n                if (isMigrating) {\n                    await this.subscriber.migrateTo(sfuClient, connectionConfig);\n                    await this.publisher.migrateTo(sfuClient, connectionConfig);\n                } else if (isReconnecting) {\n                    if (reconnected) {\n                        // update the SFU client instance on the subscriber and publisher\n                        this.subscriber.setSfuClient(sfuClient);\n                        this.publisher.setSfuClient(sfuClient);\n                        // and perform a full ICE restart on the publisher\n                        await this.publisher.restartIce();\n                    } else if (previousSfuClient?.isFastReconnecting) {\n                        // reconnection wasn't possible, so we need to do a full rejoin\n                        return await reconnect(\"full\").catch((err)=>{\n                            this.logger(\"error\", `[Rejoin]: Rejoin failed forced full rejoin.`, err);\n                        });\n                    }\n                }\n                const currentParticipants = callState?.participants || [];\n                const participantCount = callState?.participantCount;\n                const startedAt = callState?.startedAt ? Timestamp.toDate(callState.startedAt) : new Date();\n                const pins = callState?.pins ?? [];\n                this.state.setParticipants(()=>{\n                    const participantLookup = this.state.getParticipantLookupBySessionId();\n                    return currentParticipants.map((p)=>{\n                        // We need to preserve the local state of the participant\n                        // (e.g. videoDimension, visibilityState, pinnedAt, etc.)\n                        // as it doesn't exist on the server.\n                        const existingParticipant = participantLookup[p.sessionId];\n                        return Object.assign(p, existingParticipant, {\n                            isLocalParticipant: p.sessionId === sfuClient.sessionId,\n                            viewportVisibilityState: existingParticipant?.viewportVisibilityState ?? {\n                                videoTrack: VisibilityState.UNKNOWN,\n                                screenShareTrack: VisibilityState.UNKNOWN\n                            }\n                        });\n                    });\n                });\n                this.state.setParticipantCount(participantCount?.total || 0);\n                this.state.setAnonymousParticipantCount(participantCount?.anonymous || 0);\n                this.state.setStartedAt(startedAt);\n                this.state.setServerSidePins(pins);\n                this.reconnectAttempts = 0; // reset the reconnect attempts counter\n                this.state.setCallingState(CallingState.JOINED);\n                try {\n                    await this.initCamera({\n                        setStatus: true\n                    });\n                    await this.initMic({\n                        setStatus: true\n                    });\n                } catch (error) {\n                    this.logger(\"warn\", \"Camera and/or mic init failed during join call\", error);\n                }\n                // 3. once we have the \"joinResponse\", and possibly reconciled the local state\n                // we schedule a fast subscription update for all remote participants\n                // that were visible before we reconnected or migrated to a new SFU.\n                const { remoteParticipants } = this.state;\n                if (remoteParticipants.length > 0) {\n                    this.updateSubscriptions(remoteParticipants, DebounceType.FAST);\n                }\n                this.logger(\"info\", `Joined call ${this.cid}`);\n            } catch (err) {\n                // join failed, try to rejoin\n                if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                    this.logger(\"error\", `[Rejoin]: Rejoin ${this.reconnectAttempts} failed.`, err);\n                    await reconnect();\n                    this.logger(\"info\", `[Rejoin]: Rejoin ${this.reconnectAttempts} successful!`);\n                } else {\n                    this.logger(\"error\", `[Rejoin]: Rejoin failed for ${this.reconnectAttempts} times. Giving up.`);\n                    this.state.setCallingState(CallingState.RECONNECTING_FAILED);\n                    throw new Error(\"Join failed\");\n                }\n            }\n        };\n        this.waitForJoinResponse = (timeout = 5000)=>{\n            return new Promise((resolve, reject)=>{\n                const unsubscribe = this.on(\"joinResponse\", (event)=>{\n                    clearTimeout(timeoutId);\n                    unsubscribe();\n                    resolve(event);\n                });\n                const timeoutId = setTimeout(()=>{\n                    unsubscribe();\n                    reject(new Error('Waiting for \"joinResponse\" has timed out'));\n                }, timeout);\n            });\n        };\n        /**\n         * Starts publishing the given video stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the previously published stream.\n         * The previous video stream will be stopped.\n         *\n         * @param videoStream the video stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishVideoStream = async (videoStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish video before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [videoTrack] = videoStream.getVideoTracks();\n            if (!videoTrack) {\n                this.logger(\"error\", `There is no video track to publish in the stream.`);\n                return;\n            }\n            await this.publisher.publishStream(videoStream, videoTrack, TrackType.VIDEO, opts);\n        };\n        /**\n         * Starts publishing the given audio stream to the call.\n         * The stream will be stopped if the user changes an input device, or if the user leaves the call.\n         *\n         * Consecutive calls to this method will replace the audio stream that is currently being published.\n         * The previous audio stream will be stopped.\n         *\n         * @param audioStream the audio stream to publish.\n         */ this.publishAudioStream = async (audioStream)=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish audio before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [audioTrack] = audioStream.getAudioTracks();\n            if (!audioTrack) {\n                this.logger(\"error\", `There is no audio track in the stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(audioStream, audioTrack, TrackType.AUDIO);\n        };\n        /**\n         * Starts publishing the given screen-share stream to the call.\n         *\n         * Consecutive calls to this method will replace the previous screen-share stream.\n         * The previous screen-share stream will be stopped.\n         *\n         * @param screenShareStream the screen-share stream to publish.\n         * @param opts the options to use when publishing the stream.\n         */ this.publishScreenShareStream = async (screenShareStream, opts = {})=>{\n            // we should wait until we get a JoinResponse from the SFU,\n            // otherwise we risk breaking the ICETrickle flow.\n            await this.assertCallJoined();\n            if (!this.publisher) {\n                this.logger(\"error\", \"Trying to publish screen share before join is completed\");\n                throw new Error(`Call not joined yet.`);\n            }\n            const [screenShareTrack] = screenShareStream.getVideoTracks();\n            if (!screenShareTrack) {\n                this.logger(\"error\", `There is no video track in the screen share stream to publish`);\n                return;\n            }\n            await this.publisher.publishStream(screenShareStream, screenShareTrack, TrackType.SCREEN_SHARE, opts);\n            const [screenShareAudioTrack] = screenShareStream.getAudioTracks();\n            if (screenShareAudioTrack) {\n                await this.publisher.publishStream(screenShareStream, screenShareAudioTrack, TrackType.SCREEN_SHARE_AUDIO, opts);\n            }\n        };\n        /**\n         * Stops publishing the given track type to the call, if it is currently being published.\n         * Underlying track will be stopped and removed from the publisher.\n         *\n         * @param trackType the track type to stop publishing.\n         * @param stopTrack if `true` the track will be stopped, else it will be just disabled\n         */ this.stopPublish = async (trackType, stopTrack = true)=>{\n            this.logger(\"info\", `stopPublish ${TrackType[trackType]}, stop tracks: ${stopTrack}`);\n            await this.publisher?.unpublishStream(trackType, stopTrack);\n        };\n        /**\n         * Update track subscription configuration for one or more participants.\n         * You have to create a subscription for each participant for all the different kinds of tracks you want to receive.\n         * You can only subscribe for tracks after the participant started publishing the given kind of track.\n         *\n         * @param trackType the kind of subscription to update.\n         * @param changes the list of subscription changes to do.\n         * @param type the debounce type to use for the update.\n         */ this.updateSubscriptionsPartial = (trackType, changes, type = DebounceType.SLOW)=>{\n            if (trackType === \"video\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'videoTrack'`);\n                trackType = \"videoTrack\";\n            } else if (trackType === \"screen\") {\n                this.logger(\"warn\", `updateSubscriptionsPartial: ${trackType} is deprecated. Please switch to 'screenShareTrack'`);\n                trackType = \"screenShareTrack\";\n            }\n            const participants = this.state.updateParticipants(Object.entries(changes).reduce((acc, [sessionId, change])=>{\n                if (change.dimension?.height) {\n                    change.dimension.height = Math.ceil(change.dimension.height);\n                }\n                if (change.dimension?.width) {\n                    change.dimension.width = Math.ceil(change.dimension.width);\n                }\n                const prop = trackType === \"videoTrack\" ? \"videoDimension\" : trackType === \"screenShareTrack\" ? \"screenShareDimension\" : undefined;\n                if (prop) {\n                    acc[sessionId] = {\n                        [prop]: change.dimension\n                    };\n                }\n                return acc;\n            }, {}));\n            if (participants) {\n                this.updateSubscriptions(participants, type);\n            }\n        };\n        this.updateSubscriptions = (participants, type = DebounceType.SLOW)=>{\n            const subscriptions = [];\n            for (const p of participants){\n                // we don't want to subscribe to our own tracks\n                if (p.isLocalParticipant) continue;\n                // NOTE: audio tracks don't have to be requested explicitly\n                // as the SFU will implicitly subscribe us to all of them,\n                // once they become available.\n                if (p.videoDimension && p.publishedTracks.includes(TrackType.VIDEO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.VIDEO,\n                        dimension: p.videoDimension\n                    });\n                }\n                if (p.screenShareDimension && p.publishedTracks.includes(TrackType.SCREEN_SHARE)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE,\n                        dimension: p.screenShareDimension\n                    });\n                }\n                if (p.publishedTracks.includes(TrackType.SCREEN_SHARE_AUDIO)) {\n                    subscriptions.push({\n                        userId: p.userId,\n                        sessionId: p.sessionId,\n                        trackType: TrackType.SCREEN_SHARE_AUDIO\n                    });\n                }\n            }\n            // schedule update\n            this.trackSubscriptionsSubject.next({\n                type,\n                data: subscriptions\n            });\n        };\n        /**\n         * Will enhance the reported stats with additional participant-specific information (`callStatsReport$` state [store variable](./StreamVideoClient.md/#readonlystatestore)).\n         * This is usually helpful when detailed stats for a specific participant are needed.\n         *\n         * @param sessionId the sessionId to start reporting for.\n         */ this.startReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.startReportingStatsFor(sessionId);\n        };\n        /**\n         * Opposite of `startReportingStatsFor`.\n         * Will turn off stats reporting for a specific participant.\n         *\n         * @param sessionId the sessionId to stop reporting for.\n         */ this.stopReportingStatsFor = (sessionId)=>{\n            return this.statsReporter?.stopReportingStatsFor(sessionId);\n        };\n        /**\n         * Resets the last sent reaction for the user holding the given `sessionId`. This is a local action, it won't reset the reaction on the backend.\n         *\n         * @param sessionId the session id.\n         */ this.resetReaction = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                reaction: undefined\n            });\n        };\n        /**\n         * Sets the list of criteria to sort the participants by.\n         *\n         * @param criteria the list of criteria to sort the participants by.\n         */ this.setSortParticipantsBy = (criteria)=>{\n            return this.state.setSortParticipantsBy(criteria);\n        };\n        /**\n         * Updates the list of video layers to publish.\n         *\n         * @internal\n         * @param enabledLayers the list of layers to enable.\n         */ this.updatePublishQuality = async (enabledLayers)=>{\n            return this.publisher?.updateVideoPublishQuality(enabledLayers);\n        };\n        this.assertCallJoined = ()=>{\n            return new Promise((resolve)=>{\n                this.state.callingState$.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_23__.takeWhile)((state)=>state !== CallingState.JOINED, true), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_32__.filter)((s)=>s === CallingState.JOINED)).subscribe(()=>resolve());\n            });\n        };\n        /**\n         * Sends a reaction to the other call participants.\n         *\n         * @param reaction the reaction to send.\n         */ this.sendReaction = async (reaction)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/reaction`, reaction);\n        };\n        /**\n         * Blocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to block.\n         */ this.blockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/block`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Unblocks the user with the given `userId`.\n         *\n         * @param userId the id of the user to unblock.\n         */ this.unblockUser = async (userId)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unblock`, {\n                user_id: userId\n            });\n        };\n        /**\n         * Mutes the current user.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteSelf = (type)=>{\n            const myUserId = this.currentUserId;\n            if (myUserId) {\n                return this.muteUser(myUserId, type);\n            }\n        };\n        /**\n         * Mutes all the other participants.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteOthers = (type)=>{\n            const trackType = muteTypeToTrackType(type);\n            if (!trackType) return;\n            const userIdsToMute = [];\n            for (const participant of this.state.remoteParticipants){\n                if (participant.publishedTracks.includes(trackType)) {\n                    userIdsToMute.push(participant.userId);\n                }\n            }\n            return this.muteUser(userIdsToMute, type);\n        };\n        /**\n         * Mutes the user with the given `userId`.\n         *\n         * @param userId the id of the user to mute.\n         * @param type the type of the mute operation.\n         */ this.muteUser = (userId, type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                user_ids: Array.isArray(userId) ? userId : [\n                    userId\n                ],\n                [type]: true\n            });\n        };\n        /**\n         * Will mute all users in the call.\n         *\n         * @param type the type of the mute operation.\n         */ this.muteAllUsers = (type)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {\n                mute_all_users: true,\n                [type]: true\n            });\n        };\n        /**\n         * Starts recording the call\n         */ this.startRecording = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_recording`, request ? request : {});\n        };\n        /**\n         * Stops recording the call\n         */ this.stopRecording = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_recording`, {});\n        };\n        /**\n         * Sends a `call.permission_request` event to all users connected to the call. The call settings object contains infomration about which permissions can be requested during a call (for example a user might be allowed to request permission to publish audio, but not video).\n         */ this.requestPermissions = async (data)=>{\n            const { permissions } = data;\n            const canRequestPermissions = permissions.every((permission)=>this.permissionsContext.canRequest(permission));\n            if (!canRequestPermissions) {\n                throw new Error(`You are not allowed to request permissions: ${permissions.join(\", \")}`);\n            }\n            return this.streamClient.post(`${this.streamClientBasePath}/request_permission`, data);\n        };\n        /**\n         * Allows you to grant certain permissions to a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be granted are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to grant permissions to.\n         * @param permissions the permissions to grant.\n         */ this.grantPermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                grant_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to revoke certain permissions from a user in a call.\n         * The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * Supported permissions that can be revoked are:\n         * - `send-audio`\n         * - `send-video`\n         * - `screenshare`\n         *\n         * @param userId the id of the user to revoke permissions from.\n         * @param permissions the permissions to revoke.\n         */ this.revokePermissions = async (userId, permissions)=>{\n            return this.updateUserPermissions({\n                user_id: userId,\n                revoke_permissions: permissions\n            });\n        };\n        /**\n         * Allows you to grant or revoke a specific permission to a user in a call. The permissions are specific to the call experience and do not survive the call itself.\n         *\n         * When revoking a permission, this endpoint will also mute the relevant track from the user. This is similar to muting a user with the difference that the user will not be able to unmute afterwards.\n         *\n         * Supported permissions that can be granted or revoked: `send-audio`, `send-video` and `screenshare`.\n         *\n         * `call.permissions_updated` event is sent to all members of the call.\n         *\n         */ this.updateUserPermissions = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/user_permissions`, data);\n        };\n        /**\n         * Starts the livestreaming of the call.\n         *\n         * @param data the request data.\n         * @param params the request params.\n         */ this.goLive = async (data = {}, params)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/go_live`, data, params);\n        };\n        /**\n         * Stops the livestreaming of the call.\n         */ this.stopLive = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_live`, {});\n        };\n        /**\n         * Starts the broadcasting of the call.\n         */ this.startHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/start_broadcasting`, {});\n        };\n        /**\n         * Stops the broadcasting of the call.\n         */ this.stopHLS = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/stop_broadcasting`, {});\n        };\n        /**\n         * Updates the call settings or custom data.\n         *\n         * @param updates the updates to apply to the call.\n         */ this.update = async (updates)=>{\n            const response = await this.streamClient.patch(`${this.streamClientBasePath}`, updates);\n            const { call, members, own_capabilities } = response;\n            this.state.updateFromCallResponse(call);\n            this.state.setMembers(members);\n            this.state.setOwnCapabilities(own_capabilities);\n            return response;\n        };\n        /**\n         * Ends the call. Once the call is ended, it cannot be re-joined.\n         */ this.endCall = async ()=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/mark_ended`);\n        };\n        /**\n         * Pins the given session to the top of the participants list.\n         *\n         * @param sessionId the sessionId to pin.\n         */ this.pin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: {\n                    isLocalPin: true,\n                    pinnedAt: Date.now()\n                }\n            });\n        };\n        /**\n         * Unpins the given session from the top of the participants list.\n         *\n         * @param sessionId the sessionId to unpin.\n         */ this.unpin = (sessionId)=>{\n            this.state.updateParticipant(sessionId, {\n                pin: undefined\n            });\n        };\n        /**\n         * Pins the given session to the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.pinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/pin`, request);\n        };\n        /**\n         * Unpins the given session from the top of the participants list for everyone\n         * in the call.\n         * You can execute this method only if you have the `pin-for-everyone` capability.\n         *\n         * @param request the request object.\n         */ this.unpinForEveryone = async (request)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/unpin`, request);\n        };\n        /**\n         * Query call members with filter query. The result won't be stored in call state.\n         * @param request\n         * @returns\n         */ this.queryMembers = (request)=>{\n            return this.streamClient.post(\"/call/members\", {\n                ...request || {},\n                id: this.id,\n                type: this.type\n            });\n        };\n        /**\n         * Will update the call members.\n         *\n         * @param data the request data.\n         */ this.updateCallMembers = async (data)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/members`, data);\n        };\n        /**\n         * Schedules an auto-drop timeout based on the call settings.\n         * Applicable only for ringing calls.\n         */ this.scheduleAutoDrop = ()=>{\n            clearTimeout(this.dropTimeout);\n            this.leaveCallHooks.add(createSubscription(this.state.settings$, (settings)=>{\n                if (!settings) return;\n                // ignore if the call is not ringing\n                if (this.state.callingState !== CallingState.RINGING) return;\n                const timeoutInMs = settings.ring.auto_cancel_timeout_ms;\n                // 0 means no auto-drop\n                if (timeoutInMs <= 0) return;\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = setTimeout(()=>{\n                    this.leave().catch((err)=>{\n                        this.logger(\"error\", \"Failed to drop call\", err);\n                    });\n                }, timeoutInMs);\n            }));\n        };\n        /**\n         * Retrieves the list of recordings for the current call or call session.\n         *\n         * If `callSessionId` is provided, it will return the recordings for that call session.\n         * Otherwise, all recordings for the current call will be returned.\n         *\n         * @param callSessionId the call session id to retrieve recordings for.\n         */ this.queryRecordings = async (callSessionId)=>{\n            let endpoint = this.streamClientBasePath;\n            if (callSessionId) {\n                endpoint = `${endpoint}/${callSessionId}`;\n            }\n            return this.streamClient.get(`${endpoint}/recordings`);\n        };\n        /**\n         * Sends a custom event to all call participants.\n         *\n         * @param payload the payload to send.\n         */ this.sendCustomEvent = async (payload)=>{\n            return this.streamClient.post(`${this.streamClientBasePath}/event`, {\n                custom: payload\n            });\n        };\n        this.applyDeviceConfig = ()=>{\n            this.initCamera({\n                setStatus: false\n            });\n            this.initMic({\n                setStatus: false\n            });\n        };\n        /**\n         * Will begin tracking the given element for visibility changes within the\n         * configured viewport element (`call.setViewport`).\n         *\n         * @param element the element to track.\n         * @param sessionId the session id.\n         * @param trackType the video mode.\n         */ this.trackElementVisibility = (element, sessionId, trackType)=>{\n            return this.dynascaleManager.trackElementVisibility(element, sessionId, trackType);\n        };\n        /**\n         * Sets the viewport element to track bound video elements for visibility.\n         *\n         * @param element the viewport element.\n         */ this.setViewport = (element)=>{\n            return this.dynascaleManager.setViewport(element);\n        };\n        /**\n         * Binds a DOM <video> element to the given session id.\n         * This method will make sure that the video element will play\n         * the correct video stream for the given session id.\n         *\n         * Under the hood, it would also keep track of the video element dimensions\n         * and update the subscription accordingly in order to optimize the bandwidth.\n         *\n         * If a \"viewport\" is configured, the video element will be automatically\n         * tracked for visibility and the subscription will be updated accordingly.\n         *\n         * @param videoElement the video element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of video.\n         */ this.bindVideoElement = (videoElement, sessionId, trackType)=>{\n            const unbind = this.dynascaleManager.bindVideoElement(videoElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <audio> element to the given session id.\n         *\n         * This method will make sure that the audio element will\n         * play the correct audio stream for the given session id.\n         *\n         * @param audioElement the audio element to bind to.\n         * @param sessionId the session id.\n         * @param trackType the kind of audio.\n         */ this.bindAudioElement = (audioElement, sessionId, trackType = \"audioTrack\")=>{\n            const unbind = this.dynascaleManager.bindAudioElement(audioElement, sessionId, trackType);\n            if (!unbind) return;\n            this.leaveCallHooks.add(unbind);\n            return ()=>{\n                this.leaveCallHooks.delete(unbind);\n                unbind();\n            };\n        };\n        /**\n         * Binds a DOM <img> element to this call's thumbnail (if enabled in settings).\n         *\n         * @param imageElement the image element to bind to.\n         * @param opts options for the binding.\n         */ this.bindCallThumbnailElement = (imageElement, opts = {})=>{\n            const handleError = ()=>{\n                imageElement.src = opts.fallbackImageSource || \"https://getstream.io/random_svg/?name=x&id=x\";\n            };\n            const unsubscribe = createSubscription(this.state.thumbnails$, (thumbnails)=>{\n                if (!thumbnails) return;\n                imageElement.addEventListener(\"error\", handleError);\n                const thumbnailUrl = new URL(thumbnails.image_url);\n                thumbnailUrl.searchParams.set(\"w\", String(imageElement.clientWidth));\n                thumbnailUrl.searchParams.set(\"h\", String(imageElement.clientHeight));\n                imageElement.src = thumbnailUrl.toString();\n            });\n            return ()=>{\n                unsubscribe();\n                imageElement.removeEventListener(\"error\", handleError);\n            };\n        };\n        this.type = type;\n        this.id = id;\n        this.cid = `${type}:${id}`;\n        this.ringingSubject = new _barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.BehaviorSubject(ringing);\n        this.watching = watching;\n        this.streamClient = streamClient;\n        this.clientStore = clientStore;\n        this.streamClientBasePath = `/call/${this.type}/${this.id}`;\n        this.logger = getLogger([\n            \"Call\"\n        ]);\n        const callTypeConfig = CallTypes.get(type);\n        const participantSorter = sortParticipantsBy || callTypeConfig.options.sortParticipantsBy;\n        if (participantSorter) {\n            this.state.setSortParticipantsBy(participantSorter);\n        }\n        this.state.setMembers(members || []);\n        this.state.setOwnCapabilities(ownCapabilities || []);\n        this.state.setCallingState(ringing ? CallingState.RINGING : CallingState.IDLE);\n        this.on(\"all\", (event)=>{\n            // update state with the latest event data\n            this.state.updateFromEvent(event);\n        });\n        this.leaveCallHooks.add(registerEventHandlers(this, this.state, this.dispatcher));\n        this.registerEffects();\n        this.leaveCallHooks.add(createSubscription(this.trackSubscriptionsSubject.pipe((0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_33__.debounce)((v)=>(0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_34__.timer)(v.type)), (0,_barrel_optimize_names_BehaviorSubject_Observable_ReplaySubject_combineLatest_concatMap_debounce_debounceTime_distinctUntilChanged_distinctUntilKeyChanged_filter_from_map_merge_of_pairwise_shareReplay_takeWhile_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.map)((v)=>v.data)), (subscriptions)=>this.sfuClient?.updateSubscriptions(subscriptions)));\n        this.camera = new CameraManager(this);\n        this.microphone = new MicrophoneManager(this);\n        this.speaker = new SpeakerManager();\n        this.screenShare = new ScreenShareManager(this);\n    }\n    registerEffects() {\n        this.leaveCallHooks.add(// handles updating the permissions context when the settings change.\n        createSubscription(this.state.settings$, (settings)=>{\n            if (!settings) return;\n            this.permissionsContext.setCallSettings(settings);\n        }));\n        this.leaveCallHooks.add(// handle the case when the user permissions are modified.\n        createSubscription(this.state.ownCapabilities$, (ownCapabilities)=>{\n            // update the permission context.\n            this.permissionsContext.setPermissions(ownCapabilities);\n            if (!this.publisher) return;\n            // check if the user still has publishing permissions and stop publishing if not.\n            const permissionToTrackType = {\n                [OwnCapability.SEND_AUDIO]: TrackType.AUDIO,\n                [OwnCapability.SEND_VIDEO]: TrackType.VIDEO,\n                [OwnCapability.SCREENSHARE]: TrackType.SCREEN_SHARE\n            };\n            for (const [permission, trackType] of Object.entries(permissionToTrackType)){\n                const hasPermission = this.permissionsContext.hasPermission(permission);\n                if (!hasPermission && (this.publisher.isPublishing(trackType) || this.publisher.isLive(trackType))) {\n                    // Stop tracks, then notify device manager\n                    this.stopPublish(trackType).catch((err)=>{\n                        this.logger(\"error\", `Error stopping publish ${trackType}`, err);\n                    }).then(()=>{\n                        if (trackType === TrackType.VIDEO && this.camera.state.status === \"enabled\") {\n                            this.camera.disable().catch((err)=>this.logger(\"error\", `Error disabling camera after permission revoked`, err));\n                        }\n                        if (trackType === TrackType.AUDIO && this.microphone.state.status === \"enabled\") {\n                            this.microphone.disable().catch((err)=>this.logger(\"error\", `Error disabling microphone after permission revoked`, err));\n                        }\n                    });\n                }\n            }\n        }));\n        this.leaveCallHooks.add(// handles the case when the user is blocked by the call owner.\n        createSubscription(this.state.blockedUserIds$, async (blockedUserIds)=>{\n            if (!blockedUserIds || blockedUserIds.length === 0) return;\n            const currentUserId = this.currentUserId;\n            if (currentUserId && blockedUserIds.includes(currentUserId)) {\n                this.logger(\"info\", \"Leaving call because of being blocked\");\n                await this.leave();\n            }\n        }));\n        this.leaveCallHooks.add(// watch for auto drop cancellation\n        createSubscription(this.state.callingState$, (callingState)=>{\n            if (!this.ringing) return;\n            if (callingState === CallingState.JOINED || callingState === CallingState.JOINING || callingState === CallingState.LEFT) {\n                clearTimeout(this.dropTimeout);\n                this.dropTimeout = undefined;\n            }\n        }));\n        this.leaveCallHooks.add(// \"ringing\" mode effects and event handlers\n        createSubscription(this.ringingSubject, (isRinging)=>{\n            if (!isRinging) return;\n            this.scheduleAutoDrop();\n            if (this.state.callingState === CallingState.IDLE) {\n                this.state.setCallingState(CallingState.RINGING);\n            }\n            this.leaveCallHooks.add(registerRingingCallEventHandlers(this));\n        }));\n    }\n    /**\n     * A flag indicating whether the call is \"ringing\" type of call.\n     */ get ringing() {\n        return getCurrentValue(this.ringingSubject);\n    }\n    /**\n     * Retrieves the current user ID.\n     */ get currentUserId() {\n        return this.clientStore.connectedUser?.id;\n    }\n    /**\n     * A flag indicating whether the call was created by the current user.\n     */ get isCreatedByMe() {\n        return this.state.createdBy?.id === this.currentUserId;\n    }\n    async initCamera(options) {\n        // Wait for any in progress camera operation\n        if (this.camera.enablePromise) {\n            await this.camera.enablePromise;\n        }\n        if (this.camera.disablePromise) {\n            await this.camera.disablePromise;\n        }\n        if (this.state.localParticipant?.videoStream || !this.permissionsContext.hasPermission(\"send-video\")) {\n            return;\n        }\n        // Set camera direction if it's not yet set\n        if (!this.camera.state.direction && !this.camera.state.selectedDevice) {\n            let defaultDirection = \"front\";\n            const backendSetting = this.state.settings?.video.camera_facing;\n            if (backendSetting) {\n                defaultDirection = backendSetting === \"front\" ? \"front\" : \"back\";\n            }\n            this.camera.state.setDirection(defaultDirection);\n        }\n        // Set target resolution\n        const targetResolution = this.state.settings?.video.target_resolution;\n        if (targetResolution) {\n            await this.camera.selectTargetResolution(targetResolution);\n        }\n        if (options.setStatus) {\n            // Publish already that was set before we joined\n            if (this.camera.state.status === \"enabled\" && this.camera.state.mediaStream && !this.publisher?.isPublishing(TrackType.VIDEO)) {\n                await this.publishVideoStream(this.camera.state.mediaStream, {\n                    preferredCodec: this.camera.preferredCodec\n                });\n            }\n            // Start camera if backend config specifies, and there is no local setting\n            if (this.camera.state.status === undefined && this.state.settings?.video.camera_default_on) {\n                await this.camera.enable();\n            }\n        }\n    }\n    async initMic(options) {\n        // Wait for any in progress mic operation\n        if (this.microphone.enablePromise) {\n            await this.microphone.enablePromise;\n        }\n        if (this.microphone.disablePromise) {\n            await this.microphone.disablePromise;\n        }\n        if (this.state.localParticipant?.audioStream || !this.permissionsContext.hasPermission(\"send-audio\")) {\n            return;\n        }\n        if (options.setStatus) {\n            // Publish media stream that was set before we joined\n            if (this.microphone.state.status === \"enabled\" && this.microphone.state.mediaStream && !this.publisher?.isPublishing(TrackType.AUDIO)) {\n                await this.publishAudioStream(this.microphone.state.mediaStream);\n            }\n            // Start mic if backend config specifies, and there is no local setting\n            if (this.microphone.state.status === undefined && this.state.settings?.audio.mic_default_on) {\n                await this.microphone.enable();\n            }\n        }\n    }\n}\nclass InsightMetrics {\n    constructor(){\n        this.connectionStartTimestamp = null;\n        this.wsTotalFailures = 0;\n        this.wsConsecutiveFailures = 0;\n        this.instanceClientId = randomId();\n    }\n}\n/**\n * postInsights is not supposed to be used by end users directly within chat application, and thus is kept isolated\n * from all the client/connection code/logic.\n *\n * @param insightType\n * @param insights\n */ const postInsights = async (insightType, insights)=>{\n    const maxAttempts = 3;\n    for(let i = 0; i < maxAttempts; i++){\n        try {\n            await axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].post(`https://chat-insights.getstream.io/insights/${insightType}`, insights);\n        } catch (e) {\n            await sleep((i + 1) * 3000);\n            continue;\n        }\n        break;\n    }\n};\nfunction buildWsFatalInsight(connection, event) {\n    return {\n        ...event,\n        ...buildWsBaseInsight(connection)\n    };\n}\nfunction buildWsBaseInsight(connection) {\n    const { client } = connection;\n    return {\n        ready_state: connection.ws?.readyState,\n        url: connection._buildUrl(),\n        api_key: client.key,\n        start_ts: client.insightMetrics.connectionStartTimestamp,\n        end_ts: new Date().getTime(),\n        auth_type: client.getAuthType(),\n        token: client.tokenManager.token,\n        user_id: client.userID,\n        user_details: client._user,\n        // device: client.options.device,\n        device: \"browser\",\n        client_id: connection.connectionID,\n        ws_details: connection.ws,\n        ws_consecutive_failures: client.insightMetrics.wsConsecutiveFailures,\n        ws_total_failures: client.insightMetrics.wsTotalFailures,\n        request_id: connection.requestID,\n        online: typeof navigator !== \"undefined\" ? navigator?.onLine : null,\n        user_agent: typeof navigator !== \"undefined\" ? navigator?.userAgent : null,\n        instance_client_id: client.insightMetrics.instanceClientId\n    };\n}\nfunction buildWsSuccessAfterFailureInsight(connection) {\n    return buildWsBaseInsight(connection);\n}\n// Type guards to check WebSocket error type\nconst isCloseEvent = (res)=>res.code !== undefined;\nconst isErrorEvent = (res)=>res.error !== undefined;\n/**\n * StableWSConnection - A WS connection that reconnects upon failure.\n * - the browser will sometimes report that you're online or offline\n * - the WS connection can break and fail (there is a 30s health check)\n * - sometimes your WS connection will seem to work while the user is in fact offline\n * - to speed up online/offline detection you can use the window.addEventListener('offline');\n *\n * There are 4 ways in which a connection can become unhealthy:\n * - websocket.onerror is called\n * - websocket.onclose is called\n * - the health check fails and no event is received for ~40 seconds\n * - the browser indicates the connection is now offline\n *\n * There are 2 assumptions we make about the server:\n * - state can be recovered by querying the channel again\n * - if the servers fails to publish a message to the client, the WS connection is destroyed\n */ class StableWSConnection {\n    constructor(client){\n        this._log = (msg, extra = {}, level = \"info\")=>{\n            this.client.logger(level, \"connection:\" + msg, {\n                ...extra\n            });\n        };\n        this.setClient = (client)=>{\n            this.client = client;\n        };\n        /**\n         * Builds and returns the url for websocket.\n         * @private\n         * @returns url string\n         */ this._buildUrl = ()=>{\n            const params = new URLSearchParams();\n            // const qs = encodeURIComponent(this.client._buildWSPayload(this.requestID));\n            // params.set('json', qs);\n            params.set(\"api_key\", this.client.key);\n            params.set(\"stream-auth-type\", this.client.getAuthType());\n            params.set(\"X-Stream-Client\", this.client.getUserAgent());\n            // params.append('authorization', this.client._getToken()!);\n            return `${this.client.wsBaseURL}/connect?${params.toString()}`;\n        };\n        /**\n         * onlineStatusChanged - this function is called when the browser connects or disconnects from the internet.\n         *\n         * @param {Event} event Event with type online or offline\n         *\n         */ this.onlineStatusChanged = (event)=>{\n            if (event.type === \"offline\") {\n                // mark the connection as down\n                this._log(\"onlineStatusChanged() - Status changing to offline\");\n                // we know that the app is offline so dispatch the unhealthy connection event immediately\n                this._setHealth(false, true);\n            } else if (event.type === \"online\") {\n                // retry right now...\n                // We check this.isHealthy, not sure if it's always\n                // smart to create a new WS connection if the old one is still up and running.\n                // it's possible we didn't miss any messages, so this process is just expensive and not needed.\n                this._log(`onlineStatusChanged() - Status changing to online. isHealthy: ${this.isHealthy}`);\n                if (!this.isHealthy) {\n                    this._reconnect({\n                        interval: 10\n                    });\n                }\n            }\n        };\n        this.onopen = (wsID)=>{\n            if (this.wsID !== wsID) return;\n            const user = this.client.user;\n            if (!user) {\n                this.client.logger(\"error\", `User not set, can't connect to WS`);\n                return;\n            }\n            const token = this.client._getToken();\n            if (!token) {\n                this.client.logger(\"error\", `Token not set, can't connect authenticate`);\n                return;\n            }\n            const authMessage = {\n                token,\n                user_details: {\n                    id: user.id,\n                    name: user.name,\n                    image: user.image,\n                    custom: user.custom\n                }\n            };\n            this.authenticationSent = true;\n            this.ws?.send(JSON.stringify(authMessage));\n            this._log(\"onopen() - onopen callback\", {\n                wsID\n            });\n        };\n        this.onmessage = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onmessage() - onmessage callback\", {\n                event,\n                wsID\n            });\n            const data = typeof event.data === \"string\" ? JSON.parse(event.data) : null;\n            // we wait till the first message before we consider the connection open.\n            // the reason for this is that auth errors and similar errors trigger a ws.onopen and immediately\n            // after that a ws.onclose.\n            if (!this.isResolved && data && data.type === \"connection.error\") {\n                this.isResolved = true;\n                if (data.error) {\n                    // @ts-expect-error - the types of _errorFromWSEvent are incorrect\n                    this.rejectPromise?.(this._errorFromWSEvent(data, false));\n                    return;\n                }\n            }\n            // trigger the event..\n            this.lastEvent = new Date();\n            if (data && (data.type === \"health.check\" || data.type === \"connection.ok\")) {\n                // the initial health-check should come from the client\n                this.scheduleNextPing();\n            }\n            if (data && data.type === \"connection.ok\") {\n                this.resolvePromise?.(data);\n                this._setHealth(true);\n            }\n            if (data && data.type === \"connection.error\" && data.error) {\n                const { code } = data.error;\n                this.isHealthy = false;\n                this.isConnecting = false;\n                this.consecutiveFailures += 1;\n                if (code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                    clearTimeout(this.connectionCheckTimeoutRef);\n                    this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                    this._reconnect({\n                        refreshToken: true\n                    });\n                }\n            }\n            if (data) {\n                this.client.dispatchEvent(data);\n            }\n            this.scheduleConnectionCheck();\n        };\n        this.onclose = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this._log(\"onclose() - onclose callback - \" + event.code, {\n                event,\n                wsID\n            });\n            if (event.code === KnownCodes.WS_CLOSED_SUCCESS) {\n                // this is a permanent error raised by stream..\n                // usually caused by invalid auth details\n                const error = new Error(`WS connection reject with error ${event.reason}`);\n                error.reason = event.reason;\n                error.code = event.code;\n                error.wasClean = event.wasClean;\n                error.target = event.target;\n                this.rejectPromise?.(error);\n                this._log(`onclose() - WS connection reject with error ${event.reason}`, {\n                    event\n                });\n            } else {\n                this.consecutiveFailures += 1;\n                this.totalFailures += 1;\n                this._setHealth(false);\n                this.isConnecting = false;\n                this.rejectPromise?.(this._errorFromWSEvent(event));\n                this._log(`onclose() - WS connection closed. Calling reconnect ...`, {\n                    event\n                });\n                // reconnect if its an abnormal failure\n                this._reconnect();\n            }\n        };\n        this.onerror = (wsID, event)=>{\n            if (this.wsID !== wsID) return;\n            this.consecutiveFailures += 1;\n            this.totalFailures += 1;\n            this._setHealth(false);\n            this.isConnecting = false;\n            this.rejectPromise?.(this._errorFromWSEvent(event));\n            this._log(`onerror() - WS connection resulted into error`, {\n                event\n            });\n            this._reconnect();\n        };\n        /**\n         * _setHealth - Sets the connection to healthy or unhealthy.\n         * Broadcasts an event in case the connection status changed.\n         *\n         * @param {boolean} healthy boolean indicating if the connection is healthy or not\n         * @param {boolean} dispatchImmediately boolean indicating to dispatch event immediately even if the connection is unhealthy\n         *\n         */ this._setHealth = (healthy, dispatchImmediately = false)=>{\n            if (healthy === this.isHealthy) return;\n            this.isHealthy = healthy;\n            if (this.isHealthy || dispatchImmediately) {\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n                return;\n            }\n            // we're offline, wait few seconds and fire and event if still offline\n            setTimeout(()=>{\n                if (this.isHealthy) return;\n                this.client.dispatchEvent({\n                    type: \"connection.changed\",\n                    online: this.isHealthy\n                });\n            }, 5000);\n        };\n        /**\n         * _errorFromWSEvent - Creates an error object for the WS event\n         *\n         */ this._errorFromWSEvent = (event, isWSFailure = true)=>{\n            let code;\n            let statusCode;\n            let message;\n            if (isCloseEvent(event)) {\n                code = event.code;\n                statusCode = \"unknown\";\n                message = event.reason;\n            }\n            if (isErrorEvent(event)) {\n                code = event.error.code;\n                statusCode = event.error.StatusCode;\n                message = event.error.message;\n            }\n            // Keeping this `warn` level log, to avoid cluttering of error logs from ws failures.\n            this._log(`_errorFromWSEvent() - WS failed with code ${code}`, {\n                event\n            }, \"warn\");\n            const error = new Error(`WS failed with code ${code} and reason - ${message}`);\n            error.code = code;\n            /**\n             * StatusCode does not exist on any event types but has been left\n             * as is to preserve JS functionality during the TS implementation\n             */ error.StatusCode = statusCode;\n            error.isWSFailure = isWSFailure;\n            return error;\n        };\n        /**\n         * _setupPromise - sets up the this.connectOpen promise\n         */ this._setupConnectionPromise = ()=>{\n            this.isResolved = false;\n            /** a promise that is resolved once ws.open is called */ this.connectionOpen = new Promise((resolve, reject)=>{\n                this.resolvePromise = resolve;\n                this.rejectPromise = reject;\n            });\n        };\n        /**\n         * Schedules a next health check ping for websocket.\n         */ this.scheduleNextPing = ()=>{\n            if (this.healthCheckTimeoutRef) {\n                clearTimeout(this.healthCheckTimeoutRef);\n            }\n            // 30 seconds is the recommended interval (messenger uses this)\n            this.healthCheckTimeoutRef = setTimeout(()=>{\n                // send the healthcheck..., server replies with a health check event\n                const data = [\n                    {\n                        type: \"health.check\",\n                        client_id: this.client.clientID\n                    }\n                ];\n                // try to send on the connection\n                try {\n                    this.ws?.send(JSON.stringify(data));\n                } catch (e) {\n                // error will already be detected elsewhere\n                }\n            }, this.pingInterval);\n        };\n        /**\n         * scheduleConnectionCheck - schedules a check for time difference between last received event and now.\n         * If the difference is more than 35 seconds, it means our health check logic has failed and websocket needs\n         * to be reconnected.\n         */ this.scheduleConnectionCheck = ()=>{\n            if (this.connectionCheckTimeoutRef) {\n                clearTimeout(this.connectionCheckTimeoutRef);\n            }\n            this.connectionCheckTimeoutRef = setTimeout(()=>{\n                const now = new Date();\n                if (this.lastEvent && now.getTime() - this.lastEvent.getTime() > this.connectionCheckTimeout) {\n                    this._log(\"scheduleConnectionCheck - going to reconnect\");\n                    this._setHealth(false);\n                    this._reconnect();\n                }\n            }, this.connectionCheckTimeout);\n        };\n        this.client = client;\n        /** consecutive failures influence the duration of the timeout */ this.consecutiveFailures = 0;\n        /** keep track of the total number of failures */ this.totalFailures = 0;\n        /** We only make 1 attempt to reconnect at the same time.. */ this.isConnecting = false;\n        /** True after the auth payload is sent to the server */ this.authenticationSent = false;\n        /** To avoid reconnect if client is disconnected */ this.isDisconnected = false;\n        /** Boolean that indicates if the connection promise is resolved */ this.isResolved = false;\n        /** Boolean that indicates if we have a working connection to the server */ this.isHealthy = false;\n        /** Incremented when a new WS connection is made */ this.wsID = 1;\n        /** Store the last event time for health checks */ this.lastEvent = null;\n        /** Send a health check message every 25 seconds */ this.pingInterval = 25 * 1000;\n        this.connectionCheckTimeout = this.pingInterval + 10 * 1000;\n        addConnectionEventListeners(this.onlineStatusChanged);\n    }\n    /**\n     * connect - Connect to the WS URL\n     * the default 15s timeout allows between 2~3 tries\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async connect(timeout = 15000) {\n        if (this.isConnecting) {\n            throw Error(`You've called connect twice, can only attempt 1 connection at the time`);\n        }\n        this.isDisconnected = false;\n        try {\n            const healthCheck = await this._connect();\n            this.consecutiveFailures = 0;\n            this._log(`connect() - Established ws connection with healthcheck: ${healthCheck}`);\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (// @ts-ignore\n            error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"connect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                this._reconnect({\n                    refreshToken: true\n                });\n            } else {\n                // @ts-ignore\n                if (!error.isWSFailure) {\n                    // API rejected the connection and we should not retry\n                    throw new Error(JSON.stringify({\n                        // @ts-ignore\n                        code: error.code,\n                        // @ts-ignore\n                        StatusCode: error.StatusCode,\n                        // @ts-ignore\n                        message: error.message,\n                        // @ts-ignore\n                        isWSFailure: error.isWSFailure\n                    }));\n                }\n            }\n        }\n        return await this._waitForHealthy(timeout);\n    }\n    /**\n     * _waitForHealthy polls the promise connection to see if its resolved until it times out\n     * the default 15s timeout allows between 2~3 tries\n     * @param timeout duration(ms)\n     */ async _waitForHealthy(timeout = 15000) {\n        return Promise.race([\n            (async ()=>{\n                const interval = 50; // ms\n                for(let i = 0; i <= timeout; i += interval){\n                    try {\n                        return await this.connectionOpen;\n                    } catch (error) {\n                        if (i === timeout) {\n                            throw new Error(JSON.stringify({\n                                code: error.code,\n                                StatusCode: error.StatusCode,\n                                message: error.message,\n                                isWSFailure: error.isWSFailure\n                            }));\n                        }\n                        await sleep(interval);\n                    }\n                }\n            })(),\n            (async ()=>{\n                await sleep(timeout);\n                this.isConnecting = false;\n                throw new Error(JSON.stringify({\n                    code: \"\",\n                    StatusCode: \"\",\n                    message: \"initial WS connection could not be established\",\n                    isWSFailure: true\n                }));\n            })()\n        ]);\n    }\n    /**\n     * disconnect - Disconnect the connection and doesn't recover...\n     *\n     */ disconnect(timeout) {\n        this._log(`disconnect() - Closing the websocket connection for wsID ${this.wsID}`);\n        this.wsID += 1;\n        this.isConnecting = false;\n        this.isDisconnected = true;\n        // start by removing all the listeners\n        if (this.healthCheckTimeoutRef) {\n            clearInterval(this.healthCheckTimeoutRef);\n        }\n        if (this.connectionCheckTimeoutRef) {\n            clearInterval(this.connectionCheckTimeoutRef);\n        }\n        removeConnectionEventListeners(this.onlineStatusChanged);\n        this.isHealthy = false;\n        // remove ws handlers...\n        if (this.ws && this.ws.removeAllListeners) {\n            this.ws.removeAllListeners();\n        }\n        let isClosedPromise;\n        // and finally close...\n        // Assigning to local here because we will remove it from this before the\n        // promise resolves.\n        const { ws } = this;\n        if (ws && ws.close && ws.readyState === ws.OPEN) {\n            isClosedPromise = new Promise((resolve)=>{\n                const onclose = (event)=>{\n                    this._log(`disconnect() - resolving isClosedPromise ${event ? \"with\" : \"without\"} close frame`, {\n                        event\n                    });\n                    resolve();\n                };\n                ws.onclose = onclose;\n                // In case we don't receive close frame websocket server in time,\n                // lets not wait for more than 1 second.\n                setTimeout(onclose, timeout != null ? timeout : 1000);\n            });\n            this._log(`disconnect() - Manually closed connection by calling client.disconnect()`);\n            ws.close(KnownCodes.WS_CLOSED_SUCCESS, \"Manually closed connection by calling client.disconnect()\");\n        } else {\n            this._log(`disconnect() - ws connection doesn't exist or it is already closed.`);\n            isClosedPromise = Promise.resolve();\n        }\n        delete this.ws;\n        return isClosedPromise;\n    }\n    /**\n     * _connect - Connect to the WS endpoint\n     *\n     * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received\n     */ async _connect() {\n        if (this.isConnecting || this.isDisconnected && this.client.options.enableWSFallback) return; // simply ignore _connect if it's currently trying to connect\n        this.isConnecting = true;\n        this.requestID = randomId();\n        this.client.insightMetrics.connectionStartTimestamp = new Date().getTime();\n        let isTokenReady = false;\n        try {\n            this._log(`_connect() - waiting for token`);\n            await this.client.tokenManager.tokenReady();\n            isTokenReady = true;\n        } catch (e) {\n        // token provider has failed before, so try again\n        }\n        try {\n            if (!isTokenReady) {\n                this._log(`_connect() - tokenProvider failed before, so going to retry`);\n                await this.client.tokenManager.loadToken();\n            }\n            this._setupConnectionPromise();\n            const wsURL = this._buildUrl();\n            this._log(`_connect() - Connecting to ${wsURL}`, {\n                wsURL,\n                requestID: this.requestID\n            });\n            this.ws = new (isomorphic_ws__WEBPACK_IMPORTED_MODULE_4___default())(wsURL);\n            this.ws.onopen = this.onopen.bind(this, this.wsID);\n            this.ws.onclose = this.onclose.bind(this, this.wsID);\n            this.ws.onerror = this.onerror.bind(this, this.wsID);\n            this.ws.onmessage = this.onmessage.bind(this, this.wsID);\n            const response = await this.connectionOpen;\n            this.isConnecting = false;\n            if (response) {\n                this.connectionID = response.connection_id;\n                this.client.resolveConnectionId?.(this.connectionID);\n                if (this.client.insightMetrics.wsConsecutiveFailures > 0 && this.client.options.enableInsights) {\n                    postInsights(\"ws_success_after_failure\", buildWsSuccessAfterFailureInsight(this));\n                    this.client.insightMetrics.wsConsecutiveFailures = 0;\n                }\n                return response;\n            }\n        } catch (err) {\n            this.isConnecting = false;\n            // @ts-ignore\n            this._log(`_connect() - Error - `, err);\n            if (this.client.options.enableInsights) {\n                this.client.insightMetrics.wsConsecutiveFailures++;\n                this.client.insightMetrics.wsTotalFailures++;\n                const insights = buildWsFatalInsight(this, convertErrorToJson(err));\n                postInsights?.(\"ws_fatal\", insights);\n            }\n            this.client.rejectConnectionId?.();\n            throw err;\n        }\n    }\n    /**\n     * _reconnect - Retry the connection to WS endpoint\n     *\n     * @param {{ interval?: number; refreshToken?: boolean }} options Following options are available\n     *\n     * - `interval`\t{int}\t\t\tnumber of ms that function should wait before reconnecting\n     * - `refreshToken` {boolean}\treload/refresh user token be refreshed before attempting reconnection.\n     */ async _reconnect(options = {}) {\n        this._log(\"_reconnect() - Initiating the reconnect\");\n        // only allow 1 connection at the time\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (1) since already connecting or healthy\");\n            return;\n        }\n        // reconnect in case of on error or on close\n        // also reconnect if the health check cycle fails\n        let interval = options.interval;\n        if (!interval) {\n            interval = retryInterval(this.consecutiveFailures);\n        }\n        // reconnect, or try again after a little while...\n        await sleep(interval);\n        // Check once again if by some other call to _reconnect is active or connection is\n        // already restored, then no need to proceed.\n        if (this.isConnecting || this.isHealthy) {\n            this._log(\"_reconnect() - Abort (2) since already connecting or healthy\");\n            return;\n        }\n        if (this.isDisconnected && this.client.options.enableWSFallback) {\n            this._log(\"_reconnect() - Abort (3) since disconnect() is called\");\n            return;\n        }\n        this._log(\"_reconnect() - Destroying current WS connection\");\n        // cleanup the old connection\n        this._destroyCurrentWSConnection();\n        if (options.refreshToken) {\n            await this.client.tokenManager.loadToken();\n        }\n        try {\n            await this._connect();\n            this._log(\"_reconnect() - Waiting for recoverCallBack\");\n            // await this.client.recoverState();\n            this._log(\"_reconnect() - Finished recoverCallBack\");\n            this.consecutiveFailures = 0;\n        } catch (error) {\n            this.isHealthy = false;\n            this.consecutiveFailures += 1;\n            if (error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {\n                this._log(\"_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect\");\n                return this._reconnect({\n                    refreshToken: true\n                });\n            }\n            // reconnect on WS failures, don't reconnect if there is a code bug\n            if (error.isWSFailure) {\n                this._log(\"_reconnect() - WS failure, so going to try to reconnect\");\n                this._reconnect();\n            }\n        }\n        this._log(\"_reconnect() - == END ==\");\n    }\n    /**\n     * _destroyCurrentWSConnection - Removes the current WS connection\n     *\n     */ _destroyCurrentWSConnection() {\n        // increment the ID, meaning we will ignore all messages from the old\n        // ws connection from now on.\n        this.wsID += 1;\n        try {\n            this?.ws?.removeAllListeners();\n            this?.ws?.close();\n        } catch (e) {\n        // we don't care\n        }\n    }\n}\nfunction isString(arrayOrString) {\n    return typeof arrayOrString === \"string\";\n}\nfunction isMapStringCallback(arrayOrString, callback) {\n    return !!callback && isString(arrayOrString);\n}\nfunction map(arrayOrString, callback) {\n    const res = [];\n    if (isString(arrayOrString) && isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (arrayOrString.charAt(k)) {\n                const kValue = arrayOrString.charAt(k);\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    } else if (!isString(arrayOrString) && !isMapStringCallback(arrayOrString, callback)) {\n        for(let k = 0, len = arrayOrString.length; k < len; k++){\n            if (k in arrayOrString) {\n                const kValue = arrayOrString[k];\n                const mappedValue = callback(kValue, k, arrayOrString);\n                res[k] = mappedValue;\n            }\n        }\n    }\n    return res;\n}\nconst encodeBase64 = (data)=>(0,base64_js__WEBPACK_IMPORTED_MODULE_8__.fromByteArray)(new Uint8Array(map(data, (char)=>char.charCodeAt(0))));\n// base-64 decoder throws exception if encoded string is not padded by '=' to make string length\n// in multiples of 4. So gonna use our own method for this purpose to keep backwards compatibility\n// https://github.com/beatgammit/base64-js/blob/master/index.js#L26\nconst decodeBase64 = (s)=>{\n    const e = {}, w = String.fromCharCode, L = s.length;\n    let i, b = 0, c, x, l = 0, a, r = \"\";\n    const A = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(i = 0; i < 64; i++){\n        e[A.charAt(i)] = i;\n    }\n    for(x = 0; x < L; x++){\n        c = e[s.charAt(x)];\n        b = (b << 6) + c;\n        l += 6;\n        while(l >= 8){\n            ((a = b >>> (l -= 8) & 0xff) || x < L - 2) && (r += w(a));\n        }\n    }\n    return r;\n};\n/**\n * Creates the JWT token that can be used for a UserSession\n * @method JWTUserToken\n * @memberof signing\n * @private\n * @param {Secret} apiSecret - API Secret key\n * @param {string} userId - The user_id key in the JWT payload\n * @param {UR} [extraData] - Extra that should be part of the JWT token\n * @param {SignOptions} [jwtOptions] - Options that can be past to jwt.sign\n * @return {string} JWT Token\n */ function JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== \"string\") {\n        throw new TypeError(\"userId should be a string\");\n    }\n    const payload = {\n        user_id: userId,\n        ...extraData\n    };\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({\n        algorithm: \"HS256\",\n        noTimestamp: true\n    }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true\n    };\n    const opts = Object.assign({\n        algorithm: \"HS256\",\n        noTimestamp: true\n    }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_6___default().sign(payload, apiSecret, opts);\n}\nfunction UserFromToken(token) {\n    const fragments = token.split(\".\");\n    if (fragments.length !== 3) {\n        return \"\";\n    }\n    const b64Payload = fragments[1];\n    const payload = decodeBase64(b64Payload);\n    const data = JSON.parse(payload);\n    return data.user_id;\n}\n/**\n *\n * @param {string} userId the id of the user\n * @return {string}\n */ function DevToken(userId) {\n    return [\n        \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n        encodeBase64(JSON.stringify({\n            user_id: userId\n        })),\n        \"devtoken\"\n    ].join(\".\");\n}\n/**\n * TokenManager\n *\n * Handles all the operations around user token.\n */ class TokenManager {\n    /**\n     * Constructor\n     *\n     * @param {Secret} secret\n     */ constructor(secret){\n        /**\n         * Set the static string token or token provider.\n         * Token provider should return a token string or a promise which resolves to string token.\n         *\n         * @param {TokenOrProvider} tokenOrProvider - the token or token provider.\n         * @param {UserResponse} user - the user object.\n         * @param {boolean} isAnonymous - whether the user is anonymous or not.\n         */ this.setTokenOrProvider = async (tokenOrProvider, user, isAnonymous)=>{\n            this.validateToken(tokenOrProvider, user, isAnonymous);\n            this.user = user;\n            if (isFunction(tokenOrProvider)) {\n                this.tokenProvider = tokenOrProvider;\n                this.type = \"provider\";\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                this.token = tokenOrProvider;\n                this.type = \"static\";\n            }\n            if (!tokenOrProvider && this.user && this.secret) {\n                this.token = JWTUserToken(this.secret, user.id, {}, {});\n                this.type = \"static\";\n            }\n            await this.loadToken();\n        };\n        /**\n         * Resets the token manager.\n         * Useful for client disconnection or switching user.\n         */ this.reset = ()=>{\n            this.token = undefined;\n            this.user = undefined;\n            this.loadTokenPromise = null;\n        };\n        // Validates the user token.\n        this.validateToken = (tokenOrProvider, user, isAnonymous)=>{\n            // allow empty token for anon user\n            if (user && isAnonymous && !tokenOrProvider) return;\n            // Don't allow empty token for non-server side client.\n            if (!this.secret && !tokenOrProvider) {\n                throw new Error(\"UserWithId token can not be empty\");\n            }\n            if (tokenOrProvider && typeof tokenOrProvider !== \"string\" && !isFunction(tokenOrProvider)) {\n                throw new Error(\"user token should either be a string or a function\");\n            }\n            if (typeof tokenOrProvider === \"string\") {\n                // Allow empty token for anonymous users\n                if (isAnonymous && tokenOrProvider === \"\") return;\n                const tokenUserId = UserFromToken(tokenOrProvider);\n                if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === \"\" || !isAnonymous && tokenUserId !== user.id)) {\n                    throw new Error(\"userToken does not have a user_id or is not matching with user.id\");\n                }\n            }\n        };\n        // Resolves when token is ready. This function is simply to check if loadToken is in progress, in which\n        // case a function should wait.\n        this.tokenReady = ()=>this.loadTokenPromise;\n        // Fetches a token from tokenProvider function and sets in tokenManager.\n        // In case of static token, it will simply resolve to static token.\n        this.loadToken = ()=>{\n            // eslint-disable-next-line no-async-promise-executor\n            this.loadTokenPromise = new Promise(async (resolve, reject)=>{\n                if (this.type === \"static\") {\n                    return resolve(this.token);\n                }\n                if (this.tokenProvider && typeof this.tokenProvider !== \"string\") {\n                    try {\n                        this.token = await this.tokenProvider();\n                    } catch (e) {\n                        return reject(new Error(`Call to tokenProvider failed with message: ${e}`));\n                    }\n                    resolve(this.token);\n                }\n            });\n            return this.loadTokenPromise;\n        };\n        // Returns a current token\n        this.getToken = ()=>{\n            if (this.token) {\n                return this.token;\n            }\n            if (this.user && !this.token) {\n                return this.token;\n            }\n            if (this.secret) {\n                return JWTServerToken(this.secret);\n            }\n            throw new Error(`Both secret and user tokens are not set. Either client.connectUser wasn't called or client.disconnect was called`);\n        };\n        this.isStatic = ()=>this.type === \"static\";\n        this.loadTokenPromise = null;\n        if (secret) {\n            this.secret = secret;\n        }\n        this.type = \"static\";\n        if (this.secret) {\n            this.token = JWTServerToken(this.secret);\n        }\n    }\n}\nconst APIErrorCodes = {\n    \"-1\": {\n        name: \"InternalSystemError\",\n        retryable: true\n    },\n    \"2\": {\n        name: \"AccessKeyError\",\n        retryable: false\n    },\n    \"3\": {\n        name: \"AuthenticationFailedError\",\n        retryable: true\n    },\n    \"4\": {\n        name: \"InputError\",\n        retryable: false\n    },\n    \"6\": {\n        name: \"DuplicateUsernameError\",\n        retryable: false\n    },\n    \"9\": {\n        name: \"RateLimitError\",\n        retryable: true\n    },\n    \"16\": {\n        name: \"DoesNotExistError\",\n        retryable: false\n    },\n    \"17\": {\n        name: \"NotAllowedError\",\n        retryable: false\n    },\n    \"18\": {\n        name: \"EventNotSupportedError\",\n        retryable: false\n    },\n    \"19\": {\n        name: \"ChannelFeatureNotSupportedError\",\n        retryable: false\n    },\n    \"20\": {\n        name: \"MessageTooLongError\",\n        retryable: false\n    },\n    \"21\": {\n        name: \"MultipleNestingLevelError\",\n        retryable: false\n    },\n    \"22\": {\n        name: \"PayloadTooBigError\",\n        retryable: false\n    },\n    \"23\": {\n        name: \"RequestTimeoutError\",\n        retryable: true\n    },\n    \"24\": {\n        name: \"MaxHeaderSizeExceededError\",\n        retryable: false\n    },\n    \"40\": {\n        name: \"AuthErrorTokenExpired\",\n        retryable: false\n    },\n    \"41\": {\n        name: \"AuthErrorTokenNotValidYet\",\n        retryable: false\n    },\n    \"42\": {\n        name: \"AuthErrorTokenUsedBeforeIssuedAt\",\n        retryable: false\n    },\n    \"43\": {\n        name: \"AuthErrorTokenSignatureInvalid\",\n        retryable: false\n    },\n    \"44\": {\n        name: \"CustomCommandEndpointMissingError\",\n        retryable: false\n    },\n    \"45\": {\n        name: \"CustomCommandEndpointCallError\",\n        retryable: true\n    },\n    \"46\": {\n        name: \"ConnectionIDNotFoundError\",\n        retryable: false\n    },\n    \"60\": {\n        name: \"CoolDownError\",\n        retryable: true\n    },\n    \"69\": {\n        name: \"ErrWrongRegion\",\n        retryable: false\n    },\n    \"70\": {\n        name: \"ErrQueryChannelPermissions\",\n        retryable: false\n    },\n    \"71\": {\n        name: \"ErrTooManyConnections\",\n        retryable: true\n    },\n    \"99\": {\n        name: \"AppSuspendedError\",\n        retryable: false\n    }\n};\nfunction isAPIError(error) {\n    return error.code !== undefined;\n}\nfunction isErrorRetryable(error) {\n    if (!error.code) return false;\n    const err = APIErrorCodes[`${error.code}`];\n    if (!err) return false;\n    return err.retryable;\n}\nfunction isConnectionIDError(error) {\n    return error.code === 46; // ConnectionIDNotFoundError\n}\nfunction isWSFailure(err) {\n    if (typeof err.isWSFailure === \"boolean\") {\n        return err.isWSFailure;\n    }\n    try {\n        return JSON.parse(err.message).isWSFailure;\n    } catch (_) {\n        return false;\n    }\n}\nfunction isErrorResponse(res) {\n    return !res.status || res.status < 200 || 300 <= res.status;\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Closed\"] = \"CLOSED\";\n    ConnectionState[\"Connected\"] = \"CONNECTED\";\n    ConnectionState[\"Connecting\"] = \"CONNECTING\";\n    ConnectionState[\"Disconnected\"] = \"DISCONNECTED\";\n    ConnectionState[\"Init\"] = \"INIT\";\n})(ConnectionState || (ConnectionState = {}));\nclass WSConnectionFallback {\n    constructor(client){\n        /** @private */ this._onlineStatusChanged = (event)=>{\n            this._log(`_onlineStatusChanged() - ${event.type}`);\n            if (event.type === \"offline\") {\n                this._setState(ConnectionState.Closed);\n                this.cancelToken?.cancel(\"disconnect() is called\");\n                this.cancelToken = undefined;\n                return;\n            }\n            if (event.type === \"online\" && this.state === ConnectionState.Closed) {\n                this.connect(true);\n            }\n        };\n        /** @private */ this._req = async (params, config, retry)=>{\n            if (!this.cancelToken && !params.close) {\n                this.cancelToken = axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].CancelToken.source();\n            }\n            try {\n                const res = await this.client.doAxiosRequest(\"get\", this.client.baseURL.replace(\":3030\", \":8900\") + \"/longpoll\", undefined, {\n                    config: {\n                        ...config,\n                        cancelToken: this.cancelToken?.token\n                    },\n                    params,\n                    publicEndpoint: true\n                });\n                this.consecutiveFailures = 0; // always reset in case of no error\n                return res;\n            } catch (err) {\n                this.consecutiveFailures += 1;\n                // @ts-ignore\n                if (retry && isErrorRetryable(err)) {\n                    this._log(`_req() - Retryable error, retrying request`);\n                    await sleep(retryInterval(this.consecutiveFailures));\n                    return this._req(params, config, retry);\n                }\n                throw err;\n            }\n        };\n        /** @private */ this._poll = async ()=>{\n            while(this.state === ConnectionState.Connected){\n                try {\n                    const data = await this._req({}, {\n                        timeout: 30000\n                    }, true); // 30s => API responds in 20s if there is no event\n                    if (data.events?.length) {\n                        for(let i = 0; i < data.events.length; i++){\n                            this.client.dispatchEvent(data.events[i]);\n                        }\n                    }\n                } catch (err) {\n                    if (axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].isCancel(err)) {\n                        this._log(`_poll() - axios canceled request`);\n                        return;\n                    }\n                    /** client.doAxiosRequest will take care of TOKEN_EXPIRED error */ // @ts-ignore\n                    if (isConnectionIDError(err)) {\n                        this._log(`_poll() - ConnectionID error, connecting without ID...`);\n                        this._setState(ConnectionState.Disconnected);\n                        this.connect(true);\n                        return;\n                    }\n                    // @ts-ignore\n                    if (isAPIError(err) && !isErrorRetryable(err)) {\n                        this._setState(ConnectionState.Closed);\n                        return;\n                    }\n                    await sleep(retryInterval(this.consecutiveFailures));\n                }\n            }\n        };\n        /**\n         * connect try to open a longpoll request\n         * @param reconnect should be false for first call and true for subsequent calls to keep the connection alive and call recoverState\n         */ this.connect = async (reconnect = false)=>{\n            if (this.state === ConnectionState.Connecting) {\n                this._log(\"connect() - connecting already in progress\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            if (this.state === ConnectionState.Connected) {\n                this._log(\"connect() - already connected and polling\", {\n                    reconnect\n                }, \"warn\");\n                return;\n            }\n            this._setState(ConnectionState.Connecting);\n            this.connectionID = undefined; // connect should be sent with empty connection_id so API creates one\n            try {\n                const { event } = await this._req({\n                    json: this.client._buildWSPayload()\n                }, {\n                    timeout: 8000\n                }, reconnect);\n                this._setState(ConnectionState.Connected);\n                this.connectionID = event.connection_id;\n                this.client.resolveConnectionId?.();\n                // @ts-expect-error\n                this.client.dispatchEvent(event);\n                this._poll();\n                return event;\n            } catch (err) {\n                this._setState(ConnectionState.Closed);\n                this.client.rejectConnectionId?.();\n                throw err;\n            }\n        };\n        /**\n         * isHealthy checks if there is a connectionID and connection is in Connected state\n         */ this.isHealthy = ()=>{\n            return !!this.connectionID && this.state === ConnectionState.Connected;\n        };\n        this.disconnect = async (timeout = 2000)=>{\n            removeConnectionEventListeners(this._onlineStatusChanged);\n            this._setState(ConnectionState.Disconnected);\n            this.cancelToken?.cancel(\"disconnect() is called\");\n            this.cancelToken = undefined;\n            const connection_id = this.connectionID;\n            this.connectionID = undefined;\n            try {\n                await this._req({\n                    close: true,\n                    connection_id\n                }, {\n                    timeout\n                }, false);\n                this._log(`disconnect() - Closed connectionID`);\n            } catch (err) {\n                this._log(`disconnect() - Failed`, {\n                    err\n                }, \"error\");\n            }\n        };\n        this.client = client;\n        this.state = ConnectionState.Init;\n        this.consecutiveFailures = 0;\n        addConnectionEventListeners(this._onlineStatusChanged);\n    }\n    _log(msg, extra = {}, level = \"info\") {\n        this.client.logger(level, \"WSConnectionFallback:\" + msg, {\n            ...extra\n        });\n    }\n    _setState(state) {\n        this._log(`_setState() - ${state}`);\n        // transition from connecting => connected\n        if (this.state === ConnectionState.Connecting && state === ConnectionState.Connected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: true\n            });\n        }\n        if (state === ConnectionState.Closed || state === ConnectionState.Disconnected) {\n            this.client.dispatchEvent({\n                type: \"connection.changed\",\n                online: false\n            });\n        }\n        this.state = state;\n    }\n}\nconst logger = getLogger([\n    \"location\"\n]);\nconst HINT_URL = `https://hint.stream-io-video.com/`;\nconst getLocationHint = async (hintUrl = HINT_URL, timeout = 2000)=>{\n    const abortController = new AbortController();\n    const timeoutId = setTimeout(()=>abortController.abort(), timeout);\n    try {\n        const response = await fetch(HINT_URL, {\n            method: \"HEAD\",\n            signal: abortController.signal\n        });\n        const awsPop = response.headers.get(\"x-amz-cf-pop\") || \"ERR\";\n        logger(\"debug\", `Location header: ${awsPop}`);\n        return awsPop.substring(0, 3); // AMS1-P2 -> AMS\n    } catch (e) {\n        logger(\"warn\", `Failed to get location hint from ${HINT_URL}`, e);\n        return \"ERR\";\n    } finally{\n        clearTimeout(timeoutId);\n    }\n};\nclass StreamClient {\n    /**\n     * Initialize a client.\n     *\n     * @param {string} key - the api key\n     * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance\n     * @param {string} [options.secret] - the api secret\n     * @param {boolean} [options.browser] - enforce the client to be in browser mode\n     * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests\n     * @param {Logger} [options.Logger] - custom logger\n     * @param {number} [options.timeout] - default to 3000\n     * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()\n     */ constructor(key, options){\n        this.listeners = {};\n        this.nextRequestAbortController = null;\n        this.devToken = (userID)=>{\n            return DevToken(userID);\n        };\n        this.getAuthType = ()=>{\n            return this.anonymous ? \"anonymous\" : \"jwt\";\n        };\n        this.setBaseURL = (baseURL)=>{\n            this.baseURL = baseURL;\n            this.wsBaseURL = this.baseURL.replace(\"http\", \"ws\").replace(\":3030\", \":8800\");\n        };\n        this.getLocationHint = async (hintUrl, timeout)=>{\n            const hint = await this.locationHint;\n            if (!hint || hint === \"ERR\") {\n                this.locationHint = getLocationHint(hintUrl ?? this.options.locationHintUrl, timeout ?? this.options.locationHintTimeout);\n                return this.locationHint;\n            }\n            return hint;\n        };\n        this._getConnectionID = ()=>this.wsConnection?.connectionID || this.wsFallback?.connectionID;\n        this._hasConnectionID = ()=>Boolean(this._getConnectionID());\n        /**\n         * connectUser - Set the current user and open a WebSocket connection\n         *\n         * @param user Data about this user. IE {name: \"john\"}\n         * @param {TokenOrProvider} userTokenOrProvider Token or provider\n         *\n         * @return {ConnectAPIResponse} Returns a promise that resolves when the connection is setup\n         */ this.connectUser = async (user, userTokenOrProvider)=>{\n            if (!user.id) {\n                throw new Error('The \"id\" field on the user is missing');\n            }\n            /**\n             * Calling connectUser multiple times is potentially the result of a  bad integration, however,\n             * If the user id remains the same we don't throw error\n             */ if (this.userID === user.id && this.setUserPromise) {\n                this.logger(\"warn\", \"Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.\");\n                return this.setUserPromise;\n            }\n            if (this.userID) {\n                throw new Error(\"Use client.disconnect() before trying to connect as a different user. connectUser was called twice.\");\n            }\n            if ((this._isUsingServerAuth() || this.node) && !this.options.allowServerSideConnect) {\n                this.logger(\"warn\", 'Please do not use connectUser server side. connectUser impacts MAU and concurrent connection usage and thus your bill. If you have a valid use-case, add \"allowServerSideConnect: true\" to the client options to disable this warning.');\n            }\n            // we generate the client id client side\n            this.userID = user.id;\n            this.anonymous = false;\n            const setTokenPromise = this._setToken(user, userTokenOrProvider, this.anonymous);\n            this._setUser(user);\n            const wsPromise = this.openConnection();\n            this.setUserPromise = Promise.all([\n                setTokenPromise,\n                wsPromise\n            ]).then((result)=>result[1]);\n            try {\n                return await this.setUserPromise;\n            } catch (err) {\n                if (this.persistUserOnConnectionFailure) {\n                    // cleanup client to allow the user to retry connectUser again\n                    this.closeConnection();\n                } else {\n                    this.disconnectUser();\n                }\n                throw err;\n            }\n        };\n        this._setToken = (user, userTokenOrProvider, isAnonymous)=>this.tokenManager.setTokenOrProvider(userTokenOrProvider, user, isAnonymous);\n        this._setUser = (user)=>{\n            /**\n             * This one is used by the frontend. This is a copy of the current user object stored on backend.\n             * It contains reserved properties and own user properties which are not present in `this._user`.\n             */ this.user = user;\n            this.userID = user.id;\n            // this one is actually used for requests. This is a copy of current user provided to `connectUser` function.\n            this._user = {\n                ...user\n            };\n        };\n        /**\n         * Disconnects the websocket connection, without removing the user set on client.\n         * client.closeConnection will not trigger default auto-retry mechanism for reconnection. You need\n         * to call client.openConnection to reconnect to websocket.\n         *\n         * This is mainly useful on mobile side. You can only receive push notifications\n         * if you don't have active websocket connection.\n         * So when your app goes to background, you can call `client.closeConnection`.\n         * And when app comes back to foreground, call `client.openConnection`.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming succesful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.closeConnection = async (timeout)=>{\n            if (this.cleaningIntervalRef != null) {\n                clearInterval(this.cleaningIntervalRef);\n                this.cleaningIntervalRef = undefined;\n            }\n            await Promise.all([\n                this.wsConnection?.disconnect(timeout),\n                this.wsFallback?.disconnect(timeout)\n            ]);\n            return Promise.resolve();\n        };\n        /**\n         * Creates a new WebSocket connection with the current user. Returns empty promise, if there is an active connection\n         */ this.openConnection = async ()=>{\n            if (!this.userID) {\n                throw Error(\"UserWithId is not set on client, use client.connectUser or client.connectAnonymousUser instead\");\n            }\n            if (this.wsConnection?.isConnecting && this.wsPromise) {\n                this.logger(\"info\", \"client:openConnection() - connection already in progress\");\n                return this.wsPromise;\n            }\n            if ((this.wsConnection?.isHealthy || this.wsFallback?.isHealthy()) && this._hasConnectionID()) {\n                this.logger(\"info\", \"client:openConnection() - openConnection called twice, healthy connection already exists\");\n                return Promise.resolve();\n            }\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.clientID = `${this.userID}--${randomId()}`;\n            this.wsPromise = this.connect();\n            return this.wsPromise;\n        };\n        this._normalizeDate = (before)=>{\n            if (before instanceof Date) {\n                before = before.toISOString();\n            }\n            if (before === \"\") {\n                throw new Error(\"Don't pass blank string for since, use null instead if resetting the token revoke\");\n            }\n            return before;\n        };\n        /**\n         * Disconnects the websocket and removes the user from client.\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            this.logger(\"info\", \"client:disconnect() - Disconnecting the client\");\n            // remove the user specific fields\n            delete this.user;\n            delete this._user;\n            delete this.userID;\n            this.anonymous = false;\n            await this.closeConnection(timeout);\n            this.tokenManager.reset();\n            this.connectionIdPromise = undefined;\n            this.rejectConnectionId = undefined;\n            this.resolveConnectionId = undefined;\n        };\n        this.connectGuestUser = async (user)=>{\n            this.guestUserCreatePromise = this.doAxiosRequest(\"post\", \"/guest\", {\n                user: {\n                    ...user,\n                    role: \"guest\"\n                }\n            }, {\n                publicEndpoint: true\n            });\n            const response = await this.guestUserCreatePromise;\n            this.guestUserCreatePromise.finally(()=>this.guestUserCreatePromise = undefined);\n            return this.connectUser(response.user, response.access_token);\n        };\n        /**\n         * connectAnonymousUser - Set an anonymous user and open a WebSocket connection\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            this.connectionIdPromise = new Promise((resolve, reject)=>{\n                this.resolveConnectionId = resolve;\n                this.rejectConnectionId = reject;\n            });\n            this.anonymous = true;\n            await this._setToken(user, tokenOrProvider, this.anonymous);\n            this._setUser(user);\n            // some endpoints require a connection_id to be resolved.\n            // as anonymous users aren't allowed to open WS connections, we just\n            // resolve the connection_id here.\n            this.resolveConnectionId?.();\n        };\n        /**\n         * on - Listen to events on all channels and users your watching\n         *\n         * client.on('message.new', event => {console.log(\"my new message\", event, channel.state.messages)})\n         *\n         * @param eventName The event type to listen for (optional)\n         * @param callback The callback to call\n         *\n         * @return  Returns a function which, when called, unsubscribes the event handler.\n         */ this.on = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Adding listener for ${eventName} event`);\n            this.listeners[eventName]?.push(callback);\n            return ()=>{\n                this.off(eventName, callback);\n            };\n        };\n        /**\n         * off - Remove the event handler\n         */ this.off = (eventName, callback)=>{\n            if (!this.listeners[eventName]) {\n                this.listeners[eventName] = [];\n            }\n            this.logger(\"debug\", `Removing listener for ${eventName} event`);\n            this.listeners[eventName] = this.listeners[eventName]?.filter((value)=>value !== callback);\n        };\n        this._logApiRequest = (type, url, data, config)=>{\n            this.logger(\"trace\", `client: ${type} - Request - ${url}`, {\n                payload: data,\n                config\n            });\n        };\n        this._logApiResponse = (type, url, response)=>{\n            this.logger(\"trace\", `client:${type} - Response - url: ${url} > status ${response.status}`, {\n                response\n            });\n        };\n        this._logApiError = (type, url, error)=>{\n            this.logger(\"error\", `client:${type} - Error - url: ${url}`, {\n                url,\n                error\n            });\n        };\n        this.doAxiosRequest = async (type, url, data, options = {})=>{\n            if (!options.publicEndpoint) {\n                await Promise.all([\n                    this.tokenManager.tokenReady(),\n                    this.guestUserCreatePromise,\n                    this.connectionIdPromise\n                ]);\n            }\n            const requestConfig = this._enrichAxiosOptions(options);\n            try {\n                let response;\n                this._logApiRequest(type, url, data, requestConfig);\n                switch(type){\n                    case \"get\":\n                        response = await this.axiosInstance.get(url, requestConfig);\n                        break;\n                    case \"delete\":\n                        response = await this.axiosInstance.delete(url, requestConfig);\n                        break;\n                    case \"post\":\n                        response = await this.axiosInstance.post(url, data, requestConfig);\n                        break;\n                    case \"put\":\n                        response = await this.axiosInstance.put(url, data, requestConfig);\n                        break;\n                    case \"patch\":\n                        response = await this.axiosInstance.patch(url, data, requestConfig);\n                        break;\n                    case \"options\":\n                        response = await this.axiosInstance.options(url, requestConfig);\n                        break;\n                    default:\n                        throw new Error(\"Invalid request type\");\n                }\n                this._logApiResponse(type, url, response);\n                this.consecutiveFailures = 0;\n                return this.handleResponse(response);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            } catch (e /**TODO: generalize error types  */ ) {\n                e.client_request_id = requestConfig.headers?.[\"x-client-request-id\"];\n                this.consecutiveFailures += 1;\n                if (e.response) {\n                    this._logApiError(type, url, e.response);\n                    /** connection_fallback depends on this token expiration logic */ if (e.response.data.code === KnownCodes.TOKEN_EXPIRED && !this.tokenManager.isStatic()) {\n                        if (this.consecutiveFailures > 1) {\n                            await sleep(retryInterval(this.consecutiveFailures));\n                        }\n                        await this.tokenManager.loadToken();\n                        return await this.doAxiosRequest(type, url, data, options);\n                    }\n                    return this.handleResponse(e.response);\n                } else {\n                    this._logApiError(type, url, e);\n                    // eslint-disable-next-line no-throw-literal\n                    throw e;\n                }\n            }\n        };\n        this.get = (url, params)=>{\n            return this.doAxiosRequest(\"get\", url, null, {\n                params\n            });\n        };\n        this.put = (url, data, params)=>{\n            return this.doAxiosRequest(\"put\", url, data, {\n                params\n            });\n        };\n        this.post = (url, data, params)=>{\n            return this.doAxiosRequest(\"post\", url, data, {\n                params\n            });\n        };\n        this.patch = (url, data, params)=>{\n            return this.doAxiosRequest(\"patch\", url, data, {\n                params\n            });\n        };\n        this.delete = (url, params)=>{\n            return this.doAxiosRequest(\"delete\", url, null, {\n                params\n            });\n        };\n        this.errorFromResponse = (response)=>{\n            let err;\n            err = new ErrorFromResponse(`Stream error HTTP code: ${response.status}`);\n            if (response.data && response.data.code) {\n                err = new Error(`Stream error code ${response.data.code}: ${response.data.message}`);\n                err.code = response.data.code;\n            }\n            err.response = response;\n            err.status = response.status;\n            return err;\n        };\n        this.handleResponse = (response)=>{\n            const data = response.data;\n            if (isErrorResponse(response)) {\n                throw this.errorFromResponse(response);\n            }\n            return data;\n        };\n        this.dispatchEvent = (event)=>{\n            if (!event.received_at) event.received_at = new Date();\n            this.logger(\"debug\", `Dispatching event: ${event.type}`, event);\n            if (!this.listeners) return;\n            // call generic listeners\n            for (const listener of this.listeners.all || []){\n                listener(event);\n            }\n            // call type specific listeners\n            for (const listener of this.listeners[event.type] || []){\n                listener(event);\n            }\n        };\n        /**\n         * @private\n         */ this.connect = async ()=>{\n            if (!this.userID || !this._user) {\n                throw Error(\"Call connectUser or connectAnonymousUser before starting the connection\");\n            }\n            if (!this.wsBaseURL) {\n                throw Error(\"Websocket base url not set\");\n            }\n            if (!this.clientID) {\n                throw Error(\"clientID is not set\");\n            }\n            if (!this.wsConnection && (this.options.warmUp || this.options.enableInsights)) {\n                this._sayHi();\n            }\n            // The StableWSConnection handles all the reconnection logic.\n            if (this.options.wsConnection && this.node) {\n                // Intentionally avoiding adding ts generics on wsConnection in options since its only useful for unit test purpose.\n                this.options.wsConnection.setClient(this);\n                this.wsConnection = this.options.wsConnection;\n            } else {\n                this.wsConnection = new StableWSConnection(this);\n            }\n            try {\n                // if fallback is used before, continue using it instead of waiting for WS to fail\n                if (this.wsFallback) {\n                    return await this.wsFallback.connect();\n                }\n                this.logger(\"info\", \"StreamClient.connect: this.wsConnection.connect()\");\n                // if WSFallback is enabled, ws connect should timeout faster so fallback can try\n                return await this.wsConnection.connect(this.options.enableWSFallback ? this.defaultWSTimeoutWithFallback : this.defaultWSTimeout);\n            } catch (err) {\n                // run fallback only if it's WS/Network error and not a normal API error\n                // make sure browser is online before even trying the longpoll\n                if (this.options.enableWSFallback && // @ts-ignore\n                isWSFailure(err) && isOnline(this.logger)) {\n                    this.logger(\"warn\", \"client:connect() - WS failed, fallback to longpoll\");\n                    this.dispatchEvent({\n                        type: \"transport.changed\",\n                        mode: \"longpoll\"\n                    });\n                    this.wsConnection._destroyCurrentWSConnection();\n                    this.wsConnection.disconnect().then(); // close WS so no retry\n                    this.wsFallback = new WSConnectionFallback(this);\n                    return await this.wsFallback.connect();\n                }\n                throw err;\n            }\n        };\n        /**\n         * Check the connectivity with server for warmup purpose.\n         *\n         * @private\n         */ this._sayHi = ()=>{\n            const client_request_id = randomId();\n            const opts = {\n                headers: axios__WEBPACK_IMPORTED_MODULE_1__.AxiosHeaders.from({\n                    \"x-client-request-id\": client_request_id\n                })\n            };\n            this.doAxiosRequest(\"get\", this.baseURL + \"/hi\", null, opts).catch((e)=>{\n                if (this.options.enableInsights) {\n                    postInsights(\"http_hi_failed\", {\n                        api_key: this.key,\n                        err: e,\n                        client_request_id\n                    });\n                }\n            });\n        };\n        this.getUserAgent = ()=>{\n            const version = \"0.6.0\";\n            return this.userAgent || `stream-video-javascript-client-${this.node ? \"node\" : \"browser\"}-${version}`;\n        };\n        this.setUserAgent = (userAgent)=>{\n            this.userAgent = userAgent;\n        };\n        /**\n         * _isUsingServerAuth - Returns true if we're using server side auth\n         */ this._isUsingServerAuth = ()=>!!this.secret;\n        this._enrichAxiosOptions = (options = {\n            params: {},\n            headers: {},\n            config: {}\n        })=>{\n            const token = options.publicEndpoint && !this.user ? undefined : this._getToken();\n            const authorization = token ? {\n                Authorization: token\n            } : undefined;\n            let signal = null;\n            if (this.nextRequestAbortController !== null) {\n                signal = this.nextRequestAbortController.signal;\n                this.nextRequestAbortController = null;\n            }\n            if (!options.headers?.[\"x-client-request-id\"]) {\n                options.headers = {\n                    ...options.headers,\n                    \"x-client-request-id\": randomId()\n                };\n            }\n            return {\n                params: {\n                    user_id: this.userID,\n                    connection_id: this._getConnectionID(),\n                    api_key: this.key,\n                    ...options.params\n                },\n                headers: {\n                    ...authorization,\n                    \"stream-auth-type\": options.publicEndpoint && !this.user ? \"anonymous\" : this.getAuthType(),\n                    \"X-Stream-Client\": this.getUserAgent(),\n                    ...options.headers\n                },\n                ...signal ? {\n                    signal\n                } : {},\n                ...options.config,\n                ...this.options.axiosRequestConfig\n            };\n        };\n        this._getToken = ()=>{\n            if (!this.tokenManager) return null;\n            return this.tokenManager.getToken();\n        };\n        /**\n         * encode ws url payload\n         * @private\n         * @returns json string\n         */ this._buildWSPayload = (client_request_id)=>{\n            return JSON.stringify({\n                user_id: this.userID,\n                user_details: this._user,\n                client_request_id\n            });\n        };\n        /**\n         * creates an abort controller that will be used by the next HTTP Request.\n         */ this.createAbortControllerForNextRequest = ()=>{\n            return this.nextRequestAbortController = new AbortController();\n        };\n        /**\n         * createToken - Creates a token to authenticate this user. This function is used server side.\n         * The resulting token should be passed to the client side when the users registers or logs in.\n         *\n         * @param {string} userID The UserWithId ID\n         * @param {number} [exp] The expiration time for the token expressed in the number of seconds since the epoch\n         * @param call_cids for anonymous tokens you have to provide the call cids the use can join\n         *\n         * @return {string} Returns a token\n         */ this.createToken = (userID, exp, iat, call_cids)=>{\n            if (this.secret == null) {\n                throw Error(`tokens can only be created server-side using the API Secret`);\n            }\n            const extra = {};\n            if (exp) {\n                extra.exp = exp;\n            }\n            if (iat) {\n                extra.iat = iat;\n            }\n            if (call_cids) {\n                extra.call_cids = call_cids;\n            }\n            return JWTUserToken(this.secret, userID, extra, {});\n        };\n        // set the key\n        this.key = key;\n        // set the secret\n        this.secret = options?.secret;\n        // set the options... and figure out defaults...\n        const inputOptions = options ? options : {\n            browser: \"undefined\" !== \"undefined\"\n        };\n        this.browser = inputOptions.browser || \"undefined\" !== \"undefined\";\n        this.node = !this.browser;\n        if (this.browser) {\n            this.locationHint = getLocationHint(options?.locationHintUrl, options?.locationHintTimeout);\n        }\n        this.options = {\n            timeout: 5000,\n            withCredentials: false,\n            warmUp: false,\n            ...inputOptions\n        };\n        if (this.node && !this.options.httpsAgent) {\n            this.options.httpsAgent = new (https__WEBPACK_IMPORTED_MODULE_5___default().Agent)({\n                keepAlive: true,\n                keepAliveMsecs: 3000\n            });\n        }\n        this.setBaseURL(this.options.baseURL || \"https://video.stream-io-api.com/video\");\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_RUN) {\n            this.setBaseURL(\"http://localhost:3030/video\");\n        }\n        if (typeof process !== \"undefined\" && process.env.STREAM_LOCAL_TEST_HOST) {\n            this.setBaseURL(`http://${process.env.STREAM_LOCAL_TEST_HOST}/video`);\n        }\n        this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_35__[\"default\"].create({\n            ...this.options,\n            baseURL: this.baseURL\n        });\n        // WS connection is initialized when setUser is called\n        this.wsConnection = null;\n        this.wsPromise = null;\n        this.setUserPromise = null;\n        // mapping between channel groups and configs\n        this.anonymous = false;\n        this.persistUserOnConnectionFailure = this.options?.persistUserOnConnectionFailure;\n        // If it is a server-side client, then lets initialize the tokenManager, since token will be\n        // generated from secret.\n        this.tokenManager = new TokenManager(this.secret);\n        this.consecutiveFailures = 0;\n        this.insightMetrics = new InsightMetrics();\n        this.defaultWSTimeoutWithFallback = 6000;\n        this.defaultWSTimeout = 15000;\n        this.logger = isFunction(inputOptions.logger) ? inputOptions.logger : ()=>null;\n    }\n}\n/**\n * A `StreamVideoClient` instance lets you communicate with our API, and authenticate users.\n */ class StreamVideoClient {\n    constructor(apiKeyOrArgs, opts){\n        this.logLevel = \"warn\";\n        this.eventHandlersToUnregister = [];\n        /**\n         * Disconnects the currently connected user from the client.\n         *\n         * If the connection is successfully disconnected, the connected user [state variable](#readonlystatestore) will be updated accordingly\n         *\n         * @param timeout Max number of ms, to wait for close event of websocket, before forcefully assuming successful disconnection.\n         *                https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n         */ this.disconnectUser = async (timeout)=>{\n            if (!this.streamClient.user && !this.connectionPromise) {\n                return;\n            }\n            const disconnectUser = ()=>this.streamClient.disconnectUser(timeout);\n            this.disconnectionPromise = this.connectionPromise ? this.connectionPromise.then(()=>disconnectUser()) : disconnectUser();\n            this.disconnectionPromise.finally(()=>this.disconnectionPromise = undefined);\n            await this.disconnectionPromise;\n            this.eventHandlersToUnregister.forEach((unregister)=>unregister());\n            this.eventHandlersToUnregister = [];\n            this.writeableStateStore.setConnectedUser(undefined);\n        };\n        /**\n         * You can subscribe to WebSocket events provided by the API.\n         * To remove a subscription, call the `off` method or, execute the returned unsubscribe function.\n         * Please note that subscribing to WebSocket events is an advanced use-case, for most use-cases it should be enough to watch for changes in the reactive [state store](#readonlystatestore).\n         *\n         * @param eventName the event name or 'all'.\n         * @param callback the callback which will be called when the event is emitted.\n         * @returns an unsubscribe function.\n         */ this.on = (eventName, callback)=>{\n            return this.streamClient.on(eventName, callback);\n        };\n        /**\n         * Remove subscription for WebSocket events that were created by the `on` method.\n         *\n         * @param eventName the event name.\n         * @param callback the callback which was passed to the `on` method.\n         */ this.off = (eventName, callback)=>{\n            return this.streamClient.off(eventName, callback);\n        };\n        /**\n         * Creates a new call.\n         *\n         * @param type the type of the call.\n         * @param id the id of the call, if not provided a unique random value is used\n         */ this.call = (type, id)=>{\n            return new Call({\n                streamClient: this.streamClient,\n                id: id,\n                type: type,\n                clientStore: this.writeableStateStore\n            });\n        };\n        /**\n         * Creates a new guest user with the given data.\n         *\n         * @param data the data for the guest user.\n         */ this.createGuestUser = async (data)=>{\n            return this.streamClient.doAxiosRequest(\"post\", \"/guest\", data, {\n                publicEndpoint: true\n            });\n        };\n        /**\n         * Will query the API for calls matching the given filters.\n         *\n         * @param data the query data.\n         */ this.queryCalls = async (data = {})=>{\n            const response = await this.streamClient.post(\"/calls\", data);\n            const calls = response.calls.map((c)=>{\n                const call = new Call({\n                    streamClient: this.streamClient,\n                    id: c.call.id,\n                    type: c.call.type,\n                    members: c.members,\n                    ownCapabilities: c.own_capabilities,\n                    watching: data.watch,\n                    clientStore: this.writeableStateStore\n                });\n                call.state.updateFromCallResponse(c.call);\n                call.applyDeviceConfig();\n                if (data.watch) {\n                    this.writeableStateStore.registerCall(call);\n                }\n                return call;\n            });\n            return {\n                ...response,\n                calls: calls\n            };\n        };\n        /**\n         * Returns a list of available data centers available for hosting calls.\n         */ this.edges = async ()=>{\n            return this.streamClient.get(`/edges`);\n        };\n        /**\n         * addDevice - Adds a push device for a user.\n         *\n         * @param {string} id the device id\n         * @param {string} push_provider the push provider name (eg. apn, firebase)\n         * @param {string} push_provider_name user provided push provider name\n         * @param {string} [userID] the user id (defaults to current user)\n         * @param {boolean} [voip_token] enables use of VoIP token for push notifications on iOS platform\n         */ this.addDevice = async (id, push_provider, push_provider_name, userID, voip_token)=>{\n            return await this.streamClient.post(\"/devices\", {\n                id,\n                push_provider,\n                voip_token,\n                ...userID != null ? {\n                    user_id: userID\n                } : {},\n                ...push_provider_name != null ? {\n                    push_provider_name\n                } : {}\n            });\n        };\n        /**\n         * getDevices - Returns the devices associated with a current user\n         * @param {string} [userID] User ID. Only works on serverside\n         */ this.getDevices = async (userID)=>{\n            return await this.streamClient.get(\"/devices\", userID ? {\n                user_id: userID\n            } : {});\n        };\n        /**\n         * removeDevice - Removes the device with the given id.\n         *\n         * @param {string} id The device id\n         * @param {string} [userID] The user id. Only specify this for serverside requests\n         */ this.removeDevice = async (id, userID)=>{\n            return await this.streamClient.delete(\"/devices\", {\n                id,\n                ...userID ? {\n                    user_id: userID\n                } : {}\n            });\n        };\n        /**\n         * A callback that can be used to create ringing calls from push notifications. If the call already exists, it will do nothing.\n         * @param call_cid\n         * @returns\n         */ this.onRingingCall = async (call_cid)=>{\n            // if we find the call and is already ringing, we don't need to create a new call\n            // as client would have received the call.ring state because the app had WS alive when receiving push notifications\n            let call = this.readOnlyStateStore.calls.find((c)=>c.cid === call_cid && c.ringing);\n            if (!call) {\n                // if not it means that WS is not alive when receiving the push notifications and we need to fetch the call\n                const [callType, callId] = call_cid.split(\":\");\n                call = new Call({\n                    streamClient: this.streamClient,\n                    type: callType,\n                    id: callId,\n                    clientStore: this.writeableStateStore,\n                    ringing: true\n                });\n                await call.get();\n            }\n            return call;\n        };\n        /**\n         * Connects the given anonymous user to the client.\n         *\n         * @param user the user to connect.\n         * @param tokenOrProvider a token or a function that returns a token.\n         */ this.connectAnonymousUser = async (user, tokenOrProvider)=>{\n            const connectAnonymousUser = ()=>this.streamClient.connectAnonymousUser(user, tokenOrProvider);\n            this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectAnonymousUser()) : connectAnonymousUser();\n            this.connectionPromise.finally(()=>this.connectionPromise = undefined);\n            return this.connectionPromise;\n        };\n        let logger = logToConsole;\n        let logLevel = \"warn\";\n        if (typeof apiKeyOrArgs === \"string\") {\n            logLevel = opts?.logLevel || logLevel;\n            logger = opts?.logger || logger;\n        } else {\n            logLevel = apiKeyOrArgs.options?.logLevel || logLevel;\n            logger = apiKeyOrArgs.options?.logger || logger;\n        }\n        setLogger(logger, logLevel);\n        this.logger = getLogger([\n            \"client\"\n        ]);\n        if (typeof apiKeyOrArgs === \"string\") {\n            this.streamClient = new StreamClient(apiKeyOrArgs, {\n                persistUserOnConnectionFailure: true,\n                ...opts,\n                logLevel,\n                logger: this.logger\n            });\n        } else {\n            this.streamClient = new StreamClient(apiKeyOrArgs.apiKey, {\n                persistUserOnConnectionFailure: true,\n                ...apiKeyOrArgs.options,\n                logLevel,\n                logger: this.logger\n            });\n            const sdkInfo = getSdkInfo();\n            if (sdkInfo) {\n                this.streamClient.setUserAgent(this.streamClient.getUserAgent() + `-video-${SdkType[sdkInfo.type].toLowerCase()}-sdk-${sdkInfo.major}.${sdkInfo.minor}.${sdkInfo.patch}`);\n            }\n        }\n        this.writeableStateStore = new StreamVideoWriteableStateStore();\n        this.readOnlyStateStore = new StreamVideoReadOnlyStateStore(this.writeableStateStore);\n        if (typeof apiKeyOrArgs !== \"string\") {\n            const user = apiKeyOrArgs.user;\n            const token = apiKeyOrArgs.token || apiKeyOrArgs.tokenProvider;\n            if (user) {\n                this.connectUser(user, token);\n            }\n        }\n    }\n    /**\n     * Return the reactive state store, use this if you want to be notified about changes to the client state\n     */ get state() {\n        return this.readOnlyStateStore;\n    }\n    /**\n     * Connects the given user to the client.\n     * Only one user can connect at a time, if you want to change users, call `disconnectUser` before connecting a new user.\n     * If the connection is successful, the connected user [state variable](#readonlystatestore) will be updated accordingly.\n     *\n     * @param user the user to connect.\n     * @param token a token or a function that returns a token.\n     */ async connectUser(user, token) {\n        if (user.type === \"anonymous\") {\n            user.id = \"!anon\";\n            return this.connectAnonymousUser(user, token);\n        }\n        let connectUser = ()=>{\n            return this.streamClient.connectUser(user, token);\n        };\n        if (user.type === \"guest\") {\n            connectUser = async ()=>{\n                return this.streamClient.connectGuestUser(user);\n            };\n        }\n        this.connectionPromise = this.disconnectionPromise ? this.disconnectionPromise.then(()=>connectUser()) : connectUser();\n        this.connectionPromise?.finally(()=>this.connectionPromise = undefined);\n        const connectUserResponse = await this.connectionPromise;\n        // connectUserResponse will be void if connectUser called twice for the same user\n        if (connectUserResponse?.me) {\n            this.writeableStateStore.setConnectedUser(connectUserResponse.me);\n        }\n        this.eventHandlersToUnregister.push(this.on(\"connection.changed\", (event)=>{\n            if (event.online) {\n                const callsToReWatch = this.writeableStateStore.calls.filter((call)=>call.watching).map((call)=>call.cid);\n                this.logger(\"info\", `Rewatching calls after connection changed ${callsToReWatch.join(\", \")}`);\n                if (callsToReWatch.length > 0) {\n                    this.queryCalls({\n                        watch: true,\n                        filter_conditions: {\n                            cid: {\n                                $in: callsToReWatch\n                            }\n                        },\n                        sort: [\n                            {\n                                field: \"cid\",\n                                direction: 1\n                            }\n                        ]\n                    }).catch((err)=>{\n                        this.logger(\"error\", \"Failed to re-watch calls\", err);\n                    });\n                }\n            }\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.created\", (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"warn\", \"Received `call.created` sent by the current user\");\n                return;\n            }\n            this.logger(\"info\", `New call created and registered: ${call.cid}`);\n            const newCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore\n            });\n            newCall.state.updateFromCallResponse(call);\n            this.writeableStateStore.registerCall(newCall);\n        }));\n        this.eventHandlersToUnregister.push(this.on(\"call.ring\", async (event)=>{\n            const { call, members } = event;\n            if (user.id === call.created_by.id) {\n                this.logger(\"debug\", \"Received `call.ring` sent by the current user so ignoring the event\");\n                return;\n            }\n            // The call might already be tracked by the client,\n            // if `call.created` was received before `call.ring`.\n            // In that case, we cleanup the already tracked call.\n            const prevCall = this.writeableStateStore.findCall(call.type, call.id);\n            await prevCall?.leave();\n            // we create a new call\n            const theCall = new Call({\n                streamClient: this.streamClient,\n                type: call.type,\n                id: call.id,\n                members,\n                clientStore: this.writeableStateStore,\n                ringing: true\n            });\n            theCall.state.updateFromCallResponse(call);\n            // we fetch the latest metadata for the call from the server\n            await theCall.get();\n            this.writeableStateStore.registerCall(theCall);\n        }));\n        return connectUserResponse;\n    }\n    /**\n     * addDevice - Adds a push device for a user.\n     *\n     * @param {string} id the device id\n     * @param {string} push_provider the push provider name (eg. apn, firebase)\n     * @param {string} push_provider_name user provided push provider name\n     * @param {string} [userID] the user id (defaults to current user)\n     */ async addVoipDevice(id, push_provider, push_provider_name, userID) {\n        return await this.addDevice(id, push_provider, push_provider_name, userID, true);\n    }\n}\n/**\n * @deprecated Please use the `@stream-io/node-sdk` package instead.\n *\n * @see https://getstream.io/video/docs/api/\n */ class StreamVideoServerClient extends StreamVideoClient {\n    constructor(apiKey, options){\n        super({\n            apiKey,\n            options\n        });\n        this.getCallTypes = ()=>{\n            return this.streamClient.get(\"/calltypes\");\n        };\n        this.getCallType = (name)=>{\n            return this.streamClient.get(`/calltypes/${name}`);\n        };\n        this.createCallType = (data)=>{\n            return this.streamClient.post(\"/calltypes\", data);\n        };\n        this.deleteCallType = (name)=>{\n            return this.streamClient.delete(`/calltypes/${name}`);\n        };\n        this.updateCallType = (name, data)=>{\n            return this.streamClient.put(`/calltypes/${name}`, data);\n        };\n        this.listExternalStorage = ()=>{\n            return this.streamClient.get(\"/external_storage\");\n        };\n        this.createExternalStorage = (request)=>{\n            return this.streamClient.post(\"/external_storage\", request);\n        };\n        this.deleteExternalStorage = (name)=>{\n            return this.streamClient.delete(`/external_storage/${name}`);\n        };\n        this.updateExternalStorage = (name, request)=>{\n            return this.streamClient.put(`/external_storage/${name}`, request);\n        };\n        this.checkExternalStorage = (name)=>{\n            return this.streamClient.get(`/external_storage/${name}/check`);\n        };\n    }\n    /**\n     * createToken - Creates a token to authenticate this user. This function is used server side.\n     * The resulting token should be passed to the client side when the users register or logs in.\n     *\n     * @param {string} userID The User ID\n     * @param {number} [exp] The expiration time for the token expressed in the number of seconds since the epoch\n     * @param {number} [iat] The timestamp when a token has been issued\n     * @param call_cids for anonymous tokens you have to provide the call cids the use can join\n     *\n     * @return {string} Returns a token\n     */ createToken(userID, exp, iat, call_cids) {\n        return this.streamClient.createToken(userID, exp, iat, call_cids);\n    }\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1jbGllbnQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUN5SDtBQUMxRTtBQUMzQjtBQUNUO0FBQ2dDO0FBQ2dMO0FBQzlNO0FBQ0c7QUFDRjtBQUNaO0FBQ0s7QUFDZjtBQUMwQjtBQUUxQzs7Q0FFQyxHQUNELE1BQU1zQyxpQ0FBaUM7SUFDbkNDLFNBQVM7SUFDVEMsVUFBVTtBQUNkO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyx3Q0FBd0M7SUFDMUNGLFNBQVM7SUFDVEMsVUFBVTtBQUNkO0FBQ0E7O0NBRUMsR0FDRCxNQUFNRSxzQ0FBc0M7SUFDeENDLFVBQVU7SUFDVkMsS0FBSztJQUNMQyxRQUFRO0lBQ1JDLFFBQVE7QUFDWjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMseUJBQXlCO0lBQzNCQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsb0JBQW9CO0lBQ3BCQyxRQUFRO0lBQ1JDLFFBQVE7QUFDWjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsZ0NBQWdDO0lBQ2xDTCxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsb0JBQW9CO0lBQ3BCQyxRQUFRO0lBQ1JDLFFBQVE7QUFDWjtBQUNBOzs7Q0FHQyxHQUNELE1BQU1FLGdCQUFnQjtJQUNsQkMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLGlCQUFpQjtJQUNqQkMsVUFBVTtJQUNWQyxnQkFBZ0I7SUFDaEJDLFdBQVc7SUFDWEMsaUJBQWlCO0lBQ2pCQyxZQUFZO0lBQ1pDLGtCQUFrQjtJQUNsQkMsV0FBVztJQUNYQyxvQkFBb0I7SUFDcEJDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLHNCQUFzQjtJQUN0QkMsbUJBQW1CO0lBQ25CQywwQkFBMEI7SUFDMUJDLHFCQUFxQjtJQUNyQkMsa0JBQWtCO0lBQ2xCQyx5QkFBeUI7SUFDekJDLGFBQWE7SUFDYkMsb0JBQW9CO0lBQ3BCQyx5QkFBeUI7SUFDekJDLHNCQUFzQjtBQUMxQjtBQUNBOztDQUVDLEdBQ0QsTUFBTUMsZ0NBQWdDO0lBQ2xDQyxXQUFXO0lBQ1hDLFVBQVU7SUFDVkMsU0FBUztBQUNiO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyxtQ0FBbUM7SUFDckNDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsUUFBUTtBQUNaO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyxnQ0FBZ0M7SUFDbENULFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxTQUFTO0FBQ2I7QUFDQTs7Q0FFQyxHQUNELE1BQU1RLHVDQUF1QztJQUN6Q1YsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLFNBQVM7QUFDYjtBQUNBOztDQUVDLEdBQ0QsTUFBTVMsZ0NBQWdDO0lBQ2xDQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsVUFBVTtBQUNkO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyx1Q0FBdUM7SUFDekNILE9BQU87SUFDUEMsTUFBTTtJQUNOQyxVQUFVO0FBQ2Q7QUFFQSxNQUFNRSwwQkFBMEJDO0FBQ2hDO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELElBQUlDO0FBQ0gsVUFBVUEsU0FBUztJQUNoQjs7OztLQUlDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDN0MsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLDJGQUEyRjtBQUMzRixNQUFNQyxvQkFBb0JuRyw2REFBV0E7SUFDakNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLDBCQUEwQjtZQUM1QjtnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsR0FBRyxFQUFFLG1CQUFtQjtnQkFDeEJDLEdBQUc7b0JBQUVGLE1BQU07b0JBQVdHLEdBQUcsSUFBTUM7Z0JBQU07WUFDekM7U0FDSDtJQUNMO0lBQ0E7O0tBRUMsR0FDREMsa0JBQWtCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxJQUFJQyxPQUFPLENBQUM7UUFDWixLQUFLLElBQUksQ0FBQ0MsR0FBR0MsRUFBRSxJQUFJQyxPQUFPQyxPQUFPLENBQUNOLFFBQVFPLE1BQU0sRUFBRztZQUMvQ0wsSUFBSSxDQUFDQyxFQUFFLEdBQUdMLE1BQU1VLE1BQU0sQ0FBQ0o7UUFDM0I7UUFDQSxPQUFPRjtJQUNYO0lBQ0E7O0tBRUMsR0FDRE8saUJBQWlCUCxJQUFJLEVBQUVELE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ3BDLElBQUksQ0FBQ3RILG1FQUFZQSxDQUFDOEcsT0FDZCxNQUFNLElBQUlTLFdBQVd2QixLQUFLLENBQUMsNkJBQ3ZCLElBQUksQ0FBQ3dCLFFBQVEsR0FDYixnQkFDQXZILHNFQUFlQSxDQUFDNkcsUUFDaEI7UUFDUixJQUFJLENBQUNRLFFBQ0RBLFNBQVMsSUFBSSxDQUFDRyxNQUFNO1FBQ3hCLEtBQUssSUFBSSxDQUFDVixHQUFHQyxFQUFFLElBQUlPLFdBQVdOLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDSixNQUFPO1lBQ2hEUSxPQUFPSCxNQUFNLENBQUNKLEVBQUUsR0FBR0wsTUFBTWdCLFFBQVEsQ0FBQ1Y7UUFDdEM7UUFDQSxPQUFPTTtJQUNYO0lBQ0FHLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUU8sTUFBTSxHQUFHLENBQUM7UUFDbEIsSUFBSVEsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyw2Q0FBNkMsR0FBRztvQkFDakQsSUFBSSxDQUFDRyxjQUFjLENBQUMxQixRQUFRTyxNQUFNLEVBQUVZLFFBQVFsQjtvQkFDNUM7Z0JBQ0o7b0JBQ0ksSUFBSTBCLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBMEIsZUFBZXZILEdBQUcsRUFBRWdILE1BQU0sRUFBRWxCLE9BQU8sRUFBRTtRQUNqQyxJQUFJK0IsTUFBTWIsT0FBT2MsTUFBTSxJQUFJWixNQUFNRixPQUFPRyxHQUFHLEdBQUdVLEtBQUtFLEtBQUtDO1FBQ3hELE1BQU9oQixPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSztvQkFDRFcsTUFBTWYsT0FBT2lCLE1BQU07b0JBQ25CO2dCQUNKLEtBQUs7b0JBQ0RELE1BQU1yQyxNQUFNb0Isa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDO29CQUN4RDtnQkFDSjtvQkFDSSxNQUFNLElBQUlVLFdBQVd2QixLQUFLLENBQUM7WUFDbkM7UUFDSjtRQUNBakYsR0FBRyxDQUFDK0gsT0FBTyxHQUFHLEdBQUdDLE9BQU9yQyxNQUFNZSxNQUFNO0lBQ3hDO0lBQ0F3QixvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsa0RBQWtELEdBQ2xELEtBQUssSUFBSUUsS0FBS1EsV0FBV04sTUFBTSxDQUFDa0MsSUFBSSxDQUFDdkMsUUFBUU8sTUFBTSxFQUFHO1lBQ2xEK0IsT0FDS2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFDL0JDLElBQUksR0FDSmhCLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQy9CSixNQUFNLENBQUNqQztZQUNabUMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSTtZQUM1QzNDLE1BQU11QyxtQkFBbUIsQ0FBQ3JDLFFBQVFPLE1BQU0sQ0FBQ0osRUFBRSxFQUFFbUMsUUFBUXJDO1lBQ3JEcUMsT0FBT0ksSUFBSSxHQUFHQSxJQUFJO1FBQ3RCO1FBQ0EsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNTyxTQUFTLElBQUl2RDtBQUNuQiwyRkFBMkY7QUFDM0YsTUFBTXdELG1CQUFtQjNKLDZEQUFXQTtJQUNoQ29HLGFBQWM7UUFDVixLQUFLLENBQUMseUJBQXlCO1lBQzNCO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTTt3QkFBQzt3QkFBNkJSO3FCQUFVO1lBQ3JEO1lBQ0E7Z0JBQ0lHLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtZQUNBO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsRUFBRSxtQkFBbUI7WUFDNUI7WUFDQTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLEVBQUUsaUJBQWlCO1lBQzFCO1lBQ0E7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNZ0Q7WUFDYjtZQUNBO2dCQUNJckQsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU1tRDtZQUNiO1NBQ0g7SUFDTDtJQUNBOztLQUVDLEdBQ0RqRCxrQkFBa0JDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ2hDLElBQUlELFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBS2hDLFdBQzNCLE1BQU0sSUFBSU4sV0FBV3ZCLEtBQUs7UUFDOUIsT0FBUVksUUFBUU4sSUFBSSxDQUFDdUQsU0FBUztZQUMxQixLQUFLaEM7Z0JBQ0QsTUFBTSxJQUFJTixXQUFXdkIsS0FBSztZQUM5QixLQUFLO2dCQUNELE9BQU9ZLFFBQVFOLElBQUksQ0FBQ3dELFNBQVM7WUFDakMsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxJQUFJQyxjQUFjbkQsUUFBUU4sSUFBSSxDQUFDeUQsV0FBVztnQkFDMUMsSUFBSSxPQUFPQSxlQUFlLFlBQVksQ0FBQ0MsT0FBT0MsUUFBUSxDQUFDRixjQUNuRCxNQUFNLElBQUl4QyxXQUFXdkIsS0FBSztnQkFDOUIsT0FBTytEO1lBQ1gsS0FBSztnQkFDRCxPQUFPbkQsUUFBUU4sSUFBSSxDQUFDNEQsV0FBVztZQUNuQyxLQUFLO2dCQUNELElBQUlDLGlCQUFpQixJQUFJLENBQUNoRCxNQUFNLENBQUNpRCxJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRWpFLEVBQUUsS0FBSztnQkFDdEQsSUFBSStELGdCQUFnQjdELFNBQVMsV0FDekIsTUFBTSxJQUFJaUIsV0FBV3ZCLEtBQUs7Z0JBQzlCLE9BQU9tRSxlQUFlMUQsQ0FBQyxHQUFHVyxNQUFNLENBQUNSLFFBQVFOLElBQUksQ0FBQ2dFLFNBQVM7WUFDM0QsS0FBSztnQkFDRCxJQUFJQyxtQkFBbUIsSUFBSSxDQUFDcEQsTUFBTSxDQUFDaUQsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVqRSxFQUFFLEtBQUs7Z0JBQ3hELElBQUltRSxrQkFBa0JqRSxTQUFTLFdBQzNCLE1BQU0sSUFBSWlCLFdBQVd2QixLQUFLO2dCQUM5QixPQUFPdUUsaUJBQWlCOUQsQ0FBQyxHQUFHVyxNQUFNLENBQUNSLFFBQVFOLElBQUksQ0FBQ2tFLFdBQVc7UUFDbkU7SUFDSjtJQUNBOztLQUVDLEdBQ0RuRCxpQkFBaUJQLElBQUksRUFBRUQsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDcEMsSUFBSSxDQUFDQSxRQUNEQSxTQUFTLElBQUksQ0FBQ0csTUFBTTtRQUN4QixPQUFRLE9BQU9YO1lBQ1gsS0FBSztnQkFDRFEsT0FBT2hCLElBQUksR0FBRztvQkFBRXVELFdBQVc7b0JBQWVFLGFBQWFqRDtnQkFBSztnQkFDNUQ7WUFDSixLQUFLO2dCQUNEUSxPQUFPaEIsSUFBSSxHQUFHO29CQUFFdUQsV0FBVztvQkFBZUssYUFBYXBEO2dCQUFLO2dCQUM1RDtZQUNKLEtBQUs7Z0JBQ0RRLE9BQU9oQixJQUFJLEdBQUc7b0JBQUV1RCxXQUFXO29CQUFhQyxXQUFXaEQ7Z0JBQUs7Z0JBQ3hEO1lBQ0osS0FBSztnQkFDRCxJQUFJQSxTQUFTLE1BQU07b0JBQ2ZRLE9BQU9oQixJQUFJLEdBQUc7d0JBQ1Z1RCxXQUFXO3dCQUNYWSxXQUFXeEUsVUFBVXlFLFVBQVU7b0JBQ25DO2dCQUNKLE9BQ0ssSUFBSW5ELFdBQVdvRCxLQUFLLENBQUNDLE9BQU8sQ0FBQzlELE9BQU87b0JBQ3JDUSxPQUFPaEIsSUFBSSxHQUFHO3dCQUNWdUQsV0FBVzt3QkFDWFMsV0FBV1YsVUFBVWxDLFFBQVEsQ0FBQ1o7b0JBQ2xDO2dCQUNKLE9BQ0s7b0JBQ0RRLE9BQU9oQixJQUFJLEdBQUc7d0JBQ1Z1RCxXQUFXO3dCQUNYVyxhQUFhZixPQUFPL0IsUUFBUSxDQUFDWjtvQkFDakM7Z0JBQ0o7Z0JBQ0E7WUFDSjtnQkFDSSxNQUFNLElBQUlTLFdBQVd2QixLQUFLLENBQUMscUJBQ3ZCLElBQUksQ0FBQ3dCLFFBQVEsR0FDYixnQkFDQXZILHNFQUFlQSxDQUFDNkc7UUFDNUI7UUFDQSxPQUFPUTtJQUNYO0lBQ0FHLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUU4sSUFBSSxHQUFHO1lBQUV1RCxXQUFXaEM7UUFBVTtRQUN0QyxJQUFJRixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLHdDQUF3QyxHQUFHO29CQUM1Q3ZCLFFBQVFOLElBQUksR0FBRzt3QkFDWHVELFdBQVc7d0JBQ1hZLFdBQVcxQyxPQUFPOEMsS0FBSztvQkFDM0I7b0JBQ0E7Z0JBQ0osS0FBSyx1QkFBdUIsR0FBRztvQkFDM0JqRSxRQUFRTixJQUFJLEdBQUc7d0JBQ1h1RCxXQUFXO3dCQUNYRSxhQUFhaEMsT0FBTytDLE1BQU07b0JBQzlCO29CQUNBO2dCQUNKLEtBQUssdUJBQXVCLEdBQUc7b0JBQzNCbEUsUUFBUU4sSUFBSSxHQUFHO3dCQUNYdUQsV0FBVzt3QkFDWEssYUFBYW5DLE9BQU9pQixNQUFNO29CQUM5QjtvQkFDQTtnQkFDSixLQUFLLG1CQUFtQixHQUFHO29CQUN2QnBDLFFBQVFOLElBQUksR0FBRzt3QkFDWHVELFdBQVc7d0JBQ1hDLFdBQVcvQixPQUFPZ0QsSUFBSTtvQkFDMUI7b0JBQ0E7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0NuRSxRQUFRTixJQUFJLEdBQUc7d0JBQ1h1RCxXQUFXO3dCQUNYVyxhQUFhZixPQUFPM0Isa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFOLElBQUksQ0FBQ2tFLFdBQVc7b0JBQ3JHO29CQUNBO2dCQUNKLEtBQUssd0NBQXdDLEdBQUc7b0JBQzVDNUQsUUFBUU4sSUFBSSxHQUFHO3dCQUNYdUQsV0FBVzt3QkFDWFMsV0FBV1YsVUFBVTlCLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRTixJQUFJLENBQUNnRSxTQUFTO29CQUNwRztvQkFDQTtnQkFDSjtvQkFDSSxJQUFJL0IsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsNkNBQTZDLEdBQzdDLElBQUlELFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBSyxhQUMzQlgsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUU4sSUFBSSxDQUFDbUUsU0FBUztRQUMvRCw0QkFBNEIsR0FDNUIsSUFBSTdELFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBSyxlQUMzQlgsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzZLLEtBQUssRUFBRUgsTUFBTSxDQUFDbEUsUUFBUU4sSUFBSSxDQUFDeUQsV0FBVztRQUNqRSw0QkFBNEIsR0FDNUIsSUFBSW5ELFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBSyxlQUMzQlgsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUU4sSUFBSSxDQUFDNEQsV0FBVztRQUMzRSx3QkFBd0IsR0FDeEIsSUFBSXRELFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBSyxhQUMzQlgsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUQsSUFBSSxDQUFDbkUsUUFBUU4sSUFBSSxDQUFDd0QsU0FBUztRQUM5RCw0Q0FBNEMsR0FDNUMsSUFBSWxELFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBSyxlQUMzQkosT0FBT1IsbUJBQW1CLENBQUNyQyxRQUFRTixJQUFJLENBQUNrRSxXQUFXLEVBQUV0QixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUN0SCw2Q0FBNkMsR0FDN0MsSUFBSTFDLFFBQVFOLElBQUksQ0FBQ3VELFNBQVMsS0FBSyxhQUMzQkQsVUFBVVgsbUJBQW1CLENBQUNyQyxRQUFRTixJQUFJLENBQUNnRSxTQUFTLEVBQUVwQixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUN2SCxJQUFJZixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU14QyxRQUFRLElBQUlnRDtBQUNsQiwyRkFBMkY7QUFDM0YsTUFBTXdCLHVCQUF1Qm5MLDZEQUFXQTtJQUNwQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsNkJBQTZCO1lBQy9CO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1DO1lBQ2I7U0FDSDtJQUNMO0lBQ0E7O0tBRUMsR0FDREMsa0JBQWtCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxPQUFPRCxRQUFRd0UsTUFBTSxDQUFDckssR0FBRyxDQUFDLENBQUNpRyxJQUFNTixNQUFNVSxNQUFNLENBQUNKO0lBQ2xEO0lBQ0E7O0tBRUMsR0FDREssaUJBQWlCUCxJQUFJLEVBQUVELE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ3BDLElBQUksQ0FBQ0MsV0FBV29ELEtBQUssQ0FBQ0MsT0FBTyxDQUFDOUQsT0FDMUIsTUFBTSxJQUFJUyxXQUFXdkIsS0FBSyxDQUFDLHFCQUN2QixJQUFJLENBQUN3QixRQUFRLEdBQ2IsZ0JBQ0F2SCxzRUFBZUEsQ0FBQzZHO1FBQ3hCLElBQUksQ0FBQ1EsUUFDREEsU0FBUyxJQUFJLENBQUNHLE1BQU07UUFDeEIsSUFBSTJELFNBQVN0RSxLQUFLL0YsR0FBRyxDQUFDLENBQUNpRyxJQUFNTixNQUFNZ0IsUUFBUSxDQUFDVjtRQUM1Q00sT0FBTzhELE1BQU0sQ0FBQ0MsSUFBSSxJQUFJRDtRQUN0QixPQUFPOUQ7SUFDWDtJQUNBRyxPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVF3RSxNQUFNLEdBQUcsRUFBRTtRQUNuQixJQUFJekQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx5Q0FBeUMsR0FBRztvQkFDN0N2QixRQUFRd0UsTUFBTSxDQUFDQyxJQUFJLENBQUMzRSxNQUFNb0Isa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDO29CQUN0RTtnQkFDSjtvQkFDSSxJQUFJMEIsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsOENBQThDLEdBQzlDLElBQUssSUFBSXlFLElBQUksR0FBR0EsSUFBSTFFLFFBQVF3RSxNQUFNLENBQUNwRCxNQUFNLEVBQUVzRCxJQUN2QzVFLE1BQU11QyxtQkFBbUIsQ0FBQ3JDLFFBQVF3RSxNQUFNLENBQUNFLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzlHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTVUsWUFBWSxJQUFJc0I7QUFFdEIsMkZBQTJGO0FBQzNGLE1BQU1LLHVCQUF1QnhMLDZEQUFXQTtJQUNwQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsNkJBQTZCO1lBQy9CO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFXQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsa0JBQWtCO1lBQUc7WUFDcEU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxrQkFBa0I7WUFBRztTQUNyRTtJQUNMO0lBQ0E7O0tBRUMsR0FDRCtFLE1BQU07UUFDRixNQUFNQyxNQUFNLElBQUksQ0FBQ2hFLE1BQU07UUFDdkIsTUFBTWlFLEtBQUtDLEtBQUtILEdBQUc7UUFDbkJDLElBQUlHLE9BQU8sR0FBR3ZMLHlEQUFNQSxDQUFDaUIsSUFBSSxDQUFDdUssS0FBS0MsS0FBSyxDQUFDSixLQUFLLE9BQU9LLFFBQVE7UUFDekROLElBQUlPLEtBQUssR0FBRyxLQUFNLE9BQVE7UUFDMUIsT0FBT1A7SUFDWDtJQUNBOztLQUVDLEdBQ0RRLE9BQU9yRixPQUFPLEVBQUU7UUFDWixPQUFPLElBQUkrRSxLQUFLdEwseURBQU1BLENBQUNpQixJQUFJLENBQUNzRixRQUFRZ0YsT0FBTyxFQUFFTSxRQUFRLEtBQUssT0FDdERMLEtBQUtNLElBQUksQ0FBQ3ZGLFFBQVFvRixLQUFLLEdBQUc7SUFDbEM7SUFDQTs7S0FFQyxHQUNESSxTQUFTQyxJQUFJLEVBQUU7UUFDWCxNQUFNWixNQUFNLElBQUksQ0FBQ2hFLE1BQU07UUFDdkIsTUFBTWlFLEtBQUtXLEtBQUtDLE9BQU87UUFDdkJiLElBQUlHLE9BQU8sR0FBR3ZMLHlEQUFNQSxDQUFDaUIsSUFBSSxDQUFDdUssS0FBS0MsS0FBSyxDQUFDSixLQUFLLE9BQU9LLFFBQVE7UUFDekROLElBQUlPLEtBQUssR0FBRyxLQUFNLE9BQVE7UUFDMUIsT0FBT1A7SUFDWDtJQUNBOzs7S0FHQyxHQUNEOUUsa0JBQWtCQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNoQyxJQUFJNkUsS0FBS3JMLHlEQUFNQSxDQUFDaUIsSUFBSSxDQUFDc0YsUUFBUWdGLE9BQU8sRUFBRU0sUUFBUSxLQUFLO1FBQ25ELElBQUlSLEtBQUtDLEtBQUtZLEtBQUssQ0FBQywyQkFDaEJiLEtBQUtDLEtBQUtZLEtBQUssQ0FBQyx5QkFDaEIsTUFBTSxJQUFJdkcsTUFBTTtRQUNwQixJQUFJWSxRQUFRb0YsS0FBSyxHQUFHLEdBQ2hCLE1BQU0sSUFBSWhHLE1BQU07UUFDcEIsSUFBSXdHLElBQUk7UUFDUixJQUFJNUYsUUFBUW9GLEtBQUssR0FBRyxHQUFHO1lBQ25CLElBQUlTLFdBQVcsQ0FBQzdGLFFBQVFvRixLQUFLLEdBQUcsVUFBUyxFQUFHRCxRQUFRLEdBQUdXLFNBQVMsQ0FBQztZQUNqRSxJQUFJRCxTQUFTQyxTQUFTLENBQUMsT0FBTyxVQUMxQkYsSUFBSSxNQUFNQyxTQUFTQyxTQUFTLENBQUMsR0FBRyxLQUFLO2lCQUNwQyxJQUFJRCxTQUFTQyxTQUFTLENBQUMsT0FBTyxPQUMvQkYsSUFBSSxNQUFNQyxTQUFTQyxTQUFTLENBQUMsR0FBRyxLQUFLO2lCQUVyQ0YsSUFBSSxNQUFNQyxXQUFXO1FBQzdCO1FBQ0EsT0FBTyxJQUFJZCxLQUFLRCxJQUFJaUIsV0FBVyxHQUFHQyxPQUFPLENBQUMsU0FBU0o7SUFDdkQ7SUFDQTs7O0tBR0MsR0FDRG5GLGlCQUFpQlAsSUFBSSxFQUFFRCxPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNwQyxJQUFJLE9BQU9SLFNBQVMsVUFDaEIsTUFBTSxJQUFJZCxNQUFNLHlDQUF5Qy9GLHNFQUFlQSxDQUFDNkcsUUFBUTtRQUNyRixJQUFJK0YsVUFBVS9GLEtBQUtnRyxLQUFLLENBQUM7UUFDekIsSUFBSSxDQUFDRCxTQUNELE1BQU0sSUFBSTdHLE1BQU07UUFDcEIsSUFBSTBGLEtBQUtDLEtBQUtZLEtBQUssQ0FBQ00sT0FBTyxDQUFDLEVBQUUsR0FDMUIsTUFDQUEsT0FBTyxDQUFDLEVBQUUsR0FDVixNQUNBQSxPQUFPLENBQUMsRUFBRSxHQUNWLE1BQ0FBLE9BQU8sQ0FBQyxFQUFFLEdBQ1YsTUFDQUEsT0FBTyxDQUFDLEVBQUUsR0FDVixNQUNBQSxPQUFPLENBQUMsRUFBRSxHQUNUQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxHQUFHQSxPQUFPLENBQUMsRUFBRSxHQUFHLEdBQUU7UUFDakMsSUFBSTdDLE9BQU8rQyxLQUFLLENBQUNyQixLQUNiLE1BQU0sSUFBSTFGLE1BQU07UUFDcEIsSUFBSTBGLEtBQUtDLEtBQUtZLEtBQUssQ0FBQywyQkFDaEJiLEtBQUtDLEtBQUtZLEtBQUssQ0FBQyx5QkFDaEIsTUFBTSxJQUFJaEYsV0FBV3ZCLEtBQUssQ0FBQztRQUMvQixJQUFJLENBQUNzQixRQUNEQSxTQUFTLElBQUksQ0FBQ0csTUFBTTtRQUN4QkgsT0FBT3NFLE9BQU8sR0FBR3ZMLHlEQUFNQSxDQUFDaUIsSUFBSSxDQUFDb0ssS0FBSyxNQUFNSyxRQUFRO1FBQ2hEekUsT0FBTzBFLEtBQUssR0FBRztRQUNmLElBQUlhLE9BQU8sQ0FBQyxFQUFFLEVBQ1Z2RixPQUFPMEUsS0FBSyxHQUNSZ0IsU0FBUyxNQUFNSCxPQUFPLENBQUMsRUFBRSxHQUFHLElBQUkxQixNQUFNLENBQUMsSUFBSTBCLE9BQU8sQ0FBQyxFQUFFLENBQUM3RSxNQUFNLEtBQ3hEO1FBQ1osT0FBT1Y7SUFDWDtJQUNBRyxPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFnRixPQUFPLEdBQUc7UUFDbEJoRixRQUFRb0YsS0FBSyxHQUFHO1FBQ2hCLElBQUlyRSxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGlCQUFpQixHQUFHO29CQUNyQnZCLFFBQVFnRixPQUFPLEdBQUc3RCxPQUFPa0YsS0FBSyxHQUFHbEIsUUFBUTtvQkFDekM7Z0JBQ0osS0FBSyxlQUFlLEdBQUc7b0JBQ25CbkYsUUFBUW9GLEtBQUssR0FBR2pFLE9BQU84QyxLQUFLO29CQUM1QjtnQkFDSjtvQkFDSSxJQUFJdEMsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsc0JBQXNCLEdBQ3RCLElBQUlELFFBQVFnRixPQUFPLEtBQUssS0FDcEIxQyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFaUMsS0FBSyxDQUFDckcsUUFBUWdGLE9BQU87UUFDeEQsb0JBQW9CLEdBQ3BCLElBQUloRixRQUFRb0YsS0FBSyxLQUFLLEdBQ2xCOUMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUW9GLEtBQUs7UUFDdEQsSUFBSXpELElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWdFLFlBQVksSUFBSTNCO0FBRXRCOztDQUVDLEdBQ0QsSUFBSTRCO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOzs7O0tBSUMsR0FDREEsUUFBUSxDQUFDQSxRQUFRLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDM0MsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCOztDQUVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxpQkFBaUI7SUFDeEI7O0tBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDMUQ7O0tBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDbkQ7O0tBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDbkQ7O0tBRUMsR0FDREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDNUQsR0FBR0EscUJBQXNCQSxDQUFBQSxvQkFBb0IsQ0FBQztBQUM5Qzs7Q0FFQyxHQUNELElBQUlDO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQjs7S0FFQyxHQUNEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7SUFDcEQ7O0tBRUMsR0FDREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUN4Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ3pDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7QUFDNUMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEM7O0NBRUMsR0FDRCxJQUFJQztBQUNILFVBQVVBLFNBQVM7SUFDaEI7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BDOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDcEM7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUMzQzs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxxQkFBcUIsR0FBRyxFQUFFLEdBQUc7QUFDckQsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCOztDQUVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDMUM7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsMEJBQTBCLEdBQUcsSUFBSSxHQUFHO0lBQ3hEOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLDBCQUEwQixHQUFHLElBQUksR0FBRztJQUN4RDs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyw2QkFBNkIsR0FBRyxJQUFJLEdBQUc7SUFDM0Q7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsc0NBQXNDLEdBQUcsSUFBSSxHQUFHO0lBQ3BFOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGFBQWEsR0FBRyxJQUFJLEdBQUc7SUFDM0M7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxHQUFHO0lBQ3REOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLDRCQUE0QixHQUFHLElBQUksR0FBRztJQUMxRDs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQywrQkFBK0IsR0FBRyxJQUFJLEdBQUc7SUFDN0Q7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxHQUFHO0lBQ3REOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLCtCQUErQixHQUFHLElBQUksR0FBRztJQUM3RDs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxzQ0FBc0MsR0FBRyxJQUFJLEdBQUc7SUFDcEU7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxHQUFHO0lBQy9DOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLDRCQUE0QixHQUFHLElBQUksR0FBRztJQUMxRDs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLEdBQUc7SUFDaEQ7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLG9CQUFvQixHQUFHLElBQUksR0FBRztJQUNsRDs7S0FFQyxHQUNEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLEdBQUc7SUFDdEQ7O0tBRUMsR0FDREEsU0FBUyxDQUFDQSxTQUFTLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUc7QUFDN0MsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCOztDQUVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxPQUFPO0lBQ2Q7O0tBRUMsR0FDREEsT0FBTyxDQUFDQSxPQUFPLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUN0Qzs7S0FFQyxHQUNEQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsT0FBTyxDQUFDQSxPQUFPLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUNsQzs7S0FFQyxHQUNEQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQzlCOztLQUVDLEdBQ0RBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsT0FBTyxDQUFDQSxPQUFPLENBQUMsZUFBZSxHQUFHLEVBQUUsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0FBQ3BDLEdBQUdBLFdBQVlBLENBQUFBLFVBQVUsQ0FBQztBQUMxQjs7Q0FFQyxHQUNELElBQUlDO0FBQ0gsVUFBVUEsb0JBQW9CO0lBQzNCOzs7OztLQUtDLEdBQ0RBLG9CQUFvQixDQUFDQSxvQkFBb0IsQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHO0lBQ2hFOzs7O0tBSUMsR0FDREEsb0JBQW9CLENBQUNBLG9CQUFvQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDL0Q7Ozs7O0tBS0MsR0FDREEsb0JBQW9CLENBQUNBLG9CQUFvQixDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUN2RTs7Ozs7Ozs7S0FRQyxHQUNEQSxvQkFBb0IsQ0FBQ0Esb0JBQW9CLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNuRSxHQUFHQSx3QkFBeUJBLENBQUFBLHVCQUF1QixDQUFDO0FBQ3BEOztDQUVDLEdBQ0QsSUFBSUM7QUFDSCxVQUFVQSxZQUFZO0lBQ25COztLQUVDLEdBQ0RBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDaEQ7O0tBRUMsR0FDREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7QUFDbEQsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsMkZBQTJGO0FBQzNGLE1BQU1DLHVCQUF1QjVOLDZEQUFXQTtJQUNwQ29HLGFBQWM7UUFDVixLQUFLLENBQUMscUNBQXFDO1lBQ3ZDO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1tSDtZQUNiO1lBQ0E7Z0JBQUV4SCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFXRyxHQUFHLElBQU15RztZQUFVO1lBQ2pFO2dCQUNJOUcsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNb0g7WUFDYjtZQUNBO2dCQUNJekgsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTjZFLFFBQVEsRUFBRSxtQkFBbUI7Z0JBQzdCMUUsR0FBRyxJQUFNcUg7WUFDYjtTQUNIO0lBQ0w7SUFDQXJHLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUW1ILFlBQVksR0FBRyxFQUFFO1FBQ3pCbkgsUUFBUW9ILElBQUksR0FBRyxFQUFFO1FBQ2pCLElBQUlyRyxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLDZEQUE2RCxHQUFHO29CQUNqRXZCLFFBQVFtSCxZQUFZLENBQUMxQyxJQUFJLENBQUN1QyxZQUFZOUYsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDO29CQUNsRjtnQkFDSixLQUFLLHdDQUF3QyxHQUFHO29CQUM1Q0QsUUFBUXFILFNBQVMsR0FBR2YsVUFBVXBGLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRcUgsU0FBUztvQkFDcEc7Z0JBQ0osS0FBSyw4REFBOEQsR0FBRztvQkFDbEVySCxRQUFRc0gsZ0JBQWdCLEdBQUdMLGlCQUFpQi9GLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRc0gsZ0JBQWdCO29CQUN6SDtnQkFDSixLQUFLLDZDQUE2QyxHQUFHO29CQUNqRHRILFFBQVFvSCxJQUFJLENBQUMzQyxJQUFJLENBQUN5QyxJQUFJaEcsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDO29CQUNsRTtnQkFDSjtvQkFDSSxJQUFJMEIsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsa0VBQWtFLEdBQ2xFLElBQUssSUFBSXlFLElBQUksR0FBR0EsSUFBSTFFLFFBQVFtSCxZQUFZLENBQUMvRixNQUFNLEVBQUVzRCxJQUM3Q3NDLFlBQVkzRSxtQkFBbUIsQ0FBQ3JDLFFBQVFtSCxZQUFZLENBQUN6QyxFQUFFLEVBQUVwQyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMxSCw2Q0FBNkMsR0FDN0MsSUFBSTFDLFFBQVFxSCxTQUFTLEVBQ2pCZixVQUFVakUsbUJBQW1CLENBQUNyQyxRQUFRcUgsU0FBUyxFQUFFL0UsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDbEgsbUVBQW1FLEdBQ25FLElBQUkxQyxRQUFRc0gsZ0JBQWdCLEVBQ3hCTCxpQkFBaUI1RSxtQkFBbUIsQ0FBQ3JDLFFBQVFzSCxnQkFBZ0IsRUFBRWhGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2hJLGtEQUFrRCxHQUNsRCxJQUFLLElBQUlnQyxJQUFJLEdBQUdBLElBQUkxRSxRQUFRb0gsSUFBSSxDQUFDaEcsTUFBTSxFQUFFc0QsSUFDckN3QyxJQUFJN0UsbUJBQW1CLENBQUNyQyxRQUFRb0gsSUFBSSxDQUFDMUMsRUFBRSxFQUFFcEMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDMUcsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNaUYsY0FBYyxJQUFJUjtBQUN4QiwyRkFBMkY7QUFDM0YsTUFBTVMsOEJBQThCck8sNkRBQVdBO0lBQzNDb0csYUFBYztRQUNWLEtBQUssQ0FBQyw0Q0FBNEM7WUFDOUM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVVHLEdBQUcsR0FBRyxtQkFBbUI7WUFBRztZQUNwRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBYUMsTUFBTTtnQkFBVUcsR0FBRyxHQUFHLG1CQUFtQjtZQUFHO1NBQzNFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUXlILEtBQUssR0FBRztRQUNoQnpILFFBQVEwSCxTQUFTLEdBQUc7UUFDcEIsSUFBSTNHLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssZ0JBQWdCLEdBQUc7b0JBQ3BCdkIsUUFBUXlILEtBQUssR0FBR3RHLE9BQU9jLE1BQU07b0JBQzdCO2dCQUNKLEtBQUssb0JBQW9CLEdBQUc7b0JBQ3hCakMsUUFBUTBILFNBQVMsR0FBR3ZHLE9BQU9jLE1BQU07b0JBQ2pDO2dCQUNKO29CQUNJLElBQUlOLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLHFCQUFxQixHQUNyQixJQUFJRCxRQUFReUgsS0FBSyxLQUFLLEdBQ2xCbkYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRW5DLE1BQU0sQ0FBQ2pDLFFBQVF5SCxLQUFLO1FBQ3ZELHlCQUF5QixHQUN6QixJQUFJekgsUUFBUTBILFNBQVMsS0FBSyxHQUN0QnBGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVuQyxNQUFNLENBQUNqQyxRQUFRMEgsU0FBUztRQUMzRCxJQUFJL0YsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNMkUsbUJBQW1CLElBQUlPO0FBQzdCLDJGQUEyRjtBQUMzRixNQUFNRyxpQkFBaUJ4Tyw2REFBV0E7SUFDOUJvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLCtCQUErQjtZQUNqQztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBV0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3JFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7U0FDM0U7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRNEgsTUFBTSxHQUFHO1FBQ2pCNUgsUUFBUTZILFNBQVMsR0FBRztRQUNwQixJQUFJOUcsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJ2QixRQUFRNEgsTUFBTSxHQUFHekcsT0FBT2lCLE1BQU07b0JBQzlCO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCcEMsUUFBUTZILFNBQVMsR0FBRzFHLE9BQU9pQixNQUFNO29CQUNqQztnQkFDSjtvQkFDSSxJQUFJVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyx1QkFBdUIsR0FDdkIsSUFBSUQsUUFBUTRILE1BQU0sS0FBSyxJQUNuQnRGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE0SCxNQUFNO1FBQ2pFLDBCQUEwQixHQUMxQixJQUFJNUgsUUFBUTZILFNBQVMsS0FBSyxJQUN0QnZGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE2SCxTQUFTO1FBQ3BFLElBQUlsRyxJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU00RSxNQUFNLElBQUlTO0FBQ2hCLDJGQUEyRjtBQUMzRixNQUFNRyx5QkFBeUIzTyw2REFBV0E7SUFDdENvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHVDQUF1QztZQUN6QztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBV0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3JFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDeEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ042RSxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QjFFLEdBQUcsSUFBTTt3QkFDTDt3QkFDQTZHO3dCQUNBO3FCQUNIO1lBQ0w7WUFDQTtnQkFBRWxILElBQUk7Z0JBQUdDLE1BQU07Z0JBQWFDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTXlHO1lBQVU7WUFDaEU7Z0JBQ0k5RyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLEVBQUUsbUJBQW1CO1lBQzVCO1lBQ0E7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTTt3QkFDTDt3QkFDQTJHO3dCQUNBO3FCQUNIO1lBQ0w7WUFDQTtnQkFBRWhILElBQUk7Z0JBQUdDLE1BQU07Z0JBQWVDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxpQkFBaUI7WUFBRztZQUN2RTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLGlCQUFpQjtZQUMxQjtZQUNBO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsa0JBQWtCO1lBQUc7WUFDeEU7Z0JBQUVMLElBQUk7Z0JBQUlDLE1BQU07Z0JBQVFDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNuRTtnQkFBRUwsSUFBSTtnQkFBSUMsTUFBTTtnQkFBU0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3BFO2dCQUFFTCxJQUFJO2dCQUFJQyxNQUFNO2dCQUFVQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1nRDtZQUFPO1lBQzNEO2dCQUNJckQsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTjZFLFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CMUUsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtTQUNIO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTRILE1BQU0sR0FBRztRQUNqQjVILFFBQVE2SCxTQUFTLEdBQUc7UUFDcEI3SCxRQUFRK0gsZUFBZSxHQUFHLEVBQUU7UUFDNUIvSCxRQUFRZ0ksaUJBQWlCLEdBQUc7UUFDNUJoSSxRQUFRaUksaUJBQWlCLEdBQUc7UUFDNUJqSSxRQUFRa0ksVUFBVSxHQUFHO1FBQ3JCbEksUUFBUW1JLGlCQUFpQixHQUFHO1FBQzVCbkksUUFBUW9JLFVBQVUsR0FBRztRQUNyQnBJLFFBQVFQLElBQUksR0FBRztRQUNmTyxRQUFRcUksS0FBSyxHQUFHO1FBQ2hCckksUUFBUXNJLEtBQUssR0FBRyxFQUFFO1FBQ2xCLElBQUl2SCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGtCQUFrQixHQUFHO29CQUN0QnZCLFFBQVE0SCxNQUFNLEdBQUd6RyxPQUFPaUIsTUFBTTtvQkFDOUI7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJwQyxRQUFRNkgsU0FBUyxHQUFHMUcsT0FBT2lCLE1BQU07b0JBQ2pDO2dCQUNKLEtBQUssK0RBQStELEdBQUc7b0JBQ25FLElBQUlaLGFBQWFoSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFDckMsSUFBSyxJQUFJK0YsSUFBSXBILE9BQU84QyxLQUFLLEtBQUs5QyxPQUFPRyxHQUFHLEVBQUVILE9BQU9HLEdBQUcsR0FBR2lILEdBQ25EdkksUUFBUStILGVBQWUsQ0FBQ3RELElBQUksQ0FBQ3RELE9BQU84QyxLQUFLO3lCQUU3Q2pFLFFBQVErSCxlQUFlLENBQUN0RCxJQUFJLENBQUN0RCxPQUFPOEMsS0FBSztvQkFDN0M7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0NqRSxRQUFRd0ksUUFBUSxHQUFHbEMsVUFBVXBGLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRd0ksUUFBUTtvQkFDbEc7Z0JBQ0osS0FBSyw4QkFBOEIsR0FBRztvQkFDbEN4SSxRQUFRZ0ksaUJBQWlCLEdBQUc3RyxPQUFPaUIsTUFBTTtvQkFDekM7Z0JBQ0osS0FBSyxnRUFBZ0UsR0FBRztvQkFDcEVwQyxRQUFRaUksaUJBQWlCLEdBQUc5RyxPQUFPOEMsS0FBSztvQkFDeEM7Z0JBQ0osS0FBSyxvQkFBb0IsR0FBRztvQkFDeEJqRSxRQUFRa0ksVUFBVSxHQUFHL0csT0FBT2dELElBQUk7b0JBQ2hDO2dCQUNKLEtBQUssNEJBQTRCLEdBQUc7b0JBQ2hDbkUsUUFBUW1JLGlCQUFpQixHQUFHaEgsT0FBT2dELElBQUk7b0JBQ3ZDO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCbkUsUUFBUW9JLFVBQVUsR0FBR2pILE9BQU9zSCxLQUFLO29CQUNqQztnQkFDSixLQUFLLGVBQWUsR0FBRztvQkFDbkJ6SSxRQUFRUCxJQUFJLEdBQUcwQixPQUFPaUIsTUFBTTtvQkFDNUI7Z0JBQ0osS0FBSyxnQkFBZ0IsR0FBRztvQkFDcEJwQyxRQUFRcUksS0FBSyxHQUFHbEgsT0FBT2lCLE1BQU07b0JBQzdCO2dCQUNKLEtBQUssaUNBQWlDLEdBQUc7b0JBQ3JDcEMsUUFBUTBJLE1BQU0sR0FBRzdGLE9BQU8zQixrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUTBJLE1BQU07b0JBQzNGO2dCQUNKLEtBQUsseUJBQXlCLEdBQUc7b0JBQzdCMUksUUFBUXNJLEtBQUssQ0FBQzdELElBQUksQ0FBQ3RELE9BQU9pQixNQUFNO29CQUNoQztnQkFDSjtvQkFDSSxJQUFJVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyx1QkFBdUIsR0FDdkIsSUFBSUQsUUFBUTRILE1BQU0sS0FBSyxJQUNuQnRGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE0SCxNQUFNO1FBQ2pFLDBCQUEwQixHQUMxQixJQUFJNUgsUUFBUTZILFNBQVMsS0FBSyxJQUN0QnZGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE2SCxTQUFTO1FBQ3BFLG9FQUFvRSxHQUNwRSxJQUFJN0gsUUFBUStILGVBQWUsQ0FBQzNHLE1BQU0sRUFBRTtZQUNoQ2tCLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUk7WUFDNUMsSUFBSyxJQUFJaUMsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUStILGVBQWUsQ0FBQzNHLE1BQU0sRUFBRXNELElBQ2hEcEMsT0FBTzJCLEtBQUssQ0FBQ2pFLFFBQVErSCxlQUFlLENBQUNyRCxFQUFFO1lBQzNDcEMsT0FBT0ksSUFBSTtRQUNmO1FBQ0EsNENBQTRDLEdBQzVDLElBQUkxQyxRQUFRd0ksUUFBUSxFQUNoQmxDLFVBQVVqRSxtQkFBbUIsQ0FBQ3JDLFFBQVF3SSxRQUFRLEVBQUVsRyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUNqSCxtQ0FBbUMsR0FDbkMsSUFBSTFDLFFBQVFnSSxpQkFBaUIsS0FBSyxJQUM5QjFGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVFnSSxpQkFBaUI7UUFDNUUscUVBQXFFLEdBQ3JFLElBQUloSSxRQUFRaUksaUJBQWlCLEtBQUssR0FDOUIzRixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFSCxLQUFLLENBQUNqRSxRQUFRaUksaUJBQWlCO1FBQ2xFLHlCQUF5QixHQUN6QixJQUFJakksUUFBUWtJLFVBQVUsS0FBSyxPQUN2QjVGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVFrSSxVQUFVO1FBQzFELGlDQUFpQyxHQUNqQyxJQUFJbEksUUFBUW1JLGlCQUFpQixLQUFLLE9BQzlCN0YsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUQsSUFBSSxDQUFDbkUsUUFBUW1JLGlCQUFpQjtRQUNqRSwwQkFBMEIsR0FDMUIsSUFBSW5JLFFBQVFvSSxVQUFVLEtBQUssR0FDdkI5RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDbVAsS0FBSyxFQUFFRixLQUFLLENBQUN6SSxRQUFRb0ksVUFBVTtRQUMxRCxxQkFBcUIsR0FDckIsSUFBSXBJLFFBQVFQLElBQUksS0FBSyxJQUNqQjZDLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVFQLElBQUk7UUFDaEUsc0JBQXNCLEdBQ3RCLElBQUlPLFFBQVFxSSxLQUFLLEtBQUssSUFDbEIvRixPQUFPYixHQUFHLENBQUMsSUFBSWpJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRcUksS0FBSztRQUNqRSx1Q0FBdUMsR0FDdkMsSUFBSXJJLFFBQVEwSSxNQUFNLEVBQ2Q3RixPQUFPUixtQkFBbUIsQ0FBQ3JDLFFBQVEwSSxNQUFNLEVBQUVwRyxPQUFPYixHQUFHLENBQUMsSUFBSWpJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUM3RywrQkFBK0IsR0FDL0IsSUFBSyxJQUFJZ0MsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUXNJLEtBQUssQ0FBQ2xILE1BQU0sRUFBRXNELElBQ3RDcEMsT0FBT2IsR0FBRyxDQUFDLElBQUlqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUXNJLEtBQUssQ0FBQzVELEVBQUU7UUFDcEUsSUFBSS9DLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTBFLGNBQWMsSUFBSWM7QUFDeEIsMkZBQTJGO0FBQzNGLE1BQU1jLDJCQUEyQnpQLDZEQUFXQTtJQUN4Q29HLGFBQWM7UUFDVixLQUFLLENBQUMseUNBQXlDO1lBQzNDO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU07d0JBQ0w7d0JBQ0E0Rzt3QkFDQTtxQkFDSDtZQUNMO1lBQ0E7Z0JBQUVqSCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFXQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7U0FDeEU7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRNkksWUFBWSxHQUFHO1FBQ3ZCN0ksUUFBUTRILE1BQU0sR0FBRztRQUNqQixJQUFJN0csVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxzREFBc0QsR0FBRztvQkFDMUR2QixRQUFRNkksWUFBWSxHQUFHMUgsT0FBTzhDLEtBQUs7b0JBQ25DO2dCQUNKLEtBQUssa0JBQWtCLEdBQUc7b0JBQ3RCakUsUUFBUTRILE1BQU0sR0FBR3pHLE9BQU9pQixNQUFNO29CQUM5QjtnQkFDSjtvQkFDSSxJQUFJVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywyREFBMkQsR0FDM0QsSUFBSUQsUUFBUTZJLFlBQVksS0FBSyxHQUN6QnZHLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVE2SSxZQUFZO1FBQzdELHVCQUF1QixHQUN2QixJQUFJN0ksUUFBUTRILE1BQU0sS0FBSyxJQUNuQnRGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE0SCxNQUFNO1FBQ2pFLElBQUlqRyxJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU13RyxnQkFBZ0IsSUFBSUY7QUFDMUIsMkZBQTJGO0FBQzNGLE1BQU1HLDRCQUE0QjVQLDZEQUFXQTtJQUN6Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsMENBQTBDO1lBQzVDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFTQyxNQUFNO2dCQUFVRyxHQUFHLEdBQUcsbUJBQW1CO1lBQUc7WUFDcEU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVVDLE1BQU07Z0JBQVVHLEdBQUcsR0FBRyxtQkFBbUI7WUFBRztTQUN4RTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFnSixLQUFLLEdBQUc7UUFDaEJoSixRQUFRaUosTUFBTSxHQUFHO1FBQ2pCLElBQUlsSSxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGdCQUFnQixHQUFHO29CQUNwQnZCLFFBQVFnSixLQUFLLEdBQUc3SCxPQUFPYyxNQUFNO29CQUM3QjtnQkFDSixLQUFLLGlCQUFpQixHQUFHO29CQUNyQmpDLFFBQVFpSixNQUFNLEdBQUc5SCxPQUFPYyxNQUFNO29CQUM5QjtnQkFDSjtvQkFDSSxJQUFJTixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxxQkFBcUIsR0FDckIsSUFBSUQsUUFBUWdKLEtBQUssS0FBSyxHQUNsQjFHLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVuQyxNQUFNLENBQUNqQyxRQUFRZ0osS0FBSztRQUN2RCxzQkFBc0IsR0FDdEIsSUFBSWhKLFFBQVFpSixNQUFNLEtBQUssR0FDbkIzRyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFbkMsTUFBTSxDQUFDakMsUUFBUWlKLE1BQU07UUFDeEQsSUFBSXRILElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTRHLGlCQUFpQixJQUFJSDtBQUMzQiwyRkFBMkY7QUFDM0YsTUFBTUksd0JBQXdCaFEsNkRBQVdBO0lBQ3JDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxzQ0FBc0M7WUFDeEM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQU9DLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNqRTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNcUo7WUFDYjtZQUNBO2dCQUFFMUosSUFBSTtnQkFBR0MsTUFBTTtnQkFBV0MsTUFBTTtnQkFBVUcsR0FBRyxHQUFHLG1CQUFtQjtZQUFHO1lBQ3RFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFPQyxNQUFNO2dCQUFVRyxHQUFHLEdBQUcsbUJBQW1CO1lBQUc7WUFDbEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTTt3QkFDTDt3QkFDQTRHO3dCQUNBO3FCQUNIO1lBQ0w7U0FDSDtJQUNMO0lBQ0E1RixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFvSixHQUFHLEdBQUc7UUFDZHBKLFFBQVFxSixPQUFPLEdBQUc7UUFDbEJySixRQUFRc0osR0FBRyxHQUFHO1FBQ2R0SixRQUFRdUosT0FBTyxHQUFHO1FBQ2xCLElBQUl4SSxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGNBQWMsR0FBRztvQkFDbEJ2QixRQUFRb0osR0FBRyxHQUFHakksT0FBT2lCLE1BQU07b0JBQzNCO2dCQUNKLEtBQUssMERBQTBELEdBQUc7b0JBQzlEcEMsUUFBUXdKLGNBQWMsR0FBR04sZUFBZWhJLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRd0osY0FBYztvQkFDbkg7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJ4SixRQUFRcUosT0FBTyxHQUFHbEksT0FBT2MsTUFBTTtvQkFDL0I7Z0JBQ0osS0FBSyxjQUFjLEdBQUc7b0JBQ2xCakMsUUFBUXNKLEdBQUcsR0FBR25JLE9BQU9jLE1BQU07b0JBQzNCO2dCQUNKLEtBQUssZ0RBQWdELEdBQUc7b0JBQ3BEakMsUUFBUXVKLE9BQU8sR0FBR3BJLE9BQU84QyxLQUFLO29CQUM5QjtnQkFDSjtvQkFDSSxJQUFJdEMsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbUJBQW1CLEdBQ25CLElBQUlELFFBQVFvSixHQUFHLEtBQUssSUFDaEI5RyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRb0osR0FBRztRQUM5RCwrREFBK0QsR0FDL0QsSUFBSXBKLFFBQVF3SixjQUFjLEVBQ3RCTixlQUFlN0csbUJBQW1CLENBQUNyQyxRQUFRd0osY0FBYyxFQUFFbEgsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDNUgsdUJBQXVCLEdBQ3ZCLElBQUkxQyxRQUFRcUosT0FBTyxLQUFLLEdBQ3BCL0csT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRW5DLE1BQU0sQ0FBQ2pDLFFBQVFxSixPQUFPO1FBQ3pELG1CQUFtQixHQUNuQixJQUFJckosUUFBUXNKLEdBQUcsS0FBSyxHQUNoQmhILE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVuQyxNQUFNLENBQUNqQyxRQUFRc0osR0FBRztRQUNyRCxxREFBcUQsR0FDckQsSUFBSXRKLFFBQVF1SixPQUFPLEtBQUssR0FDcEJqSCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFSCxLQUFLLENBQUNqRSxRQUFRdUosT0FBTztRQUN4RCxJQUFJNUgsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNbUgsYUFBYSxJQUFJTjtBQUN2QiwyRkFBMkY7QUFDM0YsTUFBTU8sbUJBQW1CdlEsNkRBQVdBO0lBQ2hDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxpQ0FBaUM7WUFDbkM7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsR0FBRyxtQkFBbUI7WUFDN0I7WUFDQTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBUUMsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ2xFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFhQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDdkU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsR0FBRyxtQkFBbUI7WUFDN0I7WUFDQTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtZQUNBO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLHFCQUFxQjtnQkFDL0IxRSxHQUFHLEVBQUUsbUJBQW1CO1lBQzVCO1NBQ0g7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRMkosV0FBVyxHQUFHO1FBQ3RCM0osUUFBUVAsSUFBSSxHQUFHO1FBQ2ZPLFFBQVE0SixRQUFRLEdBQUc7UUFDbkI1SixRQUFRNkosU0FBUyxHQUFHO1FBQ3BCN0osUUFBUThKLGtCQUFrQixHQUFHO1FBQzdCOUosUUFBUStKLFNBQVMsR0FBRyxFQUFFO1FBQ3RCLElBQUloSixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLHVCQUF1QixHQUFHO29CQUMzQnZCLFFBQVEySixXQUFXLEdBQUd4SSxPQUFPYyxNQUFNO29CQUNuQztnQkFDSixLQUFLLGVBQWUsR0FBRztvQkFDbkJqQyxRQUFRUCxJQUFJLEdBQUcwQixPQUFPaUIsTUFBTTtvQkFDNUI7Z0JBQ0osS0FBSyxvQkFBb0IsR0FBRztvQkFDeEJwQyxRQUFRNEosUUFBUSxHQUFHekksT0FBT2lCLE1BQU07b0JBQ2hDO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCcEMsUUFBUTZKLFNBQVMsR0FBRzFJLE9BQU9jLE1BQU07b0JBQ2pDO2dCQUNKLEtBQUssOEJBQThCLEdBQUc7b0JBQ2xDakMsUUFBUThKLGtCQUFrQixHQUFHM0ksT0FBT2lCLE1BQU07b0JBQzFDO2dCQUNKLEtBQUssNkJBQTZCLEdBQUc7b0JBQ2pDcEMsUUFBUStKLFNBQVMsQ0FBQ3RGLElBQUksQ0FBQ3RELE9BQU9pQixNQUFNO29CQUNwQztnQkFDSjtvQkFDSSxJQUFJVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyw0QkFBNEIsR0FDNUIsSUFBSUQsUUFBUTJKLFdBQVcsS0FBSyxHQUN4QnJILE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVuQyxNQUFNLENBQUNqQyxRQUFRMkosV0FBVztRQUM3RCxvQkFBb0IsR0FDcEIsSUFBSTNKLFFBQVFQLElBQUksS0FBSyxJQUNqQjZDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVFQLElBQUk7UUFDL0QseUJBQXlCLEdBQ3pCLElBQUlPLFFBQVE0SixRQUFRLEtBQUssSUFDckJ0SCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNEosUUFBUTtRQUNuRSwwQkFBMEIsR0FDMUIsSUFBSTVKLFFBQVE2SixTQUFTLEtBQUssR0FDdEJ2SCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFbkMsTUFBTSxDQUFDakMsUUFBUTZKLFNBQVM7UUFDM0QsbUNBQW1DLEdBQ25DLElBQUk3SixRQUFROEosa0JBQWtCLEtBQUssSUFDL0J4SCxPQUNLYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUMvQkosTUFBTSxDQUFDcEMsUUFBUThKLGtCQUFrQjtRQUMxQyxrQ0FBa0MsR0FDbEMsSUFBSyxJQUFJcEYsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUStKLFNBQVMsQ0FBQzNJLE1BQU0sRUFBRXNELElBQzFDcEMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUStKLFNBQVMsQ0FBQ3JGLEVBQUU7UUFDdkUsSUFBSS9DLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTBILFFBQVEsSUFBSU47QUFDbEIsMkZBQTJGO0FBQzNGLElBQUlPLG9CQUFvQixNQUFNQyx3QkFBd0IvUSw2REFBV0E7SUFDN0RvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHNDQUFzQztZQUN4QztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUFDO3dCQUFvQzBHO3dCQUFVO3FCQUFhO1lBQ3pFO1lBQ0E7Z0JBQ0kvRyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLEVBQUUsbUJBQW1CO1lBQzVCO1lBQ0E7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQWNDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztTQUMzRTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFtSyxRQUFRLEdBQUc7UUFDbkJuSyxRQUFRb0ssWUFBWSxHQUFHO1FBQ3ZCcEssUUFBUTZILFNBQVMsR0FBRztRQUNwQixJQUFJOUcsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyw4Q0FBOEMsR0FBRztvQkFDbER2QixRQUFRbUssUUFBUSxHQUFHaEosT0FBTzhDLEtBQUs7b0JBQy9CO2dCQUNKLEtBQUssd0JBQXdCLEdBQUc7b0JBQzVCakUsUUFBUW9LLFlBQVksR0FBR2pKLE9BQU9pQixNQUFNO29CQUNwQztnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6QnBDLFFBQVE2SCxTQUFTLEdBQUcxRyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0o7b0JBQ0ksSUFBSVQsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbURBQW1ELEdBQ25ELElBQUlELFFBQVFtSyxRQUFRLEtBQUssR0FDckI3SCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFSCxLQUFLLENBQUNqRSxRQUFRbUssUUFBUTtRQUN6RCw2QkFBNkIsR0FDN0IsSUFBSW5LLFFBQVFvSyxZQUFZLEtBQUssSUFDekI5SCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRb0ssWUFBWTtRQUN2RSwwQkFBMEIsR0FDMUIsSUFBSXBLLFFBQVE2SCxTQUFTLEtBQUssSUFDdEJ2RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNkgsU0FBUztRQUNwRSxJQUFJbEcsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNK0gsZUFBZSxJQUFJSjtBQUN6QiwyRkFBMkY7QUFDM0YsTUFBTUssdUJBQXVCblIsNkRBQVdBO0lBQ3BDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxxQ0FBcUM7WUFDdkM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVlDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUN0RTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUNMO3dCQUNBNkc7d0JBQ0E7cUJBQ0g7WUFDTDtZQUNBO2dCQUNJbEgsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTjZFLFFBQVEsRUFBRSxtQkFBbUI7Z0JBQzdCMUUsR0FBRyxJQUFNNEo7WUFDYjtZQUNBO2dCQUFFakssSUFBSTtnQkFBR0MsTUFBTTtnQkFBT0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ2pFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFPQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsaUJBQWlCO1lBQUc7WUFDL0Q7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVVDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxpQkFBaUI7WUFBRztZQUNsRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBT0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLGlCQUFpQjtZQUFHO1NBQ2xFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUXVLLE9BQU8sR0FBRztRQUNsQnZLLFFBQVF3SyxTQUFTLEdBQUc7UUFDcEJ4SyxRQUFReUssTUFBTSxHQUFHLEVBQUU7UUFDbkJ6SyxRQUFRMEssR0FBRyxHQUFHO1FBQ2QxSyxRQUFRMkssR0FBRyxHQUFHO1FBQ2QzSyxRQUFRNEssTUFBTSxHQUFHO1FBQ2pCNUssUUFBUTZLLEdBQUcsR0FBRztRQUNkLElBQUk5SixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLG1CQUFtQixHQUFHO29CQUN2QnZCLFFBQVF1SyxPQUFPLEdBQUdwSixPQUFPaUIsTUFBTTtvQkFDL0I7Z0JBQ0osS0FBSyxnREFBZ0QsR0FBRztvQkFDcERwQyxRQUFRd0ssU0FBUyxHQUFHckosT0FBTzhDLEtBQUs7b0JBQ2hDO2dCQUNKLEtBQUssc0RBQXNELEdBQUc7b0JBQzFEakUsUUFBUXlLLE1BQU0sQ0FBQ2hHLElBQUksQ0FBQ2dGLFdBQVd2SSxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEM7b0JBQzNFO2dCQUNKLEtBQUssY0FBYyxHQUFHO29CQUNsQkQsUUFBUTBLLEdBQUcsR0FBR3ZKLE9BQU9pQixNQUFNO29CQUMzQjtnQkFDSixLQUFLLFlBQVksR0FBRztvQkFDaEJwQyxRQUFRMkssR0FBRyxHQUFHeEosT0FBT2dELElBQUk7b0JBQ3pCO2dCQUNKLEtBQUssZUFBZSxHQUFHO29CQUNuQm5FLFFBQVE0SyxNQUFNLEdBQUd6SixPQUFPZ0QsSUFBSTtvQkFDNUI7Z0JBQ0osS0FBSyxZQUFZLEdBQUc7b0JBQ2hCbkUsUUFBUTZLLEdBQUcsR0FBRzFKLE9BQU9nRCxJQUFJO29CQUN6QjtnQkFDSjtvQkFDSSxJQUFJeEMsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsd0JBQXdCLEdBQ3hCLElBQUlELFFBQVF1SyxPQUFPLEtBQUssSUFDcEJqSSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRdUssT0FBTztRQUNsRSxxREFBcUQsR0FDckQsSUFBSXZLLFFBQVF3SyxTQUFTLEtBQUssR0FDdEJsSSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFSCxLQUFLLENBQUNqRSxRQUFRd0ssU0FBUztRQUMxRCwyREFBMkQsR0FDM0QsSUFBSyxJQUFJOUYsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUXlLLE1BQU0sQ0FBQ3JKLE1BQU0sRUFBRXNELElBQ3ZDK0UsV0FBV3BILG1CQUFtQixDQUFDckMsUUFBUXlLLE1BQU0sQ0FBQy9GLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ25ILG1CQUFtQixHQUNuQixJQUFJMUMsUUFBUTBLLEdBQUcsS0FBSyxJQUNoQnBJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVEwSyxHQUFHO1FBQzlELGlCQUFpQixHQUNqQixJQUFJMUssUUFBUTJLLEdBQUcsS0FBSyxPQUNoQnJJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVEySyxHQUFHO1FBQ25ELG9CQUFvQixHQUNwQixJQUFJM0ssUUFBUTRLLE1BQU0sS0FBSyxPQUNuQnRJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVE0SyxNQUFNO1FBQ3RELGlCQUFpQixHQUNqQixJQUFJNUssUUFBUTZLLEdBQUcsS0FBSyxPQUNoQnZJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVE2SyxHQUFHO1FBQ25ELElBQUlsSixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU13SSxZQUFZLElBQUlSO0FBQ3RCLDJGQUEyRjtBQUMzRixNQUFNUyxrQkFBa0I1Uiw2REFBV0E7SUFDL0JvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLGdDQUFnQztZQUNsQztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBUUMsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ2xFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFNQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDaEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsRUFBRSxtQkFBbUI7WUFDNUI7WUFDQTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtZQUNBO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFVQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1nRDtZQUFPO1lBQzFEO2dCQUFFckQsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBV0csR0FBRyxJQUFNeUc7WUFBVTtZQUNqRTtnQkFBRTlHLElBQUk7Z0JBQUdDLE1BQU07Z0JBQWNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTXlHO1lBQVU7U0FDcEU7SUFDTDtJQUNBekYsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRZ0wsSUFBSSxHQUFHO1FBQ2ZoTCxRQUFRaUwsRUFBRSxHQUFHO1FBQ2JqTCxRQUFRa0wsZUFBZSxHQUFHO1FBQzFCbEwsUUFBUW1MLFVBQVUsR0FBRztRQUNyQixJQUFJcEssVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxlQUFlLEdBQUc7b0JBQ25CdkIsUUFBUWdMLElBQUksR0FBRzdKLE9BQU9pQixNQUFNO29CQUM1QjtnQkFDSixLQUFLLGFBQWEsR0FBRztvQkFDakJwQyxRQUFRaUwsRUFBRSxHQUFHOUosT0FBT2lCLE1BQU07b0JBQzFCO2dCQUNKLEtBQUssNkJBQTZCLEdBQUc7b0JBQ2pDcEMsUUFBUWtMLGVBQWUsR0FBRy9KLE9BQU9pQixNQUFNO29CQUN2QztnQkFDSixLQUFLLHVCQUF1QixHQUFHO29CQUMzQnBDLFFBQVFtTCxVQUFVLEdBQUdoSyxPQUFPaUIsTUFBTTtvQkFDbEM7Z0JBQ0osS0FBSyxpQ0FBaUMsR0FBRztvQkFDckNwQyxRQUFRMEksTUFBTSxHQUFHN0YsT0FBTzNCLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRMEksTUFBTTtvQkFDM0Y7Z0JBQ0osS0FBSyx3Q0FBd0MsR0FBRztvQkFDNUMxSSxRQUFRb0wsU0FBUyxHQUFHOUUsVUFBVXBGLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRb0wsU0FBUztvQkFDcEc7Z0JBQ0osS0FBSyx3Q0FBd0MsR0FBRztvQkFDNUNwTCxRQUFRcUwsU0FBUyxHQUFHL0UsVUFBVXBGLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRcUwsU0FBUztvQkFDcEc7Z0JBQ0o7b0JBQ0ksSUFBSTFKLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLG9CQUFvQixHQUNwQixJQUFJRCxRQUFRZ0wsSUFBSSxLQUFLLElBQ2pCMUksT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUWdMLElBQUk7UUFDL0Qsa0JBQWtCLEdBQ2xCLElBQUloTCxRQUFRaUwsRUFBRSxLQUFLLElBQ2YzSSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRaUwsRUFBRTtRQUM3RCxrQ0FBa0MsR0FDbEMsSUFBSWpMLFFBQVFrTCxlQUFlLEtBQUssSUFDNUI1SSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRa0wsZUFBZTtRQUMxRSw0QkFBNEIsR0FDNUIsSUFBSWxMLFFBQVFtTCxVQUFVLEtBQUssSUFDdkI3SSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRbUwsVUFBVTtRQUNyRSxzQ0FBc0MsR0FDdEMsSUFBSW5MLFFBQVEwSSxNQUFNLEVBQ2Q3RixPQUFPUixtQkFBbUIsQ0FBQ3JDLFFBQVEwSSxNQUFNLEVBQUVwRyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUM1Ryw2Q0FBNkMsR0FDN0MsSUFBSTFDLFFBQVFvTCxTQUFTLEVBQ2pCOUUsVUFBVWpFLG1CQUFtQixDQUFDckMsUUFBUW9MLFNBQVMsRUFBRTlJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2xILDZDQUE2QyxHQUM3QyxJQUFJMUMsUUFBUXFMLFNBQVMsRUFDakIvRSxVQUFVakUsbUJBQW1CLENBQUNyQyxRQUFRcUwsU0FBUyxFQUFFL0ksT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDbEgsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNZ0osU0FBUyxJQUFJUDtBQUNuQiwyRkFBMkY7QUFDM0YsSUFBSVEsZUFBZSxNQUFNQyxtQkFBbUJyUyw2REFBV0E7SUFDbkRvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLGlDQUFpQztZQUNuQztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUNMO3dCQUNBOEc7d0JBQ0E7cUJBQ0g7WUFDTDtZQUNBO2dCQUFFbkgsSUFBSTtnQkFBR0MsTUFBTTtnQkFBV0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3JFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFnQkMsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLGlCQUFpQjtZQUFHO1NBQzNFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUXlMLElBQUksR0FBRztRQUNmekwsUUFBUUEsT0FBTyxHQUFHO1FBQ2xCQSxRQUFRMEwsV0FBVyxHQUFHO1FBQ3RCLElBQUkzSyxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLDBDQUEwQyxHQUFHO29CQUM5Q3ZCLFFBQVF5TCxJQUFJLEdBQUd0SyxPQUFPOEMsS0FBSztvQkFDM0I7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJqRSxRQUFRQSxPQUFPLEdBQUdtQixPQUFPaUIsTUFBTTtvQkFDL0I7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJwQyxRQUFRMEwsV0FBVyxHQUFHdkssT0FBT2dELElBQUk7b0JBQ2pDO2dCQUNKO29CQUNJLElBQUl4QyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywrQ0FBK0MsR0FDL0MsSUFBSUQsUUFBUXlMLElBQUksS0FBSyxHQUNqQm5KLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVF5TCxJQUFJO1FBQ3JELHVCQUF1QixHQUN2QixJQUFJekwsUUFBUUEsT0FBTyxLQUFLLElBQ3BCc0MsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUUEsT0FBTztRQUNsRSwwQkFBMEIsR0FDMUIsSUFBSUEsUUFBUTBMLFdBQVcsS0FBSyxPQUN4QnBKLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVEwTCxXQUFXO1FBQzNELElBQUkvSixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1xSixVQUFVLElBQUlKO0FBQ3BCLDJGQUEyRjtBQUMzRixNQUFNSywyQkFBMkJ6Uyw2REFBV0E7SUFDeENvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHlDQUF5QztZQUMzQztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBT0MsTUFBTTtnQkFBV0csR0FBRyxJQUFNZ007WUFBSTtZQUNwRDtnQkFBRXJNLElBQUk7Z0JBQUdDLE1BQU07Z0JBQU1DLE1BQU07Z0JBQVdHLEdBQUcsSUFBTWlNO1lBQUc7WUFDbEQ7Z0JBQUV0TSxJQUFJO2dCQUFHQyxNQUFNO2dCQUFXQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1rTTtZQUFRO1lBQzVEO2dCQUFFdk0sSUFBSTtnQkFBR0MsTUFBTTtnQkFBVUMsTUFBTTtnQkFBV0csR0FBRyxJQUFNbU07WUFBTztTQUM3RDtJQUNMO0lBQ0FuTCxPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RCxJQUFJRCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLG1DQUFtQyxHQUFHO29CQUN2Q3ZCLFFBQVFpTSxHQUFHLEdBQUdKLElBQUkzSyxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUWlNLEdBQUc7b0JBQ2xGO2dCQUNKLEtBQUssaUNBQWlDLEdBQUc7b0JBQ3JDak0sUUFBUWtNLEVBQUUsR0FBR0osR0FBRzVLLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRa00sRUFBRTtvQkFDL0U7Z0JBQ0osS0FBSywyQ0FBMkMsR0FBRztvQkFDL0NsTSxRQUFRbU0sT0FBTyxHQUFHSixRQUFRN0ssa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFtTSxPQUFPO29CQUM5RjtnQkFDSixLQUFLLHlDQUF5QyxHQUFHO29CQUM3Q25NLFFBQVFvTSxNQUFNLEdBQUdKLE9BQU85SyxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW9NLE1BQU07b0JBQzNGO2dCQUNKO29CQUNJLElBQUl6SyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyx3Q0FBd0MsR0FDeEMsSUFBSUQsUUFBUWlNLEdBQUcsRUFDWEosSUFBSXhKLG1CQUFtQixDQUFDckMsUUFBUWlNLEdBQUcsRUFBRTNKLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3RHLHNDQUFzQyxHQUN0QyxJQUFJMUMsUUFBUWtNLEVBQUUsRUFDVkosR0FBR3pKLG1CQUFtQixDQUFDckMsUUFBUWtNLEVBQUUsRUFBRTVKLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3BHLGdEQUFnRCxHQUNoRCxJQUFJMUMsUUFBUW1NLE9BQU8sRUFDZkosUUFBUTFKLG1CQUFtQixDQUFDckMsUUFBUW1NLE9BQU8sRUFBRTdKLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzlHLDhDQUE4QyxHQUM5QyxJQUFJMUMsUUFBUW9NLE1BQU0sRUFDZEosT0FBTzNKLG1CQUFtQixDQUFDckMsUUFBUW9NLE1BQU0sRUFBRTlKLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTStKLGdCQUFnQixJQUFJVDtBQUMxQiwyRkFBMkY7QUFDM0YsTUFBTVUsaUJBQWlCblQsNkRBQVdBO0lBQzlCb0csYUFBYztRQUNWLEtBQUssQ0FBQywrQkFBK0I7WUFDakM7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTTt3QkFBQzt3QkFBbUMrRzt3QkFBUztxQkFBWTtZQUN0RTtZQUNBO2dCQUFFcEgsSUFBSTtnQkFBR0MsTUFBTTtnQkFBU0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ25FO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFTQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDbkU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztTQUN0RTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFnTCxJQUFJLEdBQUc7UUFDZmhMLFFBQVF1TSxLQUFLLEdBQUc7UUFDaEJ2TSxRQUFRd00sS0FBSyxHQUFHO1FBQ2hCeE0sUUFBUXlNLEtBQUssR0FBRztRQUNoQixJQUFJMUwsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx3Q0FBd0MsR0FBRztvQkFDNUN2QixRQUFRZ0wsSUFBSSxHQUFHN0osT0FBTzhDLEtBQUs7b0JBQzNCO2dCQUNKLEtBQUssZ0JBQWdCLEdBQUc7b0JBQ3BCakUsUUFBUXVNLEtBQUssR0FBR3BMLE9BQU9pQixNQUFNO29CQUM3QjtnQkFDSixLQUFLLGdCQUFnQixHQUFHO29CQUNwQnBDLFFBQVF3TSxLQUFLLEdBQUdyTCxPQUFPaUIsTUFBTTtvQkFDN0I7Z0JBQ0osS0FBSyxnQkFBZ0IsR0FBRztvQkFDcEJwQyxRQUFReU0sS0FBSyxHQUFHdEwsT0FBT2lCLE1BQU07b0JBQzdCO2dCQUNKO29CQUNJLElBQUlULElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDZDQUE2QyxHQUM3QyxJQUFJRCxRQUFRZ0wsSUFBSSxLQUFLLEdBQ2pCMUksT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUWdMLElBQUk7UUFDckQscUJBQXFCLEdBQ3JCLElBQUloTCxRQUFRdU0sS0FBSyxLQUFLLElBQ2xCakssT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUXVNLEtBQUs7UUFDaEUscUJBQXFCLEdBQ3JCLElBQUl2TSxRQUFRd00sS0FBSyxLQUFLLElBQ2xCbEssT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUXdNLEtBQUs7UUFDaEUscUJBQXFCLEdBQ3JCLElBQUl4TSxRQUFReU0sS0FBSyxLQUFLLElBQ2xCbkssT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUXlNLEtBQUs7UUFDaEUsSUFBSTlLLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXVKLE1BQU0sSUFBSVM7QUFDaEIsMkZBQTJGO0FBQzNGLE1BQU1JLGdCQUFnQnZULDZEQUFXQTtJQUM3Qm9HLGFBQWM7UUFDVixLQUFLLENBQUMsOEJBQThCO1lBQ2hDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFRQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDbEU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtTQUNIO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUVAsSUFBSSxHQUFHO1FBQ2ZPLFFBQVEyTSxPQUFPLEdBQUc7UUFDbEIzTSxRQUFRNE0sWUFBWSxHQUFHO1FBQ3ZCLElBQUk3TCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGVBQWUsR0FBRztvQkFDbkJ2QixRQUFRUCxJQUFJLEdBQUcwQixPQUFPaUIsTUFBTTtvQkFDNUI7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJwQyxRQUFRMk0sT0FBTyxHQUFHeEwsT0FBT2lCLE1BQU07b0JBQy9CO2dCQUNKLEtBQUssdUJBQXVCLEdBQUc7b0JBQzNCcEMsUUFBUTRNLFlBQVksR0FBR3pMLE9BQU9pQixNQUFNO29CQUNwQztnQkFDSjtvQkFDSSxJQUFJVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxvQkFBb0IsR0FDcEIsSUFBSUQsUUFBUVAsSUFBSSxLQUFLLElBQ2pCNkMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUVAsSUFBSTtRQUMvRCx1QkFBdUIsR0FDdkIsSUFBSU8sUUFBUTJNLE9BQU8sS0FBSyxJQUNwQnJLLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVEyTSxPQUFPO1FBQ2xFLDRCQUE0QixHQUM1QixJQUFJM00sUUFBUTRNLFlBQVksS0FBSyxJQUN6QnRLLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE0TSxZQUFZO1FBQ3ZFLElBQUlqTCxJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU13SixLQUFLLElBQUlZO0FBQ2YsMkZBQTJGO0FBQzNGLE1BQU1HLHFCQUFxQjFULDZEQUFXQTtJQUNsQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsbUNBQW1DO1lBQ3JDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFRQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDbEU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztTQUN4RTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFQLElBQUksR0FBRztRQUNmTyxRQUFRMk0sT0FBTyxHQUFHO1FBQ2xCLElBQUk1TCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGVBQWUsR0FBRztvQkFDbkJ2QixRQUFRUCxJQUFJLEdBQUcwQixPQUFPaUIsTUFBTTtvQkFDNUI7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJwQyxRQUFRMk0sT0FBTyxHQUFHeEwsT0FBT2lCLE1BQU07b0JBQy9CO2dCQUNKO29CQUNJLElBQUlULElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLG9CQUFvQixHQUNwQixJQUFJRCxRQUFRUCxJQUFJLEtBQUssSUFDakI2QyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRUCxJQUFJO1FBQy9ELHVCQUF1QixHQUN2QixJQUFJTyxRQUFRMk0sT0FBTyxLQUFLLElBQ3BCckssT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTJNLE9BQU87UUFDbEUsSUFBSWhMLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXlKLFVBQVUsSUFBSWM7QUFDcEIsMkZBQTJGO0FBQzNGLE1BQU1DLG9CQUFvQjNULDZEQUFXQTtJQUNqQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsa0NBQWtDO1lBQ3BDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFRQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDbEU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztTQUN4RTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFQLElBQUksR0FBRztRQUNmTyxRQUFRMk0sT0FBTyxHQUFHO1FBQ2xCLElBQUk1TCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGVBQWUsR0FBRztvQkFDbkJ2QixRQUFRUCxJQUFJLEdBQUcwQixPQUFPaUIsTUFBTTtvQkFDNUI7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJwQyxRQUFRMk0sT0FBTyxHQUFHeEwsT0FBT2lCLE1BQU07b0JBQy9CO2dCQUNKO29CQUNJLElBQUlULElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLG9CQUFvQixHQUNwQixJQUFJRCxRQUFRUCxJQUFJLEtBQUssSUFDakI2QyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRUCxJQUFJO1FBQy9ELHVCQUF1QixHQUN2QixJQUFJTyxRQUFRMk0sT0FBTyxLQUFLLElBQ3BCckssT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTJNLE9BQU87UUFDbEUsSUFBSWhMLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTBKLFNBQVMsSUFBSWM7QUFDbkIsMkZBQTJGO0FBQzNGLE1BQU1DLHdCQUF3QjVULDZEQUFXQTtJQUNyQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsc0NBQXNDO1lBQ3hDO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLEVBQUUsaUJBQWlCO1lBQzFCO1lBQ0E7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsRUFBRSxpQkFBaUI7WUFDMUI7WUFDQTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLGlCQUFpQjtZQUMxQjtTQUNIO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUWdOLGVBQWUsR0FBRztRQUMxQmhOLFFBQVFpTixlQUFlLEdBQUc7UUFDMUJqTixRQUFRa04sY0FBYyxHQUFHO1FBQ3pCLElBQUluTSxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLDBCQUEwQixHQUFHO29CQUM5QnZCLFFBQVFnTixlQUFlLEdBQUc3TCxPQUFPZ0QsSUFBSTtvQkFDckM7Z0JBQ0osS0FBSywwQkFBMEIsR0FBRztvQkFDOUJuRSxRQUFRaU4sZUFBZSxHQUFHOUwsT0FBT2dELElBQUk7b0JBQ3JDO2dCQUNKLEtBQUssd0JBQXdCLEdBQUc7b0JBQzVCbkUsUUFBUWtOLGNBQWMsR0FBRy9MLE9BQU9nRCxJQUFJO29CQUNwQztnQkFDSjtvQkFDSSxJQUFJeEMsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsK0JBQStCLEdBQy9CLElBQUlELFFBQVFnTixlQUFlLEtBQUssT0FDNUIxSyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFRCxJQUFJLENBQUNuRSxRQUFRZ04sZUFBZTtRQUMvRCwrQkFBK0IsR0FDL0IsSUFBSWhOLFFBQVFpTixlQUFlLEtBQUssT0FDNUIzSyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFRCxJQUFJLENBQUNuRSxRQUFRaU4sZUFBZTtRQUMvRCw2QkFBNkIsR0FDN0IsSUFBSWpOLFFBQVFrTixjQUFjLEtBQUssT0FDM0I1SyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFRCxJQUFJLENBQUNuRSxRQUFRa04sY0FBYztRQUM5RCxJQUFJdkwsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNNkssYUFBYSxJQUFJSjtBQUV2QixJQUFJSyxTQUFTLFdBQVcsR0FBRS9NLE9BQU9nTixNQUFNLENBQUM7SUFDcENDLFdBQVc7SUFDWHZCLFNBQVNBO0lBQ1R3QixNQUFNakM7SUFDTjZCLFlBQVlBO0lBQ1pLLFdBQVdqRztJQUNYOEUsZUFBZUE7SUFDZnJDLE9BQU9BO0lBQ1AsSUFBSXhELHFCQUFxQjtRQUFFLE9BQU9BO0lBQW1CO0lBQ3JEd0YsUUFBUUE7SUFDUjVNLE9BQU91TTtJQUNQLElBQUloRixhQUFhO1FBQUUsT0FBT0E7SUFBVztJQUNyQyxJQUFJRyxnQkFBZ0I7UUFBRSxPQUFPQTtJQUFjO0lBQzNDMkcsWUFBWXBEO0lBQ1p5QixJQUFJQTtJQUNKOUUsYUFBYUE7SUFDYkMsa0JBQWtCQTtJQUNsQixJQUFJVixZQUFZO1FBQUUsT0FBT0E7SUFBVTtJQUNuQ1csS0FBS0E7SUFDTDJFLEtBQUtBO0lBQ0wsSUFBSWpGLFdBQVc7UUFBRSxPQUFPQTtJQUFTO0lBQ2pDa0MsZUFBZUE7SUFDZmdDLFdBQVdBO0lBQ1gsSUFBSXBFLGFBQWE7UUFBRSxPQUFPQTtJQUFXO0lBQ3JDLElBQUlHLHdCQUF3QjtRQUFFLE9BQU9BO0lBQXNCO0lBQzNEcUMsZ0JBQWdCQTtJQUNoQk8sWUFBWUE7SUFDWixJQUFJaEQsZ0JBQWdCO1FBQUUsT0FBT0E7SUFBYztBQUMvQztBQUVBLGtCQUFrQixHQUNsQiw0R0FBNEc7QUFDNUcsdUhBQXVIO0FBQ3ZILGlCQUFpQjtBQUNqQiwyRkFBMkY7QUFDM0YsTUFBTWlILCtCQUErQnZVLDZEQUFXQTtJQUM1Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsNkNBQTZDO1lBQy9DO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDeEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTTt3QkFBQzt3QkFBb0MwRzt3QkFBVTtxQkFBYTtZQUN6RTtTQUNIO0lBQ0w7SUFDQTFGLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTZILFNBQVMsR0FBRztRQUNwQjdILFFBQVFtSyxRQUFRLEdBQUc7UUFDbkIsSUFBSXBKLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCdkIsUUFBUTZILFNBQVMsR0FBRzFHLE9BQU9pQixNQUFNO29CQUNqQztnQkFDSixLQUFLLDhDQUE4QyxHQUFHO29CQUNsRHBDLFFBQVFtSyxRQUFRLEdBQUdoSixPQUFPOEMsS0FBSztvQkFDL0I7Z0JBQ0o7b0JBQ0ksSUFBSXRDLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDBCQUEwQixHQUMxQixJQUFJRCxRQUFRNkgsU0FBUyxLQUFLLElBQ3RCdkYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTZILFNBQVM7UUFDcEUsbURBQW1ELEdBQ25ELElBQUk3SCxRQUFRbUssUUFBUSxLQUFLLEdBQ3JCN0gsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUW1LLFFBQVE7UUFDekQsSUFBSXhJLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXFMLG9CQUFvQixJQUFJRDtBQUM5QiwyRkFBMkY7QUFDM0YsTUFBTUUsZ0NBQWdDelUsNkRBQVdBO0lBQzdDb0csYUFBYztRQUNWLEtBQUssQ0FBQyw4Q0FBOEM7WUFDaEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTThMO1lBQVE7U0FDN0Q7SUFDTDtJQUNBOUssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0N2QixRQUFRNk4sS0FBSyxHQUFHbEMsUUFBUXpLLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRNk4sS0FBSztvQkFDMUY7Z0JBQ0o7b0JBQ0ksSUFBSWxNLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDRDQUE0QyxHQUM1QyxJQUFJRCxRQUFRNk4sS0FBSyxFQUNibEMsUUFBUXRKLG1CQUFtQixDQUFDckMsUUFBUTZOLEtBQUssRUFBRXZMLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXdMLHFCQUFxQixJQUFJRjtBQUMvQiwyRkFBMkY7QUFDM0YsTUFBTUcscUNBQXFDNVUsNkRBQVdBO0lBQ2xEb0csYUFBYztRQUNWLEtBQUssQ0FBQyxtREFBbUQ7WUFDckQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQWNDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUN4RTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTjZFLFFBQVEsRUFBRSxtQkFBbUI7Z0JBQzdCMUUsR0FBRyxJQUFNbU87WUFDYjtTQUNIO0lBQ0w7SUFDQW5OLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTZILFNBQVMsR0FBRztRQUNwQjdILFFBQVFpTyxVQUFVLEdBQUcsRUFBRTtRQUN2QixJQUFJbE4sVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJ2QixRQUFRNkgsU0FBUyxHQUFHMUcsT0FBT2lCLE1BQU07b0JBQ2pDO2dCQUNKLEtBQUssK0RBQStELEdBQUc7b0JBQ25FcEMsUUFBUWlPLFVBQVUsQ0FBQ3hKLElBQUksQ0FBQ3VKLGVBQWU5TSxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEM7b0JBQ25GO2dCQUNKO29CQUNJLElBQUkwQixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywwQkFBMEIsR0FDMUIsSUFBSUQsUUFBUTZILFNBQVMsS0FBSyxJQUN0QnZGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE2SCxTQUFTO1FBQ3BFLG9FQUFvRSxHQUNwRSxJQUFLLElBQUluRCxJQUFJLEdBQUdBLElBQUkxRSxRQUFRaU8sVUFBVSxDQUFDN00sTUFBTSxFQUFFc0QsSUFDM0NzSixlQUFlM0wsbUJBQW1CLENBQUNyQyxRQUFRaU8sVUFBVSxDQUFDdkosRUFBRSxFQUFFcEMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDM0gsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNNEwsMEJBQTBCLElBQUlIO0FBQ3BDLDJGQUEyRjtBQUMzRixNQUFNSSxzQ0FBc0NoViw2REFBV0E7SUFDbkRvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLG9EQUFvRDtZQUN0RDtnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBU0MsTUFBTTtnQkFBV0csR0FBRyxJQUFNOEw7WUFBUTtTQUM3RDtJQUNMO0lBQ0E5SyxPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RCxJQUFJRCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLHVDQUF1QyxHQUFHO29CQUMzQ3ZCLFFBQVE2TixLQUFLLEdBQUdsQyxRQUFRekssa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVE2TixLQUFLO29CQUMxRjtnQkFDSjtvQkFDSSxJQUFJbE0sSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsNENBQTRDLEdBQzVDLElBQUlELFFBQVE2TixLQUFLLEVBQ2JsQyxRQUFRdEosbUJBQW1CLENBQUNyQyxRQUFRNk4sS0FBSyxFQUFFdkwsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDNUcsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNOEwsMkJBQTJCLElBQUlEO0FBQ3JDLDJGQUEyRjtBQUMzRixNQUFNRSw0QkFBNEJsViw2REFBV0E7SUFDekNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLDBDQUEwQztZQUM1QztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUNMO3dCQUNBNkc7d0JBQ0E7cUJBQ0g7WUFDTDtZQUNBO2dCQUFFbEgsSUFBSTtnQkFBR0MsTUFBTTtnQkFBU0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLGlCQUFpQjtZQUFHO1NBQ3BFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUXdLLFNBQVMsR0FBRztRQUNwQnhLLFFBQVFzTyxLQUFLLEdBQUc7UUFDaEIsSUFBSXZOLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssZ0RBQWdELEdBQUc7b0JBQ3BEdkIsUUFBUXdLLFNBQVMsR0FBR3JKLE9BQU84QyxLQUFLO29CQUNoQztnQkFDSixLQUFLLGNBQWMsR0FBRztvQkFDbEJqRSxRQUFRc08sS0FBSyxHQUFHbk4sT0FBT2dELElBQUk7b0JBQzNCO2dCQUNKO29CQUNJLElBQUl4QyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxxREFBcUQsR0FDckQsSUFBSUQsUUFBUXdLLFNBQVMsS0FBSyxHQUN0QmxJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVF3SyxTQUFTO1FBQzFELG1CQUFtQixHQUNuQixJQUFJeEssUUFBUXNPLEtBQUssS0FBSyxPQUNsQmhNLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVFzTyxLQUFLO1FBQ3JELElBQUkzTSxJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU0wTCxpQkFBaUIsSUFBSUs7QUFDM0IsMkZBQTJGO0FBQzNGLE1BQU1FLDhCQUE4QnBWLDZEQUFXQTtJQUMzQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsNENBQTRDO1lBQzlDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFTQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsaUJBQWlCO1lBQUc7U0FDcEU7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRc08sS0FBSyxHQUFHO1FBQ2hCLElBQUl2TixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGNBQWMsR0FBRztvQkFDbEJ2QixRQUFRc08sS0FBSyxHQUFHbk4sT0FBT2dELElBQUk7b0JBQzNCO2dCQUNKO29CQUNJLElBQUl4QyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxtQkFBbUIsR0FDbkIsSUFBSUQsUUFBUXNPLEtBQUssS0FBSyxPQUNsQmhNLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVFzTyxLQUFLO1FBQ3JELElBQUkzTSxJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELElBQUlpTTtBQUNKLDJGQUEyRjtBQUMzRixNQUFNQyw4QkFBOEJyViw2REFBV0E7SUFDM0NvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLDRDQUE0QztZQUM5QztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBU0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLGlCQUFpQjtZQUFHO1NBQ3BFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUXNPLEtBQUssR0FBRztRQUNoQixJQUFJdk4sVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxjQUFjLEdBQUc7b0JBQ2xCdkIsUUFBUXNPLEtBQUssR0FBR25OLE9BQU9nRCxJQUFJO29CQUMzQjtnQkFDSjtvQkFDSSxJQUFJeEMsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbUJBQW1CLEdBQ25CLElBQUlELFFBQVFzTyxLQUFLLEtBQUssT0FDbEJoTSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFRCxJQUFJLENBQUNuRSxRQUFRc08sS0FBSztRQUNyRCxJQUFJM00sSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxJQUFJa007QUFDSiwyRkFBMkY7QUFDM0YsTUFBTUMsd0NBQXdDdFYsNkRBQVdBO0lBQ3JEb0csYUFBYztRQUNWLEtBQUssQ0FBQyxzREFBc0Q7WUFDeEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQWNDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUN4RTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTjZFLFFBQVEsRUFBRSxtQkFBbUI7Z0JBQzdCMUUsR0FBRyxJQUFNNk87WUFDYjtTQUNIO0lBQ0w7SUFDQTdOLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTZILFNBQVMsR0FBRztRQUNwQjdILFFBQVEyTyxNQUFNLEdBQUcsRUFBRTtRQUNuQixJQUFJNU4sVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJ2QixRQUFRNkgsU0FBUyxHQUFHMUcsT0FBT2lCLE1BQU07b0JBQ2pDO2dCQUNKLEtBQUssb0VBQW9FLEdBQUc7b0JBQ3hFcEMsUUFBUTJPLE1BQU0sQ0FBQ2xLLElBQUksQ0FBQ2lLLHlCQUF5QnhOLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQztvQkFDekY7Z0JBQ0o7b0JBQ0ksSUFBSTBCLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDBCQUEwQixHQUMxQixJQUFJRCxRQUFRNkgsU0FBUyxLQUFLLElBQ3RCdkYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTZILFNBQVM7UUFDcEUseUVBQXlFLEdBQ3pFLElBQUssSUFBSW5ELElBQUksR0FBR0EsSUFBSTFFLFFBQVEyTyxNQUFNLENBQUN2TixNQUFNLEVBQUVzRCxJQUN2Q2dLLHlCQUF5QnJNLG1CQUFtQixDQUFDckMsUUFBUTJPLE1BQU0sQ0FBQ2pLLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2pJLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXNNLDZCQUE2QixJQUFJSDtBQUN2QywyRkFBMkY7QUFDM0YsTUFBTUkseUNBQXlDMVYsNkRBQVdBO0lBQ3REb0csYUFBYztRQUNWLEtBQUssQ0FBQyx1REFBdUQ7WUFDekQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTThMO1lBQVE7U0FDN0Q7SUFDTDtJQUNBOUssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0N2QixRQUFRNk4sS0FBSyxHQUFHbEMsUUFBUXpLLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRNk4sS0FBSztvQkFDMUY7Z0JBQ0o7b0JBQ0ksSUFBSWxNLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDRDQUE0QyxHQUM1QyxJQUFJRCxRQUFRNk4sS0FBSyxFQUNibEMsUUFBUXRKLG1CQUFtQixDQUFDckMsUUFBUTZOLEtBQUssRUFBRXZMLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXdNLDhCQUE4QixJQUFJRDtBQUN4QywyRkFBMkY7QUFDM0YsTUFBTUUsc0NBQXNDNVYsNkRBQVdBO0lBQ25Eb0csYUFBYztRQUNWLEtBQUssQ0FBQyxvREFBb0Q7WUFDdEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU07d0JBQ0w7d0JBQ0E2Rzt3QkFDQTtxQkFDSDtZQUNMO1lBQ0E7Z0JBQUVsSCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFhQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1xSjtZQUFlO1NBQ3hFO0lBQ0w7SUFDQXJJLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTRILE1BQU0sR0FBRztRQUNqQjVILFFBQVE2SCxTQUFTLEdBQUc7UUFDcEI3SCxRQUFRd0ssU0FBUyxHQUFHO1FBQ3BCLElBQUl6SixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGtCQUFrQixHQUFHO29CQUN0QnZCLFFBQVE0SCxNQUFNLEdBQUd6RyxPQUFPaUIsTUFBTTtvQkFDOUI7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJwQyxRQUFRNkgsU0FBUyxHQUFHMUcsT0FBT2lCLE1BQU07b0JBQ2pDO2dCQUNKLEtBQUssZ0RBQWdELEdBQUc7b0JBQ3BEcEMsUUFBUXdLLFNBQVMsR0FBR3JKLE9BQU84QyxLQUFLO29CQUNoQztnQkFDSixLQUFLLG9EQUFvRCxHQUFHO29CQUN4RGpFLFFBQVFnUCxTQUFTLEdBQUc5RixlQUFlaEksa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFnUCxTQUFTO29CQUN6RztnQkFDSjtvQkFDSSxJQUFJck4sSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsdUJBQXVCLEdBQ3ZCLElBQUlELFFBQVE0SCxNQUFNLEtBQUssSUFDbkJ0RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNEgsTUFBTTtRQUNqRSwwQkFBMEIsR0FDMUIsSUFBSTVILFFBQVE2SCxTQUFTLEtBQUssSUFDdEJ2RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNkgsU0FBUztRQUNwRSxxREFBcUQsR0FDckQsSUFBSTdILFFBQVF3SyxTQUFTLEtBQUssR0FDdEJsSSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFSCxLQUFLLENBQUNqRSxRQUFRd0ssU0FBUztRQUMxRCx5REFBeUQsR0FDekQsSUFBSXhLLFFBQVFnUCxTQUFTLEVBQ2pCOUYsZUFBZTdHLG1CQUFtQixDQUFDckMsUUFBUWdQLFNBQVMsRUFBRTFNLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3ZILElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTW9NLDJCQUEyQixJQUFJSztBQUNyQywyRkFBMkY7QUFDM0YsTUFBTUUsK0JBQStCOVYsNkRBQVdBO0lBQzVDb0csYUFBYztRQUNWLEtBQUssQ0FBQyw2Q0FBNkM7WUFDL0M7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTTt3QkFBQzt3QkFBb0MwRzt3QkFBVTtxQkFBYTtZQUN6RTtZQUNBO2dCQUFFL0csSUFBSTtnQkFBR0MsTUFBTTtnQkFBT0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ2pFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7U0FDM0U7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRbUssUUFBUSxHQUFHO1FBQ25CbkssUUFBUWtQLEdBQUcsR0FBRztRQUNkbFAsUUFBUTZILFNBQVMsR0FBRztRQUNwQixJQUFJOUcsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyw4Q0FBOEMsR0FBRztvQkFDbER2QixRQUFRbUssUUFBUSxHQUFHaEosT0FBTzhDLEtBQUs7b0JBQy9CO2dCQUNKLEtBQUssY0FBYyxHQUFHO29CQUNsQmpFLFFBQVFrUCxHQUFHLEdBQUcvTixPQUFPaUIsTUFBTTtvQkFDM0I7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJwQyxRQUFRNkgsU0FBUyxHQUFHMUcsT0FBT2lCLE1BQU07b0JBQ2pDO2dCQUNKO29CQUNJLElBQUlULElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLG1EQUFtRCxHQUNuRCxJQUFJRCxRQUFRbUssUUFBUSxLQUFLLEdBQ3JCN0gsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUW1LLFFBQVE7UUFDekQsbUJBQW1CLEdBQ25CLElBQUluSyxRQUFRa1AsR0FBRyxLQUFLLElBQ2hCNU0sT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUWtQLEdBQUc7UUFDOUQsMEJBQTBCLEdBQzFCLElBQUlsUCxRQUFRNkgsU0FBUyxLQUFLLElBQ3RCdkYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTZILFNBQVM7UUFDcEUsSUFBSWxHLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTZNLG9CQUFvQixJQUFJRjtBQUM5QiwyRkFBMkY7QUFDM0YsTUFBTUcsZ0NBQWdDalcsNkRBQVdBO0lBQzdDb0csYUFBYztRQUNWLEtBQUssQ0FBQyw4Q0FBOEM7WUFDaEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTThMO1lBQVE7U0FDN0Q7SUFDTDtJQUNBOUssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0N2QixRQUFRNk4sS0FBSyxHQUFHbEMsUUFBUXpLLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRNk4sS0FBSztvQkFDMUY7Z0JBQ0o7b0JBQ0ksSUFBSWxNLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDRDQUE0QyxHQUM1QyxJQUFJRCxRQUFRNk4sS0FBSyxFQUNibEMsUUFBUXRKLG1CQUFtQixDQUFDckMsUUFBUTZOLEtBQUssRUFBRXZMLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTStNLHFCQUFxQixJQUFJRDtBQUMvQiwyRkFBMkY7QUFDM0YsTUFBTUUsZ0NBQWdDblcsNkRBQVdBO0lBQzdDb0csYUFBYztRQUNWLEtBQUssQ0FBQyw4Q0FBOEM7WUFDaEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTThMO1lBQVE7U0FDN0Q7SUFDTDtJQUNBOUssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0N2QixRQUFRNk4sS0FBSyxHQUFHbEMsUUFBUXpLLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRNk4sS0FBSztvQkFDMUY7Z0JBQ0o7b0JBQ0ksSUFBSWxNLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDRDQUE0QyxHQUM1QyxJQUFJRCxRQUFRNk4sS0FBSyxFQUNibEMsUUFBUXRKLG1CQUFtQixDQUFDckMsUUFBUTZOLEtBQUssRUFBRXZMLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWlOLHFCQUFxQixJQUFJRDtBQUMvQiwyRkFBMkY7QUFDM0YsTUFBTUUsaUNBQWlDclcsNkRBQVdBO0lBQzlDb0csYUFBYztRQUNWLEtBQUssQ0FBQywrQ0FBK0M7WUFDakQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQU9DLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNqRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1pTDtZQUNiO1NBQ0g7SUFDTDtJQUNBakssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRa1AsR0FBRyxHQUFHO1FBQ2RsUCxRQUFRNkgsU0FBUyxHQUFHO1FBQ3BCN0gsUUFBUTJPLE1BQU0sR0FBRyxFQUFFO1FBQ25CLElBQUk1TixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGNBQWMsR0FBRztvQkFDbEJ2QixRQUFRa1AsR0FBRyxHQUFHL04sT0FBT2lCLE1BQU07b0JBQzNCO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCcEMsUUFBUTZILFNBQVMsR0FBRzFHLE9BQU9pQixNQUFNO29CQUNqQztnQkFDSixLQUFLLHFEQUFxRCxHQUFHO29CQUN6RHBDLFFBQVEyTyxNQUFNLENBQUNsSyxJQUFJLENBQUNxRyxVQUFVNUosa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDO29CQUMxRTtnQkFDSjtvQkFDSSxJQUFJMEIsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbUJBQW1CLEdBQ25CLElBQUlELFFBQVFrUCxHQUFHLEtBQUssSUFDaEI1TSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRa1AsR0FBRztRQUM5RCwwQkFBMEIsR0FDMUIsSUFBSWxQLFFBQVE2SCxTQUFTLEtBQUssSUFDdEJ2RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNkgsU0FBUztRQUNwRSwwREFBMEQsR0FDMUQsSUFBSyxJQUFJbkQsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUTJPLE1BQU0sQ0FBQ3ZOLE1BQU0sRUFBRXNELElBQ3ZDb0csVUFBVXpJLG1CQUFtQixDQUFDckMsUUFBUTJPLE1BQU0sQ0FBQ2pLLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2xILElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTW1OLHNCQUFzQixJQUFJRDtBQUNoQywyRkFBMkY7QUFDM0YsTUFBTUUsa0NBQWtDdlcsNkRBQVdBO0lBQy9Db0csYUFBYztRQUNWLEtBQUssQ0FBQyxnREFBZ0Q7WUFDbEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQU9DLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNqRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsaUJBQWlCO1lBQUc7WUFDdkU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTThMO1lBQVE7U0FDN0Q7SUFDTDtJQUNBOUssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRa1AsR0FBRyxHQUFHO1FBQ2RsUCxRQUFRNkgsU0FBUyxHQUFHO1FBQ3BCN0gsUUFBUTJQLFVBQVUsR0FBRztRQUNyQixJQUFJNU8sVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxjQUFjLEdBQUc7b0JBQ2xCdkIsUUFBUWtQLEdBQUcsR0FBRy9OLE9BQU9pQixNQUFNO29CQUMzQjtnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6QnBDLFFBQVE2SCxTQUFTLEdBQUcxRyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0osS0FBSyxvQkFBb0IsR0FBRztvQkFDeEJwQyxRQUFRMlAsVUFBVSxHQUFHeE8sT0FBT2dELElBQUk7b0JBQ2hDO2dCQUNKLEtBQUssdUNBQXVDLEdBQUc7b0JBQzNDbkUsUUFBUTZOLEtBQUssR0FBR2xDLFFBQVF6SyxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUTZOLEtBQUs7b0JBQzFGO2dCQUNKO29CQUNJLElBQUlsTSxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxtQkFBbUIsR0FDbkIsSUFBSUQsUUFBUWtQLEdBQUcsS0FBSyxJQUNoQjVNLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVFrUCxHQUFHO1FBQzlELDBCQUEwQixHQUMxQixJQUFJbFAsUUFBUTZILFNBQVMsS0FBSyxJQUN0QnZGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE2SCxTQUFTO1FBQ3BFLHlCQUF5QixHQUN6QixJQUFJN0gsUUFBUTJQLFVBQVUsS0FBSyxPQUN2QnJOLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVEyUCxVQUFVO1FBQzFELDRDQUE0QyxHQUM1QyxJQUFJM1AsUUFBUTZOLEtBQUssRUFDYmxDLFFBQVF0SixtQkFBbUIsQ0FBQ3JDLFFBQVE2TixLQUFLLEVBQUV2TCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUM1RyxJQUFJZixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1zTix1QkFBdUIsSUFBSUY7QUFDakM7O0NBRUMsR0FDRCxNQUFNRyxlQUFlLElBQUluVyxrRUFBV0EsQ0FBQyx3Q0FBd0M7SUFDekU7UUFDSStGLE1BQU07UUFDTlEsU0FBUyxDQUFDO1FBQ1Y2UCxHQUFHTDtRQUNITSxHQUFHSDtJQUNQO0lBQ0E7UUFDSW5RLE1BQU07UUFDTlEsU0FBUyxDQUFDO1FBQ1Y2UCxHQUFHWDtRQUNIWSxHQUFHVjtJQUNQO0lBQ0E7UUFBRTVQLE1BQU07UUFBY1EsU0FBUyxDQUFDO1FBQUc2UCxHQUFHekY7UUFBYzBGLEdBQUdSO0lBQW1CO0lBQzFFO1FBQ0k5UCxNQUFNO1FBQ05RLFNBQVMsQ0FBQztRQUNWNlAsR0FBR2xCO1FBQ0htQixHQUFHakI7SUFDUDtJQUNBO1FBQ0lyUCxNQUFNO1FBQ05RLFNBQVMsQ0FBQztRQUNWNlAsR0FBRzVCO1FBQ0g2QixHQUFHM0I7SUFDUDtJQUNBO1FBQ0kzTyxNQUFNO1FBQ05RLFNBQVMsQ0FBQztRQUNWNlAsR0FBR25DO1FBQ0hvQyxHQUFHakM7SUFDUDtDQUNIO0FBRUQ7O0NBRUMsR0FDRCxJQUFJa0M7QUFDSCxVQUFVQSwwQkFBMEI7SUFDakM7O0tBRUMsR0FDREEsMEJBQTBCLENBQUNBLDBCQUEwQixDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUNqRjs7S0FFQyxHQUNEQSwwQkFBMEIsQ0FBQ0EsMEJBQTBCLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUNwRTs7S0FFQyxHQUNEQSwwQkFBMEIsQ0FBQ0EsMEJBQTBCLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUN2RTs7S0FFQyxHQUNEQSwwQkFBMEIsQ0FBQ0EsMEJBQTBCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUM3RSxHQUFHQSw4QkFBK0JBLENBQUFBLDZCQUE2QixDQUFDO0FBQ2hFLDJGQUEyRjtBQUMzRixNQUFNQyxzQkFBc0I5Vyw2REFBV0E7SUFDbkNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLG1DQUFtQztZQUNyQztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU1xUTtZQUNiO1lBQ0E7Z0JBQ0kxUSxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTXNRO1lBQ2I7WUFDQTtnQkFDSTNRLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNdVE7WUFDYjtZQUNBO2dCQUNJNVEsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU13UTtZQUNiO1lBQ0E7Z0JBQ0k3USxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTXdLO1lBQ2I7WUFDQTtnQkFDSTdLLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNeVE7WUFDYjtZQUNBO2dCQUNJOVEsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU0wUTtZQUNiO1lBQ0E7Z0JBQ0kvUSxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTTJRO1lBQ2I7WUFDQTtnQkFDSWhSLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNNFE7WUFDYjtZQUNBO2dCQUNJalIsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU02UTtZQUNiO1lBQ0E7Z0JBQ0lsUixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTThRO1lBQ2I7WUFDQTtnQkFDSW5SLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNK1E7WUFDYjtZQUNBO2dCQUNJcFIsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU1nUjtZQUNiO1lBQ0E7Z0JBQ0lyUixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTWlSO1lBQ2I7WUFDQTtnQkFDSXRSLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNa1I7WUFDYjtZQUNBO2dCQUNJdlIsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU1tUjtZQUNiO1lBQ0E7Z0JBQ0l4UixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTW9SO1lBQ2I7WUFDQTtnQkFDSXpSLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05xRCxPQUFPO2dCQUNQbEQsR0FBRyxJQUFNcVI7WUFDYjtTQUNIO0lBQ0w7SUFDQXJRLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUW1SLFlBQVksR0FBRztZQUFFbE8sV0FBV2hDO1FBQVU7UUFDOUMsSUFBSUYsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSywyREFBMkQsR0FBRztvQkFDL0R2QixRQUFRbVIsWUFBWSxHQUFHO3dCQUNuQmxPLFdBQVc7d0JBQ1htTyxpQkFBaUJsQixnQkFBZ0JoUCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW1SLFlBQVksQ0FBQ0MsZUFBZTtvQkFDOUg7b0JBQ0E7Z0JBQ0osS0FBSywyREFBMkQsR0FBRztvQkFDL0RwUixRQUFRbVIsWUFBWSxHQUFHO3dCQUNuQmxPLFdBQVc7d0JBQ1hvTyxpQkFBaUJsQixnQkFBZ0JqUCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW1SLFlBQVksQ0FBQ0UsZUFBZTtvQkFDOUg7b0JBQ0E7Z0JBQ0osS0FBSyw4RUFBOEUsR0FBRztvQkFDbEZyUixRQUFRbVIsWUFBWSxHQUFHO3dCQUNuQmxPLFdBQVc7d0JBQ1hxTywwQkFBMEJsQix5QkFBeUJsUCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW1SLFlBQVksQ0FBQ0csd0JBQXdCO29CQUN6SjtvQkFDQTtnQkFDSixLQUFLLGdFQUFnRSxHQUFHO29CQUNwRXRSLFFBQVFtUixZQUFZLEdBQUc7d0JBQ25CbE8sV0FBVzt3QkFDWHNPLG1CQUFtQmxCLGtCQUFrQm5QLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDSSxpQkFBaUI7b0JBQ3BJO29CQUNBO2dCQUNKLEtBQUssa0RBQWtELEdBQUc7b0JBQ3REdlIsUUFBUW1SLFlBQVksR0FBRzt3QkFDbkJsTyxXQUFXO3dCQUNYdU8sWUFBWW5ILGFBQWFuSixrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW1SLFlBQVksQ0FBQ0ssVUFBVTtvQkFDakg7b0JBQ0E7Z0JBQ0osS0FBSyxzRUFBc0UsR0FBRztvQkFDMUV4UixRQUFRbVIsWUFBWSxHQUFHO3dCQUNuQmxPLFdBQVc7d0JBQ1h3TyxzQkFBc0JuQixxQkFBcUJwUCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW1SLFlBQVksQ0FBQ00sb0JBQW9CO29CQUM3STtvQkFDQTtnQkFDSixLQUFLLCtEQUErRCxHQUFHO29CQUNuRXpSLFFBQVFtUixZQUFZLEdBQUc7d0JBQ25CbE8sV0FBVzt3QkFDWHlPLG1CQUFtQm5CLGtCQUFrQnJQLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDTyxpQkFBaUI7b0JBQ3BJO29CQUNBO2dCQUNKLEtBQUssMkRBQTJELEdBQUc7b0JBQy9EMVIsUUFBUW1SLFlBQVksR0FBRzt3QkFDbkJsTyxXQUFXO3dCQUNYME8saUJBQWlCbkIsZ0JBQWdCdFAsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFtUixZQUFZLENBQUNRLGVBQWU7b0JBQzlIO29CQUNBO2dCQUNKLEtBQUssMEVBQTBFLEdBQUc7b0JBQzlFM1IsUUFBUW1SLFlBQVksR0FBRzt3QkFDbkJsTyxXQUFXO3dCQUNYMk8sd0JBQXdCbkIsdUJBQXVCdlAsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFtUixZQUFZLENBQUNTLHNCQUFzQjtvQkFDbko7b0JBQ0E7Z0JBQ0osS0FBSyxxREFBcUQsR0FBRztvQkFDekQ1UixRQUFRbVIsWUFBWSxHQUFHO3dCQUNuQmxPLFdBQVc7d0JBQ1g0TyxjQUFjbkIsYUFBYXhQLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDVSxZQUFZO29CQUNySDtvQkFDQTtnQkFDSixLQUFLLG9FQUFvRSxHQUFHO29CQUN4RTdSLFFBQVFtUixZQUFZLEdBQUc7d0JBQ25CbE8sV0FBVzt3QkFDWDZPLHFCQUFxQm5CLG9CQUFvQnpQLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDVyxtQkFBbUI7b0JBQzFJO29CQUNBO2dCQUNKLEtBQUsseURBQXlELEdBQUc7b0JBQzdEOVIsUUFBUW1SLFlBQVksR0FBRzt3QkFDbkJsTyxXQUFXO3dCQUNYOE8sZ0JBQWdCbkIsZUFBZTFQLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDWSxjQUFjO29CQUMzSDtvQkFDQTtnQkFDSixLQUFLLDZEQUE2RCxHQUFHO29CQUNqRS9SLFFBQVFtUixZQUFZLEdBQUc7d0JBQ25CbE8sV0FBVzt3QkFDWCtPLGtCQUFrQm5CLGlCQUFpQjNQLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDYSxnQkFBZ0I7b0JBQ2pJO29CQUNBO2dCQUNKLEtBQUssc0NBQXNDLEdBQUc7b0JBQzFDaFMsUUFBUW1SLFlBQVksR0FBRzt3QkFDbkJsTyxXQUFXO3dCQUNYNEssT0FBT2lELFFBQVE1UCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUW1SLFlBQVksQ0FBQ3RELEtBQUs7b0JBQ2xHO29CQUNBO2dCQUNKLEtBQUssZ0VBQWdFLEdBQUc7b0JBQ3BFN04sUUFBUW1SLFlBQVksR0FBRzt3QkFDbkJsTyxXQUFXO3dCQUNYZ1AsbUJBQW1CbEIsa0JBQWtCN1Asa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFtUixZQUFZLENBQUNjLGlCQUFpQjtvQkFDcEk7b0JBQ0E7Z0JBQ0osS0FBSyx5Q0FBeUMsR0FBRztvQkFDN0NqUyxRQUFRbVIsWUFBWSxHQUFHO3dCQUNuQmxPLFdBQVc7d0JBQ1hpUCxRQUFRbEIsT0FBTzlQLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRbVIsWUFBWSxDQUFDZSxNQUFNO29CQUNuRztvQkFDQTtnQkFDSixLQUFLLGlEQUFpRCxHQUFHO29CQUNyRGxTLFFBQVFtUixZQUFZLEdBQUc7d0JBQ25CbE8sV0FBVzt3QkFDWDBNLFlBQVlzQixXQUFXL1Asa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFtUixZQUFZLENBQUN4QixVQUFVO29CQUMvRztvQkFDQTtnQkFDSixLQUFLLG1EQUFtRCxHQUFHO29CQUN2RDNQLFFBQVFtUixZQUFZLEdBQUc7d0JBQ25CbE8sV0FBVzt3QkFDWGtQLGFBQWFqQixZQUFZaFEsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFtUixZQUFZLENBQUNnQixXQUFXO29CQUNsSDtvQkFDQTtnQkFDSjtvQkFDSSxJQUFJeFEsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsZ0VBQWdFLEdBQ2hFLElBQUlELFFBQVFtUixZQUFZLENBQUNsTyxTQUFTLEtBQUssbUJBQ25DaU4sZ0JBQWdCN04sbUJBQW1CLENBQUNyQyxRQUFRbVIsWUFBWSxDQUFDQyxlQUFlLEVBQUU5TyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMzSSxnRUFBZ0UsR0FDaEUsSUFBSTFDLFFBQVFtUixZQUFZLENBQUNsTyxTQUFTLEtBQUssbUJBQ25Da04sZ0JBQWdCOU4sbUJBQW1CLENBQUNyQyxRQUFRbVIsWUFBWSxDQUFDRSxlQUFlLEVBQUUvTyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMzSSxtRkFBbUYsR0FDbkYsSUFBSTFDLFFBQVFtUixZQUFZLENBQUNsTyxTQUFTLEtBQUssNEJBQ25DbU4seUJBQXlCL04sbUJBQW1CLENBQUNyQyxRQUFRbVIsWUFBWSxDQUFDRyx3QkFBd0IsRUFBRWhQLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzdKLHFFQUFxRSxHQUNyRSxJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSyxxQkFDbkNvTixrQkFBa0JoTyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNJLGlCQUFpQixFQUFFalAsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDL0ksdURBQXVELEdBQ3ZELElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLGNBQ25Db0gsYUFBYWhJLG1CQUFtQixDQUFDckMsUUFBUW1SLFlBQVksQ0FBQ0ssVUFBVSxFQUFFbFAsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDbkksMkVBQTJFLEdBQzNFLElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLHdCQUNuQ3FOLHFCQUFxQmpPLG1CQUFtQixDQUFDckMsUUFBUW1SLFlBQVksQ0FBQ00sb0JBQW9CLEVBQUVuUCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUNySixxRUFBcUUsR0FDckUsSUFBSTFDLFFBQVFtUixZQUFZLENBQUNsTyxTQUFTLEtBQUsscUJBQ25Dc04sa0JBQWtCbE8sbUJBQW1CLENBQUNyQyxRQUFRbVIsWUFBWSxDQUFDTyxpQkFBaUIsRUFBRXBQLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2hKLGlFQUFpRSxHQUNqRSxJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSyxtQkFDbkN1TixnQkFBZ0JuTyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNRLGVBQWUsRUFBRXJQLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVJLGdGQUFnRixHQUNoRixJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSywwQkFDbkN3Tix1QkFBdUJwTyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNTLHNCQUFzQixFQUFFdFAsT0FBT2IsR0FBRyxDQUFDLElBQUlqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDMUosMkRBQTJELEdBQzNELElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLGdCQUNuQ3lOLGFBQWFyTyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNVLFlBQVksRUFBRXZQLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3RJLDBFQUEwRSxHQUMxRSxJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSyx1QkFDbkMwTixvQkFBb0J0TyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNXLG1CQUFtQixFQUFFeFAsT0FBT2IsR0FBRyxDQUFDLElBQUlqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDcEosK0RBQStELEdBQy9ELElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLGtCQUNuQzJOLGVBQWV2TyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNZLGNBQWMsRUFBRXpQLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzFJLG1FQUFtRSxHQUNuRSxJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSyxvQkFDbkM0TixpQkFBaUJ4TyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNhLGdCQUFnQixFQUFFMVAsT0FBT2IsR0FBRyxDQUFDLElBQUlqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDOUksNENBQTRDLEdBQzVDLElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLFNBQ25DNk4sUUFBUXpPLG1CQUFtQixDQUFDckMsUUFBUW1SLFlBQVksQ0FBQ3RELEtBQUssRUFBRXZMLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzFILHNFQUFzRSxHQUN0RSxJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSyxxQkFDbkM4TixrQkFBa0IxTyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNjLGlCQUFpQixFQUFFM1AsT0FBT2IsR0FBRyxDQUFDLElBQUlqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDaEosK0NBQStDLEdBQy9DLElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLFVBQ25DK04sT0FBTzNPLG1CQUFtQixDQUFDckMsUUFBUW1SLFlBQVksQ0FBQ2UsTUFBTSxFQUFFNVAsT0FBT2IsR0FBRyxDQUFDLElBQUlqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDMUgsdURBQXVELEdBQ3ZELElBQUkxQyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUyxLQUFLLGNBQ25DZ08sV0FBVzVPLG1CQUFtQixDQUFDckMsUUFBUW1SLFlBQVksQ0FBQ3hCLFVBQVUsRUFBRXJOLE9BQU9iLEdBQUcsQ0FBQyxJQUFJakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2xJLHlEQUF5RCxHQUN6RCxJQUFJMUMsUUFBUW1SLFlBQVksQ0FBQ2xPLFNBQVMsS0FBSyxlQUNuQ2lPLFlBQVk3TyxtQkFBbUIsQ0FBQ3JDLFFBQVFtUixZQUFZLENBQUNnQixXQUFXLEVBQUU3UCxPQUFPYixHQUFHLENBQUMsSUFBSWpJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUNwSSxJQUFJZixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU04UCxXQUFXLElBQUluQztBQUNyQiwyRkFBMkY7QUFDM0YsTUFBTW9DLHlCQUF5QmxaLDZEQUFXQTtJQUN0Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsc0NBQXNDO1lBQ3hDO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1xSDtZQUNiO1NBQ0g7SUFDTDtJQUNBckcsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRb0gsSUFBSSxHQUFHLEVBQUU7UUFDakIsSUFBSXJHLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssNkNBQTZDLEdBQUc7b0JBQ2pEdkIsUUFBUW9ILElBQUksQ0FBQzNDLElBQUksQ0FBQ3lDLElBQUloRyxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEM7b0JBQ2xFO2dCQUNKO29CQUNJLElBQUkwQixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxrREFBa0QsR0FDbEQsSUFBSyxJQUFJeUUsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUW9ILElBQUksQ0FBQ2hHLE1BQU0sRUFBRXNELElBQ3JDd0MsSUFBSTdFLG1CQUFtQixDQUFDckMsUUFBUW9ILElBQUksQ0FBQzFDLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzFHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTRPLGNBQWMsSUFBSW1CO0FBQ3hCLDJGQUEyRjtBQUMzRixNQUFNN0csbUJBQW1CclMsNkRBQVdBO0lBQ2hDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxnQ0FBZ0M7WUFDbEM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTThMO1lBQVE7U0FDN0Q7SUFDTDtJQUNBOUssT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyx1Q0FBdUMsR0FBRztvQkFDM0N2QixRQUFRNk4sS0FBSyxHQUFHbEMsUUFBUXpLLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRNk4sS0FBSztvQkFDMUY7Z0JBQ0o7b0JBQ0ksSUFBSWxNLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDRDQUE0QyxHQUM1QyxJQUFJRCxRQUFRNk4sS0FBSyxFQUNibEMsUUFBUXRKLG1CQUFtQixDQUFDckMsUUFBUTZOLEtBQUssRUFBRXZMLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzVHLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXdPLFVBQVUsSUFBSXRGO0FBQ3BCLDJGQUEyRjtBQUMzRixNQUFNdEIsd0JBQXdCL1EsNkRBQVdBO0lBQ3JDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxxQ0FBcUM7WUFDdkM7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTTt3QkFBQzt3QkFBb0MwRzt3QkFBVTtxQkFBYTtZQUN6RTtZQUNBO2dCQUNJL0csSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtTQUNIO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUW1LLFFBQVEsR0FBRztRQUNuQm5LLFFBQVFvSyxZQUFZLEdBQUc7UUFDdkIsSUFBSXJKLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssOENBQThDLEdBQUc7b0JBQ2xEdkIsUUFBUW1LLFFBQVEsR0FBR2hKLE9BQU84QyxLQUFLO29CQUMvQjtnQkFDSixLQUFLLHdCQUF3QixHQUFHO29CQUM1QmpFLFFBQVFvSyxZQUFZLEdBQUdqSixPQUFPaUIsTUFBTTtvQkFDcEM7Z0JBQ0o7b0JBQ0ksSUFBSVQsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbURBQW1ELEdBQ25ELElBQUlELFFBQVFtSyxRQUFRLEtBQUssR0FDckI3SCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFSCxLQUFLLENBQUNqRSxRQUFRbUssUUFBUTtRQUN6RCw2QkFBNkIsR0FDN0IsSUFBSW5LLFFBQVFvSyxZQUFZLEtBQUssSUFDekI5SCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRb0ssWUFBWTtRQUN2RSxJQUFJekksSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNbUwsYUFBYSxJQUFJdkQ7QUFDdkIsMkZBQTJGO0FBQzNGLE1BQU1vSSx3QkFBd0JuWiw2REFBV0E7SUFDckNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHFDQUFxQztZQUN2QztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUFDO3dCQUFvQzBHO3dCQUFVO3FCQUFhO1lBQ3pFO1NBQ0g7SUFDTDtJQUNBMUYsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRbUssUUFBUSxHQUFHO1FBQ25CLElBQUlwSixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLDhDQUE4QyxHQUFHO29CQUNsRHZCLFFBQVFtSyxRQUFRLEdBQUdoSixPQUFPOEMsS0FBSztvQkFDL0I7Z0JBQ0o7b0JBQ0ksSUFBSXRDLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLG1EQUFtRCxHQUNuRCxJQUFJRCxRQUFRbUssUUFBUSxLQUFLLEdBQ3JCN0gsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUW1LLFFBQVE7UUFDekQsSUFBSXhJLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTJPLGFBQWEsSUFBSXFCO0FBQ3ZCLDJGQUEyRjtBQUMzRixNQUFNQyx3QkFBd0JwWiw2REFBV0E7SUFDckNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHFDQUFxQztZQUN2QztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTnFELE9BQU87Z0JBQ1BsRCxHQUFHLElBQU0yUztZQUNiO1lBQ0E7Z0JBQ0loVCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNOcUQsT0FBTztnQkFDUGxELEdBQUcsSUFBTTRTO1lBQ2I7U0FDSDtJQUNMO0lBQ0E1UixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVEwUyxjQUFjLEdBQUc7WUFBRXpQLFdBQVdoQztRQUFVO1FBQ2hELElBQUlGLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssbURBQW1ELEdBQUc7b0JBQ3ZEdkIsUUFBUTBTLGNBQWMsR0FBRzt3QkFDckJ6UCxXQUFXO3dCQUNYMFAsYUFBYUgsWUFBWXRSLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRMFMsY0FBYyxDQUFDQyxXQUFXO29CQUNwSDtvQkFDQTtnQkFDSixLQUFLLGtFQUFrRSxHQUFHO29CQUN0RTNTLFFBQVEwUyxjQUFjLEdBQUc7d0JBQ3JCelAsV0FBVzt3QkFDWDJQLG9CQUFvQkgsbUJBQW1CdlIsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVEwUyxjQUFjLENBQUNFLGtCQUFrQjtvQkFDekk7b0JBQ0E7Z0JBQ0o7b0JBQ0ksSUFBSWpSLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLHdEQUF3RCxHQUN4RCxJQUFJRCxRQUFRMFMsY0FBYyxDQUFDelAsU0FBUyxLQUFLLGVBQ3JDdVAsWUFBWW5RLG1CQUFtQixDQUFDckMsUUFBUTBTLGNBQWMsQ0FBQ0MsV0FBVyxFQUFFclEsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDckksdUVBQXVFLEdBQ3ZFLElBQUkxQyxRQUFRMFMsY0FBYyxDQUFDelAsU0FBUyxLQUFLLHNCQUNyQ3dQLG1CQUFtQnBRLG1CQUFtQixDQUFDckMsUUFBUTBTLGNBQWMsQ0FBQ0Usa0JBQWtCLEVBQUV0USxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUNuSixJQUFJZixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU11USxhQUFhLElBQUlOO0FBQ3ZCLDJGQUEyRjtBQUMzRixNQUFNTyxnQ0FBZ0MzWiw2REFBV0E7SUFDN0NvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLDZDQUE2QyxFQUFFO0lBQ3pEO0lBQ0FzQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RCxJQUFJRCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxPQUFPQSxVQUFVLElBQUksQ0FBQ0csTUFBTTtJQUNoQztJQUNBd0Isb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLElBQUkwQixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1tUSxxQkFBcUIsSUFBSUs7QUFDL0IsMkZBQTJGO0FBQzNGLE1BQU1DLGlDQUFpQzVaLDZEQUFXQTtJQUM5Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsOENBQThDO1lBQ2hEO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU1vSDtZQUNiO1NBQ0g7SUFDTDtJQUNBcEcsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyw4REFBOEQsR0FBRztvQkFDbEV2QixRQUFRc0gsZ0JBQWdCLEdBQUdMLGlCQUFpQi9GLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRc0gsZ0JBQWdCO29CQUN6SDtnQkFDSjtvQkFDSSxJQUFJM0YsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbUVBQW1FLEdBQ25FLElBQUlELFFBQVFzSCxnQkFBZ0IsRUFDeEJMLGlCQUFpQjVFLG1CQUFtQixDQUFDckMsUUFBUXNILGdCQUFnQixFQUFFaEYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDaEksSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNcU8sc0JBQXNCLElBQUlvQztBQUNoQywyRkFBMkY7QUFDM0YsTUFBTUMsNEJBQTRCN1osNkRBQVdBO0lBQ3pDb0csYUFBYztRQUNWLEtBQUssQ0FBQyx5Q0FBeUM7WUFDM0M7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU07d0JBQ0w7d0JBQ0E2Rzt3QkFDQTtxQkFDSDtZQUNMO1lBQ0E7Z0JBQUVsSCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1tSDtZQUFZO1NBQ3ZFO0lBQ0w7SUFDQW5HLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTRILE1BQU0sR0FBRztRQUNqQjVILFFBQVE2SCxTQUFTLEdBQUc7UUFDcEI3SCxRQUFRZ0wsSUFBSSxHQUFHO1FBQ2YsSUFBSWpLLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssa0JBQWtCLEdBQUc7b0JBQ3RCdkIsUUFBUTRILE1BQU0sR0FBR3pHLE9BQU9pQixNQUFNO29CQUM5QjtnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6QnBDLFFBQVE2SCxTQUFTLEdBQUcxRyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0osS0FBSywwQ0FBMEMsR0FBRztvQkFDOUNwQyxRQUFRZ0wsSUFBSSxHQUFHN0osT0FBTzhDLEtBQUs7b0JBQzNCO2dCQUNKLEtBQUssbURBQW1ELEdBQUc7b0JBQ3ZEakUsUUFBUWlULFdBQVcsR0FBR2pNLFlBQVk5RixrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUWlULFdBQVc7b0JBQzFHO2dCQUNKO29CQUNJLElBQUl0UixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyx1QkFBdUIsR0FDdkIsSUFBSUQsUUFBUTRILE1BQU0sS0FBSyxJQUNuQnRGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE0SCxNQUFNO1FBQ2pFLDBCQUEwQixHQUMxQixJQUFJNUgsUUFBUTZILFNBQVMsS0FBSyxJQUN0QnZGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE2SCxTQUFTO1FBQ3BFLCtDQUErQyxHQUMvQyxJQUFJN0gsUUFBUWdMLElBQUksS0FBSyxHQUNqQjFJLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVFnTCxJQUFJO1FBQ3JELHdEQUF3RCxHQUN4RCxJQUFJaEwsUUFBUWlULFdBQVcsRUFDbkJqTSxZQUFZM0UsbUJBQW1CLENBQUNyQyxRQUFRaVQsV0FBVyxFQUFFM1EsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDdEgsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNc08saUJBQWlCLElBQUlvQztBQUMzQiwyRkFBMkY7QUFDM0YsTUFBTUUsOEJBQThCL1osNkRBQVdBO0lBQzNDb0csYUFBYztRQUNWLEtBQUssQ0FBQywyQ0FBMkM7WUFDN0M7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU07d0JBQ0w7d0JBQ0E2Rzt3QkFDQTtxQkFDSDtZQUNMO1lBQ0E7Z0JBQ0lsSCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU07d0JBQ0w7d0JBQ0FnSDt3QkFDQTtxQkFDSDtZQUNMO1lBQ0E7Z0JBQUVySCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1tSDtZQUFZO1NBQ3ZFO0lBQ0w7SUFDQW5HLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTRILE1BQU0sR0FBRztRQUNqQjVILFFBQVE2SCxTQUFTLEdBQUc7UUFDcEI3SCxRQUFRZ0wsSUFBSSxHQUFHO1FBQ2ZoTCxRQUFRbVQsS0FBSyxHQUFHO1FBQ2hCLElBQUlwUyxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGtCQUFrQixHQUFHO29CQUN0QnZCLFFBQVE0SCxNQUFNLEdBQUd6RyxPQUFPaUIsTUFBTTtvQkFDOUI7Z0JBQ0osS0FBSyxxQkFBcUIsR0FBRztvQkFDekJwQyxRQUFRNkgsU0FBUyxHQUFHMUcsT0FBT2lCLE1BQU07b0JBQ2pDO2dCQUNKLEtBQUssMENBQTBDLEdBQUc7b0JBQzlDcEMsUUFBUWdMLElBQUksR0FBRzdKLE9BQU84QyxLQUFLO29CQUMzQjtnQkFDSixLQUFLLHNEQUFzRCxHQUFHO29CQUMxRGpFLFFBQVFtVCxLQUFLLEdBQUdoUyxPQUFPOEMsS0FBSztvQkFDNUI7Z0JBQ0osS0FBSyxtREFBbUQsR0FBRztvQkFDdkRqRSxRQUFRaVQsV0FBVyxHQUFHak0sWUFBWTlGLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRaVQsV0FBVztvQkFDMUc7Z0JBQ0o7b0JBQ0ksSUFBSXRSLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLHVCQUF1QixHQUN2QixJQUFJRCxRQUFRNEgsTUFBTSxLQUFLLElBQ25CdEYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTRILE1BQU07UUFDakUsMEJBQTBCLEdBQzFCLElBQUk1SCxRQUFRNkgsU0FBUyxLQUFLLElBQ3RCdkYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTZILFNBQVM7UUFDcEUsK0NBQStDLEdBQy9DLElBQUk3SCxRQUFRZ0wsSUFBSSxLQUFLLEdBQ2pCMUksT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUWdMLElBQUk7UUFDckQsMkRBQTJELEdBQzNELElBQUloTCxRQUFRbVQsS0FBSyxLQUFLLEdBQ2xCN1EsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUW1ULEtBQUs7UUFDdEQsd0RBQXdELEdBQ3hELElBQUluVCxRQUFRaVQsV0FBVyxFQUNuQmpNLFlBQVkzRSxtQkFBbUIsQ0FBQ3JDLFFBQVFpVCxXQUFXLEVBQUUzUSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUN0SCxJQUFJZixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU11TyxtQkFBbUIsSUFBSXFDO0FBQzdCLDJGQUEyRjtBQUMzRixNQUFNRSx5QkFBeUJqYSw2REFBV0E7SUFDdENvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLHNDQUFzQztZQUN4QztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBU0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ25FO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7WUFDeEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsRUFBRSxtQkFBbUI7WUFDNUI7WUFDQTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNd007WUFDYjtZQUNBO2dCQUFFN00sSUFBSTtnQkFBR0MsTUFBTTtnQkFBYUMsTUFBTTtnQkFBV0csR0FBRyxJQUFNd1Q7WUFBVTtZQUNoRTtnQkFDSTdULElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsRUFBRSxpQkFBaUI7WUFDMUI7U0FDSDtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFzVCxLQUFLLEdBQUc7UUFDaEJ0VCxRQUFRNkgsU0FBUyxHQUFHO1FBQ3BCN0gsUUFBUXVULGFBQWEsR0FBRztRQUN4QnZULFFBQVF3VCxhQUFhLEdBQUc7UUFDeEIsSUFBSXpTLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssZ0JBQWdCLEdBQUc7b0JBQ3BCdkIsUUFBUXNULEtBQUssR0FBR25TLE9BQU9pQixNQUFNO29CQUM3QjtnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6QnBDLFFBQVE2SCxTQUFTLEdBQUcxRyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0osS0FBSyx5QkFBeUIsR0FBRztvQkFDN0JwQyxRQUFRdVQsYUFBYSxHQUFHcFMsT0FBT2lCLE1BQU07b0JBQ3JDO2dCQUNKLEtBQUssd0RBQXdELEdBQUc7b0JBQzVEcEMsUUFBUXlULGFBQWEsR0FBR3BILGNBQWNuTCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUXlULGFBQWE7b0JBQ2hIO2dCQUNKLEtBQUssOENBQThDLEdBQUc7b0JBQ2xEelQsUUFBUTBULFNBQVMsR0FBR0wsVUFBVW5TLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRMFQsU0FBUztvQkFDcEc7Z0JBQ0osS0FBSyx1QkFBdUIsR0FBRztvQkFDM0IxVCxRQUFRd1QsYUFBYSxHQUFHclMsT0FBT2dELElBQUk7b0JBQ25DO2dCQUNKO29CQUNJLElBQUl4QyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxxQkFBcUIsR0FDckIsSUFBSUQsUUFBUXNULEtBQUssS0FBSyxJQUNsQmhSLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVFzVCxLQUFLO1FBQ2hFLDBCQUEwQixHQUMxQixJQUFJdFQsUUFBUTZILFNBQVMsS0FBSyxJQUN0QnZGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE2SCxTQUFTO1FBQ3BFLDhCQUE4QixHQUM5QixJQUFJN0gsUUFBUXVULGFBQWEsS0FBSyxJQUMxQmpSLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVF1VCxhQUFhO1FBQ3hFLDZEQUE2RCxHQUM3RCxJQUFJdlQsUUFBUXlULGFBQWEsRUFDckJwSCxjQUFjaEssbUJBQW1CLENBQUNyQyxRQUFReVQsYUFBYSxFQUFFblIsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDMUgsbURBQW1ELEdBQ25ELElBQUkxQyxRQUFRMFQsU0FBUyxFQUNqQkwsVUFBVWhSLG1CQUFtQixDQUFDckMsUUFBUTBULFNBQVMsRUFBRXBSLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ2xILDRCQUE0QixHQUM1QixJQUFJMUMsUUFBUXdULGFBQWEsS0FBSyxPQUMxQmxSLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVELElBQUksQ0FBQ25FLFFBQVF3VCxhQUFhO1FBQzdELElBQUk3UixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1rUSxjQUFjLElBQUlZO0FBQ3hCLDJGQUEyRjtBQUMzRixNQUFNTyx1QkFBdUJ4YSw2REFBV0E7SUFDcENvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLG9DQUFvQztZQUN0QztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLG1CQUFtQjtZQUM1QjtZQUNBO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1pTDtZQUNiO1lBQ0E7Z0JBQ0l0TCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU02TztZQUNiO1NBQ0g7SUFDTDtJQUNBN04sT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRNFQsU0FBUyxHQUFHO1FBQ3BCNVQsUUFBUTZULGVBQWUsR0FBRyxFQUFFO1FBQzVCN1QsUUFBUThULGFBQWEsR0FBRyxFQUFFO1FBQzFCLElBQUkvUyxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLHNCQUFzQixHQUFHO29CQUMxQnZCLFFBQVE0VCxTQUFTLEdBQUd6UyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0osS0FBSywrREFBK0QsR0FBRztvQkFDbkVwQyxRQUFRNlQsZUFBZSxDQUFDcFAsSUFBSSxDQUFDcUcsVUFBVTVKLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQztvQkFDbkY7Z0JBQ0osS0FBSywyRUFBMkUsR0FBRztvQkFDL0VELFFBQVE4VCxhQUFhLENBQUNyUCxJQUFJLENBQUNpSyx5QkFBeUJ4TixrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEM7b0JBQ2hHO2dCQUNKO29CQUNJLElBQUkwQixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywyQkFBMkIsR0FDM0IsSUFBSUQsUUFBUTRULFNBQVMsS0FBSyxJQUN0QnRSLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVE0VCxTQUFTO1FBQ3BFLG9FQUFvRSxHQUNwRSxJQUFLLElBQUlsUCxJQUFJLEdBQUdBLElBQUkxRSxRQUFRNlQsZUFBZSxDQUFDelMsTUFBTSxFQUFFc0QsSUFDaERvRyxVQUFVekksbUJBQW1CLENBQUNyQyxRQUFRNlQsZUFBZSxDQUFDblAsRUFBRSxFQUFFcEMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDM0gsZ0ZBQWdGLEdBQ2hGLElBQUssSUFBSWdDLElBQUksR0FBR0EsSUFBSTFFLFFBQVE4VCxhQUFhLENBQUMxUyxNQUFNLEVBQUVzRCxJQUM5Q2dLLHlCQUF5QnJNLG1CQUFtQixDQUFDckMsUUFBUThULGFBQWEsQ0FBQ3BQLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3hJLElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTStRLFlBQVksSUFBSU07QUFDdEIsMkZBQTJGO0FBQzNGLE1BQU1JLDBCQUEwQjVhLDZEQUFXQTtJQUN2Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsdUNBQXVDO1lBQ3pDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFjQyxNQUFNO2dCQUFXRyxHQUFHLElBQU0wSDtZQUFZO1lBQ25FO2dCQUFFL0gsSUFBSTtnQkFBR0MsTUFBTTtnQkFBZUMsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLGlCQUFpQjtZQUFHO1NBQzFFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUWdVLFdBQVcsR0FBRztRQUN0QixJQUFJalQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxnREFBZ0QsR0FBRztvQkFDcER2QixRQUFRaVUsU0FBUyxHQUFHMU0sWUFBWXJHLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQyxTQUFTRCxRQUFRaVUsU0FBUztvQkFDdEc7Z0JBQ0osS0FBSyxvQkFBb0IsR0FBRztvQkFDeEJqVSxRQUFRZ1UsV0FBVyxHQUFHN1MsT0FBT2dELElBQUk7b0JBQ2pDO2dCQUNKO29CQUNJLElBQUl4QyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxxREFBcUQsR0FDckQsSUFBSUQsUUFBUWlVLFNBQVMsRUFDakIxTSxZQUFZbEYsbUJBQW1CLENBQUNyQyxRQUFRaVUsU0FBUyxFQUFFM1IsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDcEgseUJBQXlCLEdBQ3pCLElBQUkxQyxRQUFRZ1UsV0FBVyxLQUFLLE9BQ3hCMVIsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUQsSUFBSSxDQUFDbkUsUUFBUWdVLFdBQVc7UUFDM0QsSUFBSXJTLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTW9PLGVBQWUsSUFBSXFEO0FBQ3pCLDJGQUEyRjtBQUMzRixNQUFNRywrQkFBK0IvYSw2REFBV0E7SUFDNUNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLDRDQUE0QztZQUM5QztnQkFBRUMsSUFBSTtnQkFBR0MsTUFBTTtnQkFBWUMsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3RFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFXRyxHQUFHLElBQU1tSDtZQUFZO1NBQ3ZFO0lBQ0w7SUFDQW5HLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUW1VLE9BQU8sR0FBRztRQUNsQixJQUFJcFQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxtQkFBbUIsR0FBRztvQkFDdkJ2QixRQUFRbVUsT0FBTyxHQUFHaFQsT0FBT2lCLE1BQU07b0JBQy9CO2dCQUNKLEtBQUssbURBQW1ELEdBQUc7b0JBQ3ZEcEMsUUFBUWlULFdBQVcsR0FBR2pNLFlBQVk5RixrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUWlULFdBQVc7b0JBQzFHO2dCQUNKO29CQUNJLElBQUl0UixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyx3QkFBd0IsR0FDeEIsSUFBSUQsUUFBUW1VLE9BQU8sS0FBSyxJQUNwQjdSLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVKLE1BQU0sQ0FBQ3BDLFFBQVFtVSxPQUFPO1FBQ2xFLHdEQUF3RCxHQUN4RCxJQUFJblUsUUFBUWlULFdBQVcsRUFDbkJqTSxZQUFZM0UsbUJBQW1CLENBQUNyQyxRQUFRaVQsV0FBVyxFQUFFM1EsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDdEgsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNaU8sb0JBQW9CLElBQUkyRDtBQUM5QiwyRkFBMkY7QUFDM0YsTUFBTUUsNkJBQTZCamIsNkRBQVdBO0lBQzFDb0csYUFBYztRQUNWLEtBQUssQ0FBQywwQ0FBMEM7WUFDNUM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVlDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUN0RTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBZUMsTUFBTTtnQkFBV0csR0FBRyxJQUFNbUg7WUFBWTtTQUN2RTtJQUNMO0lBQ0FuRyxPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFtVSxPQUFPLEdBQUc7UUFDbEIsSUFBSXBULFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssbUJBQW1CLEdBQUc7b0JBQ3ZCdkIsUUFBUW1VLE9BQU8sR0FBR2hULE9BQU9pQixNQUFNO29CQUMvQjtnQkFDSixLQUFLLG1EQUFtRCxHQUFHO29CQUN2RHBDLFFBQVFpVCxXQUFXLEdBQUdqTSxZQUFZOUYsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFpVCxXQUFXO29CQUMxRztnQkFDSjtvQkFDSSxJQUFJdFIsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsd0JBQXdCLEdBQ3hCLElBQUlELFFBQVFtVSxPQUFPLEtBQUssSUFDcEI3UixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRbVUsT0FBTztRQUNsRSx3REFBd0QsR0FDeEQsSUFBSW5VLFFBQVFpVCxXQUFXLEVBQ25Cak0sWUFBWTNFLG1CQUFtQixDQUFDckMsUUFBUWlULFdBQVcsRUFBRTNRLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3RILElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWtPLGtCQUFrQixJQUFJNEQ7QUFDNUIsMkZBQTJGO0FBQzNGLE1BQU1DLDZCQUE2QmxiLDZEQUFXQTtJQUMxQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsMENBQTBDO1lBQzVDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsaUJBQWlCO1lBQUc7WUFDdkU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQU9DLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztTQUNwRTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVEyUCxVQUFVLEdBQUc7UUFDckIzUCxRQUFRa1AsR0FBRyxHQUFHO1FBQ2QsSUFBSW5PLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssb0JBQW9CLEdBQUc7b0JBQ3hCdkIsUUFBUTJQLFVBQVUsR0FBR3hPLE9BQU9nRCxJQUFJO29CQUNoQztnQkFDSixLQUFLLGNBQWMsR0FBRztvQkFDbEJuRSxRQUFRa1AsR0FBRyxHQUFHL04sT0FBT2lCLE1BQU07b0JBQzNCO2dCQUNKO29CQUNJLElBQUlULElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLHlCQUF5QixHQUN6QixJQUFJRCxRQUFRMlAsVUFBVSxLQUFLLE9BQ3ZCck4sT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUQsSUFBSSxDQUFDbkUsUUFBUTJQLFVBQVU7UUFDMUQsbUJBQW1CLEdBQ25CLElBQUkzUCxRQUFRa1AsR0FBRyxLQUFLLElBQ2hCNU0sT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUWtQLEdBQUc7UUFDOUQsSUFBSXZOLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTROLGtCQUFrQixJQUFJbUU7QUFDNUIsMkZBQTJGO0FBQzNGLE1BQU1DLDZCQUE2Qm5iLDZEQUFXQTtJQUMxQ29HLGFBQWM7UUFDVixLQUFLLENBQUMsMENBQTBDO1lBQzVDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFPQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsbUJBQW1CO1lBQUc7U0FDcEU7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRa1AsR0FBRyxHQUFHO1FBQ2QsSUFBSW5PLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssY0FBYyxHQUFHO29CQUNsQnZCLFFBQVFrUCxHQUFHLEdBQUcvTixPQUFPaUIsTUFBTTtvQkFDM0I7Z0JBQ0o7b0JBQ0ksSUFBSVQsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsbUJBQW1CLEdBQ25CLElBQUlELFFBQVFrUCxHQUFHLEtBQUssSUFDaEI1TSxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRa1AsR0FBRztRQUM5RCxJQUFJdk4sSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNNk4sa0JBQWtCLElBQUltRTtBQUM1QiwyRkFBMkY7QUFDM0YsTUFBTUMsc0NBQXNDcGIsNkRBQVdBO0lBQ25Eb0csYUFBYztRQUNWLEtBQUssQ0FBQyxtREFBbUQ7WUFDckQ7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ042RSxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QjFFLEdBQUcsSUFBTTJVO1lBQ2I7U0FDSDtJQUNMO0lBQ0EzVCxPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVF5VSx3QkFBd0IsR0FBRyxFQUFFO1FBQ3JDLElBQUkxVCxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLG9GQUFvRixHQUFHO29CQUN4RnZCLFFBQVF5VSx3QkFBd0IsQ0FBQ2hRLElBQUksQ0FBQytQLHNCQUFzQnRULGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQztvQkFDeEc7Z0JBQ0o7b0JBQ0ksSUFBSTBCLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLHlGQUF5RixHQUN6RixJQUFLLElBQUl5RSxJQUFJLEdBQUdBLElBQUkxRSxRQUFReVUsd0JBQXdCLENBQUNyVCxNQUFNLEVBQUVzRCxJQUN6RDhQLHNCQUFzQm5TLG1CQUFtQixDQUFDckMsUUFBUXlVLHdCQUF3QixDQUFDL1AsRUFBRSxFQUFFcEMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDaEosSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNOE4sMkJBQTJCLElBQUltRTtBQUNyQywyRkFBMkY7QUFDM0YsTUFBTUcsbUNBQW1DdmIsNkRBQVdBO0lBQ2hEb0csYUFBYztRQUNWLEtBQUssQ0FBQyxnREFBZ0Q7WUFDbEQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUNJTCxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLElBQU07d0JBQ0w7d0JBQ0EyRzt3QkFDQTtxQkFDSDtZQUNMO1NBQ0g7SUFDTDtJQUNBM0YsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRNEgsTUFBTSxHQUFHO1FBQ2pCNUgsUUFBUTZILFNBQVMsR0FBRztRQUNwQjdILFFBQVFpSSxpQkFBaUIsR0FBRztRQUM1QixJQUFJbEgsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxrQkFBa0IsR0FBRztvQkFDdEJ2QixRQUFRNEgsTUFBTSxHQUFHekcsT0FBT2lCLE1BQU07b0JBQzlCO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCcEMsUUFBUTZILFNBQVMsR0FBRzFHLE9BQU9pQixNQUFNO29CQUNqQztnQkFDSixLQUFLLGdFQUFnRSxHQUFHO29CQUNwRXBDLFFBQVFpSSxpQkFBaUIsR0FBRzlHLE9BQU84QyxLQUFLO29CQUN4QztnQkFDSjtvQkFDSSxJQUFJdEMsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsdUJBQXVCLEdBQ3ZCLElBQUlELFFBQVE0SCxNQUFNLEtBQUssSUFDbkJ0RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNEgsTUFBTTtRQUNqRSwwQkFBMEIsR0FDMUIsSUFBSTVILFFBQVE2SCxTQUFTLEtBQUssSUFDdEJ2RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNkgsU0FBUztRQUNwRSxxRUFBcUUsR0FDckUsSUFBSTdILFFBQVFpSSxpQkFBaUIsS0FBSyxHQUM5QjNGLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVFpSSxpQkFBaUI7UUFDbEUsSUFBSXRHLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWtTLHdCQUF3QixJQUFJRTtBQUNsQywyRkFBMkY7QUFDM0YsTUFBTUMsb0NBQW9DeGIsNkRBQVdBO0lBQ2pEb0csYUFBYztRQUNWLEtBQUssQ0FBQyxpREFBaUQ7WUFDbkQ7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1NBQzNFO0lBQ0w7SUFDQWdCLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTRILE1BQU0sR0FBRztRQUNqQjVILFFBQVE2SCxTQUFTLEdBQUc7UUFDcEIsSUFBSTlHLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssa0JBQWtCLEdBQUc7b0JBQ3RCdkIsUUFBUTRILE1BQU0sR0FBR3pHLE9BQU9pQixNQUFNO29CQUM5QjtnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6QnBDLFFBQVE2SCxTQUFTLEdBQUcxRyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0o7b0JBQ0ksSUFBSVQsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsdUJBQXVCLEdBQ3ZCLElBQUlELFFBQVE0SCxNQUFNLEtBQUssSUFDbkJ0RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNEgsTUFBTTtRQUNqRSwwQkFBMEIsR0FDMUIsSUFBSTVILFFBQVE2SCxTQUFTLEtBQUssSUFDdEJ2RixPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRNkgsU0FBUztRQUNwRSxJQUFJbEcsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNbU8seUJBQXlCLElBQUlrRTtBQUNuQywyRkFBMkY7QUFDM0YsTUFBTUMsd0JBQXdCemIsNkRBQVdBO0lBQ3JDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxxQ0FBcUM7WUFDdkM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNyRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBY0MsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLG1CQUFtQjtZQUFHO1lBQ3hFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFTQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsa0JBQWtCO1lBQUc7WUFDbEU7Z0JBQUVMLElBQUk7Z0JBQUdDLE1BQU07Z0JBQWVDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxpQkFBaUI7WUFBRztTQUMxRTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVE0SCxNQUFNLEdBQUc7UUFDakI1SCxRQUFRNkgsU0FBUyxHQUFHO1FBQ3BCN0gsUUFBUTZVLEtBQUssR0FBRztRQUNoQjdVLFFBQVFrSSxVQUFVLEdBQUc7UUFDckIsSUFBSW5ILFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssa0JBQWtCLEdBQUc7b0JBQ3RCdkIsUUFBUTRILE1BQU0sR0FBR3pHLE9BQU9pQixNQUFNO29CQUM5QjtnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6QnBDLFFBQVE2SCxTQUFTLEdBQUcxRyxPQUFPaUIsTUFBTTtvQkFDakM7Z0JBQ0osS0FBSyxlQUFlLEdBQUc7b0JBQ25CcEMsUUFBUTZVLEtBQUssR0FBRzFULE9BQU9zSCxLQUFLO29CQUM1QjtnQkFDSixLQUFLLG9CQUFvQixHQUFHO29CQUN4QnpJLFFBQVFrSSxVQUFVLEdBQUcvRyxPQUFPZ0QsSUFBSTtvQkFDaEM7Z0JBQ0o7b0JBQ0ksSUFBSXhDLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLHVCQUF1QixHQUN2QixJQUFJRCxRQUFRNEgsTUFBTSxLQUFLLElBQ25CdEYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTRILE1BQU07UUFDakUsMEJBQTBCLEdBQzFCLElBQUk1SCxRQUFRNkgsU0FBUyxLQUFLLElBQ3RCdkYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUosTUFBTSxDQUFDcEMsUUFBUTZILFNBQVM7UUFDcEUsb0JBQW9CLEdBQ3BCLElBQUk3SCxRQUFRNlUsS0FBSyxLQUFLLEdBQ2xCdlMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ21QLEtBQUssRUFBRUYsS0FBSyxDQUFDekksUUFBUTZVLEtBQUs7UUFDckQseUJBQXlCLEdBQ3pCLElBQUk3VSxRQUFRa0ksVUFBVSxLQUFLLE9BQ3ZCNUYsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUQsSUFBSSxDQUFDbkUsUUFBUWtJLFVBQVU7UUFDMUQsSUFBSXZHLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXdTLGFBQWEsSUFBSUY7QUFDdkIsMkZBQTJGO0FBQzNGLE1BQU1HLCtCQUErQjViLDZEQUFXQTtJQUM1Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsNENBQTRDO1lBQzlDO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1pVjtZQUNiO1NBQ0g7SUFDTDtJQUNBalUsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRZ1YsV0FBVyxHQUFHLEVBQUU7UUFDeEIsSUFBSWpVLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssMkRBQTJELEdBQUc7b0JBQy9EdkIsUUFBUWdWLFdBQVcsQ0FBQ3ZRLElBQUksQ0FBQ3FRLFdBQVc1VCxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEM7b0JBQ2hGO2dCQUNKO29CQUNJLElBQUkwQixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxnRUFBZ0UsR0FDaEUsSUFBSyxJQUFJeUUsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUWdWLFdBQVcsQ0FBQzVULE1BQU0sRUFBRXNELElBQzVDb1EsV0FBV3pTLG1CQUFtQixDQUFDckMsUUFBUWdWLFdBQVcsQ0FBQ3RRLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQ3hILElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTStOLG9CQUFvQixJQUFJMEU7QUFDOUIsMkZBQTJGO0FBQzNGLE1BQU1FLCtCQUErQjliLDZEQUFXQTtJQUM1Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsNENBQTRDO1lBQzlDO2dCQUNJQyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNORyxHQUFHLEVBQUUsa0JBQWtCO1lBQzNCO1NBQ0g7SUFDTDtJQUNBZ0IsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFRa1YsWUFBWSxHQUFHO1FBQ3ZCLElBQUluVSxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLHVCQUF1QixHQUFHO29CQUMzQnZCLFFBQVFrVixZQUFZLEdBQUcvVCxPQUFPOEMsS0FBSztvQkFDbkM7Z0JBQ0o7b0JBQ0ksSUFBSXRDLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDRCQUE0QixHQUM1QixJQUFJRCxRQUFRa1YsWUFBWSxLQUFLLEdBQ3pCNVMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUWtWLFlBQVk7UUFDN0QsSUFBSXZULElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTZTLG9CQUFvQixJQUFJRjtBQUM5QiwyRkFBMkY7QUFDM0YsTUFBTUcseUJBQXlCamMsNkRBQVdBO0lBQ3RDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxzQ0FBc0M7WUFDeEM7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTXNWO1lBQ2I7WUFDQTtnQkFBRTNWLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTW1LO1lBQU07U0FDM0Q7SUFDTDtJQUNBbkosT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOUQsSUFBSUQsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSywwREFBMEQsR0FBRztvQkFDOUR2QixRQUFRcVYsWUFBWSxHQUFHRixrQkFBa0JqVSxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUXFWLFlBQVk7b0JBQ2xIO2dCQUNKLEtBQUssdUNBQXVDLEdBQUc7b0JBQzNDclYsUUFBUXNWLEtBQUssR0FBR3RMLE1BQU05SSxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUXNWLEtBQUs7b0JBQ3hGO2dCQUNKO29CQUNJLElBQUkzVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywrREFBK0QsR0FDL0QsSUFBSUQsUUFBUXFWLFlBQVksRUFDcEJGLGtCQUFrQjlTLG1CQUFtQixDQUFDckMsUUFBUXFWLFlBQVksRUFBRS9TLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzdILDRDQUE0QyxHQUM1QyxJQUFJMUMsUUFBUXNWLEtBQUssRUFDYnRMLE1BQU0zSCxtQkFBbUIsQ0FBQ3JDLFFBQVFzVixLQUFLLEVBQUVoVCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMxRyxJQUFJZixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1pVCxjQUFjLElBQUlIO0FBQ3hCLDJGQUEyRjtBQUMzRixNQUFNSSwrQkFBK0JyYyw2REFBV0E7SUFDNUNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLDRDQUE0QztZQUM5QztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxFQUFFLGtCQUFrQjtZQUMzQjtZQUNBO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsa0JBQWtCO1lBQUc7WUFDeEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsRUFBRSxrQkFBa0I7WUFDM0I7U0FDSDtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVF5VixXQUFXLEdBQUc7UUFDdEJ6VixRQUFRMFYsVUFBVSxHQUFHO1FBQ3JCMVYsUUFBUTJWLGNBQWMsR0FBRztRQUN6QixJQUFJNVUsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyxzQkFBc0IsR0FBRztvQkFDMUJ2QixRQUFReVYsV0FBVyxHQUFHdFUsT0FBTzhDLEtBQUs7b0JBQ2xDO2dCQUNKLEtBQUsscUJBQXFCLEdBQUc7b0JBQ3pCakUsUUFBUTBWLFVBQVUsR0FBR3ZVLE9BQU84QyxLQUFLO29CQUNqQztnQkFDSixLQUFLLDBCQUEwQixHQUFHO29CQUM5QmpFLFFBQVEyVixjQUFjLEdBQUd4VSxPQUFPOEMsS0FBSztvQkFDckM7Z0JBQ0o7b0JBQ0ksSUFBSXRDLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLDJCQUEyQixHQUMzQixJQUFJRCxRQUFReVYsV0FBVyxLQUFLLEdBQ3hCblQsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUXlWLFdBQVc7UUFDNUQsMEJBQTBCLEdBQzFCLElBQUl6VixRQUFRMFYsVUFBVSxLQUFLLEdBQ3ZCcFQsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUTBWLFVBQVU7UUFDM0QsK0JBQStCLEdBQy9CLElBQUkxVixRQUFRMlYsY0FBYyxLQUFLLEdBQzNCclQsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUTJWLGNBQWM7UUFDL0QsSUFBSWhVLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTXNULG9CQUFvQixJQUFJSjtBQUM5QiwyRkFBMkY7QUFDM0YsTUFBTUssK0JBQStCMWMsNkRBQVdBO0lBQzVDb0csYUFBYztRQUNWLEtBQUssQ0FBQyw0Q0FBNEM7WUFDOUM7Z0JBQUVDLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVFDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztZQUNsRTtnQkFBRUwsSUFBSTtnQkFBR0MsTUFBTTtnQkFBVUMsTUFBTTtnQkFBVUcsR0FBRyxFQUFFLGlCQUFpQjtZQUFHO1lBQ2xFO2dCQUFFTCxJQUFJO2dCQUFHQyxNQUFNO2dCQUFlQyxNQUFNO2dCQUFVRyxHQUFHLEVBQUUsa0JBQWtCO1lBQUc7WUFDeEU7Z0JBQ0lMLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsRUFBRSxrQkFBa0I7WUFDM0I7WUFDQTtnQkFDSUwsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUNMO3dCQUNBbVE7d0JBQ0E7cUJBQ0g7WUFDTDtZQUNBO2dCQUFFeFEsSUFBSTtnQkFBR0MsTUFBTTtnQkFBU0MsTUFBTTtnQkFBV0csR0FBRyxJQUFNbUs7WUFBTTtZQUN4RDtnQkFDSXhLLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsR0FBRyxtQkFBbUI7WUFDN0I7U0FDSDtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFQLElBQUksR0FBRztRQUNmTyxRQUFROFYsTUFBTSxHQUFHO1FBQ2pCOVYsUUFBUStWLFVBQVUsR0FBRztRQUNyQi9WLFFBQVFnVyxxQkFBcUIsR0FBRztRQUNoQ2hXLFFBQVFpVyxRQUFRLEdBQUc7UUFDbkJqVyxRQUFRa1csWUFBWSxHQUFHO1FBQ3ZCLElBQUluVixVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLGVBQWUsR0FBRztvQkFDbkJ2QixRQUFRUCxJQUFJLEdBQUcwQixPQUFPaUIsTUFBTTtvQkFDNUI7Z0JBQ0osS0FBSyxlQUFlLEdBQUc7b0JBQ25CcEMsUUFBUThWLE1BQU0sR0FBRzNVLE9BQU9nRCxJQUFJO29CQUM1QjtnQkFDSixLQUFLLHFCQUFxQixHQUFHO29CQUN6Qm5FLFFBQVErVixVQUFVLEdBQUc1VSxPQUFPOEMsS0FBSztvQkFDakM7Z0JBQ0osS0FBSyxrQ0FBa0MsR0FBRztvQkFDdENqRSxRQUFRZ1cscUJBQXFCLEdBQUc3VSxPQUFPc0gsS0FBSztvQkFDNUM7Z0JBQ0osS0FBSyw4REFBOEQsR0FBRztvQkFDbEV6SSxRQUFRaVcsUUFBUSxHQUFHOVUsT0FBTzhDLEtBQUs7b0JBQy9CO2dCQUNKLEtBQUssdUNBQXVDLEdBQUc7b0JBQzNDakUsUUFBUXNWLEtBQUssR0FBR3RMLE1BQU05SSxrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEMsU0FBU0QsUUFBUXNWLEtBQUs7b0JBQ3hGO2dCQUNKLEtBQUssd0JBQXdCLEdBQUc7b0JBQzVCdFYsUUFBUWtXLFlBQVksR0FBRy9VLE9BQU9jLE1BQU07b0JBQ3BDO2dCQUNKO29CQUNJLElBQUlOLElBQUkxQixRQUFRMkIsZ0JBQWdCO29CQUNoQyxJQUFJRCxNQUFNLFNBQ04sTUFBTSxJQUFJaEIsV0FBV3ZCLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRW1DLFFBQVEsWUFBWSxFQUFFQyxTQUFTLE1BQU0sRUFBRSxJQUFJLENBQUNaLFFBQVEsQ0FBQyxDQUFDO29CQUN0RyxJQUFJaUIsSUFBSVYsT0FBT1csSUFBSSxDQUFDTjtvQkFDcEIsSUFBSUcsTUFBTSxPQUNOLENBQUNBLE1BQU0sT0FBT3BJLHNFQUFtQkEsQ0FBQ3dJLE1BQU0sR0FBR0osQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3VCLFNBQVNDLFVBQVVLO1lBQ3JHO1FBQ0o7UUFDQSxPQUFPN0I7SUFDWDtJQUNBcUMsb0JBQW9CckMsT0FBTyxFQUFFc0MsTUFBTSxFQUFFckMsT0FBTyxFQUFFO1FBQzFDLG9CQUFvQixHQUNwQixJQUFJRCxRQUFRUCxJQUFJLEtBQUssSUFDakI2QyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRUCxJQUFJO1FBQy9ELG9CQUFvQixHQUNwQixJQUFJTyxRQUFROFYsTUFBTSxLQUFLLE9BQ25CeFQsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUQsSUFBSSxDQUFDbkUsUUFBUThWLE1BQU07UUFDdEQsMEJBQTBCLEdBQzFCLElBQUk5VixRQUFRK1YsVUFBVSxLQUFLLEdBQ3ZCelQsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQzRLLE1BQU0sRUFBRUgsS0FBSyxDQUFDakUsUUFBUStWLFVBQVU7UUFDM0QsdUNBQXVDLEdBQ3ZDLElBQUkvVixRQUFRZ1cscUJBQXFCLEtBQUssR0FDbEMxVCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDbVAsS0FBSyxFQUFFRixLQUFLLENBQUN6SSxRQUFRZ1cscUJBQXFCO1FBQ3JFLG1FQUFtRSxHQUNuRSxJQUFJaFcsUUFBUWlXLFFBQVEsS0FBSyxHQUNyQjNULE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVFpVyxRQUFRO1FBQ3pELDRDQUE0QyxHQUM1QyxJQUFJalcsUUFBUXNWLEtBQUssRUFDYnRMLE1BQU0zSCxtQkFBbUIsQ0FBQ3JDLFFBQVFzVixLQUFLLEVBQUVoVCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMxRyw2QkFBNkIsR0FDN0IsSUFBSTFDLFFBQVFrVyxZQUFZLEtBQUssR0FDekI1VCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDNEssTUFBTSxFQUFFbkMsTUFBTSxDQUFDakMsUUFBUWtXLFlBQVk7UUFDOUQsSUFBSXZVLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTZULG9CQUFvQixJQUFJTjtBQUM5QiwyRkFBMkY7QUFDM0YsTUFBTU8seUJBQXlCamQsNkRBQVdBO0lBQ3RDb0csYUFBYztRQUNWLEtBQUssQ0FBQyxzQ0FBc0M7WUFDeEM7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05HLEdBQUcsSUFBTStWO1lBQ2I7WUFDQTtnQkFBRXBXLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVNDLE1BQU07Z0JBQVdHLEdBQUcsSUFBTW1LO1lBQU07WUFDeEQ7Z0JBQ0l4SyxJQUFJO2dCQUNKQyxNQUFNO2dCQUNOQyxNQUFNO2dCQUNONkUsUUFBUSxFQUFFLG1CQUFtQjtnQkFDN0IxRSxHQUFHLElBQU1zVztZQUNiO1NBQ0g7SUFDTDtJQUNBdFYsT0FBT0UsS0FBSyxFQUFFO1FBQ1YsTUFBTWYsVUFBVVcsV0FBV04sTUFBTSxDQUFDUSxNQUFNLENBQUMsSUFBSSxDQUFDRyxnQkFBZ0I7UUFDOURoQixRQUFReUssTUFBTSxHQUFHLEVBQUU7UUFDbkIsSUFBSTFKLFVBQVVFLFdBQ1YzSCw2RUFBc0JBLENBQUMsSUFBSSxFQUFFMEcsU0FBU2U7UUFDMUMsT0FBT2Y7SUFDWDtJQUNBa0IsbUJBQW1CQyxNQUFNLEVBQUVDLE1BQU0sRUFBRW5CLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQ2hELElBQUlWLFVBQVVVLFVBQVUsSUFBSSxDQUFDRyxNQUFNLElBQUlRLE1BQU1GLE9BQU9HLEdBQUcsR0FBR0Y7UUFDMUQsTUFBT0QsT0FBT0csR0FBRyxHQUFHRCxJQUFLO1lBQ3JCLElBQUksQ0FBQ0UsU0FBU0MsU0FBUyxHQUFHTCxPQUFPTSxHQUFHO1lBQ3BDLE9BQVFGO2dCQUNKLEtBQUssMERBQTBELEdBQUc7b0JBQzlEdkIsUUFBUXFWLFlBQVksR0FBR08sa0JBQWtCMVUsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFxVixZQUFZO29CQUNsSDtnQkFDSixLQUFLLHVDQUF1QyxHQUFHO29CQUMzQ3JWLFFBQVFzVixLQUFLLEdBQUd0TCxNQUFNOUksa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVFzVixLQUFLO29CQUN4RjtnQkFDSixLQUFLLDREQUE0RCxHQUFHO29CQUNoRXRWLFFBQVF5SyxNQUFNLENBQUNoRyxJQUFJLENBQUMwUixrQkFBa0JqVixrQkFBa0IsQ0FBQ0MsUUFBUUEsT0FBT2MsTUFBTSxJQUFJaEM7b0JBQ2xGO2dCQUNKO29CQUNJLElBQUkwQixJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywrREFBK0QsR0FDL0QsSUFBSUQsUUFBUXFWLFlBQVksRUFDcEJPLGtCQUFrQnZULG1CQUFtQixDQUFDckMsUUFBUXFWLFlBQVksRUFBRS9TLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzdILDRDQUE0QyxHQUM1QyxJQUFJMUMsUUFBUXNWLEtBQUssRUFDYnRMLE1BQU0zSCxtQkFBbUIsQ0FBQ3JDLFFBQVFzVixLQUFLLEVBQUVoVCxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMxRyxpRUFBaUUsR0FDakUsSUFBSyxJQUFJZ0MsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUXlLLE1BQU0sQ0FBQ3JKLE1BQU0sRUFBRXNELElBQ3ZDeVIsa0JBQWtCOVQsbUJBQW1CLENBQUNyQyxRQUFReUssTUFBTSxDQUFDL0YsRUFBRSxFQUFFcEMsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDMUgsSUFBSWYsSUFBSTFCLFFBQVEwQyxrQkFBa0I7UUFDbEMsSUFBSWhCLE1BQU0sT0FDTixDQUFDQSxLQUFLLE9BQU9wSSxzRUFBbUJBLENBQUNxSixPQUFPLEdBQUdqQixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTc0M7UUFDMUUsT0FBT0E7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNK1QsY0FBYyxJQUFJRDtBQUN4QiwyRkFBMkY7QUFDM0YsTUFBTUUsa0NBQWtDbmQsNkRBQVdBO0lBQy9Db0csYUFBYztRQUNWLEtBQUssQ0FBQywrQ0FBK0M7WUFDakQ7Z0JBQ0lDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ042RSxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QjFFLEdBQUcsSUFBTTBWO1lBQ2I7WUFDQTtnQkFDSS9WLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ042RSxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QjFFLEdBQUcsSUFBTXdXO1lBQ2I7U0FDSDtJQUNMO0lBQ0F4VixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVF1VyxZQUFZLEdBQUcsRUFBRTtRQUN6QnZXLFFBQVF3VyxZQUFZLEdBQUcsRUFBRTtRQUN6QixJQUFJelYsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSyw2REFBNkQsR0FBRztvQkFDakV2QixRQUFRdVcsWUFBWSxDQUFDOVIsSUFBSSxDQUFDOFEsWUFBWXJVLGtCQUFrQixDQUFDQyxRQUFRQSxPQUFPYyxNQUFNLElBQUloQztvQkFDbEY7Z0JBQ0osS0FBSyw2REFBNkQsR0FBRztvQkFDakVELFFBQVF3VyxZQUFZLENBQUMvUixJQUFJLENBQUM0UixZQUFZblYsa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDO29CQUNsRjtnQkFDSjtvQkFDSSxJQUFJMEIsSUFBSTFCLFFBQVEyQixnQkFBZ0I7b0JBQ2hDLElBQUlELE1BQU0sU0FDTixNQUFNLElBQUloQixXQUFXdkIsS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFbUMsUUFBUSxZQUFZLEVBQUVDLFNBQVMsTUFBTSxFQUFFLElBQUksQ0FBQ1osUUFBUSxDQUFDLENBQUM7b0JBQ3RHLElBQUlpQixJQUFJVixPQUFPVyxJQUFJLENBQUNOO29CQUNwQixJQUFJRyxNQUFNLE9BQ04sQ0FBQ0EsTUFBTSxPQUFPcEksc0VBQW1CQSxDQUFDd0ksTUFBTSxHQUFHSixDQUFBQSxFQUFHLElBQUksQ0FBQ2YsUUFBUSxFQUFFWixTQUFTdUIsU0FBU0MsVUFBVUs7WUFDckc7UUFDSjtRQUNBLE9BQU83QjtJQUNYO0lBQ0FxQyxvQkFBb0JyQyxPQUFPLEVBQUVzQyxNQUFNLEVBQUVyQyxPQUFPLEVBQUU7UUFDMUMsa0VBQWtFLEdBQ2xFLElBQUssSUFBSXlFLElBQUksR0FBR0EsSUFBSTFFLFFBQVF1VyxZQUFZLENBQUNuVixNQUFNLEVBQUVzRCxJQUM3QzZRLFlBQVlsVCxtQkFBbUIsQ0FBQ3JDLFFBQVF1VyxZQUFZLENBQUM3UixFQUFFLEVBQUVwQyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFQyxJQUFJLElBQUl4QyxTQUFTeUMsSUFBSTtRQUMxSCxrRUFBa0UsR0FDbEUsSUFBSyxJQUFJZ0MsSUFBSSxHQUFHQSxJQUFJMUUsUUFBUXdXLFlBQVksQ0FBQ3BWLE1BQU0sRUFBRXNELElBQzdDMlIsWUFBWWhVLG1CQUFtQixDQUFDckMsUUFBUXdXLFlBQVksQ0FBQzlSLEVBQUUsRUFBRXBDLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUNnSixlQUFlLEVBQUVDLElBQUksSUFBSXhDLFNBQVN5QyxJQUFJO1FBQzFILElBQUlmLElBQUkxQixRQUFRMEMsa0JBQWtCO1FBQ2xDLElBQUloQixNQUFNLE9BQ04sQ0FBQ0EsS0FBSyxPQUFPcEksc0VBQW1CQSxDQUFDcUosT0FBTyxHQUFHakIsQ0FBQUEsRUFBRyxJQUFJLENBQUNmLFFBQVEsRUFBRVosU0FBU3NDO1FBQzFFLE9BQU9BO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWdPLHVCQUF1QixJQUFJZ0c7QUFDakMsMkZBQTJGO0FBQzNGLE1BQU1HLCtCQUErQnRkLDZEQUFXQTtJQUM1Q29HLGFBQWM7UUFDVixLQUFLLENBQUMsNENBQTRDO1lBQzlDO2dCQUFFQyxJQUFJO2dCQUFHQyxNQUFNO2dCQUFrQkMsTUFBTTtnQkFBV0csR0FBRyxJQUFNc047WUFBVztZQUN0RTtnQkFBRTNOLElBQUk7Z0JBQUdDLE1BQU07Z0JBQVdDLE1BQU07Z0JBQVVHLEdBQUcsRUFBRSxtQkFBbUI7WUFBRztTQUN4RTtJQUNMO0lBQ0FnQixPQUFPRSxLQUFLLEVBQUU7UUFDVixNQUFNZixVQUFVVyxXQUFXTixNQUFNLENBQUNRLE1BQU0sQ0FBQyxJQUFJLENBQUNHLGdCQUFnQjtRQUM5RGhCLFFBQVFBLE9BQU8sR0FBRztRQUNsQixJQUFJZSxVQUFVRSxXQUNWM0gsNkVBQXNCQSxDQUFDLElBQUksRUFBRTBHLFNBQVNlO1FBQzFDLE9BQU9mO0lBQ1g7SUFDQWtCLG1CQUFtQkMsTUFBTSxFQUFFQyxNQUFNLEVBQUVuQixPQUFPLEVBQUVTLE1BQU0sRUFBRTtRQUNoRCxJQUFJVixVQUFVVSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJUSxNQUFNRixPQUFPRyxHQUFHLEdBQUdGO1FBQzFELE1BQU9ELE9BQU9HLEdBQUcsR0FBR0QsSUFBSztZQUNyQixJQUFJLENBQUNFLFNBQVNDLFNBQVMsR0FBR0wsT0FBT00sR0FBRztZQUNwQyxPQUFRRjtnQkFDSixLQUFLLHFEQUFxRCxHQUFHO29CQUN6RHZCLFFBQVEwVyxhQUFhLEdBQUd2SixXQUFXak0sa0JBQWtCLENBQUNDLFFBQVFBLE9BQU9jLE1BQU0sSUFBSWhDLFNBQVNELFFBQVEwVyxhQUFhO29CQUM3RztnQkFDSixLQUFLLGtCQUFrQixHQUFHO29CQUN0QjFXLFFBQVFBLE9BQU8sR0FBR21CLE9BQU9pQixNQUFNO29CQUMvQjtnQkFDSjtvQkFDSSxJQUFJVCxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQywwREFBMEQsR0FDMUQsSUFBSUQsUUFBUTBXLGFBQWEsRUFDckJ2SixXQUFXOUssbUJBQW1CLENBQUNyQyxRQUFRMFcsYUFBYSxFQUFFcFUsT0FBT2IsR0FBRyxDQUFDLEdBQUdqSSwyREFBUUEsQ0FBQ2dKLGVBQWUsRUFBRUMsSUFBSSxJQUFJeEMsU0FBU3lDLElBQUk7UUFDdkgsdUJBQXVCLEdBQ3ZCLElBQUkxQyxRQUFRQSxPQUFPLEtBQUssSUFDcEJzQyxPQUFPYixHQUFHLENBQUMsR0FBR2pJLDJEQUFRQSxDQUFDZ0osZUFBZSxFQUFFSixNQUFNLENBQUNwQyxRQUFRQSxPQUFPO1FBQ2xFLElBQUkyQixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU15TyxvQkFBb0IsSUFBSTBGO0FBQzlCLDJGQUEyRjtBQUMzRixNQUFNRSxvQkFBb0J4ZCw2REFBV0E7SUFDakNvRyxhQUFjO1FBQ1YsS0FBSyxDQUFDLGlDQUFpQztZQUNuQztnQkFDSUMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkcsR0FBRyxJQUFNO3dCQUNMO3dCQUNBaUg7d0JBQ0E7cUJBQ0g7WUFDTDtTQUNIO0lBQ0w7SUFDQWpHLE9BQU9FLEtBQUssRUFBRTtRQUNWLE1BQU1mLFVBQVVXLFdBQVdOLE1BQU0sQ0FBQ1EsTUFBTSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCO1FBQzlEaEIsUUFBUTRXLE1BQU0sR0FBRztRQUNqQixJQUFJN1YsVUFBVUUsV0FDVjNILDZFQUFzQkEsQ0FBQyxJQUFJLEVBQUUwRyxTQUFTZTtRQUMxQyxPQUFPZjtJQUNYO0lBQ0FrQixtQkFBbUJDLE1BQU0sRUFBRUMsTUFBTSxFQUFFbkIsT0FBTyxFQUFFUyxNQUFNLEVBQUU7UUFDaEQsSUFBSVYsVUFBVVUsVUFBVSxJQUFJLENBQUNHLE1BQU0sSUFBSVEsTUFBTUYsT0FBT0csR0FBRyxHQUFHRjtRQUMxRCxNQUFPRCxPQUFPRyxHQUFHLEdBQUdELElBQUs7WUFDckIsSUFBSSxDQUFDRSxTQUFTQyxTQUFTLEdBQUdMLE9BQU9NLEdBQUc7WUFDcEMsT0FBUUY7Z0JBQ0osS0FBSywrQ0FBK0MsR0FBRztvQkFDbkR2QixRQUFRNFcsTUFBTSxHQUFHelYsT0FBTzhDLEtBQUs7b0JBQzdCO2dCQUNKO29CQUNJLElBQUl0QyxJQUFJMUIsUUFBUTJCLGdCQUFnQjtvQkFDaEMsSUFBSUQsTUFBTSxTQUNOLE1BQU0sSUFBSWhCLFdBQVd2QixLQUFLLENBQUMsQ0FBQyxjQUFjLEVBQUVtQyxRQUFRLFlBQVksRUFBRUMsU0FBUyxNQUFNLEVBQUUsSUFBSSxDQUFDWixRQUFRLENBQUMsQ0FBQztvQkFDdEcsSUFBSWlCLElBQUlWLE9BQU9XLElBQUksQ0FBQ047b0JBQ3BCLElBQUlHLE1BQU0sT0FDTixDQUFDQSxNQUFNLE9BQU9wSSxzRUFBbUJBLENBQUN3SSxNQUFNLEdBQUdKLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVN1QixTQUFTQyxVQUFVSztZQUNyRztRQUNKO1FBQ0EsT0FBTzdCO0lBQ1g7SUFDQXFDLG9CQUFvQnJDLE9BQU8sRUFBRXNDLE1BQU0sRUFBRXJDLE9BQU8sRUFBRTtRQUMxQyxvREFBb0QsR0FDcEQsSUFBSUQsUUFBUTRXLE1BQU0sS0FBSyxHQUNuQnRVLE9BQU9iLEdBQUcsQ0FBQyxHQUFHakksMkRBQVFBLENBQUM0SyxNQUFNLEVBQUVILEtBQUssQ0FBQ2pFLFFBQVE0VyxNQUFNO1FBQ3ZELElBQUlqVixJQUFJMUIsUUFBUTBDLGtCQUFrQjtRQUNsQyxJQUFJaEIsTUFBTSxPQUNOLENBQUNBLEtBQUssT0FBT3BJLHNFQUFtQkEsQ0FBQ3FKLE9BQU8sR0FBR2pCLENBQUFBLEVBQUcsSUFBSSxDQUFDZixRQUFRLEVBQUVaLFNBQVNzQztRQUMxRSxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU0wTyxTQUFTLElBQUkyRjtBQUVuQixJQUFJRSxTQUFTLFdBQVcsR0FBRXhXLE9BQU9nTixNQUFNLENBQUM7SUFDcENDLFdBQVc7SUFDWHdILFlBQVlBO0lBQ1p6RSxtQkFBbUJBO0lBQ25COEUsbUJBQW1CQTtJQUNuQkksYUFBYUE7SUFDYnhFLG1CQUFtQkE7SUFDbkJULHNCQUFzQkE7SUFDdEJGLDBCQUEwQkE7SUFDMUJvRSx1QkFBdUJBO0lBQ3ZCL0Qsd0JBQXdCQTtJQUN4QnJSLE9BQU8wUjtJQUNQRSxRQUFRQTtJQUNSeUIsb0JBQW9CQTtJQUNwQjlCLHFCQUFxQkE7SUFDckJNLFlBQVlBO0lBQ1p4RCxZQUFZQTtJQUNaK0UsYUFBYUE7SUFDYjlCLGNBQWNBO0lBQ2QyQyxXQUFXQTtJQUNYOUMsbUJBQW1CQTtJQUNuQkMsaUJBQWlCQTtJQUNqQlUsYUFBYUE7SUFDYmYsaUJBQWlCQTtJQUNqQmlDLFVBQVVBO0lBQ1ZTLFlBQVlBO0lBQ1ozQyxpQkFBaUJBO0lBQ2pCVSxnQkFBZ0JBO0lBQ2hCQyxrQkFBa0JBO0lBQ2xCc0YsbUJBQW1CQTtJQUNuQixJQUFJbkcsOEJBQThCO1FBQUUsT0FBT0E7SUFBNEI7SUFDdkU0RixtQkFBbUJBO0lBQ25CUyxhQUFhQTtBQUNqQjtBQUVBLElBQUlTO0FBQ0gsVUFBVUEsZUFBZTtJQUN0QkEsZUFBZSxDQUFDLFVBQVUsR0FBRztJQUM3QkEsZUFBZSxDQUFDLFVBQVUsR0FBRztJQUM3QkEsZUFBZSxDQUFDLFlBQVksR0FBRztBQUNuQyxHQUFHQSxtQkFBb0JBLENBQUFBLGtCQUFrQixDQUFDO0FBQzFDLElBQUlDO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUMvQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLElBQUksR0FBRztJQUMzQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRztJQUM3Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsT0FBTyxHQUFHLEtBQUssR0FBRztBQUNoRCxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUVwQzs7Q0FFQyxHQUNELE1BQU1DO0lBQ0Z6WCxZQUFZMFgsVUFBVSxDQUFFO1FBQ3BCLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNyVyxRQUFRLEdBQUdpUCxhQUFhalAsUUFBUTtRQUNyQyxJQUFJLENBQUNzVyxPQUFPLEdBQUdySCxhQUFhcUgsT0FBTztRQUNuQyxJQUFJLENBQUNqWCxPQUFPLEdBQUc0UCxhQUFhNVAsT0FBTztJQUN2QztJQUNBOzs7O0tBSUMsR0FDRGtYLGFBQWFDLEtBQUssRUFBRW5YLE9BQU8sRUFBRTtRQUN6QixNQUFNb1gsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQyxFQUFFLEVBQUVJLE1BQU0sSUFBSSxDQUFDTCxVQUFVLENBQUNNLFlBQVksQ0FBQ3RYO1FBQ25FLE9BQU90Ryx5RUFBY0EsQ0FBQyxTQUFTLElBQUksQ0FBQ3NkLFVBQVUsRUFBRUksUUFBUUMsS0FBS0Y7SUFDakU7SUFDQTs7OztLQUlDLEdBQ0RJLFdBQVdKLEtBQUssRUFBRW5YLE9BQU8sRUFBRTtRQUN2QixNQUFNb1gsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQyxFQUFFLEVBQUVJLE1BQU0sSUFBSSxDQUFDTCxVQUFVLENBQUNNLFlBQVksQ0FBQ3RYO1FBQ25FLE9BQU90Ryx5RUFBY0EsQ0FBQyxTQUFTLElBQUksQ0FBQ3NkLFVBQVUsRUFBRUksUUFBUUMsS0FBS0Y7SUFDakU7SUFDQTs7OztLQUlDLEdBQ0Q1RixXQUFXNEYsS0FBSyxFQUFFblgsT0FBTyxFQUFFO1FBQ3ZCLE1BQU1vWCxTQUFTLElBQUksQ0FBQ0gsT0FBTyxDQUFDLEVBQUUsRUFBRUksTUFBTSxJQUFJLENBQUNMLFVBQVUsQ0FBQ00sWUFBWSxDQUFDdFg7UUFDbkUsT0FBT3RHLHlFQUFjQSxDQUFDLFNBQVMsSUFBSSxDQUFDc2QsVUFBVSxFQUFFSSxRQUFRQyxLQUFLRjtJQUNqRTtJQUNBOzs7OztLQUtDLEdBQ0RLLG9CQUFvQkwsS0FBSyxFQUFFblgsT0FBTyxFQUFFO1FBQ2hDLE1BQU1vWCxTQUFTLElBQUksQ0FBQ0gsT0FBTyxDQUFDLEVBQUUsRUFBRUksTUFBTSxJQUFJLENBQUNMLFVBQVUsQ0FBQ00sWUFBWSxDQUFDdFg7UUFDbkUsT0FBT3RHLHlFQUFjQSxDQUFDLFNBQVMsSUFBSSxDQUFDc2QsVUFBVSxFQUFFSSxRQUFRQyxLQUFLRjtJQUNqRTtJQUNBOztLQUVDLEdBQ0RNLGlCQUFpQk4sS0FBSyxFQUFFblgsT0FBTyxFQUFFO1FBQzdCLE1BQU1vWCxTQUFTLElBQUksQ0FBQ0gsT0FBTyxDQUFDLEVBQUUsRUFBRUksTUFBTSxJQUFJLENBQUNMLFVBQVUsQ0FBQ00sWUFBWSxDQUFDdFg7UUFDbkUsT0FBT3RHLHlFQUFjQSxDQUFDLFNBQVMsSUFBSSxDQUFDc2QsVUFBVSxFQUFFSSxRQUFRQyxLQUFLRjtJQUNqRTtJQUNBOztLQUVDLEdBQ0R6SCxXQUFXeUgsS0FBSyxFQUFFblgsT0FBTyxFQUFFO1FBQ3ZCLE1BQU1vWCxTQUFTLElBQUksQ0FBQ0gsT0FBTyxDQUFDLEVBQUUsRUFBRUksTUFBTSxJQUFJLENBQUNMLFVBQVUsQ0FBQ00sWUFBWSxDQUFDdFg7UUFDbkUsT0FBT3RHLHlFQUFjQSxDQUFDLFNBQVMsSUFBSSxDQUFDc2QsVUFBVSxFQUFFSSxRQUFRQyxLQUFLRjtJQUNqRTtBQUNKO0FBRUEsTUFBTU8saUJBQWlCO0lBQ25CQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsU0FBUyxJQUFJO0lBQ2JDLGFBQWE7UUFDVEMscUJBQXFCO0lBQ3pCO0FBQ0o7QUFDQSxNQUFNQyxjQUFjLENBQUNDO0lBQ2pCLE9BQU87UUFDSEMsZ0JBQWVDLElBQUksRUFBRWYsTUFBTSxFQUFFRCxLQUFLLEVBQUVuWCxPQUFPO1lBQ3ZDQSxRQUFRb1ksSUFBSSxHQUFHO2dCQUFFLEdBQUdwWSxRQUFRb1ksSUFBSTtnQkFBRSxHQUFHSCxPQUFPO1lBQUM7WUFDN0MsT0FBT0UsS0FBS2YsUUFBUUQsT0FBT25YO1FBQy9CO0lBQ0o7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNcVkscUJBQXFCLENBQUNyWTtJQUN4QixNQUFNc1ksWUFBWSxJQUFJeGUsOEVBQW1CQSxDQUFDO1FBQ3RDLEdBQUc0ZCxjQUFjO1FBQ2pCLEdBQUcxWCxPQUFPO0lBQ2Q7SUFDQSxPQUFPLElBQUkrVyxtQkFBbUJ1QjtBQUNsQztBQUVBOztDQUVDLEdBQ0QsTUFBTUMsZ0JBQWdCO0lBQ2xCLElBQUksT0FBT0MsY0FBYyxhQUNyQixPQUFPO0lBQ1gsT0FBT0EsVUFBVUMsT0FBTyxFQUFFQyxrQkFBa0I7QUFDaEQ7QUFFQSxrQ0FBa0M7QUFDbEMsTUFBTUMsWUFBWXZZLE9BQU9nTixNQUFNLENBQUM7SUFDNUJ3TCxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05uTCxPQUFPO0FBQ1g7QUFDQSxJQUFJb0w7QUFDSixJQUFJcEUsUUFBUTtBQUNaLE1BQU1xRSxlQUFlLENBQUNDLFVBQVVuWixTQUFTLEdBQUdvWjtJQUN4QyxJQUFJQztJQUNKLE9BQVFGO1FBQ0osS0FBSztZQUNERSxZQUFZQyxRQUFRekwsS0FBSztZQUN6QjtRQUNKLEtBQUs7WUFDRCxJQUFJMkssaUJBQWlCO2dCQUNqQnhZLFVBQVUsQ0FBQyxNQUFNLEVBQUVBLFFBQVEsQ0FBQztnQkFDNUJxWixZQUFZQyxRQUFRUCxJQUFJO2dCQUN4QjtZQUNKO1lBQ0FNLFlBQVlDLFFBQVFOLElBQUk7WUFDeEI7UUFDSixLQUFLO1lBQ0RLLFlBQVlDLFFBQVFQLElBQUk7WUFDeEI7UUFDSixLQUFLO1lBQ0RNLFlBQVlDLFFBQVFULEtBQUs7WUFDekI7UUFDSjtZQUNJUSxZQUFZQyxRQUFRQyxHQUFHO1lBQ3ZCO0lBQ1I7SUFDQUYsVUFBVXJaLFlBQVlvWjtBQUMxQjtBQUNBLE1BQU1JLFlBQVksQ0FBQ0MsR0FBR0M7SUFDbEJULFdBQVdRO0lBQ1gsSUFBSUMsS0FBSztRQUNMQyxZQUFZRDtJQUNoQjtBQUNKO0FBQ0EsTUFBTUMsY0FBYyxDQUFDRjtJQUNqQjVFLFFBQVE0RTtBQUNaO0FBQ0EsTUFBTUcsWUFBWSxDQUFDQztJQUNmLE1BQU1DLGVBQWViLFlBQVlDO0lBQ2pDLE1BQU1hLE9BQU8sQ0FBQ0YsWUFBWSxFQUFFLEVBQUVuWCxJQUFJLENBQUM7SUFDbkMsTUFBTXNYLFNBQVMsQ0FBQ2IsVUFBVW5aLFNBQVMsR0FBR29aO1FBQ2xDLElBQUlSLFNBQVMsQ0FBQ08sU0FBUyxJQUFJUCxTQUFTLENBQUMvRCxNQUFNLEVBQUU7WUFDekNpRixhQUFhWCxVQUFVLENBQUMsQ0FBQyxFQUFFWSxLQUFLLEdBQUcsRUFBRS9aLFFBQVEsQ0FBQyxLQUFLb1o7UUFDdkQ7SUFDSjtJQUNBLE9BQU9ZO0FBQ1g7QUFFQSxNQUFNQyxxQkFBcUIsQ0FBQ3ZhLE1BQU13YSxnQkFBZ0JDO0lBQzlDLE1BQU1DLFNBQVNSLFVBQVU7UUFBQztLQUFTO0lBQ25DLElBQUksQ0FBRSxzQkFBcUJTLFlBQVcsR0FBSTtRQUN0Q0QsU0FBUyxRQUFRO1FBQ2pCO0lBQ0o7SUFDQSxNQUFNRSxNQUFNRCxhQUFhRSxlQUFlLENBQUM3YTtJQUN6QyxJQUFJLENBQUM0YSxLQUNEO0lBQ0osTUFBTUUsVUFBVSxFQUFFO0lBQ2xCLE1BQU1DLGlCQUFpQixFQUFFO0lBQ3pCLE1BQU1DLFlBQVksRUFBRTtJQUNwQkosSUFBSUssTUFBTSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7UUFDaEIsTUFBTXZGLFFBQVF1RixFQUFFQyxRQUFRLENBQUNuQyxXQUFXO1FBQ3BDeUIsU0FBUyxTQUFTLENBQUMsdUJBQXVCLEVBQUU5RSxNQUFNLENBQUM7UUFDbkQsTUFBTXlGLG9CQUFvQlosaUJBQWlCN0UsVUFBVSxDQUFDLEVBQUU1VixLQUFLLENBQUMsRUFBRXlhLGNBQWN4QixXQUFXLEdBQUcsQ0FBQztRQUM3RixJQUFJb0MsbUJBQ0E7UUFDSixNQUFNQyxlQUFlMUYsVUFBVSxDQUFDLEVBQUU1VixLQUFLLENBQUMsRUFBRXdhLGVBQWV2QixXQUFXLEdBQUcsQ0FBQztRQUN4RSxJQUFJLENBQUNxQyxjQUFjO1lBQ2ZOLFVBQVVqVyxJQUFJLENBQUNvVztZQUNmO1FBQ0o7UUFDQSxtRUFBbUU7UUFDbkUsNkRBQTZEO1FBQzdELElBQUl2RixVQUFVLFFBQVE7WUFDbEIsSUFBSXVGLEVBQUVJLFdBQVcsSUFBSUosRUFBRUksV0FBVyxDQUFDQyxRQUFRLENBQUMsNEJBQTRCO2dCQUNwRVYsUUFBUS9WLElBQUksQ0FBQ29XO1lBQ2pCLE9BQ0s7Z0JBQ0RKLGVBQWVoVyxJQUFJLENBQUNvVztZQUN4QjtZQUNBO1FBQ0o7UUFDQUwsUUFBUS9WLElBQUksQ0FBQ29XO0lBQ2pCO0lBQ0EsTUFBTWIsU0FBUztXQUFJUTtXQUFZQztXQUFtQkM7S0FBVTtJQUM1RE4sU0FBUyxRQUFRLENBQUMsa0JBQWtCLENBQUMsRUFBRUo7SUFDdkMsT0FBT0E7QUFDWDtBQUNBLE1BQU1tQixnQkFBZ0IsT0FBT0M7SUFDekIsTUFBTUMsU0FBUyxJQUFJQztJQUNuQkQsT0FBT0UsY0FBYyxDQUFDLFNBQVM7UUFBRUg7SUFBVTtJQUMzQ0MsT0FBT0UsY0FBYyxDQUFDLFNBQVM7UUFBRUg7SUFBVTtJQUMzQyxNQUFNSSxRQUFRLE1BQU1ILE9BQU9JLFdBQVc7SUFDdEMsSUFBSXZNLE1BQU1zTSxNQUFNdE0sR0FBRyxJQUFJO0lBQ3ZCbU0sT0FBT0ssZUFBZSxHQUFHZCxPQUFPLENBQUMsQ0FBQ2U7UUFDOUJBLEVBQUVDLElBQUk7SUFDVjtJQUNBUCxPQUFPUSxLQUFLO0lBQ1osT0FBTzNNO0FBQ1g7QUFFQSxNQUFNNE0sZ0JBQWdCO0lBQ2xCMUssaUJBQWlCblE7SUFDakJvUSxpQkFBaUJwUTtJQUNqQnFRLDBCQUEwQnJRO0lBQzFCc1EsbUJBQW1CdFE7SUFDbkJ1USxZQUFZdlE7SUFDWndRLHNCQUFzQnhRO0lBQ3RCeVEsbUJBQW1CelE7SUFDbkIwUSxpQkFBaUIxUTtJQUNqQjJRLHdCQUF3QjNRO0lBQ3hCNFEsY0FBYzVRO0lBQ2Q2USxxQkFBcUI3UTtJQUNyQjhRLGdCQUFnQjlRO0lBQ2hCK1Esa0JBQWtCL1E7SUFDbEI0TSxPQUFPNU07SUFDUGdSLG1CQUFtQmhSO0lBQ25CaVIsUUFBUWpSO0lBQ1IwTyxZQUFZMU87SUFDWmtSLGFBQWFsUjtBQUNqQjtBQUNBLE1BQU04YSxhQUFhLENBQUNDO0lBQ2hCLE9BQU8zYixPQUFPNGIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsZUFBZUU7QUFDL0Q7QUFDQSxNQUFNSTtJQUNGN2MsYUFBYztRQUNWLElBQUksQ0FBQzZhLE1BQU0sR0FBR1IsVUFBVTtZQUFDO1NBQWE7UUFDdEMsSUFBSSxDQUFDeUMsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsQ0FBQ3RjO1lBQ2IsTUFBTXVjLFlBQVl2YyxRQUFRbVIsWUFBWSxDQUFDbE8sU0FBUztZQUNoRCxJQUFJLENBQUNzWixXQUNEO1lBQ0osTUFBTUMsVUFBVXhjLFFBQVFtUixZQUFZLENBQUNvTCxVQUFVO1lBQy9DLElBQUksQ0FBQ25DLE1BQU0sQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFbUMsVUFBVSxDQUFDLEVBQUVDO1lBQ2pELE1BQU1DLFlBQVksSUFBSSxDQUFDSixXQUFXLENBQUNFLFVBQVU7WUFDN0MsSUFBSSxDQUFDRSxXQUNEO1lBQ0osS0FBSyxNQUFNQyxNQUFNRCxVQUFXO2dCQUN4QixJQUFJO29CQUNBQyxHQUFHRjtnQkFDUCxFQUNBLE9BQU9qVSxHQUFHO29CQUNOLElBQUksQ0FBQzZSLE1BQU0sQ0FBQyxRQUFRLDhCQUE4QjdSO2dCQUN0RDtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNvVSxFQUFFLEdBQUcsQ0FBQ1gsV0FBV1U7WUFDbEIsSUFBSUU7WUFDSCxFQUFDQSxLQUFLLElBQUksQ0FBQ1AsV0FBVyxDQUFDLENBQUNMLFVBQVUsSUFBS1ksQ0FBQUEsRUFBRSxDQUFDWixVQUFVLEdBQUcsRUFBRSxHQUFHdlgsSUFBSSxDQUFDaVk7WUFDbEUsT0FBTztnQkFDSCxJQUFJLENBQUNHLEdBQUcsQ0FBQ2IsV0FBV1U7WUFDeEI7UUFDSjtRQUNBLElBQUksQ0FBQ0csR0FBRyxHQUFHLENBQUNiLFdBQVdVO1lBQ25CLElBQUksQ0FBQ0wsV0FBVyxDQUFDTCxVQUFVLEdBQUcsQ0FBQyxJQUFJLENBQUNLLFdBQVcsQ0FBQ0wsVUFBVSxJQUFJLEVBQUUsRUFBRWhoQixNQUFNLENBQUMsQ0FBQ3lJLElBQU1BLE1BQU1pWjtRQUMxRjtRQUNBLElBQUksQ0FBQ0ksTUFBTSxHQUFHLENBQUNkO1lBQ1gsSUFBSUEsV0FBVztnQkFDWCxJQUFJLENBQUNLLFdBQVcsQ0FBQ0wsVUFBVSxHQUFHLEVBQUU7WUFDcEMsT0FDSztnQkFDRCxJQUFJLENBQUNLLFdBQVcsR0FBRyxDQUFDO1lBQ3hCO1FBQ0o7SUFDSjtBQUNKO0FBRUE7OztDQUdDLEdBQ0QsTUFBTVU7SUFDRnhkLGFBQWM7UUFDVixJQUFJLENBQUN5ZCxvQkFBb0IsR0FBRyxJQUFJaGpCLHlRQUFhQTtRQUM3QyxJQUFJLENBQUNpakIsbUJBQW1CLEdBQUcsSUFBSWpqQix5UUFBYUE7UUFDNUMsSUFBSSxDQUFDb2dCLE1BQU0sR0FBR1IsVUFBVTtZQUFDO1NBQWE7UUFDdEMsSUFBSSxDQUFDblYsSUFBSSxHQUFHLENBQUMrTTtZQUNULElBQUlBLFdBQVdySCxRQUFRLEtBQUs1RCxTQUFTMlcsVUFBVSxFQUFFO2dCQUM3QyxJQUFJLENBQUNGLG9CQUFvQixDQUFDNUUsSUFBSSxDQUFDNUc7WUFDbkMsT0FDSyxJQUFJQSxXQUFXckgsUUFBUSxLQUFLNUQsU0FBUzRXLHFCQUFxQixFQUFFO2dCQUM3RCxJQUFJLENBQUNGLG1CQUFtQixDQUFDN0UsSUFBSSxDQUFDNUc7WUFDbEMsT0FDSztnQkFDRCxJQUFJLENBQUM0SSxNQUFNLENBQUMsUUFBUSxDQUFDLDZCQUE2QixDQUFDLEVBQUU1STtZQUN6RDtRQUNKO0lBQ0o7QUFDSjtBQUVBLFNBQVM0TCxnQkFBZ0JDLFNBQVM7SUFDOUIsSUFBSSxDQUFDQSxVQUFVQyxnQkFBZ0IsRUFBRTtRQUM3Qix3RUFBd0U7UUFDeEUsTUFBTUMsb0JBQW9CRixVQUFVQSxTQUFTLENBQUNHLEtBQUssQ0FBQztRQUNwRCxNQUFNQyxhQUFhRixrQkFBa0JHLFNBQVMsQ0FBQyxDQUFDQyxJQUFNQSxNQUFNLFdBQVc7UUFDdkUsTUFBTUwsbUJBQW1CQyxpQkFBaUIsQ0FBQ0UsV0FBVztRQUN0RCxPQUFPRyxLQUFLQyxTQUFTLENBQUM7WUFBRSxHQUFHUixTQUFTO1lBQUVDO1FBQWlCO0lBQzNELE9BQ0s7UUFDRCxPQUFPTSxLQUFLQyxTQUFTLENBQUNSLFVBQVVTLE1BQU07SUFDMUM7QUFDSjtBQUVBLElBQUlDO0FBQ0osSUFBSUM7QUFDSixJQUFJQztBQUNKLE1BQU1DLGFBQWEsQ0FBQ25GO0lBQ2hCZ0YsVUFBVWhGO0FBQ2Q7QUFDQSxNQUFNb0YsYUFBYTtJQUNmLE9BQU9KO0FBQ1g7QUFDQSxNQUFNSyxZQUFZLENBQUNyRjtJQUNmaUYsU0FBU2pGO0FBQ2I7QUFDQSxNQUFNc0YsWUFBWTtJQUNkLE9BQU9MO0FBQ1g7QUFDQSxNQUFNTSxnQkFBZ0IsQ0FBQ3ZGO0lBQ25Ca0YsYUFBYWxGO0FBQ2pCO0FBQ0EsTUFBTXdGLGdCQUFnQjtJQUNsQixPQUFPTjtBQUNYO0FBQ0EsTUFBTU8sbUJBQW1CO0lBQ3JCLElBQUloRyxpQkFBaUI7UUFDakIscUVBQXFFO1FBQ3JFLE9BQU87WUFDSHZNLEtBQUtrUztZQUNMalMsSUFBSW1TO1lBQ0pqUyxRQUFRbVM7UUFDWjtJQUNKO0lBQ0EsTUFBTUUsWUFBWSxJQUFJcmpCLGtEQUFRQSxDQUFDcWQsVUFBVWdHLFNBQVM7SUFDbEQsTUFBTSxFQUFFdFMsT0FBTyxFQUFFRCxFQUFFLEVBQUVFLE1BQU0sRUFBRXNTLEdBQUcsRUFBRSxHQUFHRCxVQUFVRSxTQUFTO0lBQ3hELE9BQU87UUFDSDFTLEtBQUtrUztRQUNMaFMsU0FBUztZQUNMMU0sTUFBTTBNLFFBQVExTSxJQUFJLElBQUlnWixVQUFVZ0csU0FBUztZQUN6QzlSLFNBQVNSLFFBQVFRLE9BQU8sSUFBSTtRQUNoQztRQUNBVCxJQUFJO1lBQ0F6TSxNQUFNeU0sR0FBR3pNLElBQUksSUFBSTtZQUNqQmtOLFNBQVNULEdBQUdTLE9BQU8sSUFBSTtZQUN2QkMsY0FBYzhSLElBQUk5UixZQUFZLElBQUk7UUFDdEM7UUFDQVIsUUFBUTtZQUNKM00sTUFBTSxDQUFDLEVBQUUyTSxPQUFPd1MsTUFBTSxJQUFJLEdBQUcsQ0FBQyxFQUFFeFMsT0FBT3lTLEtBQUssSUFBSSxHQUFHLENBQUMsRUFBRXpTLE9BQU9wQixJQUFJLElBQUksR0FBRyxDQUFDO1lBQ3pFMkIsU0FBUztRQUNiO0lBQ0o7QUFDSjtBQUVBLE1BQU1tUyxrQkFBa0I7QUFDeEIsTUFBTUMsMEJBQTBCO0lBQzVCMVYsU0FBU3lWO0lBQ1Q5VixPQUFPO0lBQ1BDLFFBQVE7QUFDWjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU0rVix5QkFBeUIsQ0FBQ0MsWUFBWUMsbUJBQW1CSCx1QkFBdUI7SUFDbEYsTUFBTUkscUJBQXFCLEVBQUU7SUFDN0IsTUFBTUMsV0FBV0gsV0FBV0ksV0FBVztJQUN2QyxNQUFNLEVBQUVyVyxPQUFPc1csSUFBSSxDQUFDLEVBQUVyVyxRQUFRc1csSUFBSSxDQUFDLEVBQUUsR0FBR0g7SUFDeEMsTUFBTUksVUFBVWhILG1CQUFtQjZGLGFBQWE1ZSxLQUFLa1osa0JBQWtCO0lBQ3ZFLE1BQU01QyxhQUFhMEosc0JBQXNCUCxrQkFBa0JJLEdBQUdDO0lBQzlELElBQUlHLGtCQUFrQjtJQUN0QjtRQUFDO1FBQUs7UUFBSztLQUFJLENBQUM5RSxPQUFPLENBQUMsQ0FBQ3hSO1FBQ3JCLDJFQUEyRTtRQUMzRSw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFK1YsbUJBQW1CUSxPQUFPLENBQUM7WUFDdkI3SixRQUFRO1lBQ1IxTTtZQUNBSixPQUFPL0QsS0FBSzJhLEtBQUssQ0FBQ04sSUFBSUk7WUFDdEJ6VyxRQUFRaEUsS0FBSzJhLEtBQUssQ0FBQ0wsSUFBSUc7WUFDdkIzSixZQUFZOVEsS0FBSzJhLEtBQUssQ0FBQzdKLGFBQWEySjtZQUNwQzFKLHVCQUF1QjBKO1lBQ3ZCLG1GQUFtRjtZQUNuRnhKLGNBQWM7Z0JBQ1Z6UyxHQUFHO2dCQUNIOGIsR0FBR0MsVUFBVSxLQUFLO2dCQUNsQkssR0FBR0wsVUFBVSxLQUFLO1lBQ3RCLENBQUMsQ0FBQ3BXLElBQUk7UUFDVjtRQUNBc1csbUJBQW1CO0lBQ3ZCO0lBQ0EsdUVBQXVFO0lBQ3ZFLHFEQUFxRDtJQUNyRCxPQUFPSSx5QkFBeUJWLFVBQVVEO0FBQzlDO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU1NLHdCQUF3QixDQUFDUCxrQkFBa0JhLGNBQWNDO0lBQzNELGlFQUFpRTtJQUNqRSxzREFBc0Q7SUFDdEQsTUFBTSxFQUFFaFgsT0FBT2lYLFdBQVcsRUFBRWhYLFFBQVFpWCxZQUFZLEVBQUUsR0FBR2hCO0lBQ3JELElBQUlhLGVBQWVFLGVBQWVELGdCQUFnQkUsY0FBYztRQUM1RCxNQUFNQyxnQkFBZ0JKLGVBQWVDO1FBQ3JDLE1BQU1JLGVBQWVILGNBQWNDO1FBQ25DLE1BQU1HLGtCQUFrQkYsZ0JBQWdCQztRQUN4QyxPQUFPbmIsS0FBSzJhLEtBQUssQ0FBQ1YsaUJBQWlCN1YsT0FBTyxHQUFHZ1g7SUFDakQ7SUFDQSxPQUFPbkIsaUJBQWlCN1YsT0FBTztBQUNuQztBQUNBOzs7Ozs7O0NBT0MsR0FDRCxNQUFNeVcsMkJBQTJCLENBQUNWLFVBQVVEO0lBQ3hDLElBQUkxVTtJQUNKLE1BQU02VixPQUFPcmIsS0FBS3NiLEdBQUcsQ0FBQ25CLFNBQVNwVyxLQUFLLElBQUksR0FBR29XLFNBQVNuVyxNQUFNLElBQUk7SUFDOUQsSUFBSXFYLFFBQVEsS0FBSztRQUNiLHVFQUF1RTtRQUN2RTdWLFNBQVMwVSxtQkFBbUJua0IsTUFBTSxDQUFDLENBQUN3bEIsUUFBVUEsTUFBTXBYLEdBQUcsS0FBSztJQUNoRSxPQUNLLElBQUlrWCxRQUFRLEtBQUs7UUFDbEIsa0RBQWtEO1FBQ2xEN1YsU0FBUzBVLG1CQUFtQm5rQixNQUFNLENBQUMsQ0FBQ3dsQixRQUFVQSxNQUFNcFgsR0FBRyxLQUFLO0lBQ2hFLE9BQ0s7UUFDRCwyQ0FBMkM7UUFDM0NxQixTQUFTMFU7SUFDYjtJQUNBLE1BQU1zQixhQUFhO1FBQUM7UUFBSztRQUFLO0tBQUk7SUFDbEMsT0FBT2hXLE9BQU90USxHQUFHLENBQUMsQ0FBQ3FtQixPQUFPRSxRQUFXO1lBQ2pDLEdBQUdGLEtBQUs7WUFDUnBYLEtBQUtxWCxVQUFVLENBQUNDLE1BQU07UUFDMUI7QUFDSjtBQUNBLE1BQU1DLGlDQUFpQyxDQUFDMUIsWUFBWTJCO0lBQ2hELE1BQU14QixXQUFXSCxXQUFXSSxXQUFXO0lBQ3ZDLE9BQU87UUFDSDtZQUNJdkosUUFBUTtZQUNSMU0sS0FBSztZQUNMSixPQUFPb1csU0FBU3BXLEtBQUssSUFBSTtZQUN6QkMsUUFBUW1XLFNBQVNuVyxNQUFNLElBQUk7WUFDM0IrTSx1QkFBdUI7WUFDdkJELFlBQVk2SyxhQUFhN0ssY0FBYztZQUN2Q0csY0FBYzBLLGFBQWExSyxnQkFBZ0I7UUFDL0M7S0FDSDtBQUNMO0FBRUEsTUFBTTJLLGtDQUFrQyxDQUFDclc7SUFDckMsT0FBUUE7UUFDSixLQUFLOUQsVUFBVW9hLFlBQVk7WUFDdkIsT0FBTztRQUNYLEtBQUtwYSxVQUFVcWEsa0JBQWtCO1lBQzdCLE9BQU87UUFDWCxLQUFLcmEsVUFBVXNhLEtBQUs7WUFDaEIsT0FBTztRQUNYLEtBQUt0YSxVQUFVdWEsS0FBSztZQUNoQixPQUFPO1FBQ1gsS0FBS3ZhLFVBQVV3YSxXQUFXO1lBQ3RCLE1BQU0sSUFBSTloQixNQUFNO1FBQ3BCO1lBQ0ksTUFBTStoQiwyQkFBMkIzVztZQUNqQyxNQUFNLElBQUlwTCxNQUFNLENBQUMsb0JBQW9CLEVBQUUraEIseUJBQXlCLENBQUM7SUFDekU7QUFDSjtBQUNBLE1BQU1DLHNCQUFzQixDQUFDQztJQUN6QixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPM2EsVUFBVXVhLEtBQUs7UUFDMUIsS0FBSztZQUNELE9BQU92YSxVQUFVc2EsS0FBSztRQUMxQixLQUFLO1lBQ0QsT0FBT3RhLFVBQVVvYSxZQUFZO1FBQ2pDLEtBQUs7WUFDRCxPQUFPcGEsVUFBVXFhLGtCQUFrQjtRQUN2QztZQUNJLE1BQU1PLDBCQUEwQkQ7WUFDaEMsTUFBTSxJQUFJamlCLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRWtpQix3QkFBd0IsQ0FBQztJQUN2RTtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1DLGtCQUFrQixDQUFDQyxTQUFXLE9BQU9BLFdBQVc7QUFDdEQ7Ozs7O0NBS0MsR0FDRCxNQUFNQyxrQkFBa0IsQ0FBQ0M7SUFDckIsSUFBSTNnQjtJQUNKLElBQUk0Z0IsTUFBTTFnQjtJQUNWaEgsNlFBQWFBLENBQUM7UUFBQ3luQjtLQUFZLEVBQ3RCRSxTQUFTLENBQUM7UUFDWHhKLE1BQU0sQ0FBQyxDQUFDaFksRUFBRTtZQUNOVyxRQUFRWDtRQUNaO1FBQ0F5TixPQUFPLENBQUN0RjtZQUNKb1osTUFBTXBaO1FBQ1Y7SUFDSixHQUNLc1osV0FBVztJQUNoQixJQUFJRixLQUNBLE1BQU1BO0lBQ1YsT0FBTzVnQjtBQUNYO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNK2dCLGtCQUFrQixDQUFDQyxTQUFTUDtJQUM5QixNQUFNcEosT0FBT21KLGdCQUFnQkMsVUFDdkJBLE9BQU9DLGdCQUFnQk0sWUFDdkJQO0lBQ05PLFFBQVEzSixJQUFJLENBQUNBO0lBQ2IsT0FBT0E7QUFDWDtBQUNBOzs7OztDQUtDLEdBQ0QsTUFBTTRKLHFCQUFxQixDQUFDQyxZQUFZQztJQUNwQyxNQUFNQyxlQUFlRixXQUFXTCxTQUFTLENBQUNNO0lBQzFDLE9BQU87UUFDSEMsYUFBYU4sV0FBVztJQUM1QjtBQUNKO0FBRUEsSUFBSU8sVUFBVSxXQUFXLEdBQUUvaEIsT0FBT2dOLE1BQU0sQ0FBQztJQUNyQ0MsV0FBVztJQUNYMFUsb0JBQW9CQTtJQUNwQlAsaUJBQWlCQTtJQUNqQkssaUJBQWlCQTtBQUNyQjtBQUVBOzs7Ozs7Q0FNQyxHQUNELE1BQU1PLHFCQUFxQixDQUFDLEdBQUdDO0lBQzNCLE9BQU8sQ0FBQ0MsR0FBR0M7UUFDUCxLQUFLLE1BQU1DLGNBQWNILFlBQWE7WUFDbEMsTUFBTXRJLFNBQVN5SSxXQUFXRixHQUFHQztZQUM3QixJQUFJeEksV0FBVyxHQUNYLE9BQU9BO1FBQ2Y7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTTBJLGFBQWEsQ0FBQ0Q7SUFDaEIsT0FBTyxDQUFDRixHQUFHQyxJQUFNQyxXQUFXRCxHQUFHRDtBQUNuQztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1JLGNBQWMsQ0FBQ0M7SUFDakIsT0FBTyxDQUFDSDtRQUNKLE9BQU8sQ0FBQ0YsR0FBR0M7WUFDUCxJQUFJLENBQUNJLFVBQVVMLEdBQUdDLElBQ2QsT0FBTztZQUNYLE9BQU9DLFdBQVdGLEdBQUdDO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTUssaUJBQWlCO0lBQ25CLE9BQU8sSUFBTTtBQUNqQjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUMsa0JBQWtCLENBQUNQLEdBQUdDO0lBQ3hCLElBQUlELEVBQUVwYSxpQkFBaUIsSUFBSSxDQUFDcWEsRUFBRXJhLGlCQUFpQixFQUMzQyxPQUFPLENBQUM7SUFDWixJQUFJLENBQUNvYSxFQUFFcGEsaUJBQWlCLElBQUlxYSxFQUFFcmEsaUJBQWlCLEVBQzNDLE9BQU87SUFDWCxPQUFPO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU00YSxXQUFXLENBQUNSLEdBQUdDO0lBQ2pCLElBQUlELEVBQUVyYSxVQUFVLElBQUksQ0FBQ3NhLEVBQUV0YSxVQUFVLEVBQzdCLE9BQU8sQ0FBQztJQUNaLElBQUksQ0FBQ3FhLEVBQUVyYSxVQUFVLElBQUlzYSxFQUFFdGEsVUFBVSxFQUM3QixPQUFPO0lBQ1gsT0FBTztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxNQUFNOGEsZ0JBQWdCLENBQUNULEdBQUdDO0lBQ3RCLElBQUlTLGVBQWVWLE1BQU0sQ0FBQ1UsZUFBZVQsSUFDckMsT0FBTyxDQUFDO0lBQ1osSUFBSSxDQUFDUyxlQUFlVixNQUFNVSxlQUFlVCxJQUNyQyxPQUFPO0lBQ1gsT0FBTztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxNQUFNVSxrQkFBa0IsQ0FBQ1gsR0FBR0M7SUFDeEIsSUFBSVcsU0FBU1osTUFBTSxDQUFDWSxTQUFTWCxJQUN6QixPQUFPLENBQUM7SUFDWixJQUFJLENBQUNXLFNBQVNaLE1BQU1ZLFNBQVNYLElBQ3pCLE9BQU87SUFDWCxPQUFPO0FBQ1g7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU1ZLGtCQUFrQixDQUFDYixHQUFHQztJQUN4QixJQUFJYSxTQUFTZCxNQUFNLENBQUNjLFNBQVNiLElBQ3pCLE9BQU8sQ0FBQztJQUNaLElBQUksQ0FBQ2EsU0FBU2QsTUFBTWMsU0FBU2IsSUFDekIsT0FBTztJQUNYLE9BQU87QUFDWDtBQUNBOzs7OztDQUtDLEdBQ0QsTUFBTWMsU0FBUyxDQUFDZixHQUFHQztJQUNmLElBQUlELEVBQUVnQixHQUFHLElBQUlmLEVBQUVlLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNoQixFQUFFZ0IsR0FBRyxDQUFDQyxVQUFVLElBQUloQixFQUFFZSxHQUFHLENBQUNDLFVBQVUsRUFDckMsT0FBTyxDQUFDO1FBQ1osSUFBSWpCLEVBQUVnQixHQUFHLENBQUNDLFVBQVUsSUFBSSxDQUFDaEIsRUFBRWUsR0FBRyxDQUFDQyxVQUFVLEVBQ3JDLE9BQU87UUFDWCxJQUFJakIsRUFBRWdCLEdBQUcsQ0FBQ0UsUUFBUSxHQUFHakIsRUFBRWUsR0FBRyxDQUFDRSxRQUFRLEVBQy9CLE9BQU8sQ0FBQztRQUNaLElBQUlsQixFQUFFZ0IsR0FBRyxDQUFDRSxRQUFRLEdBQUdqQixFQUFFZSxHQUFHLENBQUNFLFFBQVEsRUFDL0IsT0FBTztJQUNmO0lBQ0EsSUFBSWxCLEVBQUVnQixHQUFHLElBQUksQ0FBQ2YsRUFBRWUsR0FBRyxFQUNmLE9BQU8sQ0FBQztJQUNaLElBQUksQ0FBQ2hCLEVBQUVnQixHQUFHLElBQUlmLEVBQUVlLEdBQUcsRUFDZixPQUFPO0lBQ1gsT0FBTztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxNQUFNRyxlQUFlLENBQUMxWTtJQUNsQixPQUFPLENBQUN1WCxHQUFHQztRQUNQLElBQUlELEVBQUVvQixRQUFRLEVBQUUzWSxTQUFTQSxRQUFRd1gsRUFBRW1CLFFBQVEsRUFBRTNZLFNBQVNBLE1BQ2xELE9BQU8sQ0FBQztRQUNaLElBQUl1WCxFQUFFb0IsUUFBUSxFQUFFM1ksU0FBU0EsUUFBUXdYLEVBQUVtQixRQUFRLEVBQUUzWSxTQUFTQSxNQUNsRCxPQUFPO1FBQ1gsT0FBTztJQUNYO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU00WSxPQUFPLENBQUMsR0FBR3RiLFFBQVUsQ0FBQ2lhLEdBQUdDO1FBQzNCLElBQUlxQixXQUFXdEIsR0FBR2phLFVBQVUsQ0FBQ3ViLFdBQVdyQixHQUFHbGEsUUFDdkMsT0FBTyxDQUFDO1FBQ1osSUFBSSxDQUFDdWIsV0FBV3RCLEdBQUdqYSxVQUFVdWIsV0FBV3JCLEdBQUdsYSxRQUN2QyxPQUFPO1FBQ1gsT0FBTztJQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxNQUFNN0ksT0FBTyxDQUFDOGlCLEdBQUdDO0lBQ2IsSUFBSUQsRUFBRTlpQixJQUFJLEdBQUcraUIsRUFBRS9pQixJQUFJLEVBQ2YsT0FBTyxDQUFDO0lBQ1osSUFBSThpQixFQUFFOWlCLElBQUksR0FBRytpQixFQUFFL2lCLElBQUksRUFDZixPQUFPO0lBQ1gsT0FBTztBQUNYO0FBQ0EsTUFBTW9rQixhQUFhLENBQUNDLEdBQUd4YixRQUFVLENBQUN3YixFQUFFeGIsS0FBSyxJQUFJLEVBQUUsRUFBRXliLElBQUksQ0FBQyxDQUFDQyxJQUFNMWIsTUFBTTRTLFFBQVEsQ0FBQzhJO0FBQzVFLE1BQU1mLGlCQUFpQixDQUFDYSxJQUFNQSxFQUFFL2IsZUFBZSxDQUFDbVQsUUFBUSxDQUFDeFUsVUFBVW9hLFlBQVk7QUFDL0UsTUFBTXFDLFdBQVcsQ0FBQ1csSUFBTUEsRUFBRS9iLGVBQWUsQ0FBQ21ULFFBQVEsQ0FBQ3hVLFVBQVVzYSxLQUFLO0FBQ2xFLE1BQU1xQyxXQUFXLENBQUNTLElBQU1BLEVBQUUvYixlQUFlLENBQUNtVCxRQUFRLENBQUN4VSxVQUFVdWEsS0FBSztBQUVsRSw0RUFBNEU7QUFDNUUsNEJBQTRCO0FBQzVCLGlFQUFpRTtBQUNqRSxNQUFNZ0QsZ0JBQWdCdEIsWUFBWSxDQUFDSixHQUFHQyxJQUFNRCxFQUFFMkIsdUJBQXVCLEVBQUVqRixlQUFlbkksZ0JBQWdCcU4sU0FBUyxJQUMzRzNCLEVBQUUwQix1QkFBdUIsRUFBRWpGLGVBQWVuSSxnQkFBZ0JxTixTQUFTO0FBQ3ZFOzs7O0NBSUMsR0FDRCxNQUFNQyx5QkFBeUJ6QixZQUFZLENBQUNKLEdBQUdDLElBQU1ELEVBQUUyQix1QkFBdUIsRUFBRWpGLGVBQWVuSSxnQkFBZ0JxTixTQUFTLElBQ3BINUIsRUFBRTJCLHVCQUF1QixFQUFFakYsZUFBZW5JLGdCQUFnQnVOLE9BQU8sSUFDakU3QixFQUFFMEIsdUJBQXVCLEVBQUVqRixlQUFlbkksZ0JBQWdCcU4sU0FBUyxJQUNuRTNCLEVBQUUwQix1QkFBdUIsRUFBRWpGLGVBQWVuSSxnQkFBZ0J1TixPQUFPO0FBQ3JFOztDQUVDLEdBQ0QsTUFBTUMsb0JBQW9CakMsbUJBQW1CaUIsUUFBUU4sZUFBZWlCLGNBQWM1QixtQkFBbUJTLGlCQUFpQkMsVUFBVVcsYUFBYSxnQkFBZ0JSLGlCQUFpQkU7QUFDOUs7O0NBRUMsR0FDRCxNQUFNbUIsMEJBQTBCbEMsbUJBQW1CaUIsUUFBUU4sZUFBZUYsaUJBQWlCbUIsY0FBYzVCLG1CQUFtQlUsVUFBVVcsYUFBYSxnQkFBZ0JSLGlCQUFpQkU7QUFDcEw7OztDQUdDLEdBQ0QsTUFBTW9CLDRCQUE0Qm5DLG1CQUFtQmlCLFFBQVFjLHVCQUF1Qi9CLG1CQUFtQlMsaUJBQWlCQyxVQUFVVyxhQUFhLGdCQUFnQlIsaUJBQWlCRTtBQUNoTDs7Q0FFQyxHQUNELE1BQU1xQixrQ0FBa0NwQyxtQkFBbUI0QixjQUFjNUIsbUJBQW1CUyxpQkFBaUJDLFVBQVVXLGFBQWEsZ0JBQWdCUixpQkFBaUJFLG1CQUFtQlEsS0FBSyxTQUFTLFFBQVE7QUFFOU07O0NBRUMsR0FDRCxJQUFJYztBQUNILFVBQVVBLFlBQVk7SUFDbkI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFVBQVUsR0FBRztJQUMxQjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCOzs7S0FHQyxHQUNEQSxZQUFZLENBQUMsVUFBVSxHQUFHO0lBQzFCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxVQUFVLEdBQUc7SUFDMUI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFNBQVMsR0FBRztJQUN6Qjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxlQUFlLEdBQUc7SUFDL0I7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFlBQVksR0FBRztJQUM1Qjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsc0JBQXNCLEdBQUc7SUFDdEM7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFVBQVUsR0FBRztBQUM5QixHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUNwQzs7O0NBR0MsR0FDRCxNQUFNbFg7SUFDRjs7O0tBR0MsR0FDRGpPLGFBQWM7UUFDVixJQUFJLENBQUNvbEIsZ0JBQWdCLEdBQUcsSUFBSXpxQiwyUUFBZUEsQ0FBQztRQUM1QyxJQUFJLENBQUMwcUIscUJBQXFCLEdBQUcsSUFBSTFxQiwyUUFBZUEsQ0FBQyxFQUFFO1FBQ25ELElBQUksQ0FBQzJxQixnQkFBZ0IsR0FBRyxJQUFJM3FCLDJRQUFlQSxDQUFDLElBQUk2SztRQUNoRCxJQUFJLENBQUMrZixjQUFjLEdBQUcsSUFBSTVxQiwyUUFBZUEsQ0FBQytHO1FBQzFDLElBQUksQ0FBQzhqQixlQUFlLEdBQUcsSUFBSTdxQiwyUUFBZUEsQ0FBQytHO1FBQzNDLElBQUksQ0FBQytqQixnQkFBZ0IsR0FBRyxJQUFJOXFCLDJRQUFlQSxDQUFDLElBQUk2SztRQUNoRCxJQUFJLENBQUNrZ0IsZ0JBQWdCLEdBQUcsSUFBSS9xQiwyUUFBZUEsQ0FBQytHO1FBQzVDLElBQUksQ0FBQ2lrQixhQUFhLEdBQUcsSUFBSWhyQiwyUUFBZUEsQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQ2lyQixhQUFhLEdBQUcsSUFBSWpyQiwyUUFBZUEsQ0FBQytHO1FBQ3pDLElBQUksQ0FBQ21rQixjQUFjLEdBQUcsSUFBSWxyQiwyUUFBZUEsQ0FBQytHO1FBQzFDLElBQUksQ0FBQ29rQixnQkFBZ0IsR0FBRyxJQUFJbnJCLDJRQUFlQSxDQUFDO1FBQzVDLElBQUksQ0FBQ29yQixjQUFjLEdBQUcsSUFBSXByQiwyUUFBZUEsQ0FBQytHO1FBQzFDLElBQUksQ0FBQ3NrQixlQUFlLEdBQUcsSUFBSXJyQiwyUUFBZUEsQ0FBQytHO1FBQzNDLElBQUksQ0FBQ3VrQixtQkFBbUIsR0FBRyxJQUFJdHJCLDJRQUFlQSxDQUFDO1FBQy9DLElBQUksQ0FBQ3VyQixjQUFjLEdBQUcsSUFBSXZyQiwyUUFBZUEsQ0FBQytHO1FBQzFDLElBQUksQ0FBQ3lrQixpQkFBaUIsR0FBRyxJQUFJeHJCLDJRQUFlQSxDQUFDK0c7UUFDN0MsSUFBSSxDQUFDMGtCLGNBQWMsR0FBRyxJQUFJenJCLDJRQUFlQSxDQUFDLEVBQUU7UUFDNUMsSUFBSSxDQUFDMHJCLHNCQUFzQixHQUFHLElBQUkxckIsMlFBQWVBLENBQUMsRUFBRTtRQUNwRCxJQUFJLENBQUMyckIsbUJBQW1CLEdBQUcsSUFBSTNyQiwyUUFBZUEsQ0FBQ3dxQixhQUFhTCxPQUFPO1FBQ25FLElBQUksQ0FBQ3lCLGdCQUFnQixHQUFHLElBQUk1ckIsMlFBQWVBLENBQUMrRztRQUM1QyxJQUFJLENBQUM4a0IsdUJBQXVCLEdBQUcsSUFBSTdyQiwyUUFBZUEsQ0FBQztRQUNuRCxJQUFJLENBQUM4ckIsZ0NBQWdDLEdBQUcsSUFBSTlyQiwyUUFBZUEsQ0FBQztRQUM1RCxJQUFJLENBQUMrckIsbUJBQW1CLEdBQUcsSUFBSS9yQiwyUUFBZUEsQ0FBQyxFQUFFO1FBQ2pELElBQUksQ0FBQ2dzQixzQkFBc0IsR0FBRyxJQUFJaHNCLDJRQUFlQSxDQUFDK0c7UUFDbEQ7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ2tsQixrQkFBa0IsR0FBRzdCO1FBQzFCOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDOEIscUJBQXFCLEdBQUcsQ0FBQzNEO1lBQzFCLElBQUksQ0FBQzBELGtCQUFrQixHQUFHMUQ7WUFDMUIscUNBQXFDO1lBQ3JDLElBQUksQ0FBQ1gsZUFBZSxDQUFDLElBQUksQ0FBQ21FLG1CQUFtQixFQUFFLENBQUNJLEtBQU9BO1FBQzNEO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUM1RSxlQUFlLEdBQUdBO1FBQ3ZCOzs7Ozs7Ozs7O1NBVUMsR0FDRCxJQUFJLENBQUNLLGVBQWUsR0FBR0E7UUFDdkI7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUN3RSxtQkFBbUIsR0FBRyxDQUFDQztZQUN4QixPQUFPLElBQUksQ0FBQ3pFLGVBQWUsQ0FBQyxJQUFJLENBQUNpRSx1QkFBdUIsRUFBRVE7UUFDOUQ7UUFDQTs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLENBQUNuZjtZQUNqQixPQUFPLElBQUksQ0FBQ3lhLGVBQWUsQ0FBQyxJQUFJLENBQUNnRSxnQkFBZ0IsRUFBRXplO1FBQ3ZEO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNvZiw0QkFBNEIsR0FBRyxDQUFDRjtZQUNqQyxPQUFPLElBQUksQ0FBQ3pFLGVBQWUsQ0FBQyxJQUFJLENBQUNrRSxnQ0FBZ0MsRUFBRU87UUFDdkU7UUFDQTs7Ozs7O1NBTUMsR0FDRCxJQUFJLENBQUNHLGVBQWUsR0FBRyxDQUFDdmY7WUFDcEIsT0FBTyxJQUFJLENBQUMyYSxlQUFlLENBQUMsSUFBSSxDQUFDbUUsbUJBQW1CLEVBQUU5ZTtRQUMxRDtRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDd2YsZUFBZSxHQUFHLENBQUNDO1lBQ3BCLE9BQU8sSUFBSSxDQUFDOUUsZUFBZSxDQUFDLElBQUksQ0FBQytELG1CQUFtQixFQUFFZTtRQUMxRDtRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxDQUFDQztZQUN2QixPQUFPLElBQUksQ0FBQ2hGLGVBQWUsQ0FBQyxJQUFJLENBQUNvRSxzQkFBc0IsRUFBRVk7UUFDN0Q7UUFDQTs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUNDO1lBQ2YsSUFBSSxDQUFDbEYsZUFBZSxDQUFDLElBQUksQ0FBQzZELGNBQWMsRUFBRXFCO1FBQzlDO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNDLGtCQUFrQixHQUFHLENBQUNDO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDcEYsZUFBZSxDQUFDLElBQUksQ0FBQzhELHNCQUFzQixFQUFFc0I7UUFDN0Q7UUFDQTs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ0MsMEJBQTBCLEdBQUcsQ0FBQ3RmO1lBQy9CLE9BQU8sSUFBSSxDQUFDVixZQUFZLENBQUMzRCxJQUFJLENBQUMsQ0FBQ3NnQixJQUFNQSxFQUFFamMsU0FBUyxLQUFLQTtRQUN6RDtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDdWYsK0JBQStCLEdBQUc7WUFDbkMsT0FBTyxJQUFJLENBQUNqZ0IsWUFBWSxDQUFDa2dCLE1BQU0sQ0FBQyxDQUFDQyxhQUFhclU7Z0JBQzFDcVUsV0FBVyxDQUFDclUsWUFBWXBMLFNBQVMsQ0FBQyxHQUFHb0w7Z0JBQ3JDLE9BQU9xVTtZQUNYLEdBQUcsQ0FBQztRQUNSO1FBQ0E7Ozs7Ozs7OztTQVNDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxDQUFDMWYsV0FBVzRFO1lBQ2pDLE1BQU13RyxjQUFjLElBQUksQ0FBQ2tVLDBCQUEwQixDQUFDdGY7WUFDcEQsSUFBSSxDQUFDb0wsYUFBYTtnQkFDZCxJQUFJLENBQUNtSCxNQUFNLENBQUMsUUFBUSxDQUFDLDJCQUEyQixFQUFFdlMsVUFBVSxVQUFVLENBQUM7Z0JBQ3ZFO1lBQ0o7WUFDQSxNQUFNMmYsV0FBVyxPQUFPL2EsVUFBVSxhQUFhQSxNQUFNd0csZUFBZXhHO1lBQ3BFLE1BQU1nYixxQkFBcUI7Z0JBQ3ZCLG9FQUFvRTtnQkFDcEUsR0FBR3hVLFdBQVc7Z0JBQ2QsR0FBR3VVLFFBQVE7WUFDZjtZQUNBLE9BQU8sSUFBSSxDQUFDZCxlQUFlLENBQUMsQ0FBQ3ZmLGVBQWlCQSxhQUFhaE4sR0FBRyxDQUFDLENBQUMycEIsSUFBTUEsRUFBRWpjLFNBQVMsS0FBS0EsWUFBWTRmLHFCQUFxQjNEO1FBQzNIO1FBQ0E7Ozs7Ozs7U0FPQyxHQUNELElBQUksQ0FBQzRELHNCQUFzQixHQUFHLENBQUM3ZixXQUFXb0w7WUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQ2tVLDBCQUEwQixDQUFDdGYsWUFBWTtnQkFDN0MsT0FBTyxJQUFJLENBQUM2ZSxlQUFlLENBQUMsQ0FBQ3ZmLGVBQWlCOzJCQUN2Q0E7d0JBQ0g4TDtxQkFDSDtZQUNMO1lBQ0EsT0FBTyxJQUFJLENBQUN5VCxlQUFlLENBQUMsQ0FBQ3ZmLGVBQWlCQSxhQUFhaE4sR0FBRyxDQUFDLENBQUMycEI7b0JBQzVELElBQUlBLEVBQUVqYyxTQUFTLEtBQUtBLFdBQVc7d0JBQzNCLE9BQU87NEJBQ0gsR0FBR2ljLENBQUM7NEJBQ0osR0FBRzdRLFdBQVc7d0JBQ2xCO29CQUNKO29CQUNBLE9BQU82UTtnQkFDWDtRQUNKO1FBQ0E7Ozs7Ozs7O1NBUUMsR0FDRCxJQUFJLENBQUM2RCxrQkFBa0IsR0FBRyxDQUFDbGI7WUFDdkIsSUFBSXBNLE9BQU9rQyxJQUFJLENBQUNrSyxPQUFPckwsTUFBTSxLQUFLLEdBQzlCO1lBQ0osT0FBTyxJQUFJLENBQUNzbEIsZUFBZSxDQUFDLENBQUN2ZixlQUFpQkEsYUFBYWhOLEdBQUcsQ0FBQyxDQUFDMnBCO29CQUM1RCxNQUFNMEQsV0FBVy9hLEtBQUssQ0FBQ3FYLEVBQUVqYyxTQUFTLENBQUM7b0JBQ25DLElBQUkyZixVQUFVO3dCQUNWLE9BQU87NEJBQ0gsR0FBRzFELENBQUM7NEJBQ0osR0FBRzBELFFBQVE7d0JBQ2Y7b0JBQ0o7b0JBQ0EsT0FBTzFEO2dCQUNYO1FBQ0o7UUFDQTs7Ozs7O1NBTUMsR0FDRCxJQUFJLENBQUM4RCxlQUFlLEdBQUcsQ0FBQ0M7WUFDcEIsTUFBTXJHLFNBQVMsSUFBSSxDQUFDc0csYUFBYSxDQUFDRCxNQUFNN2MsSUFBSSxDQUFDO1lBQzdDLElBQUl3VyxRQUFRO2dCQUNSQSxPQUFPcUc7WUFDWDtRQUNKO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0UsaUJBQWlCLEdBQUcsQ0FBQzNnQjtZQUN0QixNQUFNNGdCLGFBQWE1Z0IsS0FBS2lnQixNQUFNLENBQUMsQ0FBQ1ksUUFBUTFFO2dCQUNwQzBFLE1BQU0sQ0FBQzFFLElBQUkxYixTQUFTLENBQUMsR0FBRzlDLEtBQUtILEdBQUc7Z0JBQ2hDLE9BQU9xakI7WUFDWCxHQUFHLENBQUM7WUFDSixPQUFPLElBQUksQ0FBQ3ZCLGVBQWUsQ0FBQyxDQUFDdmYsZUFBaUJBLGFBQWFoTixHQUFHLENBQUMsQ0FBQzhZO29CQUM1RCxNQUFNaVYscUJBQXFCRixVQUFVLENBQUMvVSxZQUFZcEwsU0FBUyxDQUFDO29CQUM1RCxrQ0FBa0M7b0JBQ2xDLElBQUlxZ0Isb0JBQW9CO3dCQUNwQixPQUFPOzRCQUNILEdBQUdqVixXQUFXOzRCQUNkc1EsS0FBSztnQ0FDREMsWUFBWTtnQ0FDWkMsVUFBVXlFOzRCQUNkO3dCQUNKO29CQUNKO29CQUNBLGtEQUFrRDtvQkFDbEQsMkJBQTJCO29CQUMzQixJQUFJalYsWUFBWXNRLEdBQUcsSUFBSSxDQUFDdFEsWUFBWXNRLEdBQUcsQ0FBQ0MsVUFBVSxFQUFFO3dCQUNoRCxPQUFPOzRCQUNILEdBQUd2USxXQUFXOzRCQUNkc1EsS0FBS3RpQjt3QkFDVDtvQkFDSjtvQkFDQSwyQkFBMkI7b0JBQzNCLE9BQU9nUztnQkFDWDtRQUNKO1FBQ0E7Ozs7OztTQU1DLEdBQ0QsSUFBSSxDQUFDa1Ysc0JBQXNCLEdBQUcsQ0FBQ2hNO1lBQzNCLElBQUksQ0FBQzJGLGVBQWUsQ0FBQyxJQUFJLENBQUM2QyxnQkFBZ0IsRUFBRXhJLEtBQUtpTSxTQUFTO1lBQzFELElBQUksQ0FBQ3RHLGVBQWUsQ0FBQyxJQUFJLENBQUM4QyxxQkFBcUIsRUFBRXpJLEtBQUtrTSxnQkFBZ0I7WUFDdEUsSUFBSSxDQUFDdkcsZUFBZSxDQUFDLElBQUksQ0FBQytDLGdCQUFnQixFQUFFLElBQUk5ZixLQUFLb1gsS0FBS21NLFVBQVU7WUFDcEUsSUFBSSxDQUFDeEcsZUFBZSxDQUFDLElBQUksQ0FBQ2tELGdCQUFnQixFQUFFLElBQUlqZ0IsS0FBS29YLEtBQUtvTSxVQUFVO1lBQ3BFLElBQUksQ0FBQ3pHLGVBQWUsQ0FBQyxJQUFJLENBQUNpRCxlQUFlLEVBQUU1SSxLQUFLcU0sU0FBUyxHQUFHLElBQUl6akIsS0FBS29YLEtBQUtxTSxTQUFTLElBQUl2bkI7WUFDdkYsSUFBSSxDQUFDNmdCLGVBQWUsQ0FBQyxJQUFJLENBQUNnRCxjQUFjLEVBQUUzSSxLQUFLc00sUUFBUSxHQUFHLElBQUkxakIsS0FBS29YLEtBQUtzTSxRQUFRLElBQUl4bkI7WUFDcEYsSUFBSSxDQUFDNmdCLGVBQWUsQ0FBQyxJQUFJLENBQUNtRCxnQkFBZ0IsRUFBRTlJLEtBQUt1TSxVQUFVO1lBQzNELElBQUksQ0FBQzVHLGVBQWUsQ0FBQyxJQUFJLENBQUNvRCxhQUFhLEVBQUUvSSxLQUFLelQsTUFBTTtZQUNwRCxJQUFJLENBQUNvWixlQUFlLENBQUMsSUFBSSxDQUFDcUQsYUFBYSxFQUFFaEosS0FBS3dNLE1BQU07WUFDcEQsSUFBSSxDQUFDN0csZUFBZSxDQUFDLElBQUksQ0FBQ3NELGNBQWMsRUFBRWpKLEtBQUt5TSxPQUFPO1lBQ3RELElBQUksQ0FBQzlHLGVBQWUsQ0FBQyxJQUFJLENBQUN1RCxnQkFBZ0IsRUFBRWxKLEtBQUswTSxTQUFTO1lBQzFELElBQUksQ0FBQy9HLGVBQWUsQ0FBQyxJQUFJLENBQUN3RCxjQUFjLEVBQUVuSixLQUFLMk0sT0FBTztZQUN0RCxJQUFJLENBQUNoSCxlQUFlLENBQUMsSUFBSSxDQUFDeUQsZUFBZSxFQUFFcEosS0FBS2lELFFBQVE7WUFDeEQsSUFBSSxDQUFDMEMsZUFBZSxDQUFDLElBQUksQ0FBQzBELG1CQUFtQixFQUFFckosS0FBSzRNLFlBQVk7WUFDaEUsSUFBSSxDQUFDakgsZUFBZSxDQUFDLElBQUksQ0FBQzRELGlCQUFpQixFQUFFdkosS0FBSzZNLFVBQVU7UUFDaEU7UUFDQSxJQUFJLENBQUNDLHVCQUF1QixHQUFHLENBQUNwQjtZQUM1QixJQUFJLENBQUMvRixlQUFlLENBQUMsSUFBSSxDQUFDNkQsY0FBYyxFQUFFLENBQUNxQixVQUFZQSxRQUFRaHNCLE1BQU0sQ0FBQyxDQUFDa3VCLElBQU1yQixNQUFNYixPQUFPLENBQUNtQyxPQUFPLENBQUNELEVBQUVFLE9BQU8sTUFBTSxDQUFDO1FBQ3ZIO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRyxDQUFDeEI7WUFDMUIsSUFBSSxDQUFDL0YsZUFBZSxDQUFDLElBQUksQ0FBQzZELGNBQWMsRUFBRSxDQUFDcUIsVUFBWTt1QkFDaERBO3VCQUNBYSxNQUFNYixPQUFPO2lCQUNuQjtRQUNMO1FBQ0EsSUFBSSxDQUFDc0MsNkJBQTZCLEdBQUc7WUFDakMsSUFBSSxDQUFDeEgsZUFBZSxDQUFDLElBQUksQ0FBQ3FELGFBQWEsRUFBRSxDQUFDd0QsU0FBWTtvQkFDbEQsR0FBR0EsTUFBTTtvQkFDVFksY0FBYztnQkFDbEI7UUFDSjtRQUNBLElBQUksQ0FBQ0MsK0JBQStCLEdBQUc7WUFDbkMsSUFBSSxDQUFDMUgsZUFBZSxDQUFDLElBQUksQ0FBQ3FELGFBQWEsRUFBRSxDQUFDd0QsU0FBWTtvQkFDbEQsR0FBR0EsTUFBTTtvQkFDVFksY0FBYztnQkFDbEI7UUFDSjtRQUNBLElBQUksQ0FBQ0UsNkJBQTZCLEdBQUcsQ0FBQzVCO1lBQ2xDLElBQUksQ0FBQy9GLGVBQWUsQ0FBQyxJQUFJLENBQUNxRCxhQUFhLEVBQUUsQ0FBQ3dELFNBQVk7b0JBQ2xELEdBQUdBLE1BQU07b0JBQ1RZLGNBQWM7b0JBQ2RHLEtBQUs7d0JBQ0QsR0FBR2YsT0FBT2UsR0FBRzt3QkFDYkMsY0FBYzlCLE1BQU0rQixnQkFBZ0I7b0JBQ3hDO2dCQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNDLGdDQUFnQyxHQUFHLENBQUNoQztZQUNyQyxJQUFJLENBQUMvRixlQUFlLENBQUMsSUFBSSxDQUFDd0QsY0FBYyxFQUFFLENBQUN3RDtnQkFDdkMsSUFBSSxDQUFDQSxTQUFTO29CQUNWLElBQUksQ0FBQzFPLE1BQU0sQ0FBQyxRQUFRLENBQUMseUVBQXlFLENBQUMsRUFBRXlOO29CQUNqRyxPQUFPaUI7Z0JBQ1g7Z0JBQ0EsTUFBTSxFQUFFM2hCLFlBQVksRUFBRTJpQiwwQkFBMEIsRUFBRSxHQUFHaEI7Z0JBQ3JELE1BQU0sRUFBRWlCLElBQUksRUFBRUMsZUFBZSxFQUFFLEdBQUduQyxNQUFNNVUsV0FBVztnQkFDbkQsT0FBTztvQkFDSCxHQUFHNlYsT0FBTztvQkFDVjNoQixjQUFjQSxhQUFhbk0sTUFBTSxDQUFDLENBQUM4b0IsSUFBTUEsRUFBRWtHLGVBQWUsS0FBS0E7b0JBQy9ERiw0QkFBNEI7d0JBQ3hCLEdBQUdBLDBCQUEwQjt3QkFDN0IsQ0FBQ0MsS0FBS25HLElBQUksQ0FBQyxFQUFFM2UsS0FBS3NiLEdBQUcsQ0FBQyxHQUFHLENBQUN1SiwwQkFBMEIsQ0FBQ0MsS0FBS25HLElBQUksQ0FBQyxJQUFJLEtBQUs7b0JBQzVFO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ3FHLGtDQUFrQyxHQUFHLENBQUNwQztZQUN2QyxJQUFJLENBQUMvRixlQUFlLENBQUMsSUFBSSxDQUFDd0QsY0FBYyxFQUFFLENBQUN3RDtnQkFDdkMsSUFBSSxDQUFDQSxTQUFTO29CQUNWLElBQUksQ0FBQzFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsMkVBQTJFLENBQUMsRUFBRXlOO29CQUNuRyxPQUFPaUI7Z0JBQ1g7Z0JBQ0EsTUFBTSxFQUFFM2hCLFlBQVksRUFBRTJpQiwwQkFBMEIsRUFBRSxHQUFHaEI7Z0JBQ3JELE1BQU0sRUFBRWlCLElBQUksRUFBRUMsZUFBZSxFQUFFLEdBQUduQyxNQUFNNVUsV0FBVztnQkFDbkQsaUZBQWlGO2dCQUNqRixtRUFBbUU7Z0JBQ25FLHVEQUF1RDtnQkFDdkQsd0VBQXdFO2dCQUN4RSxJQUFJaVgsMEJBQTBCO2dCQUM5QixNQUFNQyxzQkFBc0JoakIsYUFBYWhOLEdBQUcsQ0FBQyxDQUFDMnBCO29CQUMxQyxJQUFJQSxFQUFFa0csZUFBZSxLQUFLQSxpQkFBaUI7d0JBQ3ZDRSwwQkFBMEI7d0JBQzFCLE9BQU9yQyxNQUFNNVUsV0FBVztvQkFDNUI7b0JBQ0EsT0FBTzZRO2dCQUNYO2dCQUNBLElBQUlvRyx5QkFBeUI7b0JBQ3pCLDhEQUE4RDtvQkFDOURDLG9CQUFvQjFsQixJQUFJLENBQUNvakIsTUFBTTVVLFdBQVc7Z0JBQzlDO2dCQUNBLHlFQUF5RTtnQkFDekUsaUNBQWlDO2dCQUNqQyxNQUFNbVgsWUFBWUYsMEJBQTBCLElBQUk7Z0JBQ2hELE9BQU87b0JBQ0gsR0FBR3BCLE9BQU87b0JBQ1YzaEIsY0FBY2dqQjtvQkFDZEwsNEJBQTRCO3dCQUN4QixHQUFHQSwwQkFBMEI7d0JBQzdCLENBQUNDLEtBQUtuRyxJQUFJLENBQUMsRUFBRSxDQUFDa0csMEJBQTBCLENBQUNDLEtBQUtuRyxJQUFJLENBQUMsSUFBSSxLQUFLd0c7b0JBQ2hFO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUN4QztZQUNsQixJQUFJLENBQUMvRixlQUFlLENBQUMsSUFBSSxDQUFDNkQsY0FBYyxFQUFFLENBQUNxQixVQUFZQSxRQUFRN3NCLEdBQUcsQ0FBQyxDQUFDbXdCO29CQUNoRSxNQUFNQyxlQUFlMUMsTUFBTWIsT0FBTyxDQUFDeGpCLElBQUksQ0FBQyxDQUFDMGxCLElBQU1BLEVBQUVFLE9BQU8sS0FBS2tCLE9BQU9sQixPQUFPO29CQUMzRSxPQUFPbUIsZUFBZUEsZUFBZUQ7Z0JBQ3pDO1FBQ0o7UUFDQSxJQUFJLENBQUNFLHlCQUF5QixHQUFHLENBQUMzQztZQUM5QixNQUFNLEVBQUVrQyxJQUFJLEVBQUVyaEIsTUFBTSxFQUFFc0MsSUFBSSxFQUFFeWYsVUFBVSxFQUFFLEdBQUc1QyxNQUFNbEUsUUFBUTtZQUN6RCxJQUFJLENBQUMrQyxlQUFlLENBQUMsQ0FBQ3ZmO2dCQUNsQixPQUFPQSxhQUFhaE4sR0FBRyxDQUFDLENBQUMycEI7b0JBQ3JCLG1EQUFtRDtvQkFDbkQsSUFBSUEsRUFBRWxjLE1BQU0sS0FBS21pQixLQUFLOWUsRUFBRSxFQUNwQixPQUFPNlk7b0JBQ1gsK0NBQStDO29CQUMvQyxPQUFPO3dCQUNILEdBQUdBLENBQUM7d0JBQ0pILFVBQVU7NEJBQ04zWTs0QkFDQXlmOzRCQUNBL2hCO3dCQUNKO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ2dpQixXQUFXLEdBQUcsQ0FBQzdDO1lBQ2hCLElBQUksQ0FBQy9GLGVBQWUsQ0FBQyxJQUFJLENBQUM4QyxxQkFBcUIsRUFBRSxDQUFDK0Y7Z0JBQzlDLElBQUksQ0FBQ0EsU0FDRCxPQUFPQTtnQkFDWCxPQUFPQSxRQUFRM3ZCLE1BQU0sQ0FBQyxDQUFDaVEsS0FBT0EsT0FBTzRjLE1BQU1rQyxJQUFJLENBQUM5ZSxFQUFFO1lBQ3REO1FBQ0o7UUFDQSxJQUFJLENBQUMyZixTQUFTLEdBQUcsQ0FBQy9DO1lBQ2QsSUFBSSxDQUFDL0YsZUFBZSxDQUFDLElBQUksQ0FBQzhDLHFCQUFxQixFQUFFLENBQUMrRixVQUFZO3VCQUN0REEsV0FBVyxFQUFFO29CQUNqQjlDLE1BQU1rQyxJQUFJLENBQUM5ZSxFQUFFO2lCQUNoQjtRQUNMO1FBQ0EsSUFBSSxDQUFDNGYscUJBQXFCLEdBQUcsQ0FBQ2hEO1lBQzFCLElBQUlBLE1BQU1rQyxJQUFJLENBQUM5ZSxFQUFFLEtBQUssSUFBSSxDQUFDNmYsZ0JBQWdCLEVBQUVsakIsUUFBUTtnQkFDakQsSUFBSSxDQUFDa2EsZUFBZSxDQUFDLElBQUksQ0FBQzhELHNCQUFzQixFQUFFaUMsTUFBTWtELGdCQUFnQjtZQUM1RTtRQUNKO1FBQ0EsSUFBSSxDQUFDM1EsTUFBTSxHQUFHUixVQUFVO1lBQUM7U0FBWTtRQUNyQyxJQUFJLENBQUNvUixhQUFhLEdBQUcsSUFBSSxDQUFDL0UsbUJBQW1CLENBQUNnRixZQUFZLEdBQUdDLElBQUksQ0FDakUsMkRBQTJEO1FBQzNELDBCQUEwQjtRQUMxQjl3QixtUUFBS0EsQ0FBQyxDQUFDaXNCLEtBQU9BLEdBQUc4RSxJQUFJLENBQUMsSUFBSSxDQUFDaEYsa0JBQWtCLElBQUk5ckIsMlFBQVdBLENBQUM7WUFBRSt3QixZQUFZO1lBQUdDLFVBQVU7UUFBSztRQUM3RixJQUFJLENBQUNDLGlCQUFpQixHQUFHLElBQUksQ0FBQ04sYUFBYSxDQUFDRSxJQUFJLENBQUM5d0IsbVFBQUtBLENBQUMsQ0FBQytNLGVBQWlCQSxhQUFhM0QsSUFBSSxDQUFDLENBQUNzZ0IsSUFBTUEsRUFBRXlILGtCQUFrQixJQUFJbHhCLDJRQUFXQSxDQUFDO1lBQUUrd0IsWUFBWTtZQUFHQyxVQUFVO1FBQUs7UUFDdEssSUFBSSxDQUFDRyxtQkFBbUIsR0FBRyxJQUFJLENBQUNSLGFBQWEsQ0FBQ0UsSUFBSSxDQUFDOXdCLG1RQUFLQSxDQUFDLENBQUMrTSxlQUFpQkEsYUFBYW5NLE1BQU0sQ0FBQyxDQUFDOG9CLElBQU0sQ0FBQ0EsRUFBRXlILGtCQUFrQixJQUFJbHhCLDJRQUFXQSxDQUFDO1lBQUUrd0IsWUFBWTtZQUFHQyxVQUFVO1FBQUs7UUFDM0ssSUFBSSxDQUFDSSxtQkFBbUIsR0FBRyxJQUFJLENBQUNULGFBQWEsQ0FBQ0UsSUFBSSxDQUFDOXdCLG1RQUFLQSxDQUFDLENBQUMrTSxlQUFpQkEsYUFBYW5NLE1BQU0sQ0FBQyxDQUFDOG9CLElBQU0sQ0FBQyxDQUFDQSxFQUFFUCxHQUFHLElBQUlscEIsMlFBQVdBLENBQUM7WUFBRSt3QixZQUFZO1lBQUdDLFVBQVU7UUFBSztRQUM3SixJQUFJLENBQUNLLGdCQUFnQixHQUFHLElBQUksQ0FBQ1YsYUFBYSxDQUFDRSxJQUFJLENBQUM5d0IsbVFBQUtBLENBQUMsQ0FBQytNLGVBQWlCQSxhQUFhM0QsSUFBSSxDQUFDLENBQUNzZ0IsSUFBTUEsRUFBRTNiLGlCQUFpQixJQUFJOU4sMlFBQVdBLENBQUM7WUFBRSt3QixZQUFZO1lBQUdDLFVBQVU7UUFBSztRQUNwSyxJQUFJLENBQUNNLHNCQUFzQixHQUFHLElBQUksQ0FBQ1gsYUFBYSxDQUFDRSxJQUFJLENBQUM5d0IsbVFBQUtBLENBQUMsQ0FBQytNLGVBQWlCQSxhQUFhNGMsSUFBSSxDQUFDLENBQUNELElBQU1BLEVBQUUvYixlQUFlLENBQUNtVCxRQUFRLENBQUN4VSxVQUFVb2EsWUFBWSxLQUFLeG1CLG9SQUFvQkEsSUFBSUQsMlFBQVdBLENBQUM7WUFBRSt3QixZQUFZO1lBQUdDLFVBQVU7UUFBSztRQUNqTyxJQUFJLENBQUNPLFVBQVUsR0FBRyxJQUFJLENBQUM5RixnQkFBZ0IsQ0FBQ21GLFlBQVk7UUFDcEQsSUFBSSxDQUFDWSxpQkFBaUIsR0FBRyxJQUFJLENBQUM5Rix1QkFBdUIsQ0FBQ2tGLFlBQVk7UUFDbEUsSUFBSSxDQUFDYSwwQkFBMEIsR0FDM0IsSUFBSSxDQUFDOUYsZ0NBQWdDLENBQUNpRixZQUFZO1FBQ3RELElBQUksQ0FBQ2MsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDN0Ysc0JBQXNCLENBQUMrRSxZQUFZO1FBQ2hFLElBQUksQ0FBQ2UsUUFBUSxHQUFHLElBQUksQ0FBQ3JHLGNBQWMsQ0FBQ3NGLFlBQVk7UUFDaEQsSUFBSSxDQUFDZ0IsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDckcsc0JBQXNCLENBQUNxRixZQUFZO1FBQ2hFLElBQUksQ0FBQ2lCLGFBQWEsR0FBRyxJQUFJLENBQUNyRyxtQkFBbUIsQ0FBQ29GLFlBQVk7UUFDMUQsSUFBSSxDQUFDa0IsVUFBVSxHQUFHLElBQUksQ0FBQ3hILGdCQUFnQixDQUFDc0csWUFBWTtRQUNwRCxJQUFJLENBQUNtQixlQUFlLEdBQUcsSUFBSSxDQUFDeEgscUJBQXFCLENBQUNxRyxZQUFZO1FBQzlELElBQUksQ0FBQ29CLFVBQVUsR0FBRyxJQUFJLENBQUN4SCxnQkFBZ0IsQ0FBQ29HLFlBQVk7UUFDcEQsSUFBSSxDQUFDcUIsUUFBUSxHQUFHLElBQUksQ0FBQ3hILGNBQWMsQ0FBQ21HLFlBQVk7UUFDaEQsSUFBSSxDQUFDc0IsU0FBUyxHQUFHLElBQUksQ0FBQ3hILGVBQWUsQ0FBQ2tHLFlBQVk7UUFDbEQsSUFBSSxDQUFDdUIsVUFBVSxHQUFHLElBQUksQ0FBQ3hILGdCQUFnQixDQUFDaUcsWUFBWTtRQUNwRCxJQUFJLENBQUN3QixVQUFVLEdBQUcsSUFBSSxDQUFDeEgsZ0JBQWdCLENBQUNnRyxZQUFZO1FBQ3BELElBQUksQ0FBQ3lCLE9BQU8sR0FBRyxJQUFJLENBQUN4SCxhQUFhLENBQUMrRixZQUFZO1FBQzlDLElBQUksQ0FBQzBCLE9BQU8sR0FBRyxJQUFJLENBQUN4SCxhQUFhLENBQUM4RixZQUFZO1FBQzlDLElBQUksQ0FBQzJCLFFBQVEsR0FBRyxJQUFJLENBQUN4SCxjQUFjLENBQUM2RixZQUFZO1FBQ2hELElBQUksQ0FBQzRCLFVBQVUsR0FBRyxJQUFJLENBQUN4SCxnQkFBZ0IsQ0FBQzRGLFlBQVk7UUFDcEQsSUFBSSxDQUFDNkIsUUFBUSxHQUFHLElBQUksQ0FBQ3hILGNBQWMsQ0FBQzJGLFlBQVk7UUFDaEQsSUFBSSxDQUFDOEIsU0FBUyxHQUFHLElBQUksQ0FBQ3hILGVBQWUsQ0FBQzBGLFlBQVk7UUFDbEQsSUFBSSxDQUFDK0IsYUFBYSxHQUFHLElBQUksQ0FBQ3hILG1CQUFtQixDQUFDeUYsWUFBWTtRQUMxRCxJQUFJLENBQUNnQyxRQUFRLEdBQUcsSUFBSSxDQUFDeEgsY0FBYyxDQUFDd0YsWUFBWTtRQUNoRCxJQUFJLENBQUNpQyxXQUFXLEdBQUcsSUFBSSxDQUFDeEgsaUJBQWlCLENBQUN1RixZQUFZO1FBQ3RELElBQUksQ0FBQ25ELGFBQWEsR0FBRztZQUNqQixnREFBZ0Q7WUFDaEQsMkJBQTJCN21CO1lBQzNCLHlCQUF5QkE7WUFDekIsd0JBQXdCQTtZQUN4QixtQkFBbUJBO1lBQ25CLG9CQUFvQkE7WUFDcEIsaUJBQWlCQTtZQUNqQixnQkFBZ0JBO1lBQ2hCeUgsUUFBUXpIO1lBQ1IsaUNBQWlDO1lBQ2pDLGlCQUFpQixDQUFDc0gsSUFBTSxJQUFJLENBQUM0ZixzQkFBc0IsQ0FBQzVmLEVBQUU0VCxJQUFJO1lBQzFELHFCQUFxQixJQUFJLENBQUN5TyxTQUFTO1lBQ25DLGdCQUFnQixDQUFDcmlCLElBQU0sSUFBSSxDQUFDNGYsc0JBQXNCLENBQUM1ZixFQUFFNFQsSUFBSTtZQUN6RCxjQUFjLENBQUM1VDtnQkFDWCxJQUFJLENBQUM0ZixzQkFBc0IsQ0FBQzVmLEVBQUU0VCxJQUFJO2dCQUNsQyxJQUFJLENBQUMyRixlQUFlLENBQUMsSUFBSSxDQUFDMkQsY0FBYyxFQUFFbGQsRUFBRXdoQixJQUFJO1lBQ3BEO1lBQ0EsZ0NBQWdDLElBQUksQ0FBQ1AsK0JBQStCO1lBQ3BFLGlDQUFpQyxJQUFJLENBQUNDLDZCQUE2QjtZQUNuRSxpQ0FBaUMsSUFBSSxDQUFDSCw2QkFBNkI7WUFDbkUscUJBQXFCLENBQUMvZ0IsSUFBTSxJQUFJLENBQUM0ZixzQkFBc0IsQ0FBQzVmLEVBQUU0VCxJQUFJO1lBQzlELHFCQUFxQixJQUFJLENBQUNrTixxQkFBcUI7WUFDL0MsdUJBQXVCLElBQUksQ0FBQ0osdUJBQXVCO1lBQ25ELGtDQUFrQyxJQUFJLENBQUNvQixhQUFhO1lBQ3BELHVCQUF1QixJQUFJLENBQUNBLGFBQWE7WUFDekMscUJBQXFCLENBQUM5aEI7Z0JBQ2xCLElBQUksQ0FBQzRmLHNCQUFzQixDQUFDNWYsRUFBRTRULElBQUk7Z0JBQ2xDLElBQUksQ0FBQzRLLFVBQVUsQ0FBQ3hlLEVBQUV5ZSxPQUFPO1lBQzdCO1lBQ0EsNEJBQTRCLElBQUksQ0FBQzZELHFCQUFxQjtZQUN0RCxxQkFBcUIsSUFBSSxDQUFDTCx5QkFBeUI7WUFDbkQsMEJBQTBCLElBQU0sSUFBSSxDQUFDMUksZUFBZSxDQUFDLElBQUksQ0FBQ3VELGdCQUFnQixFQUFFO1lBQzVFLDBCQUEwQixJQUFNLElBQUksQ0FBQ3ZELGVBQWUsQ0FBQyxJQUFJLENBQUN1RCxnQkFBZ0IsRUFBRTtZQUM1RSxpQkFBaUIsQ0FBQzljLElBQU0sSUFBSSxDQUFDNGYsc0JBQXNCLENBQUM1ZixFQUFFNFQsSUFBSTtZQUMxRCxhQUFhLENBQUM1VCxJQUFNLElBQUksQ0FBQzRmLHNCQUFzQixDQUFDNWYsRUFBRTRULElBQUk7WUFDdEQsc0JBQXNCLENBQUM1VCxJQUFNLElBQUksQ0FBQzRmLHNCQUFzQixDQUFDNWYsRUFBRTRULElBQUk7WUFDL0QsbUNBQW1DLElBQUksQ0FBQzhOLGtDQUFrQztZQUMxRSxpQ0FBaUMsSUFBSSxDQUFDSixnQ0FBZ0M7WUFDdEUsd0JBQXdCLENBQUN0aEIsSUFBTSxJQUFJLENBQUM0ZixzQkFBc0IsQ0FBQzVmLEVBQUU0VCxJQUFJO1lBQ2pFLHVCQUF1QixJQUFJLENBQUN1TyxXQUFXO1lBQ3ZDLGdCQUFnQixDQUFDbmlCLElBQU0sSUFBSSxDQUFDNGYsc0JBQXNCLENBQUM1ZixFQUFFNFQsSUFBSTtRQUM3RDtJQUNKO0lBQ0E7OztLQUdDLEdBQ0QsSUFBSTdVLG1CQUFtQjtRQUNuQixPQUFPLElBQUksQ0FBQ21hLGVBQWUsQ0FBQyxJQUFJLENBQUNvSyxpQkFBaUI7SUFDdEQ7SUFDQTs7O0tBR0MsR0FDRCxJQUFJeGtCLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQ29hLGVBQWUsQ0FBQyxJQUFJLENBQUNtSyxVQUFVO0lBQy9DO0lBQ0E7OztLQUdDLEdBQ0QsSUFBSXVCLDRCQUE0QjtRQUM1QixPQUFPLElBQUksQ0FBQzFMLGVBQWUsQ0FBQyxJQUFJLENBQUNxSywwQkFBMEI7SUFDL0Q7SUFDQTs7S0FFQyxHQUNELElBQUkza0IsZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDc2EsZUFBZSxDQUFDLElBQUksQ0FBQ3VKLGFBQWE7SUFDbEQ7SUFDQTs7S0FFQyxHQUNELElBQUlGLG1CQUFtQjtRQUNuQixPQUFPLElBQUksQ0FBQ3JKLGVBQWUsQ0FBQyxJQUFJLENBQUM2SixpQkFBaUI7SUFDdEQ7SUFDQTs7S0FFQyxHQUNELElBQUk4QixxQkFBcUI7UUFDckIsT0FBTyxJQUFJLENBQUMzTCxlQUFlLENBQUMsSUFBSSxDQUFDK0osbUJBQW1CO0lBQ3hEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJMUksa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDckIsZUFBZSxDQUFDLElBQUksQ0FBQ2lLLGdCQUFnQjtJQUNyRDtJQUNBOztLQUVDLEdBQ0QsSUFBSTJCLHFCQUFxQjtRQUNyQixPQUFPLElBQUksQ0FBQzVMLGVBQWUsQ0FBQyxJQUFJLENBQUNnSyxtQkFBbUI7SUFDeEQ7SUFDQTs7S0FFQyxHQUNELElBQUk2Qix3QkFBd0I7UUFDeEIsT0FBTyxJQUFJLENBQUM3TCxlQUFlLENBQUMsSUFBSSxDQUFDa0ssc0JBQXNCO0lBQzNEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJNEIsZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDOUwsZUFBZSxDQUFDLElBQUksQ0FBQ3lLLGFBQWE7SUFDbEQ7SUFDQTs7S0FFQyxHQUNELElBQUlzQixrQkFBa0I7UUFDbEIsT0FBTyxJQUFJLENBQUMvTCxlQUFlLENBQUMsSUFBSSxDQUFDc0ssZ0JBQWdCO0lBQ3JEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJL0UsVUFBVTtRQUNWLE9BQU8sSUFBSSxDQUFDdkYsZUFBZSxDQUFDLElBQUksQ0FBQ3VLLFFBQVE7SUFDN0M7SUFDQTs7S0FFQyxHQUNELElBQUl5QixrQkFBa0I7UUFDbEIsT0FBTyxJQUFJLENBQUNoTSxlQUFlLENBQUMsSUFBSSxDQUFDd0ssZ0JBQWdCO0lBQ3JEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJN0QsWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDM0csZUFBZSxDQUFDLElBQUksQ0FBQzBLLFVBQVU7SUFDL0M7SUFDQTs7S0FFQyxHQUNELElBQUl1QixpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNqTSxlQUFlLENBQUMsSUFBSSxDQUFDMkssZUFBZTtJQUNwRDtJQUNBOztLQUVDLEdBQ0QsSUFBSWhoQixZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNxVyxlQUFlLENBQUMsSUFBSSxDQUFDNEssVUFBVTtJQUMvQztJQUNBOztLQUVDLEdBQ0QsSUFBSXNCLFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ2xNLGVBQWUsQ0FBQyxJQUFJLENBQUM2SyxRQUFRO0lBQzdDO0lBQ0E7O0tBRUMsR0FDRCxJQUFJc0IsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDbk0sZUFBZSxDQUFDLElBQUksQ0FBQzhLLFNBQVM7SUFDOUM7SUFDQTs7S0FFQyxHQUNELElBQUlsaEIsWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDb1csZUFBZSxDQUFDLElBQUksQ0FBQytLLFVBQVU7SUFDL0M7SUFDQTs7S0FFQyxHQUNELElBQUlxQixZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNwTSxlQUFlLENBQUMsSUFBSSxDQUFDZ0wsVUFBVTtJQUMvQztJQUNBOztLQUVDLEdBQ0QsSUFBSS9qQixTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUMrWSxlQUFlLENBQUMsSUFBSSxDQUFDaUwsT0FBTztJQUM1QztJQUNBOztLQUVDLEdBQ0QsSUFBSS9ELFNBQVM7UUFDVCxPQUFPLElBQUksQ0FBQ2xILGVBQWUsQ0FBQyxJQUFJLENBQUNrTCxPQUFPO0lBQzVDO0lBQ0E7O0tBRUMsR0FDRCxJQUFJL0QsVUFBVTtRQUNWLE9BQU8sSUFBSSxDQUFDbkgsZUFBZSxDQUFDLElBQUksQ0FBQ21MLFFBQVE7SUFDN0M7SUFDQTs7S0FFQyxHQUNELElBQUkvRCxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNwSCxlQUFlLENBQUMsSUFBSSxDQUFDb0wsVUFBVTtJQUMvQztJQUNBOztLQUVDLEdBQ0QsSUFBSS9ELFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQ3JILGVBQWUsQ0FBQyxJQUFJLENBQUNxTCxRQUFRO0lBQzdDO0lBQ0E7O0tBRUMsR0FDRCxJQUFJMU4sV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDcUMsZUFBZSxDQUFDLElBQUksQ0FBQ3NMLFNBQVM7SUFDOUM7SUFDQTs7S0FFQyxHQUNELElBQUloRSxlQUFlO1FBQ2YsT0FBTyxJQUFJLENBQUN0SCxlQUFlLENBQUMsSUFBSSxDQUFDdUwsYUFBYTtJQUNsRDtJQUNBOztLQUVDLEdBQ0QsSUFBSWMsVUFBVTtRQUNWLE9BQU8sSUFBSSxDQUFDck0sZUFBZSxDQUFDLElBQUksQ0FBQ3dMLFFBQVE7SUFDN0M7SUFDQTs7S0FFQyxHQUNELElBQUlqRSxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUN2SCxlQUFlLENBQUMsSUFBSSxDQUFDeUwsV0FBVztJQUNoRDtBQUNKO0FBRUEsTUFBTWE7SUFDRnh1QixhQUFjO1FBQ1Y7O1NBRUMsR0FDRCxJQUFJLENBQUN5dUIsb0JBQW9CLEdBQUcsSUFBSTl6QiwyUUFBZUEsQ0FBQytHO1FBQ2hEOztTQUVDLEdBQ0QsSUFBSSxDQUFDZ3RCLFlBQVksR0FBRyxJQUFJL3pCLDJRQUFlQSxDQUFDLEVBQUU7UUFDMUM7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUN1bkIsZUFBZSxHQUFHQTtRQUN2Qjs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQ0ssZUFBZSxHQUFHQTtRQUN2Qjs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ29NLGdCQUFnQixHQUFHLENBQUNuRTtZQUNyQixPQUFPLElBQUksQ0FBQ2pJLGVBQWUsQ0FBQyxJQUFJLENBQUNrTSxvQkFBb0IsRUFBRWpFO1FBQzNEO1FBQ0E7OztTQUdDLEdBQ0QsSUFBSSxDQUFDb0UsUUFBUSxHQUFHLENBQUNDO1lBQ2IsT0FBTyxJQUFJLENBQUN0TSxlQUFlLENBQUMsSUFBSSxDQUFDbU0sWUFBWSxFQUFFRztRQUNuRDtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDbFM7WUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ2lTLEtBQUssQ0FBQzVxQixJQUFJLENBQUMsQ0FBQ3FYLElBQU1BLEVBQUV5VCxHQUFHLEtBQUtuUyxLQUFLbVMsR0FBRyxHQUFHO2dCQUM3QyxJQUFJLENBQUNILFFBQVEsQ0FBQyxDQUFDQyxRQUFVOzJCQUFJQTt3QkFBT2pTO3FCQUFLO1lBQzdDO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDb1MsY0FBYyxHQUFHLENBQUNwUztZQUNuQixPQUFPLElBQUksQ0FBQ2dTLFFBQVEsQ0FBQyxDQUFDQyxRQUFVQSxNQUFNcHpCLE1BQU0sQ0FBQyxDQUFDNmYsSUFBTUEsTUFBTXNCO1FBQzlEO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNxUyxRQUFRLEdBQUcsQ0FBQ3hqQixNQUFNQztZQUNuQixPQUFPLElBQUksQ0FBQ21qQixLQUFLLENBQUM1cUIsSUFBSSxDQUFDLENBQUNxWCxJQUFNQSxFQUFFN1AsSUFBSSxLQUFLQSxRQUFRNlAsRUFBRTVQLEVBQUUsS0FBS0E7UUFDOUQ7UUFDQSxJQUFJLENBQUMraUIsb0JBQW9CLENBQUNwTSxTQUFTLENBQUMsT0FBT21JO1lBQ3ZDLDZDQUE2QztZQUM3QyxJQUFJLENBQUNBLE1BQU07Z0JBQ1AsTUFBTTNQLFNBQVNSLFVBQVU7b0JBQUM7aUJBQWU7Z0JBQ3pDLEtBQUssTUFBTXVDLFFBQVEsSUFBSSxDQUFDaVMsS0FBSyxDQUFFO29CQUMzQixJQUFJalMsS0FBS3lLLEtBQUssQ0FBQzJHLFlBQVksS0FBSzdJLGFBQWErSixJQUFJLEVBQzdDO29CQUNKclUsT0FBTyxRQUFRLENBQUMsaUNBQWlDLEVBQUUrQixLQUFLbVMsR0FBRyxDQUFDLENBQUM7b0JBQzdELE1BQU1uUyxLQUFLdVMsS0FBSyxHQUFHQyxLQUFLLENBQUMsQ0FBQ2hOO3dCQUN0QnZILE9BQU8sU0FBUyxDQUFDLG9CQUFvQixFQUFFK0IsS0FBS21TLEdBQUcsQ0FBQyxDQUFDLEVBQUUzTTtvQkFDdkQ7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7S0FFQyxHQUNELElBQUlpTixnQkFBZ0I7UUFDaEIsT0FBTyxJQUFJLENBQUNuTixlQUFlLENBQUMsSUFBSSxDQUFDdU0sb0JBQW9CO0lBQ3pEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJSSxRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUMzTSxlQUFlLENBQUMsSUFBSSxDQUFDd00sWUFBWTtJQUNqRDtBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1ZO0lBQ0Z0dkIsWUFBWXV2QixLQUFLLENBQUU7UUFDZjs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ3JOLGVBQWUsR0FBR0E7UUFDdkIsNkNBQTZDO1FBQzdDLElBQUksQ0FBQ3NOLGNBQWMsR0FBR0QsTUFBTWQsb0JBQW9CLENBQUMvQyxZQUFZO1FBQzdELElBQUksQ0FBQytELE1BQU0sR0FBR0YsTUFBTWIsWUFBWSxDQUFDaEQsWUFBWTtJQUNqRDtJQUNBOztLQUVDLEdBQ0QsSUFBSTJELGdCQUFnQjtRQUNoQixPQUFPbk4sZ0JBQWdCLElBQUksQ0FBQ3NOLGNBQWM7SUFDOUM7SUFDQTs7S0FFQyxHQUNELElBQUlYLFFBQVE7UUFDUixPQUFPM00sZ0JBQWdCLElBQUksQ0FBQ3VOLE1BQU07SUFDdEM7QUFDSjtBQUVBLE1BQU1DLFlBQVksQ0FBQ0M7SUFDZixxQ0FBcUM7SUFDckMsTUFBTUMsV0FBVztJQUNqQiwrTUFBK007SUFDL00sTUFBTUMsV0FBV0QsU0FBU0UsSUFBSSxDQUFDSDtJQUMvQixJQUFJRSxVQUFVO1FBQ1YsT0FBTztZQUNIRSxVQUFVRixRQUFRLENBQUMsRUFBRTtZQUNyQjVTLFNBQVM0UyxRQUFRLENBQUMsRUFBRTtZQUNwQjlaLE9BQU84WixRQUFRLENBQUMsRUFBRTtRQUN0QjtJQUNKO0FBQ0o7QUFDQSxNQUFNRyxVQUFVLENBQUNMO0lBQ2Isa0RBQWtEO0lBQ2xELE1BQU1NLFlBQVk7SUFDbEIsTUFBTUMsWUFBWUQsVUFBVUgsSUFBSSxDQUFDSDtJQUNqQywrR0FBK0c7SUFDL0csSUFBSU8sV0FBVztRQUNYLE9BQU87WUFDSEgsVUFBVUcsU0FBUyxDQUFDLEVBQUU7WUFDdEJqVCxTQUFTaVQsU0FBUyxDQUFDLEVBQUU7WUFDckJDLFFBQVFELFNBQVMsQ0FBQyxFQUFFO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNRSxXQUFXLENBQUNULE1BQU1VO0lBQ3BCLE1BQU1DLFFBQVEsSUFBSUMsT0FBTyxDQUFDLEdBQUcsRUFBRUYsVUFBVSwwQkFBMEIsQ0FBQztJQUNwRSxNQUFNMXBCLFFBQVEycEIsTUFBTVIsSUFBSSxDQUFDSDtJQUN6QixJQUFJaHBCLE9BQU87UUFDUCxPQUFPO1lBQ0hvcEIsVUFBVXBwQixLQUFLLENBQUMsRUFBRTtZQUNsQjZwQixnQkFBZ0I3cEIsS0FBSyxDQUFDLEVBQUU7WUFDeEI4cEIsWUFBWTlwQixLQUFLLENBQUMsRUFBRTtRQUN4QjtJQUNKO0FBQ0o7QUFDQSxNQUFNK3BCLGtCQUFrQixDQUFDL2dCLEtBQUswZ0I7SUFDMUIsSUFBSU07SUFDSixNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsNEJBQTRCO0lBQ2hDbmhCLElBQUlzTyxLQUFLLENBQUMsZ0JBQWdCNUMsT0FBTyxDQUFDLENBQUNzVTtRQUMvQixNQUFNb0IsY0FBYyxnQkFBZ0JDLElBQUksQ0FBQ3JCO1FBQ3pDLElBQUksQ0FBQ29CLGFBQ0Q7UUFDSjs7O1FBR0EsR0FDQSxNQUFNdGxCLE9BQU9ra0IsSUFBSSxDQUFDLEVBQUU7UUFDcEIsSUFBSWxrQixTQUFTLEtBQUs7WUFDZCxNQUFNd2xCLFNBQVNiLFNBQVNULE1BQU1VO1lBQzlCUyw0QkFBNEIsQ0FBQyxDQUFDRztZQUM5QixJQUFJQSxRQUFRO2dCQUNSTixRQUFRTTtZQUNaO1FBQ0osT0FDSyxJQUFJSCw2QkFBNkJybEIsU0FBUyxLQUFLO1lBQ2hELE1BQU15bEIsYUFBYXhCLFVBQVVDO1lBQzdCLE1BQU10bEIsV0FBVzJsQixRQUFRTDtZQUN6QixJQUFJdUIsWUFBWTtnQkFDWk4sT0FBTzFyQixJQUFJLENBQUNnc0I7WUFDaEIsT0FDSyxJQUFJN21CLFVBQVU7Z0JBQ2Z3bUIsS0FBSzNyQixJQUFJLENBQUNtRjtZQUNkO1FBQ0o7SUFDSjtJQUNBLElBQUlzbUIsT0FBTztRQUNQLE9BQU87WUFDSEE7WUFDQUM7WUFDQUM7UUFDSjtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELE1BQU1NLGNBQWMsQ0FBQ3hoQjtJQUNqQixNQUFNeWhCLFVBQVVWLGdCQUFnQi9nQixLQUFLO0lBQ3JDLE1BQU1paEIsU0FBU1EsU0FBU1IsT0FBTzNzQixLQUFLLENBQUN3Z0IsSUFBTUEsRUFBRTFPLEtBQUssQ0FBQ3FELFdBQVcsT0FBTztJQUNyRSxNQUFNaVksVUFBVVQsUUFBUTNUO0lBQ3hCLElBQUlvVSxTQUFTO1FBQ1QsT0FBT0QsU0FBU1AsS0FBSzVzQixLQUFLLENBQUNDLElBQU1BLEVBQUUrWSxPQUFPLEtBQUtvVTtJQUNuRDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyxZQUFZLENBQUMzaEIsS0FBSzRoQjtJQUNwQixNQUFNQyxXQUFXTCxZQUFZeGhCO0lBQzdCLElBQUk2aEIsVUFBVTtRQUNWLE1BQU1DLFdBQVcsY0FBYzNCLElBQUksQ0FBQzBCLFNBQVNyQixNQUFNO1FBQ25ELE1BQU11QixvQkFBb0IsQ0FBQyxPQUFPLEVBQUVILFNBQVMsTUFBTSxJQUFJLENBQUM7UUFDeEQsSUFBSUUsVUFBVTtZQUNWLE1BQU1FLFVBQVVILFNBQVN6QixRQUFRLENBQUN0cEIsT0FBTyxDQUFDLGVBQWVpckI7WUFDekQsT0FBTy9oQixJQUFJbEosT0FBTyxDQUFDK3FCLFNBQVN6QixRQUFRLEVBQUU0QjtRQUMxQyxPQUNLO1lBQ0QsTUFBTUEsVUFBVSxDQUFDLEVBQUVILFNBQVN6QixRQUFRLENBQUMsQ0FBQyxFQUFFMkIsa0JBQWtCLENBQUM7WUFDM0QsT0FBTy9oQixJQUFJbEosT0FBTyxDQUFDK3FCLFNBQVN6QixRQUFRLEVBQUU0QjtRQUMxQztJQUNKO0lBQ0EsT0FBT2hpQjtBQUNYO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsTUFBTWlpQix5QkFBeUIsQ0FBQ2ppQixLQUFLa2lCLFVBQVVyYixhQUFhLE1BQU07SUFDOURBLGFBQWE5USxLQUFLc2IsR0FBRyxDQUFDdGIsS0FBS29zQixHQUFHLENBQUN0YixZQUFZLFNBQVM7SUFDcEQsTUFBTXViLFlBQVluMkIsZ0RBQVMsQ0FBQytUO0lBQzVCLE1BQU1xaUIsYUFBYUQsVUFBVXBCLEtBQUssQ0FBQzFzQixJQUFJLENBQUMsQ0FBQzBsQixJQUFNQSxFQUFFbGUsSUFBSSxLQUFLLFdBQVd3bUIsT0FBT3RJLEVBQUV4ZSxHQUFHLE1BQU0wbUI7SUFDdkYsSUFBSSxDQUFDRyxZQUNELE9BQU9yaUI7SUFDWCxNQUFNdWlCLFVBQVVGLFdBQVdHLEdBQUcsQ0FBQ2x1QixJQUFJLENBQUMsQ0FBQ3dnQixJQUFNQSxFQUFFMU8sS0FBSyxLQUFLO0lBQ3ZELElBQUksQ0FBQ21jLFNBQ0QsT0FBT3ZpQjtJQUNYLE1BQU02aEIsV0FBV1EsV0FBV25CLElBQUksQ0FBQzVzQixJQUFJLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRStZLE9BQU8sS0FBS2lWLFFBQVFqVixPQUFPO0lBQzFFLElBQUksQ0FBQ3VVLFVBQ0QsT0FBTzdoQjtJQUNYLHdDQUF3QztJQUN4QyxJQUFJNmhCLFNBQVNyQixNQUFNLENBQUN4cEIsS0FBSyxDQUFDLGdCQUFnQjtRQUN0QzZxQixTQUFTckIsTUFBTSxHQUFHcUIsU0FBU3JCLE1BQU0sQ0FBQzFwQixPQUFPLENBQUMsZUFBZTtJQUM3RCxPQUNLO1FBQ0QrcUIsU0FBU3JCLE1BQU0sR0FBRyxDQUFDLEVBQUVxQixTQUFTckIsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuRDtJQUNBLDRDQUE0QztJQUM1QyxJQUFJcUIsU0FBU3JCLE1BQU0sQ0FBQ3hwQixLQUFLLENBQUMsNEJBQTRCO1FBQ2xENnFCLFNBQVNyQixNQUFNLEdBQUdxQixTQUFTckIsTUFBTSxDQUFDMXBCLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxrQkFBa0IsRUFBRStQLFdBQVcsQ0FBQztJQUMxRyxPQUNLO1FBQ0RnYixTQUFTckIsTUFBTSxHQUFHLENBQUMsRUFBRXFCLFNBQVNyQixNQUFNLENBQUMsbUJBQW1CLEVBQUUzWixXQUFXLENBQUM7SUFDMUU7SUFDQSxPQUFPNWEsZ0RBQVMsQ0FBQ20yQjtBQUNyQjtBQUVBLE1BQU1NLFdBQVdoWSxVQUFVO0lBQUM7Q0FBWTtBQUN4Qzs7O0NBR0MsR0FDRCxNQUFNaVk7SUFDRjs7OztLQUlDLEdBQ0QsSUFBSUMsMEJBQTBCO1FBQzFCLElBQUksSUFBSSxDQUFDQyxFQUFFLENBQUNDLGdCQUFnQixFQUN4QixPQUFPLElBQUksQ0FBQ0QsRUFBRSxDQUFDQyxnQkFBZ0I7UUFDbkMsT0FBTyxJQUFJLENBQUNDLHdCQUF3QjtJQUN4QztJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRDF5QixZQUFZLEVBQUUyeUIsZ0JBQWdCLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFeEwsS0FBSyxFQUFFeUwsWUFBWSxFQUFFQyxZQUFZLEVBQUVDLGtCQUFrQixJQUFJLEVBQUcsQ0FBRTtRQUNqSCxJQUFJLENBQUNDLG1CQUFtQixHQUFHO1lBQ3ZCLENBQUM5ckIsVUFBVXVhLEtBQUssQ0FBQyxFQUFFaGdCO1lBQ25CLENBQUN5RixVQUFVc2EsS0FBSyxDQUFDLEVBQUUvZjtZQUNuQixDQUFDeUYsVUFBVW9hLFlBQVksQ0FBQyxFQUFFN2Y7WUFDMUIsQ0FBQ3lGLFVBQVVxYSxrQkFBa0IsQ0FBQyxFQUFFOWY7WUFDaEMsQ0FBQ3lGLFVBQVV3YSxXQUFXLENBQUMsRUFBRWpnQjtRQUM3QjtRQUNBLElBQUksQ0FBQ3d4QiwwQkFBMEIsR0FBRyxJQUFJQztRQUN0Qzs7Ozs7O1NBTUMsR0FDRCxJQUFJLENBQUNDLG9CQUFvQixHQUFHLEVBQUU7UUFDOUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztZQUNwQixDQUFDbHNCLFVBQVV1YSxLQUFLLENBQUMsRUFBRTtZQUNuQixDQUFDdmEsVUFBVXNhLEtBQUssQ0FBQyxFQUFFO1lBQ25CLENBQUN0YSxVQUFVb2EsWUFBWSxDQUFDLEVBQUU7WUFDMUIsQ0FBQ3BhLFVBQVVxYSxrQkFBa0IsQ0FBQyxFQUFFO1lBQ2hDLENBQUNyYSxVQUFVd2EsV0FBVyxDQUFDLEVBQUVqZ0I7UUFDN0I7UUFDQSxJQUFJLENBQUM0eEIsZ0JBQWdCLEdBQUc7WUFDcEIsQ0FBQ25zQixVQUFVdWEsS0FBSyxDQUFDLEVBQUVoZ0I7WUFDbkIsQ0FBQ3lGLFVBQVVzYSxLQUFLLENBQUMsRUFBRS9mO1lBQ25CLENBQUN5RixVQUFVb2EsWUFBWSxDQUFDLEVBQUU3ZjtZQUMxQixDQUFDeUYsVUFBVXFhLGtCQUFrQixDQUFDLEVBQUU5ZjtZQUNoQyxDQUFDeUYsVUFBVXdhLFdBQVcsQ0FBQyxFQUFFamdCO1FBQzdCO1FBQ0EsSUFBSSxDQUFDNnhCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLG9CQUFvQixHQUFHLENBQUNiO1lBQ3pCLE1BQU1ILEtBQUssSUFBSXpXLGtCQUFrQjRXO1lBQ2pDLElBQUksQ0FBQ0Qsd0JBQXdCLEdBQUdDO1lBQ2hDSCxHQUFHaUIsZ0JBQWdCLENBQUMsZ0JBQWdCLElBQUksQ0FBQ0MsY0FBYztZQUN2RGxCLEdBQUdpQixnQkFBZ0IsQ0FBQyxxQkFBcUIsSUFBSSxDQUFDRSxtQkFBbUI7WUFDakVuQixHQUFHaUIsZ0JBQWdCLENBQUMscUJBQXFCLElBQUksQ0FBQ0csbUJBQW1CO1lBQ2pFcEIsR0FBR2lCLGdCQUFnQixDQUFDLDRCQUE0QixJQUFJLENBQUNJLDBCQUEwQjtZQUMvRXJCLEdBQUdpQixnQkFBZ0IsQ0FBQywyQkFBMkIsSUFBSSxDQUFDSyx5QkFBeUI7WUFDN0V0QixHQUFHaUIsZ0JBQWdCLENBQUMsd0JBQXdCLElBQUksQ0FBQ00sc0JBQXNCO1lBQ3ZFLE9BQU92QjtRQUNYO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUNsVyxLQUFLLEdBQUcsQ0FBQyxFQUFFMFgsYUFBYSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDcEMsSUFBSUEsWUFBWTtnQkFDWixJQUFJLENBQUNDLGNBQWM7Z0JBQ25CbnpCLE9BQU9rQyxJQUFJLENBQUMsSUFBSSxDQUFDaXdCLG1CQUFtQixFQUFFNVgsT0FBTyxDQUFDLENBQUNwUTtvQkFDM0MsYUFBYTtvQkFDYixJQUFJLENBQUNnb0IsbUJBQW1CLENBQUNob0IsVUFBVSxHQUFHdko7Z0JBQzFDO2dCQUNBWixPQUFPa0MsSUFBSSxDQUFDLElBQUksQ0FBQ3N3QixnQkFBZ0IsRUFBRWpZLE9BQU8sQ0FBQyxDQUFDcFE7b0JBQ3hDLGFBQWE7b0JBQ2IsSUFBSSxDQUFDcW9CLGdCQUFnQixDQUFDcm9CLFVBQVUsR0FBR3ZKO2dCQUN2QztZQUNKO1lBQ0F3eUIsYUFBYSxJQUFJLENBQUNDLGlCQUFpQjtZQUNuQyxJQUFJLENBQUNDLHVCQUF1QjtZQUM1QixJQUFJLENBQUM1QixFQUFFLENBQUM2QixtQkFBbUIsQ0FBQyxxQkFBcUIsSUFBSSxDQUFDVixtQkFBbUI7WUFDekUsSUFBSSxDQUFDbkIsRUFBRSxDQUFDbFcsS0FBSztRQUNqQjtRQUNBOzs7Ozs7Ozs7O1NBVUMsR0FDRCxJQUFJLENBQUNnWSxhQUFhLEdBQUcsT0FBT0MsYUFBYUMsT0FBT3ZwQixXQUFXd3BCLE9BQU8sQ0FBQyxDQUFDO1lBQ2hFLElBQUlELE1BQU1FLFVBQVUsS0FBSyxTQUFTO2dCQUM5QixNQUFNLElBQUk3MEIsTUFBTSxDQUFDLDZDQUE2QyxDQUFDO1lBQ25FO1lBQ0EsSUFBSTgwQixjQUFjLElBQUksQ0FBQ25DLEVBQUUsQ0FDcEJyVyxlQUFlLEdBQ2ZsWSxJQUFJLENBQUMsQ0FBQ21ZLElBQU1BLE1BQU0sSUFBSSxDQUFDNlcsbUJBQW1CLENBQUNob0IsVUFBVSxJQUN0RG1SLEVBQUV3WSxNQUFNLENBQUNKLEtBQUssSUFDZHBZLEVBQUV3WSxNQUFNLENBQUNKLEtBQUssRUFBRXIwQixTQUFTLElBQUksQ0FBQ2t6QixnQkFBZ0IsQ0FBQ3BvQixVQUFVO1lBQzdEOzs7YUFHQyxHQUNELE1BQU00cEIsbUJBQW1CO2dCQUNyQnhDLFNBQVMsUUFBUSxDQUFDLE1BQU0sRUFBRWxyQixTQUFTLENBQUM4RCxVQUFVLENBQUMsNkJBQTZCLENBQUM7Z0JBQzdFLE1BQU0sSUFBSSxDQUFDNnBCLDJCQUEyQixDQUFDUCxhQUFhdHBCLFdBQVc7Z0JBQy9ELHdEQUF3RDtnQkFDeER1cEIsTUFBTUgsbUJBQW1CLENBQUMsU0FBU1E7WUFDdkM7WUFDQSxJQUFJLENBQUNGLGFBQWE7Z0JBQ2QsTUFBTSxFQUFFOVUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDd0gsS0FBSztnQkFDL0IsTUFBTTFILG1CQUFtQkUsVUFBVWtWLE1BQU1DO2dCQUN6QyxNQUFNQyxpQkFBaUJocUIsY0FBYzlELFVBQVVzYSxLQUFLLEdBQzlDaEMsdUJBQXVCK1UsT0FBTzdVLG9CQUM5QjFVLGNBQWM5RCxVQUFVb2EsWUFBWSxHQUNoQ0gsK0JBQStCb1QsT0FBT0MsS0FBS1MsbUJBQW1CLElBQzlEeHpCO2dCQUNWLElBQUlpWixpQkFBaUI4WixLQUFLOVosY0FBYztnQkFDeEMsSUFBSSxDQUFDQSxrQkFBa0IxUCxjQUFjOUQsVUFBVXNhLEtBQUssRUFBRTtvQkFDbEQsSUFBSXhJLGlCQUFpQjt3QkFDakIsTUFBTWtjLFNBQVNyVyxhQUFhNWUsS0FBS2taO3dCQUNqQyxJQUFJK2IsV0FBVyxVQUFVOzRCQUNyQixvREFBb0Q7NEJBQ3BELCtDQUErQzs0QkFDL0MseUNBQXlDOzRCQUN6Q3hhLGlCQUFpQjt3QkFDckIsT0FDSyxJQUFJd2EsV0FBVyxXQUFXOzRCQUMzQnhhLGlCQUFpQjt3QkFDckI7b0JBQ0o7Z0JBQ0o7Z0JBQ0EsTUFBTXlhLG1CQUFtQixJQUFJLENBQUNDLG1CQUFtQixDQUFDcHFCLFdBQVcwUDtnQkFDN0Qsc0VBQXNFO2dCQUN0RSx5RUFBeUU7Z0JBQ3pFLCtEQUErRDtnQkFDL0Q2WixNQUFNZixnQkFBZ0IsQ0FBQyxTQUFTb0I7Z0JBQ2hDLElBQUksQ0FBQ0wsTUFBTWMsT0FBTyxFQUFFO29CQUNoQmQsTUFBTWMsT0FBTyxHQUFHO2dCQUNwQjtnQkFDQVgsY0FBYyxJQUFJLENBQUNuQyxFQUFFLENBQUN4VyxjQUFjLENBQUN3WSxPQUFPO29CQUN4QzNZLFdBQVc7b0JBQ1gwWixTQUFTdHFCLGNBQWM5RCxVQUFVc2EsS0FBSyxJQUFJeFcsY0FBYzlELFVBQVVvYSxZQUFZLEdBQ3hFO3dCQUFDZ1Q7cUJBQVksR0FDYjd5QjtvQkFDTjh6QixlQUFlUDtnQkFDbkI7Z0JBQ0E1QyxTQUFTLFNBQVMsQ0FBQyxNQUFNLEVBQUVsckIsU0FBUyxDQUFDOEQsVUFBVSxDQUFDLFlBQVksQ0FBQztnQkFDN0QsSUFBSSxDQUFDbW9CLG9CQUFvQixDQUFDbHVCLElBQUksQ0FBQytGO2dCQUMvQixJQUFJLENBQUNnb0IsbUJBQW1CLENBQUNob0IsVUFBVSxHQUFHMHBCO2dCQUN0QyxJQUFJLENBQUN6QiwwQkFBMEIsQ0FBQ3VDLEdBQUcsQ0FBQ3hxQixXQUFXd3BCO2dCQUMvQyxJQUFJLHlCQUF5QkUsZUFBZVMsa0JBQWtCO29CQUMxRC9DLFNBQVMsUUFBUSxDQUFDLFFBQVEsRUFBRWxyQixTQUFTLENBQUM4RCxVQUFVLENBQUMsa0JBQWtCLENBQUMsRUFBRW1xQjtvQkFDdEVULFlBQVllLG1CQUFtQixDQUFDTjtnQkFDcEM7WUFDSixPQUNLO2dCQUNELE1BQU1PLGdCQUFnQmhCLFlBQVlDLE1BQU0sQ0FBQ0osS0FBSztnQkFDOUMsOERBQThEO2dCQUM5RCxJQUFJbUIsaUJBQWlCQSxrQkFBa0JuQixPQUFPO29CQUMxQ21CLGNBQWN0WixJQUFJO29CQUNsQnNaLGNBQWN0QixtQkFBbUIsQ0FBQyxTQUFTUTtvQkFDM0NMLE1BQU1mLGdCQUFnQixDQUFDLFNBQVNvQjtnQkFDcEM7Z0JBQ0EsSUFBSSxDQUFDTCxNQUFNYyxPQUFPLEVBQUU7b0JBQ2hCZCxNQUFNYyxPQUFPLEdBQUc7Z0JBQ3BCO2dCQUNBLE1BQU1YLFlBQVlDLE1BQU0sQ0FBQ2dCLFlBQVksQ0FBQ3BCO1lBQzFDO1lBQ0EsTUFBTSxJQUFJLENBQUNNLDJCQUEyQixDQUFDUCxhQUFhdHBCLFdBQVc7UUFDbkU7UUFDQTs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQzRxQixlQUFlLEdBQUcsT0FBTzVxQixXQUFXNnFCO1lBQ3JDLE1BQU1uQixjQUFjLElBQUksQ0FBQ25DLEVBQUUsQ0FDdEJyVyxlQUFlLEdBQ2ZsWSxJQUFJLENBQUMsQ0FBQ21ZLElBQU1BLE1BQU0sSUFBSSxDQUFDNlcsbUJBQW1CLENBQUNob0IsVUFBVSxJQUFJbVIsRUFBRXdZLE1BQU0sQ0FBQ0osS0FBSztZQUM1RSxJQUFJRyxlQUNBQSxZQUFZQyxNQUFNLENBQUNKLEtBQUssSUFDdkJzQixDQUFBQSxZQUNLbkIsWUFBWUMsTUFBTSxDQUFDSixLQUFLLENBQUNFLFVBQVUsS0FBSyxTQUN4Q0MsWUFBWUMsTUFBTSxDQUFDSixLQUFLLENBQUNjLE9BQU8sR0FBRztnQkFDekNRLFlBQ01uQixZQUFZQyxNQUFNLENBQUNKLEtBQUssQ0FBQ25ZLElBQUksS0FDNUJzWSxZQUFZQyxNQUFNLENBQUNKLEtBQUssQ0FBQ2MsT0FBTyxHQUFHO2dCQUMxQyw4RUFBOEU7Z0JBQzlFLElBQUksSUFBSSxDQUFDak8sS0FBSyxDQUFDa0UsZ0JBQWdCLEVBQUUvaUIsZ0JBQWdCbVQsU0FBUzFRLFlBQVk7b0JBQ2xFLE1BQU0sSUFBSSxDQUFDNnBCLDJCQUEyQixDQUFDcHpCLFdBQVd1SixXQUFXO2dCQUNqRTtZQUNKO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDOHFCLFlBQVksR0FBRyxDQUFDOXFCO1lBQ2pCLE1BQU0rcUIsMEJBQTBCLElBQUksQ0FBQy9DLG1CQUFtQixDQUFDaG9CLFVBQVU7WUFDbkUsSUFBSStxQiwyQkFBMkJBLHdCQUF3QnBCLE1BQU0sRUFBRTtnQkFDM0QsTUFBTUEsU0FBU29CLHdCQUF3QnBCLE1BQU07Z0JBQzdDLE9BQVEsQ0FBQyxDQUFDQSxPQUFPSixLQUFLLElBQ2xCSSxPQUFPSixLQUFLLENBQUNFLFVBQVUsS0FBSyxVQUM1QkUsT0FBT0osS0FBSyxDQUFDYyxPQUFPO1lBQzVCO1lBQ0EsT0FBTztRQUNYO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ1csTUFBTSxHQUFHLENBQUNockI7WUFDWCxNQUFNK3FCLDBCQUEwQixJQUFJLENBQUMvQyxtQkFBbUIsQ0FBQ2hvQixVQUFVO1lBQ25FLElBQUkrcUIsMkJBQTJCQSx3QkFBd0JwQixNQUFNLEVBQUU7Z0JBQzNELE1BQU1BLFNBQVNvQix3QkFBd0JwQixNQUFNO2dCQUM3QyxPQUFPLENBQUMsQ0FBQ0EsT0FBT0osS0FBSyxJQUFJSSxPQUFPSixLQUFLLENBQUNFLFVBQVUsS0FBSztZQUN6RDtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0ksMkJBQTJCLEdBQUcsT0FBT1AsYUFBYXRwQixXQUFXaXJCO1lBQzlELE1BQU0sSUFBSSxDQUFDdEQsU0FBUyxDQUFDdUQsZUFBZSxDQUFDbHJCLFdBQVdpckI7WUFDaEQsTUFBTUUsa0NBQWtDOVUsZ0NBQWdDclc7WUFDeEUsSUFBSWlyQixTQUFTO2dCQUNULElBQUksQ0FBQzdPLEtBQUssQ0FBQ1csaUJBQWlCLENBQUMsSUFBSSxDQUFDNEssU0FBUyxDQUFDdHFCLFNBQVMsRUFBRSxDQUFDaWMsSUFBTzt3QkFDM0QvYixpQkFBaUIrYixFQUFFL2IsZUFBZSxDQUFDL00sTUFBTSxDQUFDLENBQUMyZ0IsSUFBTUEsTUFBTW5SO3dCQUN2RCxDQUFDbXJCLGdDQUFnQyxFQUFFMTBCO29CQUN2QztZQUNKLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDMmxCLEtBQUssQ0FBQ1csaUJBQWlCLENBQUMsSUFBSSxDQUFDNEssU0FBUyxDQUFDdHFCLFNBQVMsRUFBRSxDQUFDaWM7b0JBQ3BELE9BQU87d0JBQ0gvYixpQkFBaUIrYixFQUFFL2IsZUFBZSxDQUFDbVQsUUFBUSxDQUFDMVEsYUFDdENzWixFQUFFL2IsZUFBZSxHQUNqQjsrQkFBSStiLEVBQUUvYixlQUFlOzRCQUFFeUM7eUJBQVU7d0JBQ3ZDLENBQUNtckIsZ0NBQWdDLEVBQUU3QjtvQkFDdkM7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUNOLGNBQWMsR0FBRztZQUNsQjVCLFNBQVMsU0FBUztZQUNsQixJQUFJLENBQUNHLEVBQUUsQ0FBQzZELFVBQVUsR0FBR2hiLE9BQU8sQ0FBQyxDQUFDK0M7Z0JBQzFCQSxFQUFFb1csS0FBSyxFQUFFblk7Z0JBQ1QsSUFBSSxJQUFJLENBQUNtVyxFQUFFLENBQUM4RCxjQUFjLEtBQUssVUFBVTtvQkFDckMsSUFBSSxDQUFDOUQsRUFBRSxDQUFDK0QsV0FBVyxDQUFDblk7Z0JBQ3hCO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ29ZLHlCQUF5QixHQUFHLE9BQU9DO1lBQ3BDcEUsU0FBUyxRQUFRLG9EQUFvRG9FO1lBQ3JFLE1BQU1DLGNBQWMsSUFBSSxDQUFDekQsbUJBQW1CLENBQUM5ckIsVUFBVXNhLEtBQUssQ0FBQyxFQUFFbVQ7WUFDL0QsSUFBSSxDQUFDOEIsYUFBYTtnQkFDZHJFLFNBQVMsUUFBUTtnQkFDakI7WUFDSjtZQUNBLE1BQU1zRSxTQUFTRCxZQUFZRSxhQUFhO1lBQ3hDLElBQUlELE9BQU9FLFNBQVMsQ0FBQ2gxQixNQUFNLEtBQUssR0FBRztnQkFDL0J3d0IsU0FBUyxRQUFRO2dCQUNqQjtZQUNKO1lBQ0EsSUFBSXlFLFVBQVU7WUFDZCxJQUFJQyxjQUFjTixjQUNiaDdCLE1BQU0sQ0FBQyxDQUFDdTdCLEtBQU9BLEdBQUd6Z0IsTUFBTSxFQUN4QjNiLEdBQUcsQ0FBQyxDQUFDbzhCLEtBQU9BLEdBQUc5MkIsSUFBSTtZQUN4QnkyQixPQUFPRSxTQUFTLENBQUN4YixPQUFPLENBQUMsQ0FBQzRiO2dCQUN0Qix5Q0FBeUM7Z0JBQ3pDLE1BQU1DLGVBQWVILFlBQVlwYixRQUFRLENBQUNzYixJQUFJcHRCLEdBQUc7Z0JBQ2pELElBQUlxdEIsaUJBQWlCRCxJQUFJMWdCLE1BQU0sRUFBRTtvQkFDN0IwZ0IsSUFBSTFnQixNQUFNLEdBQUcyZ0I7b0JBQ2JKLFVBQVU7Z0JBQ2Q7Z0JBQ0EsSUFBSUksY0FBYztvQkFDZCxJQUFJalcsUUFBUXdWLGNBQWN4eUIsSUFBSSxDQUFDLENBQUNrekIsTUFBUUEsSUFBSWozQixJQUFJLEtBQUsrMkIsSUFBSXB0QixHQUFHO29CQUM1RCxJQUFJb1gsVUFBVXZmLFdBQVc7d0JBQ3JCLElBQUl1ZixNQUFNeEsscUJBQXFCLElBQUksS0FDL0J3SyxNQUFNeEsscUJBQXFCLEtBQUt3Z0IsSUFBSXhnQixxQkFBcUIsRUFBRTs0QkFDM0Q0YixTQUFTLFNBQVMsMERBQTBELFNBQVNwUixNQUFNL2dCLElBQUksRUFBRSw0QkFBNEIrZ0IsTUFBTXhLLHFCQUFxQjs0QkFDeEp3Z0IsSUFBSXhnQixxQkFBcUIsR0FBR3dLLE1BQU14SyxxQkFBcUI7NEJBQ3ZEcWdCLFVBQVU7d0JBQ2Q7d0JBQ0EsSUFBSTdWLE1BQU16SyxVQUFVLEdBQUcsS0FBS3lLLE1BQU16SyxVQUFVLEtBQUt5Z0IsSUFBSXpnQixVQUFVLEVBQUU7NEJBQzdENmIsU0FBUyxTQUFTLG1EQUFtRCxTQUFTcFIsTUFBTS9nQixJQUFJLEVBQUUsZUFBZStnQixNQUFNekssVUFBVTs0QkFDekh5Z0IsSUFBSXpnQixVQUFVLEdBQUd5SyxNQUFNekssVUFBVTs0QkFDakNzZ0IsVUFBVTt3QkFDZDt3QkFDQSxJQUFJN1YsTUFBTXRLLFlBQVksR0FBRyxLQUNyQnNLLE1BQU10SyxZQUFZLEtBQUtzZ0IsSUFBSXRnQixZQUFZLEVBQUU7NEJBQ3pDMGIsU0FBUyxTQUFTLGlEQUFpRCxTQUFTcFIsTUFBTS9nQixJQUFJLEVBQUUsaUJBQWlCK2dCLE1BQU10SyxZQUFZOzRCQUMzSHNnQixJQUFJdGdCLFlBQVksR0FBR3NLLE1BQU10SyxZQUFZOzRCQUNyQ21nQixVQUFVO3dCQUNkO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxNQUFNTSxlQUFlVCxPQUFPRSxTQUFTLENBQUNwN0IsTUFBTSxDQUFDLENBQUN1TixJQUFNQSxFQUFFdU4sTUFBTTtZQUM1RCxJQUFJdWdCLFNBQVM7Z0JBQ1QsTUFBTUosWUFBWVcsYUFBYSxDQUFDVjtnQkFDaEN0RSxTQUFTLFFBQVEsQ0FBQyxzQ0FBc0MsQ0FBQyxFQUFFK0U7WUFDL0QsT0FDSztnQkFDRC9FLFNBQVMsUUFBUSxDQUFDLG1DQUFtQyxDQUFDLEVBQUUrRTtZQUM1RDtRQUNKO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0UsUUFBUSxHQUFHLENBQUNDO1lBQ2IsT0FBTyxJQUFJLENBQUMvRSxFQUFFLENBQUM4RSxRQUFRLENBQUNDO1FBQzVCO1FBQ0EsSUFBSSxDQUFDbEMsbUJBQW1CLEdBQUcsQ0FBQ3BxQixXQUFXMFA7WUFDbkMsSUFBSTFQLGNBQWM5RCxVQUFVc2EsS0FBSyxFQUFFO2dCQUMvQixPQUFPL0csbUJBQW1CLFNBQVNDLGtCQUFrQjtZQUN6RDtZQUNBLElBQUkxUCxjQUFjOUQsVUFBVXVhLEtBQUssRUFBRTtnQkFDL0IsTUFBTThWLG9CQUFvQixJQUFJLENBQUN6RSxZQUFZLEdBQUcsUUFBUTtnQkFDdEQsTUFBTW5ZLGdCQUFnQixDQUFDLElBQUksQ0FBQ21ZLFlBQVksR0FBRyxRQUFRcnhCO2dCQUNuRCxPQUFPZ1osbUJBQW1CLFNBQVNDLGtCQUFrQjZjLG1CQUFtQjVjO1lBQzVFO1FBQ0o7UUFDQSxJQUFJLENBQUM4WSxjQUFjLEdBQUcsT0FBTzFxQjtZQUN6QixNQUFNLEVBQUU4VSxTQUFTLEVBQUUsR0FBRzlVO1lBQ3RCLElBQUksQ0FBQzhVLFdBQVc7Z0JBQ1p1VSxTQUFTLFNBQVM7Z0JBQ2xCO1lBQ0o7WUFDQSxNQUFNLElBQUksQ0FBQ08sU0FBUyxDQUFDM2dCLFVBQVUsQ0FBQztnQkFDNUJwSCxjQUFjZ1QsZ0JBQWdCQztnQkFDOUJsVCxVQUFVNUQsU0FBUzRXLHFCQUFxQjtZQUM1QztRQUNKO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQzZaLFlBQVksR0FBRyxDQUFDN0U7WUFDakIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO1FBQ3JCO1FBQ0E7Ozs7Ozs7U0FPQyxHQUNELElBQUksQ0FBQzhFLFNBQVMsR0FBRyxPQUFPOUUsV0FBV0Q7WUFDL0IsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1lBQ2pCLElBQUksQ0FBQ0osRUFBRSxDQUFDbUYsZ0JBQWdCLENBQUNoRjtZQUN6QixJQUFJLENBQUNELHdCQUF3QixHQUFHQztZQUNoQyxNQUFNaUYsbUJBQW1CLElBQUksQ0FBQ3BGLEVBQUUsQ0FBQ3FGLGtCQUFrQixLQUFLO1lBQ3hELElBQUlELGtCQUFrQjtnQkFDbEIsZ0RBQWdEO2dCQUNoRCxNQUFNLElBQUksQ0FBQ0UsU0FBUyxDQUFDO29CQUFFMW5CLFlBQVk7Z0JBQUs7WUFDNUM7UUFDSjtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDMm5CLFVBQVUsR0FBRztZQUNkMUYsU0FBUyxTQUFTO1lBQ2xCLE1BQU1pRSxpQkFBaUIsSUFBSSxDQUFDOUQsRUFBRSxDQUFDOEQsY0FBYztZQUM3QyxJQUFJLElBQUksQ0FBQy9DLGVBQWUsSUFBSStDLG1CQUFtQixvQkFBb0I7Z0JBQy9EakUsU0FBUyxTQUFTO2dCQUNsQjtZQUNKO1lBQ0EsTUFBTSxJQUFJLENBQUN5RixTQUFTLENBQUM7Z0JBQUUxbkIsWUFBWTtZQUFLO1FBQzVDO1FBQ0EsSUFBSSxDQUFDdWpCLG1CQUFtQixHQUFHO1lBQ3ZCLE1BQU0sSUFBSSxDQUFDbUUsU0FBUztRQUN4QjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNBLFNBQVMsR0FBRyxPQUFPcDNCO1lBQ3BCLElBQUksQ0FBQzZ5QixlQUFlLEdBQUc3eUIsU0FBUzBQLGNBQWM7WUFDOUMsTUFBTTZMLFFBQVEsTUFBTSxJQUFJLENBQUN1VyxFQUFFLENBQUN0VyxXQUFXLENBQUN4YjtZQUN4QyxJQUFJaVAsTUFBTSxJQUFJLENBQUNxb0IsV0FBVyxDQUFDL2IsTUFBTXRNLEdBQUc7WUFDcEMsSUFBSUEsT0FBTyxJQUFJLENBQUNvbUIsWUFBWSxDQUFDNXVCLFVBQVVxYSxrQkFBa0IsR0FBRztnQkFDeEQsTUFBTW1ULGNBQWMsSUFBSSxDQUFDMUIsbUJBQW1CLENBQUM5ckIsVUFBVXFhLGtCQUFrQixDQUFDO2dCQUMxRSxJQUFJbVQsZUFBZUEsWUFBWUMsTUFBTSxDQUFDSixLQUFLLEVBQUU7b0JBQ3pDLE1BQU1ycEIsTUFBTXdwQixZQUFZeHBCLEdBQUcsSUFDdkIsSUFBSSxDQUFDOHNCLFVBQVUsQ0FBQ3RvQixLQUFLZ2xCLFlBQVlDLE1BQU0sQ0FBQ0osS0FBSyxFQUFFcnRCLFVBQVVxYSxrQkFBa0I7b0JBQy9FN1IsTUFBTWlpQix1QkFBdUJqaUIsS0FBS3hFO2dCQUN0QztZQUNKO1lBQ0EsdUNBQXVDO1lBQ3ZDOFEsTUFBTXRNLEdBQUcsR0FBR0E7WUFDWixNQUFNdW9CLGFBQWEsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ2xjLE1BQU10TSxHQUFHO1lBQ3RELElBQUl1b0IsV0FBV3IyQixNQUFNLEtBQUssR0FBRztnQkFDekIsTUFBTSxJQUFJaEMsTUFBTSxDQUFDLHdEQUF3RCxDQUFDO1lBQzlFO1lBQ0EsTUFBTSxJQUFJLENBQUMyeUIsRUFBRSxDQUFDNEYsbUJBQW1CLENBQUNuYztZQUNsQyxNQUFNLEVBQUVvYyxRQUFRLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ3pGLFNBQVMsQ0FBQ2hiLFlBQVksQ0FBQztnQkFDbkRqSSxLQUFLc00sTUFBTXRNLEdBQUcsSUFBSTtnQkFDbEJQLFFBQVE4b0I7WUFDWjtZQUNBLElBQUk7Z0JBQ0EsTUFBTSxJQUFJLENBQUMxRixFQUFFLENBQUM4RixvQkFBb0IsQ0FBQztvQkFDL0I3c0IsTUFBTTtvQkFDTmtFLEtBQUswb0IsU0FBUzFvQixHQUFHO2dCQUNyQjtZQUNKLEVBQ0EsT0FBTzNHLEdBQUc7Z0JBQ05xcEIsU0FBUyxTQUFTLENBQUMsMEJBQTBCLENBQUMsRUFBRTtvQkFDNUMxaUIsS0FBSzBvQixTQUFTMW9CLEdBQUc7b0JBQ2pCckIsT0FBT3RGO2dCQUNYO1lBQ0o7WUFDQSxJQUFJLENBQUN1cUIsZUFBZSxHQUFHO1lBQ3ZCLElBQUksQ0FBQ1gsU0FBUyxDQUFDMkYsZ0JBQWdCLENBQUM3YSxtQkFBbUIsQ0FBQzJFLFNBQVMsQ0FBQyxPQUFPdkU7Z0JBQ2pFLElBQUk7b0JBQ0EsTUFBTWpULGVBQWV3VCxLQUFLalksS0FBSyxDQUFDMFgsVUFBVWpULFlBQVk7b0JBQ3RELE1BQU0sSUFBSSxDQUFDMm5CLEVBQUUsQ0FBQ2dHLGVBQWUsQ0FBQzN0QjtnQkFDbEMsRUFDQSxPQUFPN0IsR0FBRztvQkFDTnFwQixTQUFTLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO3dCQUFDcnBCO3dCQUFHOFU7cUJBQVU7Z0JBQzFEO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ2thLFdBQVcsR0FBRyxDQUFDcm9CO1lBQ2hCLElBQUlBLEtBQUs7Z0JBQ0xBLE1BQU0yaEIsVUFBVTNoQixLQUFLLElBQUksQ0FBQ21qQixZQUFZO1lBQzFDO1lBQ0EsT0FBT25qQjtRQUNYO1FBQ0EsSUFBSSxDQUFDc29CLFVBQVUsR0FBRyxDQUFDdG9CLEtBQUs2a0IsT0FBT3ZwQjtZQUMzQixJQUFJLENBQUMwRSxLQUFLO2dCQUNOMGlCLFNBQVMsUUFBUTtnQkFDakIsT0FBTztZQUNYO1lBQ0FBLFNBQVMsU0FBUyxDQUFDLDhEQUE4RCxDQUFDO1lBQ2xGLE1BQU1OLFlBQVluMkIsZ0RBQVMsQ0FBQytUO1lBQzVCLE1BQU1naEIsUUFBUW9CLFVBQVVwQixLQUFLLENBQUMxc0IsSUFBSSxDQUFDLENBQUMwbEI7Z0JBQ2hDLE9BQVFBLEVBQUVsZSxJQUFJLEtBQUsrb0IsTUFBTXIwQixJQUFJLElBQ3pCLHNFQUFzRTtnQkFDckV3cEIsQ0FBQUEsRUFBRThPLElBQUksRUFBRTljLFNBQVM2WSxNQUFNOW9CLEVBQUUsS0FBSyxJQUFHO1lBQzFDO1lBQ0EsSUFBSSxPQUFPaWxCLE9BQU94bEIsUUFBUSxhQUFhO2dCQUNuQ2tuQixTQUFTLFNBQVMsQ0FBQyxtQ0FBbUMsRUFBRW1DLE1BQU1yMEIsSUFBSSxDQUFDLFFBQVEsRUFBRXEwQixNQUFNOW9CLEVBQUUsQ0FBQyxvQ0FBb0MsQ0FBQztnQkFDM0gsTUFBTWd0QixlQUFlLElBQUksQ0FBQ3RGLG9CQUFvQixDQUFDeEosT0FBTyxDQUFDM2U7Z0JBQ3ZELElBQUl5dEIsaUJBQWlCLENBQUMsR0FBRztvQkFDckIsT0FBT3pHLE9BQU95RztnQkFDbEI7Z0JBQ0FyRyxTQUFTLFNBQVM7Z0JBQ2xCLE9BQU87WUFDWDtZQUNBLE9BQU9KLE9BQU90QixNQUFNeGxCLEdBQUc7UUFDM0I7UUFDQSxJQUFJLENBQUNndEIsb0JBQW9CLEdBQUcsQ0FBQ3hvQjtZQUN6QkEsTUFBTUEsT0FBTyxJQUFJLENBQUM2aUIsRUFBRSxDQUFDbUcsZ0JBQWdCLEVBQUVocEI7WUFDdkMsTUFBTSxFQUFFa1EsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDd0gsS0FBSztZQUMvQixNQUFNMUgsbUJBQW1CRSxVQUFVa1YsTUFBTUM7WUFDekMsT0FBTyxJQUFJLENBQUN4QyxFQUFFLENBQ1RyVyxlQUFlLEdBQ2YxZ0IsTUFBTSxDQUFDLENBQUMyZ0IsSUFBTUEsRUFBRVAsU0FBUyxLQUFLLGNBQWNPLEVBQUV3WSxNQUFNLENBQUNKLEtBQUssRUFDMUQ1NUIsR0FBRyxDQUFDLENBQUMrNUI7Z0JBQ04sTUFBTTFwQixZQUFZcEgsT0FBTy9DLE9BQU9rQyxJQUFJLENBQUMsSUFBSSxDQUFDaXdCLG1CQUFtQixFQUFFaHZCLElBQUksQ0FBQyxDQUFDdEIsTUFBUSxJQUFJLENBQUNzd0IsbUJBQW1CLENBQUN0d0IsSUFBSSxLQUFLZ3lCO2dCQUMvRyxNQUFNSCxRQUFRRyxZQUFZQyxNQUFNLENBQUNKLEtBQUs7Z0JBQ3RDLElBQUlvRTtnQkFDSixJQUFJcEUsTUFBTUUsVUFBVSxLQUFLLFFBQVE7b0JBQzdCLE1BQU1tRSxjQUFjLElBQUksQ0FBQzNGLDBCQUEwQixDQUFDNEYsR0FBRyxDQUFDN3RCO29CQUN4RDJ0QixnQkFDSTN0QixjQUFjOUQsVUFBVXNhLEtBQUssR0FDdkJoQyx1QkFBdUIrVSxPQUFPN1Usb0JBQzlCMVUsY0FBYzlELFVBQVVvYSxZQUFZLEdBQ2hDSCwrQkFBK0JvVCxPQUFPcUUsYUFBYTNELHVCQUNuRCxFQUFFO29CQUNoQixJQUFJLENBQUM1QixnQkFBZ0IsQ0FBQ3JvQixVQUFVLEdBQUcydEI7Z0JBQ3ZDLE9BQ0s7b0JBQ0QsMkRBQTJEO29CQUMzREEsZ0JBQWdCLElBQUksQ0FBQ3RGLGdCQUFnQixDQUFDcm9CLFVBQVUsSUFBSSxFQUFFO29CQUN0RG9uQixTQUFTLFNBQVMsQ0FBQyxNQUFNLEVBQUVsckIsU0FBUyxDQUFDOEQsVUFBVSxDQUFDLCtDQUErQyxDQUFDLEVBQUUydEI7Z0JBQ3RHO2dCQUNBLE1BQU0xdEIsU0FBUzB0QixjQUFjaCtCLEdBQUcsQ0FBQyxDQUFDbStCLGVBQWtCO3dCQUNoRGx2QixLQUFLa3ZCLGFBQWFsdkIsR0FBRyxJQUFJO3dCQUN6QkMsU0FBU2l2QixhQUFhdmlCLFVBQVUsSUFBSTt3QkFDcEN6TSxLQUFLZ3ZCLGFBQWFwaUIsWUFBWSxJQUFJO3dCQUNsQzNNLFNBQVMsSUFBSSxDQUFDZ3ZCLGlCQUFpQixDQUFDRCxhQUFhbHZCLEdBQUcsSUFBSTt3QkFDcERJLGdCQUFnQjs0QkFDWlIsT0FBT3N2QixhQUFhdHZCLEtBQUs7NEJBQ3pCQyxRQUFRcXZCLGFBQWFydkIsTUFBTTt3QkFDL0I7b0JBQ0o7Z0JBQ0EsTUFBTXV2QixlQUFlO29CQUNqQjl4QixVQUFVdWEsS0FBSztvQkFDZnZhLFVBQVVxYSxrQkFBa0I7aUJBQy9CLENBQUM3RixRQUFRLENBQUMxUTtnQkFDWCxNQUFNaXVCLGdCQUFnQjFFLE1BQU0xVSxXQUFXO2dCQUN2QyxNQUFNcVosV0FBV0YsZ0JBQWdCQyxjQUFjdmpCLFlBQVksS0FBSztnQkFDaEUsT0FBTztvQkFDSDNLLFNBQVN3cEIsTUFBTTlvQixFQUFFO29CQUNqQlIsUUFBUUE7b0JBQ1JEO29CQUNBRSxLQUFLd3BCLFlBQVl4cEIsR0FBRyxJQUFJLElBQUksQ0FBQzhzQixVQUFVLENBQUN0b0IsS0FBSzZrQixPQUFPdnBCO29CQUNwREksUUFBUTh0QjtvQkFDUi90QixLQUFLNnRCLGdCQUFnQixJQUFJLENBQUNuRyxZQUFZO29CQUN0Q3huQixLQUFLMnRCLGdCQUFnQixJQUFJLENBQUNsRyxZQUFZO2dCQUMxQztZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNhLG1CQUFtQixHQUFHLENBQUM1cUI7WUFDeEIsTUFBTW93QixlQUFlcHdCLGFBQWFxd0Isa0NBQzlCLENBQUMsRUFBRXJ3QixFQUFFc3dCLFNBQVMsQ0FBQyxFQUFFLEVBQUV0d0IsRUFBRXV3QixTQUFTLENBQUMsQ0FBQztZQUNwQyxNQUFNM2YsV0FBVyxJQUFJLENBQUM0WSxFQUFFLENBQUNxRixrQkFBa0IsS0FBSyxjQUFjLFVBQVU7WUFDeEV4RixTQUFTelksVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUV3ZjtRQUM5QztRQUNBLElBQUksQ0FBQ3ZGLDBCQUEwQixHQUFHO1lBQzlCLE1BQU14TSxRQUFRLElBQUksQ0FBQ21MLEVBQUUsQ0FBQ3FGLGtCQUFrQjtZQUN4Q3hGLFNBQVMsU0FBUyxDQUFDLCtCQUErQixDQUFDLEVBQUVoTDtZQUNyRCxNQUFNbVMsdUJBQXVCLElBQUksQ0FBQ25TLEtBQUssQ0FBQzJHLFlBQVksS0FBSzdJLGFBQWFzVSxPQUFPO1lBQzdFLElBQUlwUyxVQUFVLFVBQVU7Z0JBQ3BCZ0wsU0FBUyxRQUFRLENBQUMseUJBQXlCLENBQUM7Z0JBQzVDLElBQUksQ0FBQzBGLFVBQVUsR0FBRzNJLEtBQUssQ0FBQyxDQUFDcG1CO29CQUNyQnFwQixTQUFTLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFcnBCO2dCQUMzQztZQUNKLE9BQ0ssSUFBSXFlLFVBQVUsa0JBQWtCbVMsc0JBQXNCO2dCQUN2RCx1RUFBdUU7Z0JBQ3ZFLGtDQUFrQztnQkFDbENuSCxTQUFTLFFBQVEsQ0FBQywwQkFBMEIsRUFBRSxJQUFJLENBQUNXLGVBQWUsQ0FBQyxJQUFJLENBQUM7Z0JBQ3hFLElBQUksQ0FBQ21CLGlCQUFpQixHQUFHdUYsV0FBVztvQkFDaEMseURBQXlEO29CQUN6RCxtRUFBbUU7b0JBQ25FLElBQUksSUFBSSxDQUFDbEgsRUFBRSxDQUFDcUYsa0JBQWtCLEtBQUssa0JBQy9CLElBQUksQ0FBQ3JGLEVBQUUsQ0FBQ3FGLGtCQUFrQixLQUFLLFVBQVU7d0JBQ3pDLElBQUksQ0FBQ0UsVUFBVSxHQUFHM0ksS0FBSyxDQUFDLENBQUNwbUI7NEJBQ3JCcXBCLFNBQVMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLEVBQUVycEI7d0JBQzNDO29CQUNKLE9BQ0s7d0JBQ0RxcEIsU0FBUyxTQUFTLENBQUMsc0RBQXNELENBQUM7b0JBQzlFO2dCQUNKLEdBQUcsSUFBSSxDQUFDVyxlQUFlO1lBQzNCO1FBQ0o7UUFDQSxJQUFJLENBQUNjLHlCQUF5QixHQUFHO1lBQzdCekIsU0FBUyxTQUFTLENBQUMsbUJBQW1CLENBQUMsRUFBRSxJQUFJLENBQUNHLEVBQUUsQ0FBQ21ILGlCQUFpQjtRQUN0RTtRQUNBLElBQUksQ0FBQzVGLHNCQUFzQixHQUFHO1lBQzFCMUIsU0FBUyxTQUFTLENBQUMsdUJBQXVCLENBQUMsRUFBRSxJQUFJLENBQUNHLEVBQUUsQ0FBQzhELGNBQWM7UUFDdkU7UUFDQSxJQUFJLENBQUMwQyxpQkFBaUIsR0FBRyxDQUFDbnZCO1lBQ3RCLE9BQU9BLFFBQVEsTUFDVDNDLGFBQWEweUIsZUFBZSxHQUM1Qi92QixRQUFRLE1BQ0ozQyxhQUFhMnlCLEdBQUcsR0FDaEIzeUIsYUFBYTR5QixJQUFJLEVBQUUsa0JBQWtCO1FBQ25EO1FBQ0EsSUFBSSxDQUFDdEgsRUFBRSxHQUFHLElBQUksQ0FBQ2dCLG9CQUFvQixDQUFDYjtRQUNwQyxJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDdkwsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3lMLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0MsZUFBZSxHQUFHQTtRQUN2QixJQUFJLENBQUNvQix1QkFBdUIsR0FBR3ZCLFdBQVd6VixFQUFFLENBQUMsY0FBYyxPQUFPaE47WUFDOUQsSUFBSUEsV0FBV3hGLFFBQVEsS0FBSzVELFNBQVM0VyxxQkFBcUIsRUFDdEQ7WUFDSixNQUFNLElBQUksQ0FBQ21hLFVBQVU7UUFDekI7SUFDSjtBQUNKO0FBRUEsTUFBTWdDLFdBQVcxZixVQUFVO0lBQUM7Q0FBYTtBQUN6Qzs7O0NBR0MsR0FDRCxNQUFNMmY7SUFDRjs7OztLQUlDLEdBQ0QsSUFBSXpILDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ0MsRUFBRSxDQUFDQyxnQkFBZ0IsRUFDeEIsT0FBTyxJQUFJLENBQUNELEVBQUUsQ0FBQ0MsZ0JBQWdCO1FBQ25DLE9BQU8sSUFBSSxDQUFDQyx3QkFBd0I7SUFDeEM7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNEMXlCLFlBQVksRUFBRTR5QixTQUFTLEVBQUVDLFVBQVUsRUFBRXhMLEtBQUssRUFBRXNMLGdCQUFnQixFQUFFSyxrQkFBa0IsSUFBSSxFQUFHLENBQUU7UUFDckYsSUFBSSxDQUFDTyxlQUFlLEdBQUc7UUFDdkI7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsQ0FBQ2I7WUFDekIsTUFBTUgsS0FBSyxJQUFJelcsa0JBQWtCNFc7WUFDakMsSUFBSSxDQUFDRCx3QkFBd0IsR0FBR0M7WUFDaENILEdBQUdpQixnQkFBZ0IsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDQyxjQUFjO1lBQ3ZEbEIsR0FBR2lCLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDd0csYUFBYTtZQUMvQ3pILEdBQUdpQixnQkFBZ0IsQ0FBQyxxQkFBcUIsSUFBSSxDQUFDRyxtQkFBbUI7WUFDakVwQixHQUFHaUIsZ0JBQWdCLENBQUMsNEJBQTRCLElBQUksQ0FBQ0ksMEJBQTBCO1lBQy9FckIsR0FBR2lCLGdCQUFnQixDQUFDLDJCQUEyQixJQUFJLENBQUNLLHlCQUF5QjtZQUM3RSxPQUFPdEI7UUFDWDtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDbFcsS0FBSyxHQUFHO1lBQ1Q0WCxhQUFhLElBQUksQ0FBQ0MsaUJBQWlCO1lBQ25DLElBQUksQ0FBQytGLDJCQUEyQjtZQUNoQyxJQUFJLENBQUNDLHNCQUFzQjtZQUMzQixJQUFJLENBQUMzSCxFQUFFLENBQUNsVyxLQUFLO1FBQ2pCO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ2diLFFBQVEsR0FBRyxDQUFDQztZQUNiLE9BQU8sSUFBSSxDQUFDL0UsRUFBRSxDQUFDOEUsUUFBUSxDQUFDQztRQUM1QjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNFLFlBQVksR0FBRyxDQUFDN0U7WUFDakIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO1FBQ3JCO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUM4RSxTQUFTLEdBQUcsQ0FBQzlFLFdBQVdEO1lBQ3pCLElBQUksQ0FBQzhFLFlBQVksQ0FBQzdFO1lBQ2xCLCtEQUErRDtZQUMvRCxpQ0FBaUM7WUFDakMsTUFBTXdILGFBQWEsSUFBSSxDQUFDNUgsRUFBRTtZQUMxQix3REFBd0Q7WUFDeEQsK0RBQStEO1lBQy9ELHlDQUF5QztZQUN6QyxNQUFNNkgsb0JBQW9CLElBQUlDO1lBQzlCRixXQUFXRyxZQUFZLEdBQUdsZixPQUFPLENBQUMsQ0FBQ29KO2dCQUMvQixJQUFJQSxFQUFFK1AsS0FBSyxDQUFDcjBCLElBQUksS0FBSyxTQUFTO29CQUMxQms2QixrQkFBa0JHLEdBQUcsQ0FBQy9WLEVBQUUrUCxLQUFLLENBQUM5b0IsRUFBRTtnQkFDcEM7WUFDSjtZQUNBLGlFQUFpRTtZQUNqRSxzQkFBc0I7WUFDdEIsTUFBTThtQixLQUFLLElBQUksQ0FBQ2dCLG9CQUFvQixDQUFDYjtZQUNyQyxJQUFJOEg7WUFDSixNQUFNQyxtQkFBbUI7Z0JBQ3JCTixXQUFXOWQsS0FBSztnQkFDaEI0WCxhQUFhdUc7WUFDakI7WUFDQSw0REFBNEQ7WUFDNUQsNENBQTRDO1lBQzVDLHdFQUF3RTtZQUN4RSxNQUFNRSx1QkFBdUIsQ0FBQzN4QjtnQkFDMUIrd0IsU0FBUyxTQUFTLENBQUMsNkJBQTZCLEVBQUUvd0IsRUFBRXdyQixLQUFLLENBQUM5b0IsRUFBRSxDQUFDLEVBQUUsRUFBRTFDLEVBQUV3ckIsS0FBSyxDQUFDcjBCLElBQUksQ0FBQyxDQUFDO2dCQUMvRWs2QixrQkFBa0JPLE1BQU0sQ0FBQzV4QixFQUFFd3JCLEtBQUssQ0FBQzlvQixFQUFFO2dCQUNuQyxJQUFJMnVCLGtCQUFrQnRaLElBQUksS0FBSyxHQUFHO29CQUM5QmdaLFNBQVMsU0FBUyxDQUFDLCtCQUErQixDQUFDO29CQUNuRHZILEdBQUc2QixtQkFBbUIsQ0FBQyxTQUFTc0c7b0JBQ2hDRDtnQkFDSjtZQUNKO1lBQ0EsZ0VBQWdFO1lBQ2hFLHlCQUF5QjtZQUN6QixzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLG1FQUFtRTtZQUNuRSxNQUFNRyw4QkFBOEI7Z0JBQ2hDLElBQUlySSxHQUFHc0ksZUFBZSxLQUFLLGFBQWE7b0JBQ3BDTCxxQkFBcUJmLFdBQVc7d0JBQzVCbEgsR0FBRzZCLG1CQUFtQixDQUFDLFNBQVNzRzt3QkFDaENEO29CQUNKLEdBQUc7b0JBQ0hsSSxHQUFHNkIsbUJBQW1CLENBQUMseUJBQXlCd0c7Z0JBQ3BEO1lBQ0o7WUFDQXJJLEdBQUdpQixnQkFBZ0IsQ0FBQyxTQUFTa0g7WUFDN0JuSSxHQUFHaUIsZ0JBQWdCLENBQUMseUJBQXlCb0g7WUFDN0Msc0NBQXNDO1lBQ3RDLElBQUksQ0FBQ3JJLEVBQUUsR0FBR0E7UUFDZDtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDdUYsVUFBVSxHQUFHO1lBQ2RnQyxTQUFTLFNBQVM7WUFDbEIsSUFBSSxJQUFJLENBQUN2SCxFQUFFLENBQUM4RCxjQUFjLEtBQUsscUJBQXFCO2dCQUNoRHlELFNBQVMsU0FBUztnQkFDbEI7WUFDSjtZQUNBLE1BQU1nQiwwQkFBMEIsSUFBSSxDQUFDeEgsZUFBZTtZQUNwRCxJQUFJO2dCQUNBLElBQUksQ0FBQ0EsZUFBZSxHQUFHO2dCQUN2QixNQUFNLElBQUksQ0FBQ1gsU0FBUyxDQUFDeGlCLFVBQVUsQ0FBQztvQkFDNUJ4RixVQUFVNUQsU0FBUzJXLFVBQVU7Z0JBQ2pDO1lBQ0osRUFDQSxPQUFPM1UsR0FBRztnQkFDTixzRUFBc0U7Z0JBQ3RFLElBQUksQ0FBQ3VxQixlQUFlLEdBQUd3SDtnQkFDdkIsTUFBTS94QjtZQUNWO1FBQ0o7UUFDQSxJQUFJLENBQUNpeEIsYUFBYSxHQUFHLENBQUNqeEI7WUFDbEIsTUFBTSxDQUFDZ3lCLGNBQWMsR0FBR2h5QixFQUFFdXNCLE9BQU87WUFDakMsbUVBQW1FO1lBQ25FLE1BQU0sQ0FBQ3ZxQixTQUFTQyxVQUFVLEdBQUcrdkIsY0FBY3R2QixFQUFFLENBQUN1UyxLQUFLLENBQUM7WUFDcEQsTUFBTWdkLHNCQUFzQixJQUFJLENBQUM1VCxLQUFLLENBQUN6ZixZQUFZLENBQUMzRCxJQUFJLENBQUMsQ0FBQ3NnQixJQUFNQSxFQUFFOWIsaUJBQWlCLEtBQUt1QztZQUN4Rit1QixTQUFTLFNBQVMsQ0FBQyxzQkFBc0IsRUFBRTl1QixVQUFVLG1CQUFtQixFQUFFZ3dCLHFCQUFxQjV5QixPQUFPLENBQUMsRUFBRVcsRUFBRXdyQixLQUFLLENBQUM5b0IsRUFBRSxFQUFFMUMsRUFBRXdyQixLQUFLO1lBQzVILElBQUksQ0FBQ3lHLHFCQUFxQjtnQkFDdEJsQixTQUFTLFNBQVMsQ0FBQyxtREFBbUQsRUFBRS91QixRQUFRLENBQUMsRUFBRWhDO2dCQUNuRjtZQUNKO1lBQ0FBLEVBQUV3ckIsS0FBSyxDQUFDZixnQkFBZ0IsQ0FBQyxRQUFRO2dCQUM3QnNHLFNBQVMsUUFBUSxDQUFDLHdCQUF3QixFQUFFa0Isb0JBQW9CNXlCLE1BQU0sQ0FBQyxDQUFDLEVBQUU0QyxVQUFVLENBQUMsRUFBRUQsUUFBUSxDQUFDO1lBQ3BHO1lBQ0FoQyxFQUFFd3JCLEtBQUssQ0FBQ2YsZ0JBQWdCLENBQUMsVUFBVTtnQkFDL0JzRyxTQUFTLFFBQVEsQ0FBQywwQkFBMEIsRUFBRWtCLG9CQUFvQjV5QixNQUFNLENBQUMsQ0FBQyxFQUFFNEMsVUFBVSxDQUFDLEVBQUVELFFBQVEsQ0FBQztZQUN0RztZQUNBaEMsRUFBRXdyQixLQUFLLENBQUNmLGdCQUFnQixDQUFDLFNBQVM7Z0JBQzlCc0csU0FBUyxRQUFRLENBQUMsd0JBQXdCLEVBQUVrQixvQkFBb0I1eUIsTUFBTSxDQUFDLENBQUMsRUFBRTRDLFVBQVUsQ0FBQyxFQUFFRCxRQUFRLENBQUM7WUFDcEc7WUFDQSxNQUFNa3dCLGlCQUFpQjtnQkFDbkJDLGtCQUFrQjtnQkFDbEJDLGtCQUFrQjtnQkFDbEJDLHlCQUF5QjtnQkFDekJDLCtCQUErQjtZQUNuQyxDQUFDLENBQUNyd0IsVUFBVTtZQUNaLElBQUksQ0FBQ2l3QixnQkFBZ0I7Z0JBQ2pCbkIsU0FBUyxTQUFTLENBQUMsb0JBQW9CLEVBQUU5dUIsVUFBVSxDQUFDO2dCQUNwRDtZQUNKO1lBQ0EsTUFBTXN3QixpQkFBaUJOLG1CQUFtQixDQUFDQyxlQUFlO1lBQzFELElBQUlLLGdCQUFnQjtnQkFDaEJ4QixTQUFTLFFBQVEsQ0FBQyx1Q0FBdUMsRUFBRS93QixFQUFFd3JCLEtBQUssQ0FBQ3IwQixJQUFJLENBQUMsb0JBQW9CLEVBQUU4NkIsb0JBQW9CNXlCLE1BQU0sQ0FBQyxDQUFDO2dCQUMxSGt6QixlQUFlQyxTQUFTLEdBQUduZ0IsT0FBTyxDQUFDLENBQUNlO29CQUNoQ0EsRUFBRUMsSUFBSTtvQkFDTmtmLGVBQWVoRixXQUFXLENBQUNuYTtnQkFDL0I7WUFDSjtZQUNBLElBQUksQ0FBQ2lMLEtBQUssQ0FBQ1csaUJBQWlCLENBQUNpVCxvQkFBb0IzeUIsU0FBUyxFQUFFO2dCQUN4RCxDQUFDNHlCLGVBQWUsRUFBRUY7WUFDdEI7UUFDSjtRQUNBLElBQUksQ0FBQ3RILGNBQWMsR0FBRyxPQUFPMXFCO1lBQ3pCLE1BQU0sRUFBRThVLFNBQVMsRUFBRSxHQUFHOVU7WUFDdEIsSUFBSSxDQUFDOFUsV0FBVztnQkFDWmljLFNBQVMsU0FBUztnQkFDbEI7WUFDSjtZQUNBLE1BQU0sSUFBSSxDQUFDbkgsU0FBUyxDQUFDM2dCLFVBQVUsQ0FBQztnQkFDNUJwSCxjQUFjZ1QsZ0JBQWdCQztnQkFDOUJsVCxVQUFVNUQsU0FBUzJXLFVBQVU7WUFDakM7UUFDSjtRQUNBLElBQUksQ0FBQ21hLFNBQVMsR0FBRyxPQUFPam1CO1lBQ3BCa29CLFNBQVMsUUFBUSxDQUFDLHdCQUF3QixDQUFDLEVBQUVsb0I7WUFDN0MsTUFBTSxJQUFJLENBQUMyZ0IsRUFBRSxDQUFDOEYsb0JBQW9CLENBQUM7Z0JBQy9CN3NCLE1BQU07Z0JBQ05rRSxLQUFLa0MsZ0JBQWdCbEMsR0FBRztZQUM1QjtZQUNBLElBQUksQ0FBQ2lqQixTQUFTLENBQUMyRixnQkFBZ0IsQ0FBQzlhLG9CQUFvQixDQUFDNEUsU0FBUyxDQUFDLE9BQU92RTtnQkFDbEUsSUFBSTtvQkFDQSxNQUFNalQsZUFBZXdULEtBQUtqWSxLQUFLLENBQUMwWCxVQUFValQsWUFBWTtvQkFDdEQsTUFBTSxJQUFJLENBQUMybkIsRUFBRSxDQUFDZ0csZUFBZSxDQUFDM3RCO2dCQUNsQyxFQUNBLE9BQU83QixHQUFHO29CQUNOK3dCLFNBQVMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7d0JBQUMvd0I7d0JBQUc4VTtxQkFBVTtnQkFDMUQ7WUFDSjtZQUNBLE1BQU0yZCxTQUFTLE1BQU0sSUFBSSxDQUFDakosRUFBRSxDQUFDa0osWUFBWTtZQUN6QyxNQUFNLElBQUksQ0FBQ2xKLEVBQUUsQ0FBQzRGLG1CQUFtQixDQUFDcUQ7WUFDbEMsTUFBTSxJQUFJLENBQUM3SSxTQUFTLENBQUMzYSxVQUFVLENBQUM7Z0JBQzVCck4sVUFBVTVELFNBQVMyVyxVQUFVO2dCQUM3QmhPLEtBQUs4ckIsT0FBTzlyQixHQUFHLElBQUk7WUFDdkI7WUFDQSxJQUFJLENBQUM0akIsZUFBZSxHQUFHO1FBQzNCO1FBQ0EsSUFBSSxDQUFDTSwwQkFBMEIsR0FBRztZQUM5QixNQUFNeE0sUUFBUSxJQUFJLENBQUNtTCxFQUFFLENBQUNxRixrQkFBa0I7WUFDeENrQyxTQUFTLFNBQVMsQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFMVM7WUFDbEQsb0NBQW9DO1lBQ3BDLElBQUksSUFBSSxDQUFDa00sZUFBZSxFQUNwQjtZQUNKLE1BQU1pRyx1QkFBdUIsSUFBSSxDQUFDblMsS0FBSyxDQUFDMkcsWUFBWSxLQUFLN0ksYUFBYXNVLE9BQU87WUFDN0UsSUFBSXBTLFVBQVUsVUFBVTtnQkFDcEIwUyxTQUFTLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQztnQkFDNUMsSUFBSSxDQUFDaEMsVUFBVSxHQUFHM0ksS0FBSyxDQUFDLENBQUNwbUI7b0JBQ3JCK3dCLFNBQVMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLEVBQUUvd0I7Z0JBQzVDO1lBQ0osT0FDSyxJQUFJcWUsVUFBVSxrQkFBa0JtUyxzQkFBc0I7Z0JBQ3ZELHVFQUF1RTtnQkFDdkUsa0NBQWtDO2dCQUNsQ08sU0FBUyxRQUFRLENBQUMsMEJBQTBCLEVBQUUsSUFBSSxDQUFDL0csZUFBZSxDQUFDLElBQUksQ0FBQztnQkFDeEUsSUFBSSxDQUFDbUIsaUJBQWlCLEdBQUd1RixXQUFXO29CQUNoQyx5REFBeUQ7b0JBQ3pELG1FQUFtRTtvQkFDbkUsSUFBSSxJQUFJLENBQUNsSCxFQUFFLENBQUNxRixrQkFBa0IsS0FBSyxrQkFDL0IsSUFBSSxDQUFDckYsRUFBRSxDQUFDcUYsa0JBQWtCLEtBQUssVUFBVTt3QkFDekMsSUFBSSxDQUFDRSxVQUFVLEdBQUczSSxLQUFLLENBQUMsQ0FBQ3BtQjs0QkFDckIrd0IsU0FBUyxTQUFTLENBQUMsa0JBQWtCLENBQUMsRUFBRS93Qjt3QkFDNUM7b0JBQ0osT0FDSzt3QkFDRCt3QixTQUFTLFNBQVMsQ0FBQyxzREFBc0QsQ0FBQztvQkFDOUU7Z0JBQ0osR0FBRztZQUNQO1FBQ0o7UUFDQSxJQUFJLENBQUNqRyx5QkFBeUIsR0FBRztZQUM3QmlHLFNBQVMsU0FBUyxDQUFDLDJCQUEyQixDQUFDLEVBQUUsSUFBSSxDQUFDdkgsRUFBRSxDQUFDbUgsaUJBQWlCO1FBQzlFO1FBQ0EsSUFBSSxDQUFDL0YsbUJBQW1CLEdBQUcsQ0FBQzVxQjtZQUN4QixNQUFNb3dCLGVBQWVwd0IsYUFBYXF3QixrQ0FDOUIsQ0FBQyxFQUFFcndCLEVBQUVzd0IsU0FBUyxDQUFDLEVBQUUsRUFBRXR3QixFQUFFdXdCLFNBQVMsQ0FBQyxDQUFDO1lBQ3BDLE1BQU0zZixXQUFXLElBQUksQ0FBQzRZLEVBQUUsQ0FBQ3FGLGtCQUFrQixLQUFLLGNBQWMsVUFBVTtZQUN4RWtDLFNBQVNuZ0IsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUV3ZjtRQUM5QztRQUNBLElBQUksQ0FBQ3hHLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDdkwsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzJMLGVBQWUsR0FBR0E7UUFDdkIsSUFBSSxDQUFDUixFQUFFLEdBQUcsSUFBSSxDQUFDZ0Isb0JBQW9CLENBQUNiO1FBQ3BDLElBQUksQ0FBQ3VILDJCQUEyQixHQUFHckgsV0FBV3pWLEVBQUUsQ0FBQyxtQkFBbUIsT0FBT3ZMO1lBQ3ZFLE1BQU0sSUFBSSxDQUFDaW1CLFNBQVMsQ0FBQ2ptQjtRQUN6QjtRQUNBLElBQUksQ0FBQ3NvQixzQkFBc0IsR0FBR3RILFdBQVd6VixFQUFFLENBQUMsY0FBYyxPQUFPaE47WUFDN0QsSUFBSUEsV0FBV3hGLFFBQVEsS0FBSzVELFNBQVMyVyxVQUFVLEVBQzNDO1lBQ0osTUFBTSxJQUFJLENBQUNvYSxVQUFVO1FBQ3pCO0lBQ0o7QUFDSjtBQUVBLE1BQU00RCwrQkFBK0IsQ0FBQ2xIO0lBQ2xDLE1BQU01WixTQUFTUixVQUFVO1FBQUM7S0FBYTtJQUN2QyxNQUFNLEVBQUV1aEIsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR3BIO0lBQ2hDLE1BQU1xSCxLQUFLLElBQUloZ0Msc0RBQVNBLENBQUM4L0I7SUFDekJFLEdBQUdDLFVBQVUsR0FBRyxlQUFlLG1CQUFtQjtJQUNsREQsR0FBR3JJLGdCQUFnQixDQUFDLFNBQVMsQ0FBQ3pxQjtRQUMxQjZSLE9BQU8sU0FBUyw4QkFBOEI3UjtJQUNsRDtJQUNBOHlCLEdBQUdySSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUN6cUI7UUFDMUI2UixPQUFPLFFBQVEsa0NBQWtDN1I7SUFDckQ7SUFDQTh5QixHQUFHckksZ0JBQWdCLENBQUMsUUFBUSxDQUFDenFCO1FBQ3pCNlIsT0FBTyxRQUFRLGdDQUFnQzdSO0lBQ25EO0lBQ0E4eUIsR0FBR3JJLGdCQUFnQixDQUFDLFdBQVcsQ0FBQ3pxQjtRQUM1QixJQUFJO1lBQ0EsTUFBTXZJLFVBQVV1SSxFQUFFZ3pCLElBQUksWUFBWUMsY0FDNUJwcEIsU0FBU3FwQixVQUFVLENBQUMsSUFBSUMsV0FBV256QixFQUFFZ3pCLElBQUksS0FDekNucEIsU0FBU3VwQixjQUFjLENBQUNwekIsRUFBRWd6QixJQUFJLENBQUNwMkIsUUFBUTtZQUM3Q2kyQixVQUFVcDdCO1FBQ2QsRUFDQSxPQUFPMmhCLEtBQUs7WUFDUnZILE9BQU8sU0FBUyxxRUFBcUU7Z0JBQUV5TixPQUFPdGY7Z0JBQUdzRixPQUFPOFQ7WUFBSTtRQUNoSDtJQUNKO0lBQ0EsT0FBTzBaO0FBQ1g7QUFFQSxNQUFNTyxRQUFRLENBQUMxUyxJQUFNLElBQUkyUyxRQUFRLENBQUM3WCxJQUFNaVYsV0FBV2pWLEdBQUdrRjtBQUN0RCxTQUFTNFMsV0FBVy82QixLQUFLO0lBQ3JCLE9BQVFBLFNBQ0hWLENBQUFBLE9BQU80YixTQUFTLENBQUM5VyxRQUFRLENBQUNnWCxJQUFJLENBQUNwYixXQUFXLHVCQUN2QyxlQUFlLE9BQU9BLFNBQ3RCQSxpQkFBaUJnN0IsUUFBTztBQUNwQztBQUNBOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtJQUNmQyxlQUFlO0lBQ2ZDLG1CQUFtQjtJQUNuQkMsb0JBQW9CO0lBQ3BCQyxxQkFBcUI7QUFDekI7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBY0MsZ0JBQWdCO0lBQ25DLG1GQUFtRjtJQUNuRixNQUFNL2IsTUFBTXRiLEtBQUtvc0IsR0FBRyxDQUFDLE1BQU1pTCxtQkFBbUIsTUFBTTtJQUNwRCxNQUFNakwsTUFBTXBzQixLQUFLb3NCLEdBQUcsQ0FBQ3BzQixLQUFLc2IsR0FBRyxDQUFDLEtBQUssQ0FBQytiLG1CQUFtQixLQUFLLE9BQU87SUFDbkUsT0FBT3IzQixLQUFLQyxLQUFLLENBQUNELEtBQUtzM0IsTUFBTSxLQUFNaGMsQ0FBQUEsTUFBTThRLEdBQUUsSUFBS0E7QUFDcEQ7QUFDQSxTQUFTbUw7SUFDTCxPQUFPQztBQUNYO0FBQ0EsU0FBU0MsSUFBSUMsS0FBSztJQUNkLElBQUloZixJQUFJO0lBQ1IsSUFBSyxJQUFJalosSUFBSSxHQUFHQSxJQUFJaTRCLE1BQU12N0IsTUFBTSxFQUFFc0QsSUFBSztRQUNuQ2laLEtBQUtnZixLQUFLLENBQUNqNEIsRUFBRSxDQUFDUyxRQUFRLENBQUMsSUFBSXkzQixRQUFRLENBQUMsR0FBRztJQUMzQztJQUNBLE9BQU9qZjtBQUNYO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVM4ZTtJQUNMLE1BQU1FLFFBQVFFLGVBQWU7SUFDN0JGLEtBQUssQ0FBQyxFQUFFLEdBQUcsS0FBTSxDQUFDLEVBQUUsR0FBRyxPQUFRLE1BQU0sVUFBVTtJQUMvQ0EsS0FBSyxDQUFDLEVBQUUsR0FBRyxLQUFNLENBQUMsRUFBRSxHQUFHLE9BQVEsTUFBTSxVQUFVO0lBQy9DLE9BQVFELElBQUlDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHLE1BQzFCLE1BQ0FKLElBQUlDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHLE1BQ3RCLE1BQ0FKLElBQUlDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHLE1BQ3RCLE1BQ0FKLElBQUlDLE1BQU1HLFFBQVEsQ0FBQyxHQUFHLE9BQ3RCLE1BQ0FKLElBQUlDLE1BQU1HLFFBQVEsQ0FBQyxJQUFJO0FBQy9CO0FBQ0EsU0FBU0MsOEJBQThCSixLQUFLO0lBQ3hDLE1BQU1wYyxNQUFNdGIsS0FBSyszQixHQUFHLENBQUMsR0FBRyxJQUFLTCxNQUFNTSxVQUFVLEdBQUlOLE1BQU12N0IsTUFBTTtJQUM3RCxJQUFLLElBQUlzRCxJQUFJLEdBQUdBLElBQUlpNEIsTUFBTXY3QixNQUFNLEVBQUVzRCxJQUFLO1FBQ25DaTRCLEtBQUssQ0FBQ2o0QixFQUFFLEdBQUdPLEtBQUtzM0IsTUFBTSxLQUFLaGM7SUFDL0I7QUFDSjtBQUNBLE1BQU0yYyxrQkFBa0IsQ0FBQztJQUNyQixJQUFJLE9BQU9DLFdBQVcsZUFDbEIsT0FBT0EsUUFBUUQsb0JBQW9CLGFBQWE7UUFDaEQsT0FBT0MsT0FBT0QsZUFBZSxDQUFDRSxJQUFJLENBQUNEO0lBQ3ZDLE9BQ0ssSUFBSSxPQUFPRSxhQUFhLGFBQWE7UUFDdEMsT0FBT0EsU0FBU0gsZUFBZSxDQUFDRSxJQUFJLENBQUNDO0lBQ3pDLE9BQ0s7UUFDRCxPQUFPTjtJQUNYO0FBQ0o7QUFDQSxTQUFTRixlQUFlejdCLE1BQU07SUFDMUIsTUFBTXU3QixRQUFRLElBQUlqQixXQUFXdDZCO0lBQzdCODdCLGdCQUFnQlA7SUFDaEIsT0FBT0E7QUFDWDtBQUNBLFNBQVNXLG1CQUFtQjNiLEdBQUc7SUFDM0IsTUFBTTRiLFVBQVUsQ0FBQztJQUNqQixJQUFJLENBQUM1YixLQUNELE9BQU80YjtJQUNYLElBQUk7UUFDQWw5QixPQUFPbTlCLG1CQUFtQixDQUFDN2IsS0FBSy9HLE9BQU8sQ0FBQyxDQUFDMVk7WUFDckNxN0IsT0FBTyxDQUFDcjdCLElBQUksR0FBRzdCLE9BQU9vOUIsd0JBQXdCLENBQUM5YixLQUFLemY7UUFDeEQ7SUFDSixFQUNBLE9BQU93N0IsR0FBRztRQUNOLE9BQU87WUFDSDd2QixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU8wdkI7QUFDWDtBQUNBOzs7Q0FHQyxHQUNELFNBQVNJLFNBQVN2akIsTUFBTTtJQUNwQixNQUFNd2pCLE1BQU0sT0FBT25sQixjQUFjLGNBQzNCQSxZQUNBLE1BQWlELEdBQzdDb2xCLENBQWdCLEdBQ2hCNThCO0lBQ1YsSUFBSSxDQUFDMjhCLEtBQUs7UUFDTnhqQixPQUFPLFFBQVE7UUFDZixPQUFPO0lBQ1g7SUFDQSx3Q0FBd0M7SUFDeEMsSUFBSSxPQUFPd2pCLElBQUlFLE1BQU0sS0FBSyxXQUFXO1FBQ2pDLE9BQU87SUFDWDtJQUNBLE9BQU9GLElBQUlFLE1BQU07QUFDckI7QUFDQTs7Q0FFQyxHQUNELFNBQVNDLDRCQUE0QkMsRUFBRTtJQUNuQyxJQUFJLEtBQXdELEVBQUUsRUFHN0Q7QUFDTDtBQUNBLFNBQVNDLCtCQUErQkQsRUFBRTtJQUN0QyxJQUFJLEtBQTJELEVBQUUsRUFHaEU7QUFDTDtBQUVBOztDQUVDLEdBQ0QsTUFBTUU7SUFDRjs7Ozs7OztLQU9DLEdBQ0QzK0IsWUFBWSxFQUFFNnlCLFVBQVUsRUFBRStMLFNBQVMsRUFBRTdxQixLQUFLLEVBQUV6TCxTQUFTLEVBQUcsQ0FBRTtRQUN0RDs7O1NBR0MsR0FDRCxJQUFJLENBQUNpd0IsZ0JBQWdCLEdBQUcsSUFBSS9hO1FBQzVCOzs7U0FHQyxHQUNELElBQUksQ0FBQ3FoQixlQUFlLEdBQUc7UUFDdkI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEtBQUs7UUFDN0IsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxJQUFJLENBQUNELGdCQUFnQixHQUFHLElBQUk7UUFDeEQsSUFBSSxDQUFDemlCLEtBQUssR0FBRyxDQUFDcFEsT0FBT3l5QixnQkFBZ0JNLGNBQWMsRUFBRTVuQixTQUFTLDhDQUE4QztZQUN4RyxJQUFJLENBQUN3RCxNQUFNLENBQUMsU0FBUyw2QkFBNkIzTyxNQUFNbUw7WUFDeEQsSUFBSSxJQUFJLENBQUM2bkIsUUFBUSxDQUFDeEssVUFBVSxLQUFLLElBQUksQ0FBQ3dLLFFBQVEsQ0FBQ0MsTUFBTSxFQUFFO2dCQUNuRCxJQUFJLENBQUNELFFBQVEsQ0FBQzVpQixLQUFLLENBQUNwUSxNQUFNbUw7WUFDOUI7WUFDQSxJQUFJLENBQUMrbkIscUJBQXFCO1lBQzFCQyxjQUFjLElBQUksQ0FBQ0MsaUJBQWlCO1lBQ3BDcEwsYUFBYSxJQUFJLENBQUNxTCxzQkFBc0I7UUFDNUM7UUFDQSxJQUFJLENBQUNybkIsbUJBQW1CLEdBQUcsT0FBTzNEO1lBQzlCLE9BQU9pckIsVUFBVSxJQUFNLElBQUksQ0FBQ0MsR0FBRyxDQUFDdm5CLG1CQUFtQixDQUFDO29CQUNoRDVQLFdBQVcsSUFBSSxDQUFDQSxTQUFTO29CQUN6QjhHLFFBQVFtRjtnQkFDWixJQUFJLElBQUksQ0FBQ3NHLE1BQU07UUFDbkI7UUFDQSxJQUFJLENBQUNqRCxZQUFZLEdBQUcsT0FBT29rQjtZQUN2QixPQUFPd0QsVUFBVSxJQUFNLElBQUksQ0FBQ0MsR0FBRyxDQUFDN25CLFlBQVksQ0FBQztvQkFDekMsR0FBR29rQixJQUFJO29CQUNQMXpCLFdBQVcsSUFBSSxDQUFDQSxTQUFTO2dCQUM3QixJQUFJLElBQUksQ0FBQ3VTLE1BQU07UUFDbkI7UUFDQSxJQUFJLENBQUM1QyxVQUFVLEdBQUcsT0FBTytqQjtZQUNyQixPQUFPd0QsVUFBVSxJQUFNLElBQUksQ0FBQ0MsR0FBRyxDQUFDeG5CLFVBQVUsQ0FBQztvQkFDdkMsR0FBRytqQixJQUFJO29CQUNQMXpCLFdBQVcsSUFBSSxDQUFDQSxTQUFTO2dCQUM3QixJQUFJLElBQUksQ0FBQ3VTLE1BQU07UUFDbkI7UUFDQSxJQUFJLENBQUM1SSxVQUFVLEdBQUcsT0FBTytwQjtZQUNyQixPQUFPd0QsVUFBVSxJQUFNLElBQUksQ0FBQ0MsR0FBRyxDQUFDeHRCLFVBQVUsQ0FBQztvQkFDdkMsR0FBRytwQixJQUFJO29CQUNQMXpCLFdBQVcsSUFBSSxDQUFDQSxTQUFTO2dCQUM3QixJQUFJLElBQUksQ0FBQ3VTLE1BQU07UUFDbkI7UUFDQSxJQUFJLENBQUN6SyxVQUFVLEdBQUcsT0FBTzRyQjtZQUNyQixPQUFPd0QsVUFBVSxJQUFNLElBQUksQ0FBQ0MsR0FBRyxDQUFDcnZCLFVBQVUsQ0FBQztvQkFDdkMsR0FBRzRyQixJQUFJO29CQUNQMXpCLFdBQVcsSUFBSSxDQUFDQSxTQUFTO2dCQUM3QixJQUFJLElBQUksQ0FBQ3VTLE1BQU07UUFDbkI7UUFDQSxJQUFJLENBQUNzYixlQUFlLEdBQUcsT0FBT2xyQixXQUFXOEQ7WUFDckMsT0FBTyxJQUFJLENBQUNvSixnQkFBZ0IsQ0FBQztnQkFDekJ6SixZQUFZO29CQUNSO3dCQUNJekQ7d0JBQ0E4RDtvQkFDSjtpQkFDSDtZQUNMO1FBQ0o7UUFDQSxJQUFJLENBQUNvSixnQkFBZ0IsR0FBRyxPQUFPNmpCO1lBQzNCLE9BQU93RCxVQUFVLElBQU0sSUFBSSxDQUFDQyxHQUFHLENBQUN0bkIsZ0JBQWdCLENBQUM7b0JBQzdDLEdBQUc2akIsSUFBSTtvQkFDUDF6QixXQUFXLElBQUksQ0FBQ0EsU0FBUztnQkFDN0IsSUFBSSxJQUFJLENBQUN1UyxNQUFNO1FBQ25CO1FBQ0EsSUFBSSxDQUFDMVgsSUFBSSxHQUFHLE9BQU82NEI7WUFDZixNQUFNNW9CLGNBQWNILFlBQVkzUixNQUFNLENBQUM7Z0JBQ25DLEdBQUcwNkIsSUFBSTtnQkFDUDF6QixXQUFXLElBQUksQ0FBQ0EsU0FBUztnQkFDekJ5TCxPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNyQjtZQUNBLE9BQU8sSUFBSSxDQUFDMnJCLElBQUksQ0FBQ3BzQixXQUFXaFMsTUFBTSxDQUFDO2dCQUMvQjZSLGdCQUFnQjtvQkFDWnpQLFdBQVc7b0JBQ1gwUDtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNzc0IsSUFBSSxHQUFHLE9BQU9qL0I7WUFDZixPQUFPLElBQUksQ0FBQ2svQixXQUFXLENBQUNDLElBQUksQ0FBQyxDQUFDQztnQkFDMUIsSUFBSUEsT0FBT25MLFVBQVUsS0FBS21MLE9BQU9DLElBQUksRUFDakM7Z0JBQ0osSUFBSSxDQUFDamxCLE1BQU0sQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDa2xCLFFBQVEsQ0FBQyxDQUFDLEVBQUV6c0IsV0FBV3JTLE1BQU0sQ0FBQ1I7Z0JBQy9Fby9CLE9BQU9ILElBQUksQ0FBQ3BzQixXQUFXMHNCLFFBQVEsQ0FBQ3YvQjtZQUNwQztRQUNKO1FBQ0EsSUFBSSxDQUFDdy9CLFNBQVMsR0FBRztZQUNiWixjQUFjLElBQUksQ0FBQ0MsaUJBQWlCO1lBQ3BDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUdZLFlBQVk7Z0JBQ2pDLElBQUksQ0FBQ3JsQixNQUFNLENBQUMsU0FBUztnQkFDckIsTUFBTXBhLFVBQVU2UyxXQUFXaFMsTUFBTSxDQUFDO29CQUM5QjZSLGdCQUFnQjt3QkFDWnpQLFdBQVc7d0JBQ1gyUCxvQkFBb0IsQ0FBQztvQkFDekI7Z0JBQ0o7Z0JBQ0EsSUFBSSxDQUFDcXNCLElBQUksQ0FBQ2ovQixTQUFTMnVCLEtBQUssQ0FBQyxDQUFDcG1CO29CQUN0QixJQUFJLENBQUM2UixNQUFNLENBQUMsU0FBUywyQ0FBMkM3UjtnQkFDcEU7WUFDSixHQUFHLElBQUksQ0FBQysxQixnQkFBZ0I7UUFDNUI7UUFDQSxJQUFJLENBQUNvQix1QkFBdUIsR0FBRztZQUMzQmpNLGFBQWEsSUFBSSxDQUFDcUwsc0JBQXNCO1lBQ3hDLElBQUksQ0FBQ0Esc0JBQXNCLEdBQUc3RixXQUFXO2dCQUNyQyxJQUFJLElBQUksQ0FBQzBHLG9CQUFvQixFQUFFO29CQUMzQixNQUFNQyx1QkFBdUIsSUFBSTc2QixPQUFPVyxPQUFPLEtBQUssSUFBSSxDQUFDaTZCLG9CQUFvQixDQUFDajZCLE9BQU87b0JBQ3JGLElBQUlrNkIsdUJBQXVCLElBQUksQ0FBQ3JCLG9CQUFvQixFQUFFO3dCQUNsRCxJQUFJLENBQUMxaUIsS0FBSyxDQUFDcWlCLGdCQUFnQjJCLDBCQUEwQixFQUFFLENBQUMseURBQXlELEVBQUUsSUFBSSxDQUFDdEIsb0JBQW9CLENBQUMsRUFBRSxDQUFDO29CQUNwSjtnQkFDSjtZQUNKLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDaEM7UUFDQSxJQUFJLENBQUMxMkIsU0FBUyxHQUFHQSxhQUFhNDBCO1FBQzlCLElBQUksQ0FBQzBCLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDbUIsUUFBUSxHQUFHbkIsVUFBVTJCLFNBQVM7UUFDbkMsSUFBSSxDQUFDeHNCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUM4RyxNQUFNLEdBQUdSLFVBQVU7WUFBQztTQUFhO1FBQ3RDLE1BQU1tbUIsaUJBQWlCO1lBQ25CNW5CLGdCQUFnQixDQUFDQyxNQUFNZixRQUFRRCxPQUFPblg7Z0JBQ2xDLElBQUksQ0FBQ21hLE1BQU0sQ0FBQyxTQUFTLENBQUMsdUJBQXVCLEVBQUUvQyxPQUFPNVgsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDMUQyWDtvQkFDQW5YO2dCQUNKO2dCQUNBLE9BQU9tWSxLQUFLZixRQUFRRCxPQUFPblg7WUFDL0I7UUFDSjtRQUNBLElBQUksQ0FBQysrQixHQUFHLEdBQUcxbUIsbUJBQW1CO1lBQzFCVixTQUFTdW1CLFVBQVU2QixHQUFHO1lBQ3RCQyxjQUFjO2dCQUNWaG9CLFlBQVk7b0JBQ1Jpb0IsZUFBZSxDQUFDLE9BQU8sRUFBRTVzQixNQUFNLENBQUM7Z0JBQ3BDO2dCQUNBeXNCO2FBQ0g7UUFDTDtRQUNBLHNEQUFzRDtRQUN0RCxvRUFBb0U7UUFDcEUseUVBQXlFO1FBQ3pFLHdFQUF3RTtRQUN4RSwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDcEIscUJBQXFCLEdBQUd2TSxXQUFXelYsRUFBRSxDQUFDLGNBQWMsQ0FBQ25MO1lBQ3RELElBQUksQ0FBQ3NtQixnQkFBZ0IsQ0FBQ3J6QixJQUFJLENBQUMrTTtRQUMvQjtRQUNBLElBQUksQ0FBQ2l0QixRQUFRLEdBQUd2RCw2QkFBNkI7WUFDekNDLFVBQVVnRCxVQUFVZ0MsV0FBVztZQUMvQi9FLFdBQVcsQ0FBQ3A3QjtnQkFDUixJQUFJLENBQUMyL0Isb0JBQW9CLEdBQUcsSUFBSTU2QjtnQkFDaEMsSUFBSSxDQUFDMjZCLHVCQUF1QjtnQkFDNUJ0TixXQUFXOVYsUUFBUSxDQUFDdGM7WUFDeEI7UUFDSjtRQUNBLElBQUksQ0FBQ2svQixXQUFXLEdBQUcsSUFBSXJELFFBQVEsQ0FBQ3VFO1lBQzVCLE1BQU1DLFNBQVM7Z0JBQ1gsSUFBSSxDQUFDNUIsUUFBUSxDQUFDN0ssbUJBQW1CLENBQUMsUUFBUXlNO2dCQUMxQyxJQUFJLENBQUNiLFNBQVM7Z0JBQ2RZLFFBQVEsSUFBSSxDQUFDM0IsUUFBUTtZQUN6QjtZQUNBLElBQUksQ0FBQ0EsUUFBUSxDQUFDekwsZ0JBQWdCLENBQUMsUUFBUXFOO1FBQzNDO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0RuQyxnQkFBZ0JNLGNBQWMsR0FBRztBQUNqQzs7OztDQUlDLEdBQ0ROLGdCQUFnQjJCLDBCQUEwQixHQUFHO0FBQzdDOzs7O0NBSUMsR0FDRDNCLGdCQUFnQm9DLHVCQUF1QixHQUFHLE1BQU0sMEJBQTBCO0FBQzFFLE1BQU1DLGNBQWM7QUFDcEI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNeEIsWUFBWSxPQUFPQyxLQUFLNWtCO0lBQzFCLElBQUlvbUIsZUFBZTtJQUNuQixJQUFJQztJQUNKLEdBQUc7UUFDQyxtQ0FBbUM7UUFDbkMsSUFBSUQsZUFBZSxHQUFHO1lBQ2xCLE1BQU01RSxNQUFNUyxjQUFjbUU7UUFDOUI7UUFDQUMsZ0JBQWdCLE1BQU16QjtRQUN0QjVrQixPQUFPLFNBQVMsQ0FBQyw4QkFBOEIsRUFBRXFtQixjQUFjcHBCLE1BQU0sQ0FBQzVYLElBQUksQ0FBQyxDQUFDLEVBQUVnaEM7UUFDOUUsa0RBQWtEO1FBQ2xELElBQUlBLGNBQWM3SSxRQUFRLENBQUMvcEIsS0FBSyxFQUFFO1lBQzlCdU0sT0FBTyxTQUFTLENBQUMsZUFBZSxFQUFFcW1CLGNBQWNwcEIsTUFBTSxDQUFDNVgsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFZ2hDLGNBQWM3SSxRQUFRLENBQUMvcEIsS0FBSztRQUNqRztRQUNBMnlCO0lBQ0osUUFBU0MsY0FBYzdJLFFBQVEsQ0FBQy9wQixLQUFLLEVBQUVuQyxlQUNuQzgwQixlQUFlRCxhQUFhO0lBQ2hDLElBQUlFLGNBQWM3SSxRQUFRLENBQUMvcEIsS0FBSyxFQUFFO1FBQzlCLE1BQU00eUIsY0FBYzdJLFFBQVEsQ0FBQy9wQixLQUFLO0lBQ3RDO0lBQ0EsT0FBTzR5QjtBQUNYO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsb0JBQW9CLENBQUN2a0I7SUFDdkIsT0FBTyxlQUFld2tCLGVBQWU5WSxLQUFLO1FBQ3RDLDZEQUE2RDtRQUM3RCxJQUFJQSxNQUFNa0MsSUFBSSxDQUFDOWUsRUFBRSxLQUFLa1IsS0FBS3lrQixhQUFhLEVBQ3BDO1FBQ0osTUFBTSxFQUFFaGEsS0FBSyxFQUFFLEdBQUd6SztRQUNsQixJQUFJMEwsTUFBTTFMLElBQUksQ0FBQ3VNLFVBQVUsQ0FBQ3pkLEVBQUUsS0FBS2tSLEtBQUt5a0IsYUFBYSxJQUMvQ2hhLE1BQU0yRyxZQUFZLEtBQUs3SSxhQUFhbWMsT0FBTyxFQUFFO1lBQzdDLE1BQU0xa0IsS0FBS3paLElBQUk7UUFDbkI7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTW8rQixvQkFBb0IsQ0FBQzNrQjtJQUN2QixPQUFPLGVBQWU0a0IsZUFBZWxaLEtBQUs7UUFDdEMsNkRBQTZEO1FBQzdELElBQUlBLE1BQU1rQyxJQUFJLENBQUM5ZSxFQUFFLEtBQUtrUixLQUFLeWtCLGFBQWEsRUFDcEM7UUFDSixNQUFNLEVBQUV6a0IsTUFBTTZrQixTQUFTLEVBQUUsR0FBR25aO1FBQzVCLE1BQU0sRUFBRWlCLFNBQVNtWSxXQUFXLEVBQUUsR0FBR0Q7UUFDakMsSUFBSSxDQUFDQyxhQUFhO1lBQ2Q5a0IsS0FBSy9CLE1BQU0sQ0FBQyxRQUFRLDJEQUEyRHlOO1lBQy9FO1FBQ0o7UUFDQSxNQUFNcVosYUFBYUQsWUFBWUUsV0FBVztRQUMxQyxNQUFNLEVBQUVuYSxPQUFPLEVBQUV1RyxZQUFZLEVBQUUsR0FBR3BSLEtBQUt5SyxLQUFLO1FBQzVDLElBQUkyRyxpQkFBaUI3SSxhQUFhbWMsT0FBTyxFQUFFO1lBQ3ZDMWtCLEtBQUsvQixNQUFNLENBQUMsUUFBUSwwR0FBMEd5TjtZQUM5SDtRQUNKO1FBQ0EsSUFBSTFMLEtBQUtpbEIsYUFBYSxFQUFFO1lBQ3BCLE1BQU1DLHVCQUF1QnJhLFFBQ3hCaHNCLE1BQU0sQ0FBQyxDQUFDa3VCLElBQU1BLEVBQUVFLE9BQU8sS0FBS2pOLEtBQUt5a0IsYUFBYSxFQUM5Q1UsS0FBSyxDQUFDLENBQUNwWSxJQUFNZ1ksVUFBVSxDQUFDaFksRUFBRUUsT0FBTyxDQUFDO1lBQ3ZDLElBQUlpWSxzQkFBc0I7Z0JBQ3RCbGxCLEtBQUsvQixNQUFNLENBQUMsUUFBUTtnQkFDcEIsTUFBTStCLEtBQUt1UyxLQUFLO1lBQ3BCO1FBQ0osT0FDSztZQUNELElBQUl3UyxVQUFVLENBQUNGLFVBQVV0WSxVQUFVLENBQUN6ZCxFQUFFLENBQUMsRUFBRTtnQkFDckNrUixLQUFLL0IsTUFBTSxDQUFDLFFBQVE7Z0JBQ3BCLE1BQU0rQixLQUFLdVMsS0FBSztZQUNwQjtRQUNKO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTTZTLGlCQUFpQixDQUFDcGxCO0lBQ3BCLE9BQU8sZUFBZXFsQjtRQUNsQixNQUFNLEVBQUVqVSxZQUFZLEVBQUUsR0FBR3BSLEtBQUt5SyxLQUFLO1FBQ25DLElBQUkyRyxpQkFBaUI3SSxhQUFhbWMsT0FBTyxJQUNyQ3RULGlCQUFpQjdJLGFBQWErYyxNQUFNLElBQ3BDbFUsaUJBQWlCN0ksYUFBYWdkLE9BQU8sRUFBRTtZQUN2QyxNQUFNdmxCLEtBQUt1UyxLQUFLO1FBQ3BCO0lBQ0o7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNaVQseUJBQXlCLENBQUMvYTtJQUM1QixPQUFPLFNBQVNnYixvQkFBb0IvWixLQUFLO1FBQ3JDLE1BQU0sRUFBRW5SLGFBQWEsRUFBRSxHQUFHbVI7UUFDMUIsSUFBSW5SLGVBQWU7WUFDZixNQUFNLEVBQUUxSixlQUFlLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFLEdBQUd3SjtZQUM3RCxNQUFNOEssU0FBUztnQkFDWCxDQUFDL2tCLGNBQWNhLFVBQVUsQ0FBQyxFQUFFMFA7Z0JBQzVCLENBQUN2USxjQUFjYyxVQUFVLENBQUMsRUFBRTBQO2dCQUM1QixDQUFDeFEsY0FBY1ksV0FBVyxDQUFDLEVBQUU2UDtZQUNqQztZQUNBLE1BQU0yMEIsbUJBQW1CamIsTUFBTTZHLGVBQWUsQ0FBQ3p5QixNQUFNLENBQUMsQ0FBQzhtQyxhQUFldGdCLE1BQU0sQ0FBQ3NnQixXQUFXLEtBQUs7WUFDN0Z6aEMsT0FBT0MsT0FBTyxDQUFDa2hCLFFBQVE1RyxPQUFPLENBQUMsQ0FBQyxDQUFDa25CLFlBQVkvZ0MsTUFBTTtnQkFDL0MsSUFBSUEsU0FBUyxDQUFDOGdDLGlCQUFpQjNtQixRQUFRLENBQUM0bUIsYUFBYTtvQkFDakRELGlCQUFpQnA5QixJQUFJLENBQUNxOUI7Z0JBQzFCO1lBQ0o7WUFDQWxiLE1BQU1LLGtCQUFrQixDQUFDNGE7UUFDN0I7SUFDSjtBQUNKO0FBRUEsTUFBTUUsV0FBV25vQixVQUFVO0lBQUM7Q0FBUztBQUNyQzs7Q0FFQyxHQUNELE1BQU1vb0IsNEJBQTRCLENBQUM1UCxZQUFZalc7SUFDM0MsT0FBT2lXLFdBQVd6VixFQUFFLENBQUMsd0JBQXdCLENBQUNwVTtRQUMxQyxNQUFNLEVBQUVpTyxZQUFZLEVBQUUsR0FBR2pPO1FBQ3pCaU8sYUFBYW9FLE9BQU8sQ0FBQyxDQUFDcWI7WUFDbEIsTUFBTSxFQUFFeHJCLE1BQU0sRUFBRSxHQUFHd3JCO1lBQ25COVosS0FBSzhsQixvQkFBb0IsQ0FBQ3gzQixPQUFPelAsTUFBTSxDQUFDLENBQUN5ZSxJQUFNQSxFQUFFM0QsTUFBTTtRQUMzRDtJQUNKO0FBQ0o7QUFDQSxNQUFNb3NCLGdDQUFnQyxDQUFDOVAsWUFBWXhMO0lBQy9DLE9BQU93TCxXQUFXelYsRUFBRSxDQUFDLDRCQUE0QixDQUFDcFU7UUFDOUMsTUFBTSxFQUFFa00sd0JBQXdCLEVBQUUsR0FBR2xNO1FBQ3JDLElBQUksQ0FBQ2tNLDBCQUNEO1FBQ0ptUyxNQUFNZSxrQkFBa0IsQ0FBQ2xULHlCQUF5QjRTLE1BQU0sQ0FBQyxDQUFDOGEsU0FBUzNnQjtZQUMvRCxNQUFNLEVBQUUzWixTQUFTLEVBQUVJLGlCQUFpQixFQUFFLEdBQUd1WjtZQUN6QzJnQixPQUFPLENBQUN0NkIsVUFBVSxHQUFHO2dCQUNqQkk7WUFDSjtZQUNBLE9BQU9rNkI7UUFDWCxHQUFHLENBQUM7SUFDUjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUMsK0JBQStCLENBQUNoUSxZQUFZeEw7SUFDOUMsT0FBT3dMLFdBQVd6VixFQUFFLENBQUMsdUJBQXVCLENBQUNwVTtRQUN6QyxNQUFNLEVBQUVqQixnQkFBZ0IsRUFBRSxHQUFHaUI7UUFDN0IsSUFBSWpCLGtCQUFrQjtZQUNsQnNmLE1BQU1OLG1CQUFtQixDQUFDaGYsaUJBQWlCRyxLQUFLO1lBQ2hEbWYsTUFBTUgsNEJBQTRCLENBQUNuZixpQkFBaUJJLFNBQVM7UUFDakU7SUFDSjtBQUNKO0FBQ0EsTUFBTTI2QixpQkFBaUIsQ0FBQ2pRLFlBQVlqVztJQUNoQyxPQUFPaVcsV0FBV3pWLEVBQUUsQ0FBQyxTQUFTLENBQUNwVTtRQUMzQixJQUFJQSxFQUFFc0YsS0FBSyxJQUFJdEYsRUFBRXNGLEtBQUssQ0FBQ3BDLElBQUksS0FBSzlFLFVBQVUyN0IsVUFBVSxFQUNoRDtRQUNKLElBQUksQ0FBQ25tQixLQUFLb21CLGtCQUFrQixDQUFDQyxhQUFhLENBQUMvbEMsY0FBY0ssY0FBYyxHQUFHO1lBQ3RFcWYsS0FBS3VTLEtBQUssR0FBR0MsS0FBSyxDQUFDLENBQUNoTjtnQkFDaEJvZ0IsU0FBUyxTQUFTLHlDQUF5Q3BnQjtZQUMvRDtRQUNKO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTThnQix1QkFBdUIsQ0FBQ3JRO0lBQzFCLE9BQU9BLFdBQVd6VixFQUFFLENBQUMsU0FBUyxDQUFDcFU7UUFDM0IsSUFBSSxDQUFDQSxFQUFFc0YsS0FBSyxFQUNSO1FBQ0osTUFBTSxFQUFFQSxLQUFLLEVBQUUsR0FBR3RGO1FBQ2xCdzVCLFNBQVMsU0FBUyxzQkFBc0I7WUFDcEN0MkIsTUFBTTlFLFNBQVMsQ0FBQ2tILE1BQU1wQyxJQUFJLENBQUM7WUFDM0J6TCxTQUFTNk4sTUFBTTdOLE9BQU87WUFDdEIwTCxhQUFhbUMsTUFBTW5DLFdBQVc7UUFDbEM7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTWczQixtQkFBbUIsQ0FBQzliO0lBQ3RCLE9BQU8sU0FBUytiLGNBQWNwNkIsQ0FBQztRQUMzQixNQUFNLEVBQUVuQixJQUFJLEVBQUUsR0FBR21CO1FBQ2pCcWUsTUFBTW1CLGlCQUFpQixDQUFDM2dCO0lBQzVCO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXc3Qix1QkFBdUIsQ0FBQ3ptQjtJQUMxQixPQUFPQSxLQUFLUSxFQUFFLENBQUMsb0JBQW9CLE9BQU9rTDtRQUN0QyxNQUFNLEVBQUUxVSxLQUFLLEVBQUVuSSxJQUFJLEVBQUVuRCxTQUFTLEVBQUUsR0FBR2dnQjtRQUNuQyxNQUFNLEVBQUVpRCxnQkFBZ0IsRUFBRSxHQUFHM08sS0FBS3lLLEtBQUs7UUFDdkMsSUFBSXpULFVBQVV0TSxxQkFBcUJnOEIsVUFBVSxJQUN6Q2g3QixjQUFjaWpCLGtCQUFrQmpqQixXQUFXO1lBQzNDLE1BQU11UyxTQUFTK0IsS0FBSy9CLE1BQU07WUFDMUJBLE9BQU8sUUFBUSxDQUFDLG9CQUFvQixFQUFFMVQsU0FBUyxDQUFDc0UsS0FBSyxDQUFDLHdCQUF3QixDQUFDO1lBQy9FLElBQUk7Z0JBQ0EsSUFBSUEsU0FBU3RFLFVBQVVzYSxLQUFLLEVBQUU7b0JBQzFCLE1BQU03RSxLQUFLMm1CLE1BQU0sQ0FBQ0MsT0FBTztnQkFDN0IsT0FDSyxJQUFJLzNCLFNBQVN0RSxVQUFVdWEsS0FBSyxFQUFFO29CQUMvQixNQUFNOUUsS0FBSzZtQixVQUFVLENBQUNELE9BQU87Z0JBQ2pDLE9BQ0s7b0JBQ0Qzb0IsT0FBTyxRQUFRLHVDQUF1QzFULFNBQVMsQ0FBQ3NFLEtBQUs7Z0JBQ3pFO2dCQUNBLElBQUltUixLQUFLOG1CLFNBQVMsRUFBRTNOLGFBQWF0cUIsT0FBTztvQkFDcEMsTUFBTW1SLEtBQUsrbUIsV0FBVyxDQUFDbDRCO2dCQUMzQjtZQUNKLEVBQ0EsT0FBTzZDLE9BQU87Z0JBQ1Z1TSxPQUFPLFNBQVMsNkJBQTZCdk07WUFDakQ7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELE1BQU1zMUIseUJBQXlCLENBQUN2YztJQUM1QixPQUFPLFNBQVN3YyxvQkFBb0I3NkIsQ0FBQztRQUNqQyxNQUFNLEVBQUUwSyxXQUFXLEVBQUUsR0FBRzFLO1FBQ3hCLElBQUksQ0FBQzBLLGFBQ0Q7UUFDSiw2REFBNkQ7UUFDN0QsMkNBQTJDO1FBQzNDLEVBQUU7UUFDRixrRUFBa0U7UUFDbEUsZ0VBQWdFO1FBQ2hFLDREQUE0RDtRQUM1RCxtRUFBbUU7UUFDbkUsa0NBQWtDO1FBQ2xDMlQsTUFBTWMsc0JBQXNCLENBQUN6VSxZQUFZcEwsU0FBUyxFQUFFeEgsT0FBT2dqQyxNQUFNLENBQUNwd0IsYUFBYTtZQUMzRWlSLHlCQUF5QjtnQkFDckJqRixZQUFZbkksZ0JBQWdCdU4sT0FBTztnQkFDbkNpZixrQkFBa0J4c0IsZ0JBQWdCdU4sT0FBTztZQUM3QztRQUNKO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTWtmLHVCQUF1QixDQUFDM2M7SUFDMUIsT0FBTyxTQUFTNGMsa0JBQWtCajdCLENBQUM7UUFDL0IsTUFBTSxFQUFFMEssV0FBVyxFQUFFLEdBQUcxSztRQUN4QixJQUFJLENBQUMwSyxhQUNEO1FBQ0oyVCxNQUFNRixlQUFlLENBQUMsQ0FBQ3ZmLGVBQWlCQSxhQUFhbk0sTUFBTSxDQUFDLENBQUM4b0IsSUFBTUEsRUFBRWpjLFNBQVMsS0FBS29MLFlBQVlwTCxTQUFTO0lBQzVHO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCxNQUFNNDdCLHNCQUFzQixDQUFDN2M7SUFDekIsT0FBTyxTQUFTOGMsaUJBQWlCbjdCLENBQUM7UUFDOUIsTUFBTSxFQUFFeUMsSUFBSSxFQUFFbkQsU0FBUyxFQUFFb0wsV0FBVyxFQUFFLEdBQUcxSztRQUN6QyxtQ0FBbUM7UUFDbkMsNkVBQTZFO1FBQzdFLDJFQUEyRTtRQUMzRSxzQ0FBc0M7UUFDdEMsSUFBSTBLLGFBQWE7WUFDYjJULE1BQU1jLHNCQUFzQixDQUFDN2YsV0FBV29MO1FBQzVDLE9BQ0s7WUFDRDJULE1BQU1XLGlCQUFpQixDQUFDMWYsV0FBVyxDQUFDaWMsSUFBTztvQkFDdkMvYixpQkFBaUI7MkJBQUkrYixFQUFFL2IsZUFBZTt3QkFBRWlEO3FCQUFLLENBQUNoUSxNQUFNLENBQUMyb0M7Z0JBQ3pEO1FBQ0o7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUMsd0JBQXdCLENBQUNoZDtJQUMzQixPQUFPLFNBQVNpZCxtQkFBbUJ0N0IsQ0FBQztRQUNoQyxNQUFNLEVBQUV5QyxJQUFJLEVBQUVuRCxTQUFTLEVBQUVvTCxXQUFXLEVBQUUsR0FBRzFLO1FBQ3pDLDhEQUE4RDtRQUM5RCxJQUFJMEssYUFBYTtZQUNiMlQsTUFBTWMsc0JBQXNCLENBQUM3ZixXQUFXb0w7UUFDNUMsT0FDSztZQUNEMlQsTUFBTVcsaUJBQWlCLENBQUMxZixXQUFXLENBQUNpYyxJQUFPO29CQUN2Qy9iLGlCQUFpQitiLEVBQUUvYixlQUFlLENBQUMvTSxNQUFNLENBQUMsQ0FBQzJnQixJQUFNQSxNQUFNM1E7Z0JBQzNEO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsTUFBTTI0QixTQUFTLENBQUN2akMsR0FBR3NFLEdBQUdvL0IsTUFBUUEsSUFBSTNhLE9BQU8sQ0FBQy9vQixPQUFPc0U7QUFFakQ7O0NBRUMsR0FDRCxNQUFNcS9CLDhCQUE4QixDQUFDM1IsWUFBWXhMO0lBQzdDLE9BQU93TCxXQUFXelYsRUFBRSxDQUFDLDBCQUEwQixDQUFDcFU7UUFDNUMsTUFBTSxFQUFFVixTQUFTLEVBQUUsR0FBR1U7UUFDdEIsSUFBSVYsY0FBYytlLE1BQU05RCxlQUFlLEVBQUVqYixXQUNyQztRQUNKK2UsTUFBTUYsZUFBZSxDQUFDLENBQUN2ZixlQUFpQkEsYUFBYWhOLEdBQUcsQ0FBQyxDQUFDOFk7Z0JBQ3RELGdDQUFnQztnQkFDaEMsSUFBSUEsWUFBWXBMLFNBQVMsS0FBS0EsV0FBVztvQkFDckMsT0FBTzt3QkFDSCxHQUFHb0wsV0FBVzt3QkFDZDlLLG1CQUFtQjtvQkFDdkI7Z0JBQ0o7Z0JBQ0Esa0NBQWtDO2dCQUNsQyxJQUFJOEssWUFBWTlLLGlCQUFpQixFQUFFO29CQUMvQixPQUFPO3dCQUNILEdBQUc4SyxXQUFXO3dCQUNkOUssbUJBQW1CO29CQUN2QjtnQkFDSjtnQkFDQSxPQUFPOEssYUFBYSxZQUFZO1lBQ3BDO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ0QsTUFBTSt3Qix5QkFBeUIsQ0FBQzVSLFlBQVl4TDtJQUN4QyxPQUFPd0wsV0FBV3pWLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQ3BVO1FBQ3ZDLE1BQU0sRUFBRXlNLFdBQVcsRUFBRSxHQUFHek07UUFDeEJxZSxNQUFNZSxrQkFBa0IsQ0FBQzNTLFlBQVlxUyxNQUFNLENBQUMsQ0FBQzhhLFNBQVN4WDtZQUNsRHdYLE9BQU8sQ0FBQ3hYLFFBQVE5aUIsU0FBUyxDQUFDLEdBQUc7Z0JBQ3pCTyxZQUFZdWlCLFFBQVE5VixLQUFLO2dCQUN6QjNNLFlBQVl5aUIsUUFBUXppQixVQUFVO1lBQ2xDO1lBQ0EsT0FBT2k2QjtRQUNYLEdBQUcsQ0FBQztJQUNSO0FBQ0o7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNOEIsd0JBQXdCLENBQUM5bkIsTUFBTXlLLE9BQU93TDtJQUN4QyxNQUFNdEssZ0JBQWdCO1FBQ2xCM0wsS0FBS1EsRUFBRSxDQUFDLGNBQWM0a0IsZUFBZXBsQjtRQUNyQ2ttQixlQUFlalEsWUFBWWpXO1FBQzNCc21CLHFCQUFxQnJRO1FBQ3JCNFAsMEJBQTBCNVAsWUFBWWpXO1FBQ3RDK2xCLDhCQUE4QjlQLFlBQVl4TDtRQUMxQ3diLDZCQUE2QmhRLFlBQVl4TDtRQUN6Q3pLLEtBQUtRLEVBQUUsQ0FBQyxxQkFBcUJ3bUIsdUJBQXVCdmM7UUFDcER6SyxLQUFLUSxFQUFFLENBQUMsbUJBQW1CNG1CLHFCQUFxQjNjO1FBQ2hEekssS0FBS1EsRUFBRSxDQUFDLGtCQUFrQjhtQixvQkFBb0I3YztRQUM5Q3pLLEtBQUtRLEVBQUUsQ0FBQyxvQkFBb0JpbkIsc0JBQXNCaGQ7UUFDbERvZCx1QkFBdUI1UixZQUFZeEw7UUFDbkNtZCw0QkFBNEIzUixZQUFZeEw7UUFDeEN6SyxLQUFLUSxFQUFFLENBQUMscUJBQXFCZ2xCLHVCQUF1Qi9hO1FBQ3BEekssS0FBS1EsRUFBRSxDQUFDLGVBQWUrbEIsaUJBQWlCOWI7UUFDeENnYyxxQkFBcUJ6bUI7S0FDeEI7SUFDRCxJQUFJQSxLQUFLK25CLE9BQU8sRUFBRTtRQUNkLDBEQUEwRDtRQUMxRHBjLGNBQWNyakIsSUFBSSxDQUFDMC9CLGlDQUFpQ2hvQjtJQUN4RDtJQUNBLE9BQU87UUFDSDJMLGNBQWNsTixPQUFPLENBQUMsQ0FBQ2lILGNBQWdCQTtJQUMzQztBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU1zaUIsbUNBQW1DLENBQUNob0I7SUFDdEMsTUFBTWlvQix3QkFBd0I7UUFDMUIsaUJBQWlCMUQsa0JBQWtCdmtCO1FBQ25DLGlCQUFpQjJrQixrQkFBa0Iza0I7SUFDdkM7SUFDQSxNQUFNMkwsZ0JBQWdCem5CLE9BQU9rQyxJQUFJLENBQUM2aEMsdUJBQXVCanFDLEdBQUcsQ0FBQyxDQUFDMHRCO1FBQzFELE1BQU03TCxZQUFZNkw7UUFDbEIsT0FBTzFMLEtBQUtRLEVBQUUsQ0FBQ1gsV0FBV29vQixxQkFBcUIsQ0FBQ3BvQixVQUFVO0lBQzlEO0lBQ0EsT0FBTztRQUNIOEwsY0FBY2xOLE9BQU8sQ0FBQyxDQUFDaUgsY0FBZ0JBO0lBQzNDO0FBQ0o7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1uZixPQUFPLE9BQU8yaEMsWUFBWXI1QixNQUFNQyxJQUFJc3dCO0lBQ3RDLE1BQU0rSSxtQkFBbUIsTUFBTUMsT0FBT0YsWUFBWXI1QixNQUFNQyxJQUFJc3dCO0lBQzVELE1BQU0sRUFBRXBmLElBQUksRUFBRXFvQixXQUFXLEVBQUV4ZCxPQUFPLEVBQUUrRCxnQkFBZ0IsRUFBRSxHQUFHdVo7SUFDekQsT0FBTztRQUNIcFMsa0JBQWtCdVMsbUJBQW1CRCxZQUFZRSxXQUFXO1FBQzVEdkcsV0FBV3FHLFlBQVlHLE1BQU07UUFDN0JyeEIsT0FBT2t4QixZQUFZbHhCLEtBQUs7UUFDeEJzeEIsVUFBVXpvQjtRQUNWNks7UUFDQXlHLGlCQUFpQjFDO0lBQ3JCO0FBQ0o7QUFDQSxNQUFNd1osU0FBUyxPQUFPRixZQUFZcjVCLE1BQU1DLElBQUlzd0I7SUFDeEMsTUFBTXNKLFdBQVcsTUFBTVIsV0FBV1MsZUFBZTtJQUNqRCxNQUFNQyxVQUFVO1FBQ1osR0FBR3hKLElBQUk7UUFDUHNKO0lBQ0o7SUFDQSxPQUFPUixXQUFXVyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUVoNkIsS0FBSyxDQUFDLEVBQUVDLEdBQUcsS0FBSyxDQUFDLEVBQUU4NUI7QUFDdkQ7QUFDQSxNQUFNTixxQkFBcUIsQ0FBQy9VO0lBQ3hCLElBQUksQ0FBQ0EsVUFBVUEsT0FBT3R1QixNQUFNLEtBQUssR0FDN0IsT0FBT0g7SUFDWCxNQUFNZ2tDLFlBQVk7UUFDZEMsWUFBWXhWLE9BQU92MUIsR0FBRyxDQUFDLENBQUNnckMsTUFBUztnQkFDN0JDLE1BQU1ELElBQUlDLElBQUk7Z0JBQ2RDLFVBQVVGLElBQUlFLFFBQVE7Z0JBQ3RCQyxZQUFZSCxJQUFJSSxRQUFRO1lBQzVCO0lBQ0o7SUFDQSxPQUFPTjtBQUNYO0FBRUE7O0NBRUMsR0FDRCxNQUFNTyxzQkFBc0IsQ0FBQyxFQUFFQyxVQUFVLEVBQUV4QyxTQUFTLEVBQUVyYyxLQUFLLEVBQUU4ZSxzQkFBc0IsSUFBSSxFQUFHO0lBQ3RGLE1BQU10ckIsU0FBU1IsVUFBVTtRQUFDO0tBQVE7SUFDbEMsTUFBTStyQixzQkFBc0IsT0FBT2ptQyxNQUFNbzNCO1FBQ3JDLElBQUlwM0IsU0FBUyxnQkFBZ0IrbEMsWUFBWTtZQUNyQyxPQUFPQSxXQUFXNU8sUUFBUSxDQUFDQztRQUMvQixPQUNLLElBQUlwM0IsU0FBUyxlQUFldWpDLFdBQVc7WUFDeEMsT0FBT0EsVUFBVXBNLFFBQVEsQ0FBQ0M7UUFDOUIsT0FDSztZQUNEMWMsT0FBTyxRQUFRLENBQUMsNkJBQTZCLEVBQUUxYSxLQUFLLENBQUM7WUFDckQsT0FBT3VCO1FBQ1g7SUFDSjtJQUNBLE1BQU0ya0Msb0JBQW9CLE9BQU9sbUMsTUFBTW8wQjtRQUNuQyxNQUFNL0IsS0FBS3J5QixTQUFTLGVBQWUrbEMsYUFBYXhDO1FBQ2hELE1BQU00QyxpQkFBaUIsRUFBRTtRQUN6QixLQUFLLElBQUk5UixTQUFTRCxZQUFZaUgsU0FBUyxHQUFJO1lBQ3ZDLE1BQU1qVSxTQUFTLE1BQU1pTCxHQUFHOEUsUUFBUSxDQUFDOUM7WUFDakMsTUFBTStSLFFBQVFDLFVBQVVqZixRQUFRO2dCQUM1QixhQUFhO2dCQUNia2YsV0FBV2pTLE1BQU1yMEIsSUFBSTtnQkFDckJBO1lBQ0o7WUFDQW1tQyxlQUFlcGhDLElBQUksQ0FBQ3FoQztRQUN4QjtRQUNBLE9BQU9EO0lBQ1g7SUFDQSxNQUFNSSx5QkFBeUIsQ0FBQ3ArQjtRQUM1QnErQixrQkFBa0JuTSxHQUFHLENBQUNseUI7UUFDdEIsS0FBS3MrQjtJQUNUO0lBQ0EsTUFBTUMsd0JBQXdCLENBQUN2K0I7UUFDM0JxK0Isa0JBQWtCL0wsTUFBTSxDQUFDdHlCO1FBQ3pCLEtBQUtzK0I7SUFDVDtJQUNBLE1BQU1ELG9CQUFvQixJQUFJck07SUFDOUI7O0tBRUMsR0FDRCxNQUFNc00sTUFBTTtRQUNSLE1BQU1FLG1CQUFtQixDQUFDO1FBQzFCLE1BQU1DLGFBQWEsSUFBSXpNLElBQUlxTTtRQUMzQixJQUFJSSxXQUFXaG1CLElBQUksR0FBRyxHQUFHO1lBQ3JCLEtBQUssSUFBSXJOLGVBQWUyVCxNQUFNemYsWUFBWSxDQUFFO2dCQUN4QyxJQUFJLENBQUNtL0IsV0FBV0MsR0FBRyxDQUFDdHpCLFlBQVlwTCxTQUFTLEdBQ3JDO2dCQUNKLE1BQU1uSSxPQUFPdVQsWUFBWXNZLGtCQUFrQixHQUNyQyxjQUNBO2dCQUNOLElBQUk7b0JBQ0EsTUFBTWliLGVBQWUsSUFBSUMsWUFBWTsyQkFDN0J4ekIsWUFBWXl6QixXQUFXLEVBQUVDLG9CQUFvQixFQUFFOzJCQUMvQzF6QixZQUFZMnpCLFdBQVcsRUFBRUMsb0JBQW9CLEVBQUU7cUJBQ3REO29CQUNEUixnQkFBZ0IsQ0FBQ3B6QixZQUFZcEwsU0FBUyxDQUFDLEdBQUcsTUFBTSs5QixrQkFBa0JsbUMsTUFBTThtQztvQkFDeEVBLGFBQWF6TCxTQUFTLEdBQUduZ0IsT0FBTyxDQUFDLENBQUNlO3dCQUM5QjZxQixhQUFhMVEsV0FBVyxDQUFDbmE7b0JBQzdCO2dCQUNKLEVBQ0EsT0FBT3BULEdBQUc7b0JBQ042UixPQUFPLFNBQVMsQ0FBQyw0QkFBNEIsRUFBRTFhLEtBQUssSUFBSSxFQUFFdVQsWUFBWXJMLE1BQU0sQ0FBQyxDQUFDLEVBQUVXO2dCQUNwRjtZQUNKO1FBQ0o7UUFDQSxNQUFNLENBQUN1K0IsaUJBQWlCQyxlQUFlLEdBQUcsTUFBTWxMLFFBQVFtTCxHQUFHLENBQUM7WUFDeER2QixXQUNLNU8sUUFBUSxHQUNSc0ksSUFBSSxDQUFDLENBQUNyWSxTQUFXaWYsVUFBVWpmLFFBQVE7b0JBQ3BDcG5CLE1BQU07b0JBQ05zbUMsV0FBVztnQkFDZixJQUNLN0csSUFBSSxDQUFDOEg7WUFDVmhFLFVBQ0twTSxRQUFRLEdBQ1JzSSxJQUFJLENBQUMsQ0FBQ3JZLFNBQVdpZixVQUFVamYsUUFBUTtvQkFDcENwbkIsTUFBTTtvQkFDTnNtQyxXQUFXO2dCQUNmLElBQ0s3RyxJQUFJLENBQUM4SDtTQUNiO1FBQ0QsTUFBTSxDQUFDQyxvQkFBb0JDLGtCQUFrQixHQUFHLE1BQU10TCxRQUFRbUwsR0FBRyxDQUFDO1lBQzlEckIsb0JBQW9CO1lBQ3BCQSxvQkFBb0I7U0FDdkI7UUFDRC9lLE1BQU1DLGtCQUFrQixDQUFDO1lBQ3JCdWdCLFlBQVluRSxVQUFVOVEsU0FBUyxDQUFDbU4sUUFBUTtZQUN4Q3lIO1lBQ0FEO1lBQ0FJO1lBQ0FDO1lBQ0FoZ0MsY0FBY2svQjtZQUNkZ0IsV0FBV3RpQyxLQUFLSCxHQUFHO1FBQ3ZCO0lBQ0o7SUFDQSxJQUFJMGlDO0lBQ0osSUFBSTVCLHNCQUFzQixHQUFHO1FBQ3pCLE1BQU02QixPQUFPO1lBQ1QsTUFBTXBCLE1BQU14WCxLQUFLLENBQUMsQ0FBQ3BtQjtnQkFDZjZSLE9BQU8sU0FBUywyQkFBMkI3UjtZQUMvQztZQUNBKytCLFlBQVlyTyxXQUFXc08sTUFBTTdCO1FBQ2pDO1FBQ0EsS0FBSzZCO0lBQ1Q7SUFDQSxNQUFNM3JCLE9BQU87UUFDVCxJQUFJMHJCLFdBQVc7WUFDWDdULGFBQWE2VDtRQUNqQjtJQUNKO0lBQ0EsT0FBTztRQUNIM0I7UUFDQUM7UUFDQUs7UUFDQUc7UUFDQXhxQjtJQUNKO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNELE1BQU1tcUIsWUFBWSxDQUFDamYsUUFBUWtOO0lBQ3ZCLE1BQU0sRUFBRWdTLFNBQVMsRUFBRXRtQyxJQUFJLEVBQUUsR0FBR3MwQjtJQUM1QixNQUFNNVksWUFBWTFiLFNBQVMsZUFBZSxnQkFBZ0I7SUFDMUQsTUFBTW9tQyxRQUFRMEIsVUFBVTFnQjtJQUN4QixNQUFNZ08sVUFBVWdSLE1BQ1g5cUMsTUFBTSxDQUFDLENBQUN5c0MsT0FBU0EsS0FBS3o4QixJQUFJLEtBQUtvUSxhQUNoQ3FzQixLQUFLL25DLElBQUksS0FBS3NtQyxXQUNiN3JDLEdBQUcsQ0FBQyxDQUFDc3RDO1FBQ04sTUFBTUMsaUJBQWlCRDtRQUN2QixNQUFNbnlCLFFBQVF3d0IsTUFBTXRpQyxJQUFJLENBQUMsQ0FBQ21hLElBQU1BLEVBQUUzUyxJQUFJLEtBQUssV0FBVzJTLEVBQUUxUyxFQUFFLEtBQUt5OEIsZUFBZTlXLE9BQU8sR0FBRyw0QkFBNEI7UUFDcEgsTUFBTXJZLFlBQVl1dEIsTUFBTXRpQyxJQUFJLENBQUMsQ0FBQ21hLElBQU1BLEVBQUUzUyxJQUFJLEtBQUssZUFBZTJTLEVBQUUxUyxFQUFFLEtBQUt5OEIsZUFBZUMsV0FBVztRQUNqRyxJQUFJQztRQUNKLElBQUlydkIsYUFBYUEsVUFBVXN2QixTQUFTLEtBQUssYUFBYTtZQUNsRCxNQUFNQyxnQkFBZ0JoQyxNQUFNdGlDLElBQUksQ0FBQyxDQUFDbWEsSUFBTUEsRUFBRTNTLElBQUksS0FBSyxvQkFDL0MyUyxFQUFFMVMsRUFBRSxLQUFLc04sVUFBVXd2Qix1QkFBdUI7WUFDOUNILGdCQUFnQkUsZUFBZUU7UUFDbkM7UUFDQSxPQUFPO1lBQ0hDLFdBQVdQLGVBQWVPLFNBQVM7WUFDbkNDLGVBQWVSLGVBQWVRLGFBQWE7WUFDM0M1eUIsT0FBT0EsT0FBT3dGO1lBQ2RrdEIsc0JBQXNCSjtZQUN0Qk8sYUFBYVQsZUFBZVMsV0FBVztZQUN2Q0MsWUFBWVYsZUFBZVUsVUFBVTtZQUNyQ0MsaUJBQWlCWCxlQUFlVyxlQUFlO1lBQy9DQyxRQUFRWixlQUFlWSxNQUFNO1lBQzdCNW9DLE1BQU1nb0MsZUFBZWhvQyxJQUFJO1lBQ3pCLGtFQUFrRTtZQUNsRTZvQyx5QkFBeUJiLGVBQWVhLHVCQUF1QjtZQUMvRG4vQixLQUFLcytCLGVBQWV0K0IsR0FBRztZQUN2Qm8vQixNQUFNZCxlQUFlYyxJQUFJO1FBQzdCO0lBQ0o7SUFDQSxPQUFPO1FBQ0hDLFVBQVUzaEI7UUFDVmdPO1FBQ0F1UyxXQUFXdGlDLEtBQUtILEdBQUc7SUFDdkI7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNcWlDLFlBQVksQ0FBQ25CO0lBQ2YsTUFBTTRDLGtCQUFrQjtRQUNwQkMsV0FBVzdDO1FBQ1g4QyxnQkFBZ0I7UUFDaEJDLG9CQUFvQjtRQUNwQkMsbUJBQW1CO1FBQ25CQywwQkFBMEI7UUFDMUJDLDBCQUEwQjtRQUMxQkMsbUJBQW1CO1FBQ25CQyxvQkFBb0I7UUFDcEJDLHdCQUF3QjtRQUN4QjlCLFdBQVd0aUMsS0FBS0gsR0FBRztJQUN2QjtJQUNBLElBQUl3a0MsVUFBVSxDQUFDO0lBQ2YsTUFBTUMsT0FBTyxDQUFDL3BCLEdBQUdDLElBQU1ELElBQUlDO0lBQzNCLE1BQU15cEIsMkJBQTJCLElBQUluUDtJQUNyQyxNQUFNL0UsVUFBVWdSLE1BQU1oUixPQUFPO0lBQzdCLE1BQU1oTyxTQUFTZ08sUUFBUXpOLE1BQU0sQ0FBQyxDQUFDaWlCLEtBQUtDO1FBQ2hDRCxJQUFJVixjQUFjLElBQUlXLE9BQU90QixTQUFTLElBQUk7UUFDMUNxQixJQUFJVCxrQkFBa0IsSUFBSVUsT0FBT3JCLGFBQWEsSUFBSTtRQUNsRG9CLElBQUlSLGlCQUFpQixJQUFJUyxPQUFPakIsTUFBTSxJQUFJO1FBQzFDZ0IsSUFBSVAsd0JBQXdCLElBQUlRLE9BQU92QixvQkFBb0IsSUFBSTtRQUMvRCw4Q0FBOEM7UUFDOUMsTUFBTXdCLGFBQWFILEtBQUtFLE9BQU9uQixVQUFVLElBQUksR0FBR21CLE9BQU9wQixXQUFXLElBQUk7UUFDdEUsSUFBSXFCLGFBQWFKLFNBQVM7WUFDdEJFLElBQUlMLGlCQUFpQixHQUFHTSxPQUFPbkIsVUFBVSxJQUFJO1lBQzdDa0IsSUFBSUosa0JBQWtCLEdBQUdLLE9BQU9wQixXQUFXLElBQUk7WUFDL0NtQixJQUFJSCxzQkFBc0IsR0FBR0ksT0FBT2xCLGVBQWUsSUFBSTtZQUN2RGUsVUFBVUk7UUFDZDtRQUNBUix5QkFBeUJqUCxHQUFHLENBQUN3UCxPQUFPaEIsdUJBQXVCLElBQUk7UUFDL0QsT0FBT2U7SUFDWCxHQUFHWjtJQUNILElBQUk1VCxRQUFRMXpCLE1BQU0sR0FBRyxHQUFHO1FBQ3BCMGxCLE9BQU9naUIsaUJBQWlCLEdBQUc3akMsS0FBSzJhLEtBQUssQ0FBQyxPQUFRa3BCLGlCQUFpQixHQUFHaFUsUUFBUTF6QixNQUFNLEdBQUk7UUFDcEYwbEIsT0FBT2lpQix3QkFBd0IsR0FBRzlqQyxLQUFLMmEsS0FBSyxDQUFDLE9BQVFtcEIsd0JBQXdCLEdBQUdqVSxRQUFRMXpCLE1BQU0sR0FBSTtJQUN0RztJQUNBLE1BQU1tbkMsMEJBQTBCO1FBQzVCUyx5QkFBeUJ6QyxHQUFHLENBQUMsVUFBVTtRQUN2Q3lDLHlCQUF5QnpDLEdBQUcsQ0FBQyxnQkFBZ0I7UUFDN0N5Qyx5QkFBeUJ6QyxHQUFHLENBQUMsWUFBWTtLQUM1QyxDQUNJdnJDLE1BQU0sQ0FBQ3l1QyxTQUNQL21DLElBQUksQ0FBQztJQUNWLElBQUk2bEMseUJBQXlCO1FBQ3pCemhCLE9BQU9raUIsd0JBQXdCLEdBQUdUO0lBQ3RDO0lBQ0EsT0FBT3poQjtBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU0wZ0IsWUFBWSxDQUFDMWdCO0lBQ2YsTUFBTWdmLFFBQVEsRUFBRTtJQUNoQmhmLE9BQU9sTSxPQUFPLENBQUMsQ0FBQytDO1FBQ1ptb0IsTUFBTXJoQyxJQUFJLENBQUNrWjtJQUNmO0lBQ0EsT0FBT21vQjtBQUNYO0FBRUEsTUFBTTRELG9CQUFvQjtBQUMxQixNQUFNQztJQUNGcHFDLGFBQWM7UUFDVjs7U0FFQyxHQUNELElBQUksQ0FBQ3FxQyxpQkFBaUIsR0FBRyxJQUFJbFg7UUFDN0I7O1NBRUMsR0FDRCxJQUFJLENBQUNtWCxRQUFRLEdBQUc7UUFDaEIsdURBQXVEO1FBQ3ZELGdFQUFnRTtRQUNoRTs7U0FFQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlqUTtRQUNwQjs7Ozs7OztTQU9DLEdBQ0QsSUFBSSxDQUFDa1EsV0FBVyxHQUFHLENBQUNDLGlCQUFpQi9wQztZQUNqQyxNQUFNZ3FDLFVBQVU7Z0JBQ1osSUFBSSxDQUFDSixRQUFRLEVBQUVLO2dCQUNmLElBQUksQ0FBQ0wsUUFBUSxHQUFHO2dCQUNoQixJQUFJLENBQUNELGlCQUFpQixDQUFDTyxLQUFLO1lBQ2hDO1lBQ0EsSUFBSSxDQUFDTixRQUFRLEdBQUcsSUFBSU8scUJBQXFCLENBQUM5cEM7Z0JBQ3RDQSxRQUFRc2EsT0FBTyxDQUFDLENBQUN5dkI7b0JBQ2IsTUFBTW5vQixVQUFVLElBQUksQ0FBQzBuQixpQkFBaUIsQ0FBQ3ZSLEdBQUcsQ0FBQ2dTLE1BQU0zcEMsTUFBTTtvQkFDdkR3aEIsVUFBVW1vQjtnQkFDZDtZQUNKLEdBQUc7Z0JBQ0NDLE1BQU1OO2dCQUNOLEdBQUcvcEMsT0FBTztnQkFDVnNxQyxXQUFXdHFDLFNBQVNzcUMsYUFBYWI7WUFDckM7WUFDQSxJQUFJLElBQUksQ0FBQ0ksUUFBUSxDQUFDeHBCLElBQUksRUFBRTtnQkFDcEIsSUFBSSxDQUFDd3BCLFFBQVEsQ0FBQ2x2QixPQUFPLENBQUMsQ0FBQyxDQUFDNHZCLGNBQWNDLGFBQWE7b0JBQy9DLGtEQUFrRDtvQkFDbEQsK0NBQStDO29CQUMvQyxJQUFJLENBQUNULGdCQUFnQlUsUUFBUSxDQUFDRixlQUMxQjtvQkFDSixJQUFJLENBQUNYLFFBQVEsQ0FBQ2MsT0FBTyxDQUFDSDtvQkFDdEIsSUFBSSxDQUFDWixpQkFBaUIsQ0FBQzVVLEdBQUcsQ0FBQ3dWLGNBQWNDO2dCQUM3QztnQkFDQSxJQUFJLENBQUNYLFFBQVEsQ0FBQ0ssS0FBSztZQUN2QjtZQUNBLE9BQU9GO1FBQ1g7UUFDQTs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQ1UsT0FBTyxHQUFHLENBQUNDLFNBQVMxb0I7WUFDckIsTUFBTTJvQixZQUFZO2dCQUFDRDtnQkFBUzFvQjthQUFRO1lBQ3BDLE1BQU0rbkIsVUFBVTtnQkFDWixJQUFJLENBQUNMLGlCQUFpQixDQUFDelAsTUFBTSxDQUFDeVE7Z0JBQzlCLElBQUksQ0FBQ2YsUUFBUSxFQUFFaUIsVUFBVUY7Z0JBQ3pCLElBQUksQ0FBQ2QsUUFBUSxDQUFDM1AsTUFBTSxDQUFDMFE7WUFDekI7WUFDQSxJQUFJLElBQUksQ0FBQ2pCLGlCQUFpQixDQUFDckQsR0FBRyxDQUFDcUUsVUFDM0IsT0FBT1g7WUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDSixRQUFRLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQ0MsUUFBUSxDQUFDL1AsR0FBRyxDQUFDOFE7Z0JBQ2xCLE9BQU9aO1lBQ1g7WUFDQSxJQUFJLElBQUksQ0FBQ0osUUFBUSxDQUFDUyxJQUFJLENBQUNJLFFBQVEsQ0FBQ0UsVUFBVTtnQkFDdEMsSUFBSSxDQUFDaEIsaUJBQWlCLENBQUM1VSxHQUFHLENBQUM0VixTQUFTMW9CO2dCQUNwQyxJQUFJLENBQUMybkIsUUFBUSxDQUFDYyxPQUFPLENBQUNDO1lBQzFCO1lBQ0EsT0FBT1g7UUFDWDtJQUNKO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELE1BQU1jLFdBQVc7SUFDYixJQUFJLE9BQU90eUIsY0FBYyxhQUNyQixPQUFPO0lBQ1gsT0FBTyxpQ0FBaUM4WCxJQUFJLENBQUM5WCxVQUFVZ0csU0FBUyxJQUFJO0FBQ3hFO0FBQ0E7O0NBRUMsR0FDRCxNQUFNdXNCLFlBQVk7SUFDZCxJQUFJLE9BQU92eUIsY0FBYyxhQUNyQixPQUFPO0lBQ1gsT0FBT0EsVUFBVWdHLFNBQVMsRUFBRXZELFNBQVM7QUFDekM7QUFDQTs7Q0FFQyxHQUNELE1BQU0rdkIsV0FBVztJQUNiLElBQUksT0FBT3h5QixjQUFjLGFBQ3JCLE9BQU87SUFDWCxPQUFPQSxVQUFVZ0csU0FBUyxFQUFFdkQsU0FBUztBQUN6QztBQUVBLElBQUlnd0IsV0FBVyxXQUFXLEdBQUU3cUMsT0FBT2dOLE1BQU0sQ0FBQztJQUN0Q0MsV0FBVztJQUNYMjlCLFVBQVVBO0lBQ1ZELFdBQVdBO0lBQ1hELFVBQVVBO0FBQ2Q7QUFFQSxNQUFNSSxvQ0FBb0M7SUFDdENsc0IsWUFBWW5JLGdCQUFnQnVOLE9BQU87SUFDbkNpZixrQkFBa0J4c0IsZ0JBQWdCdU4sT0FBTztBQUM3QztBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU0rbUI7SUFDRjs7OztLQUlDLEdBQ0Q3ckMsWUFBWTRjLElBQUksQ0FBRTtRQUNkOztTQUVDLEdBQ0QsSUFBSSxDQUFDa3ZCLGVBQWUsR0FBRyxJQUFJMUI7UUFDM0IsSUFBSSxDQUFDdnZCLE1BQU0sR0FBR1IsVUFBVTtZQUFDO1NBQW1CO1FBQzVDOzs7Ozs7OztTQVFDLEdBQ0QsSUFBSSxDQUFDMHhCLHNCQUFzQixHQUFHLENBQUNWLFNBQVMvaUMsV0FBVzJDO1lBQy9DLE1BQU15L0IsVUFBVSxJQUFJLENBQUNvQixlQUFlLENBQUNWLE9BQU8sQ0FBQ0MsU0FBUyxDQUFDUDtnQkFDbkQsSUFBSSxDQUFDbHVCLElBQUksQ0FBQ3lLLEtBQUssQ0FBQ1csaUJBQWlCLENBQUMxZixXQUFXLENBQUNvTDtvQkFDMUMsTUFBTXM0QiwwQkFBMEJ0NEIsWUFBWWlSLHVCQUF1QixJQUMvRGluQjtvQkFDSiwyRUFBMkU7b0JBQzNFLHlFQUF5RTtvQkFDekUsTUFBTUssWUFBWW5CLE1BQU1vQixjQUFjLElBQUlDLFNBQVNDLGlCQUFpQixLQUFLZixVQUNuRTl6QixnQkFBZ0I4MEIsT0FBTyxHQUN2QjkwQixnQkFBZ0JxTixTQUFTO29CQUMvQixPQUFPO3dCQUNILEdBQUdsUixXQUFXO3dCQUNkaVIseUJBQXlCOzRCQUNyQixHQUFHcW5CLHVCQUF1Qjs0QkFDMUIsQ0FBQy9nQyxVQUFVLEVBQUVnaEM7d0JBQ2pCO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxPQUFPO2dCQUNIdkI7Z0JBQ0EsaURBQWlEO2dCQUNqRCxxREFBcUQ7Z0JBQ3JELHlEQUF5RDtnQkFDekQsSUFBSSxDQUFDOXRCLElBQUksQ0FBQ3lLLEtBQUssQ0FBQ1csaUJBQWlCLENBQUMxZixXQUFXLENBQUNvTDtvQkFDMUMsTUFBTXM0QiwwQkFBMEJ0NEIsWUFBWWlSLHVCQUF1QixJQUMvRGluQjtvQkFDSixPQUFPO3dCQUNILEdBQUdsNEIsV0FBVzt3QkFDZGlSLHlCQUF5Qjs0QkFDckIsR0FBR3FuQix1QkFBdUI7NEJBQzFCLENBQUMvZ0MsVUFBVSxFQUFFc00sZ0JBQWdCdU4sT0FBTzt3QkFDeEM7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQzBsQixXQUFXLEdBQUcsQ0FBQ2E7WUFDaEIsT0FBTyxJQUFJLENBQUNTLGVBQWUsQ0FBQ3RCLFdBQVcsQ0FBQ2E7UUFDNUM7UUFDQTs7Ozs7Ozs7Ozs7Ozs7U0FjQyxHQUNELElBQUksQ0FBQ2lCLGdCQUFnQixHQUFHLENBQUNDLGNBQWNqa0MsV0FBVzJDO1lBQzlDLE1BQU11aEMsbUJBQW1CLElBQUksQ0FBQzV2QixJQUFJLENBQUN5SyxLQUFLLENBQUNPLDBCQUEwQixDQUFDdGY7WUFDcEUsSUFBSSxDQUFDa2tDLGtCQUNEO1lBQ0osTUFBTUMsNkJBQTZCLENBQUNDLGNBQWNqOUI7Z0JBQzlDLElBQUlBLGFBQWNBLENBQUFBLFVBQVVoRyxLQUFLLEtBQUssS0FBS2dHLFVBQVUvRixNQUFNLEtBQUssSUFBSTtvQkFDaEUsZ0VBQWdFO29CQUNoRSw0Q0FBNEM7b0JBQzVDLDZEQUE2RDtvQkFDN0QscUVBQXFFO29CQUNyRSxJQUFJLENBQUNtUixNQUFNLENBQUMsU0FBUyxDQUFDLHNCQUFzQixDQUFDLEVBQUUyeEI7b0JBQy9DLzhCLFlBQVkvTjtnQkFDaEI7Z0JBQ0EsSUFBSSxDQUFDa2IsSUFBSSxDQUFDK3ZCLDBCQUEwQixDQUFDMWhDLFdBQVc7b0JBQUUsQ0FBQzNDLFVBQVUsRUFBRTt3QkFBRW1IO29CQUFVO2dCQUFFLEdBQUdpOUI7WUFDcEY7WUFDQSxNQUFNRSxlQUFlLElBQUksQ0FBQ2h3QixJQUFJLENBQUN5SyxLQUFLLENBQUNvRSxhQUFhLENBQUNFLElBQUksQ0FBQzl3QixtUUFBS0EsQ0FBQyxDQUFDK00sZUFBaUJBLGFBQWEzRCxJQUFJLENBQUMsQ0FBQ3lQLGNBQWdCQSxZQUFZcEwsU0FBUyxLQUFLQSxhQUFhdE4seVFBQVNBLENBQUMsQ0FBQzBZLGNBQWdCLENBQUMsQ0FBQ0EsY0FBYzNZLG9SQUFvQkEsSUFBSUQsMlFBQVdBLENBQUM7Z0JBQUUrd0IsWUFBWTtnQkFBR0MsVUFBVTtZQUFLO1lBQ3pROzs7OzthQUtDLEdBQ0Qsd0NBQXdDO1lBQ3hDLElBQUluSDtZQUNKLE1BQU1rb0Isc0NBQXNDTCxpQkFBaUJ4Z0Isa0JBQWtCLEdBQ3pFLE9BQ0E0Z0IsYUFDR2poQixJQUFJLENBQUM5d0IsbVFBQUtBLENBQUMsQ0FBQzBwQixJQUFNQSxFQUFFSSx1QkFBdUIsRUFBRSxDQUFDMVosVUFBVSxHQUFHbFEsb1JBQW9CQSxJQUMvRXNuQixTQUFTLENBQUMsQ0FBQ3lxQjtnQkFDWix1QkFBdUI7Z0JBQ3ZCLElBQUksQ0FBQ25vQix5QkFBeUI7b0JBQzFCQSwwQkFDSW1vQiwrQkFBK0J2MUIsZ0JBQWdCdU4sT0FBTztvQkFDMUQ7Z0JBQ0o7Z0JBQ0FILDBCQUNJbW9CLCtCQUErQnYxQixnQkFBZ0J1TixPQUFPO2dCQUMxRCxJQUFJZ29CLGdDQUFnQ3YxQixnQkFBZ0JxTixTQUFTLEVBQUU7b0JBQzNELE9BQU82bkIsMkJBQTJCajFCLGFBQWF1MUIsTUFBTSxFQUFFcnJDO2dCQUMzRDtnQkFDQStxQywyQkFBMkJqMUIsYUFBYXUxQixNQUFNLEVBQUU7b0JBQzVDdGpDLE9BQU84aUMsYUFBYVMsV0FBVztvQkFDL0J0akMsUUFBUTZpQyxhQUFhVSxZQUFZO2dCQUNyQztZQUNKO1lBQ0osSUFBSUM7WUFDSixNQUFNQyxpQkFBaUJYLGlCQUFpQnhnQixrQkFBa0IsR0FDcEQsT0FDQSxJQUFJb2hCLGVBQWU7Z0JBQ2pCLE1BQU1DLG9CQUFvQixDQUFDLEVBQUVkLGFBQWFTLFdBQVcsQ0FBQyxDQUFDLEVBQUVULGFBQWFVLFlBQVksQ0FBQyxDQUFDO2dCQUNwRix1QkFBdUI7Z0JBQ3ZCLElBQUksQ0FBQ0MsZ0JBQWdCO29CQUNqQkEsaUJBQWlCRztvQkFDakI7Z0JBQ0o7Z0JBQ0EsSUFBSUgsbUJBQW1CRyxxQkFDbkIxb0IsNEJBQTRCcE4sZ0JBQWdCcU4sU0FBUyxFQUFFO29CQUN2RDtnQkFDSjtnQkFDQTZuQiwyQkFBMkJqMUIsYUFBYTgxQixJQUFJLEVBQUU7b0JBQzFDN2pDLE9BQU84aUMsYUFBYVMsV0FBVztvQkFDL0J0akMsUUFBUTZpQyxhQUFhVSxZQUFZO2dCQUNyQztnQkFDQUMsaUJBQWlCRztZQUNyQjtZQUNKRixnQkFBZ0IvQixRQUFRbUI7WUFDeEIsMkRBQTJEO1lBQzNELGtFQUFrRTtZQUNsRSxNQUFNZ0IsOEJBQThCZixpQkFBaUJ4Z0Isa0JBQWtCLEdBQ2pFLE9BQ0E0Z0IsYUFDR2poQixJQUFJLENBQUMxd0IsdVJBQXVCQSxDQUFDLG9CQUFvQkosbVFBQUtBLENBQUMsQ0FBQzBwQixJQUFNQSxFQUFFL2IsZUFBZSxDQUFDbVQsUUFBUSxDQUFDMVEsY0FBYyxlQUN0RzlELFVBQVVzYSxLQUFLLEdBQ2Z0YSxVQUFVb2EsWUFBWSxJQUFJeG1CLG9SQUFvQkEsSUFDL0NzbkIsU0FBUyxDQUFDLENBQUMwVDtnQkFDWixJQUFJQSxjQUFjO29CQUNkLGtEQUFrRDtvQkFDbEQwVywyQkFBMkJqMUIsYUFBYWcyQixJQUFJLEVBQUU7d0JBQzFDL2pDLE9BQU84aUMsYUFBYVMsV0FBVzt3QkFDL0J0akMsUUFBUTZpQyxhQUFhVSxZQUFZO29CQUNyQztnQkFDSixPQUNLO29CQUNELGtEQUFrRDtvQkFDbERSLDJCQUEyQmoxQixhQUFhZzJCLElBQUksRUFBRTlyQztnQkFDbEQ7WUFDSjtZQUNKNnFDLGFBQWFrQixRQUFRLEdBQUc7WUFDeEJsQixhQUFhbUIsV0FBVyxHQUFHO1lBQzNCLHNFQUFzRTtZQUN0RSxrQ0FBa0M7WUFDbEMsb0VBQW9FO1lBQ3BFbkIsYUFBYXg5QixLQUFLLEdBQUc7WUFDckIsTUFBTTQrQixxQkFBcUJmLGFBQ3RCamhCLElBQUksQ0FBQzF3Qix1UkFBdUJBLENBQUNnUSxjQUFjLGVBQWUsZ0JBQWdCLHNCQUMxRW9YLFNBQVMsQ0FBQyxDQUFDa0M7Z0JBQ1osTUFBTXFwQixTQUFTM2lDLGNBQWMsZUFBZXNaLEVBQUU0aUIsV0FBVyxHQUFHNWlCLEVBQUVzcEIsaUJBQWlCO2dCQUMvRSxJQUFJdEIsYUFBYXVCLFNBQVMsS0FBS0YsUUFDM0I7Z0JBQ0pyQixhQUFhdUIsU0FBUyxHQUFHRixVQUFVO2dCQUNuQyxJQUFJcEMsY0FBY0MsYUFBYTtvQkFDM0IvUixXQUFXO3dCQUNQNlMsYUFBYXVCLFNBQVMsR0FBR0YsVUFBVTt3QkFDbkNyQixhQUFhd0IsSUFBSSxHQUFHM2UsS0FBSyxDQUFDLENBQUNwbUI7NEJBQ3ZCLElBQUksQ0FBQzZSLE1BQU0sQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsRUFBRTdSO3dCQUNqRDtvQkFDQSxvREFBb0Q7b0JBQ3BELHdEQUF3RDtvQkFDeEQsMENBQTBDO29CQUM5QyxHQUFHO2dCQUNQO1lBQ0o7WUFDQSxPQUFPO2dCQUNIeWpDLDJCQUEyQmoxQixhQUFhZzJCLElBQUksRUFBRTlyQztnQkFDOUNtckMscUNBQXFDdnFCO2dCQUNyQ2lyQiw2QkFBNkJqckI7Z0JBQzdCcXJCLG1CQUFtQnJyQixXQUFXO2dCQUM5QjZxQixnQkFBZ0J4QztZQUNwQjtRQUNKO1FBQ0E7Ozs7Ozs7Ozs7U0FVQyxHQUNELElBQUksQ0FBQ3FELGdCQUFnQixHQUFHLENBQUNDLGNBQWMzbEMsV0FBVzJDO1lBQzlDLE1BQU15SSxjQUFjLElBQUksQ0FBQ2tKLElBQUksQ0FBQ3lLLEtBQUssQ0FBQ08sMEJBQTBCLENBQUN0ZjtZQUMvRCxJQUFJLENBQUNvTCxlQUFlQSxZQUFZc1ksa0JBQWtCLEVBQzlDO1lBQ0osTUFBTTRnQixlQUFlLElBQUksQ0FBQ2h3QixJQUFJLENBQUN5SyxLQUFLLENBQUNvRSxhQUFhLENBQUNFLElBQUksQ0FBQzl3QixtUUFBS0EsQ0FBQyxDQUFDK00sZUFBaUJBLGFBQWEzRCxJQUFJLENBQUMsQ0FBQ3NnQixJQUFNQSxFQUFFamMsU0FBUyxLQUFLQSxhQUFhdE4seVFBQVNBLENBQUMsQ0FBQ3VwQixJQUFNLENBQUMsQ0FBQ0EsSUFBSXhwQixvUkFBb0JBLElBQUlELDJRQUFXQSxDQUFDO2dCQUFFK3dCLFlBQVk7Z0JBQUdDLFVBQVU7WUFBSztZQUNqTyxNQUFNb2lCLGdDQUFnQ3RCLGFBQ2pDamhCLElBQUksQ0FBQzF3Qix1UkFBdUJBLENBQUNnUSxjQUFjLDBCQUMxQywyQkFDQSxnQkFDRG9YLFNBQVMsQ0FBQyxDQUFDa0M7Z0JBQ1osTUFBTXFwQixTQUFTM2lDLGNBQWMsMEJBQ3ZCc1osRUFBRTRwQixzQkFBc0IsR0FDeEI1cEIsRUFBRThpQixXQUFXO2dCQUNuQixJQUFJNEcsYUFBYUgsU0FBUyxLQUFLRixRQUMzQjtnQkFDSmxVLFdBQVc7b0JBQ1B1VSxhQUFhSCxTQUFTLEdBQUdGLFVBQVU7b0JBQ25DLElBQUlLLGFBQWFILFNBQVMsRUFBRTt3QkFDeEJHLGFBQWFGLElBQUksR0FBRzNlLEtBQUssQ0FBQyxDQUFDcG1COzRCQUN2QixJQUFJLENBQUM2UixNQUFNLENBQUMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLEVBQUU3Ujt3QkFDakQ7d0JBQ0EscUVBQXFFO3dCQUNyRSw4REFBOEQ7d0JBQzlELGlEQUFpRDt3QkFDakQsTUFBTSxFQUFFb2xDLGNBQWMsRUFBRSxHQUFHLElBQUksQ0FBQ3h4QixJQUFJLENBQUN5eEIsT0FBTyxDQUFDaG5CLEtBQUs7d0JBQ2xELElBQUkrbUIsa0JBQWtCLGVBQWVILGNBQWM7NEJBQy9DLG1EQUFtRDs0QkFDbkRBLGFBQWFLLFNBQVMsQ0FBQ0Y7d0JBQzNCO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxNQUFNRyxxQkFBcUIsQ0FBRSxnQkFBZU4sWUFBVyxJQUNqRCxPQUNBLElBQUksQ0FBQ3J4QixJQUFJLENBQUN5eEIsT0FBTyxDQUFDaG5CLEtBQUssQ0FBQ21uQixlQUFlLENBQUNuc0IsU0FBUyxDQUFDLENBQUNvc0I7Z0JBQ2pELElBQUlBLFVBQVU7b0JBQ1YsbURBQW1EO29CQUNuRFIsYUFBYUssU0FBUyxDQUFDRztnQkFDM0I7WUFDSjtZQUNKLE1BQU1DLHFCQUFxQixJQUFJLENBQUM5eEIsSUFBSSxDQUFDeXhCLE9BQU8sQ0FBQ2huQixLQUFLLENBQUNzbkIsT0FBTyxDQUFDdHNCLFNBQVMsQ0FBQyxDQUFDdXNCO2dCQUNsRVgsYUFBYVcsTUFBTSxHQUFHQTtZQUMxQjtZQUNBWCxhQUFhUixRQUFRLEdBQUc7WUFDeEIsT0FBTztnQkFDSGMsb0JBQW9CanNCO2dCQUNwQm9zQixtQkFBbUJwc0IsV0FBVztnQkFDOUI0ckIsOEJBQThCNXJCLFdBQVc7WUFDN0M7UUFDSjtRQUNBLElBQUksQ0FBQzFGLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTWl5QjtJQUNGN3VDLGFBQWM7UUFDVixJQUFJLENBQUM4dUMsV0FBVyxHQUFHLEVBQUU7UUFDckI7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUNEO1lBQ25CLElBQUksQ0FBQ0EsV0FBVyxHQUFHQSxlQUFlLEVBQUU7UUFDeEM7UUFDQTs7O1NBR0MsR0FDRCxJQUFJLENBQUNFLGVBQWUsR0FBRyxDQUFDbnZCO1lBQ3BCLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtRQUNwQjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNvakIsYUFBYSxHQUFHLENBQUNnTTtZQUNsQixPQUFPLElBQUksQ0FBQ0gsV0FBVyxDQUFDbnpCLFFBQVEsQ0FBQ3N6QjtRQUNyQztRQUNBOzs7Ozs7U0FNQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUNELFlBQVlwdkIsV0FBVyxJQUFJLENBQUNBLFFBQVE7WUFDbkQsSUFBSSxDQUFDQSxVQUNELE9BQU87WUFDWCxNQUFNLEVBQUVzdkIsS0FBSyxFQUFFcGEsS0FBSyxFQUFFcWEsYUFBYSxFQUFFLEdBQUd2dkI7WUFDeEMsT0FBUW92QjtnQkFDSixLQUFLL3hDLGNBQWNhLFVBQVU7b0JBQ3pCLE9BQU9veEMsTUFBTUUsc0JBQXNCO2dCQUN2QyxLQUFLbnlDLGNBQWNjLFVBQVU7b0JBQ3pCLE9BQU8rMkIsTUFBTXNhLHNCQUFzQjtnQkFDdkMsS0FBS255QyxjQUFjWSxXQUFXO29CQUMxQixPQUFPc3hDLGNBQWNDLHNCQUFzQjtnQkFDL0M7b0JBQ0ksT0FBTztZQUNmO1FBQ0o7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0R0dkMsWUFBWUUsSUFBSSxFQUFFUSxVQUFVO1FBQ3hCa21CLG9CQUFvQjdCO0lBQ3hCLENBQUMsQ0FBRTtRQUNDLElBQUksQ0FBQzdrQixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDUSxPQUFPLEdBQUdBO0lBQ25CO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCxNQUFNNnVDO0lBQ0Y7Ozs7S0FJQyxHQUNEdnZDLFlBQVl3dkMsU0FBUyxDQUFFO1FBQ25COzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDQztZQUNiLElBQUksQ0FBQ0YsU0FBUyxDQUFDRSxTQUFTeHZDLElBQUksQ0FBQyxHQUFHd3ZDO1FBQ3BDO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUN6dkM7WUFDZixPQUFPLElBQUksQ0FBQ3N2QyxTQUFTLENBQUN0dkMsS0FBSztRQUMvQjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUM0NEIsR0FBRyxHQUFHLENBQUM1NEI7WUFDUixJQUFJLENBQUMsSUFBSSxDQUFDc3ZDLFNBQVMsQ0FBQ3R2QyxLQUFLLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBQ3V2QyxRQUFRLENBQUMsSUFBSUgsU0FBU3B2QztZQUMvQjtZQUNBLE9BQU8sSUFBSSxDQUFDc3ZDLFNBQVMsQ0FBQ3R2QyxLQUFLO1FBQy9CO1FBQ0EsSUFBSSxDQUFDc3ZDLFNBQVMsR0FBR0EsVUFBVTFuQixNQUFNLENBQUMsQ0FBQ2lpQixLQUFLMkY7WUFDcEMzRixHQUFHLENBQUMyRixTQUFTeHZDLElBQUksQ0FBQyxHQUFHd3ZDO1lBQ3JCLE9BQU8zRjtRQUNYLEdBQUcsQ0FBQztJQUNSO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRCxNQUFNNkYsWUFBWSxJQUFJTCxrQkFBa0I7SUFDcEMsSUFBSUQsU0FBUyxXQUFXO1FBQ3BCMW9CLG9CQUFvQjdCO0lBQ3hCO0lBQ0EsSUFBSXVxQixTQUFTLGVBQWU7UUFDeEIxb0Isb0JBQW9CN0I7SUFDeEI7SUFDQSxJQUFJdXFCLFNBQVMsY0FBYztRQUN2QjFvQixvQkFBb0IxQjtJQUN4QjtJQUNBLElBQUlvcUIsU0FBUyxjQUFjO1FBQ3ZCMW9CLG9CQUFvQjFCO0lBQ3hCO0NBQ0g7QUFFRDs7Ozs7O0NBTUMsR0FDRCxNQUFNMnFCLGFBQWEsQ0FBQ0MsYUFBYTN2QztJQUM3QixPQUFPLElBQUkvRSxzUUFBVUEsQ0FBQyxDQUFDOHFDO1FBQ25CLE1BQU02SixZQUFZO1lBQ2QsSUFBSUMsVUFBVSxNQUFNOTJCLFVBQVUrMkIsWUFBWSxDQUFDQyxnQkFBZ0I7WUFDM0Qsc0RBQXNEO1lBQ3RELGtFQUFrRTtZQUNsRSxzQ0FBc0M7WUFDdEMsTUFBTUMsb0JBQW9CSCxRQUFReHJCLElBQUksQ0FBQyxDQUFDM1gsU0FBV0EsT0FBTzFNLElBQUksS0FBS0EsUUFBUTBNLE9BQU91akMsS0FBSyxLQUFLO1lBQzVGLElBQUlELG1CQUFtQjtnQkFDbkIsSUFBSTViO2dCQUNKLElBQUk7b0JBQ0FBLGNBQWMsTUFBTXJiLFVBQVUrMkIsWUFBWSxDQUFDSSxZQUFZLENBQUNQO29CQUN4REUsVUFBVSxNQUFNOTJCLFVBQVUrMkIsWUFBWSxDQUFDQyxnQkFBZ0I7Z0JBQzNELFNBQ1E7b0JBQ0osSUFBSTNiLGFBQ0ErYixxQkFBcUIvYjtnQkFDN0I7WUFDSjtZQUNBLE9BQU95YjtRQUNYO1FBQ0FELFlBQ0tuUSxJQUFJLENBQUMsQ0FBQ29RO1lBQ1Asa0NBQWtDO1lBQ2xDOUosV0FBV3J0QixJQUFJLENBQUNtM0I7WUFDaEI5SixXQUFXcUssUUFBUTtRQUN2QixHQUNLbmhCLEtBQUssQ0FBQyxDQUFDOWdCO1lBQ1IsTUFBTXVNLFNBQVNSLFVBQVU7Z0JBQUM7YUFBVTtZQUNwQ1EsT0FBTyxTQUFTLCtCQUErQnZNO1lBQy9DNDNCLFdBQVc1M0IsS0FBSyxDQUFDQTtRQUNyQjtJQUNKO0FBQ0o7QUFDQTs7O0lBR0ksR0FDSixNQUFNa2lDLG9DQUFvQztJQUN0QyxJQUFJLE9BQU9yRSxhQUFhLGFBQ3BCLE9BQU87SUFDWCxNQUFNZCxVQUFVYyxTQUFTc0UsYUFBYSxDQUFDO0lBQ3ZDLE9BQU8sZUFBZXBGO0FBQzFCO0FBQ0E7O0NBRUMsR0FDRCxNQUFNcUYseUJBQXlCO0lBQzNCdkIsT0FBTztRQUNId0IsaUJBQWlCO1FBQ2pCQyxrQkFBa0I7UUFDbEJDLGtCQUFrQjtJQUN0QjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxNQUFNQyx5QkFBeUI7SUFDM0IvYixPQUFPO1FBQ0h0ckIsT0FBTztRQUNQQyxRQUFRO0lBQ1o7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsTUFBTXFuQyxxQkFBcUIsQ0FBQ3p2QztJQUN4QixJQUFJMHZDO0lBQ0osT0FBTztRQUNILElBQUksQ0FBQ0EsVUFDREEsV0FBVzF2QztRQUNmLE9BQU8wdkM7SUFDWDtBQUNKO0FBQ0EsTUFBTUMsMEJBQTBCRixtQkFBbUI7SUFDL0Msa0VBQWtFO0lBQ2xFLDhEQUE4RDtJQUM5RCw2REFBNkQ7SUFDN0QsT0FBTyxJQUFJMzFDLHNRQUFVQSxDQUFDLENBQUM4cUM7UUFDbkIsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ2h0QixVQUFVKzJCLFlBQVksQ0FBQ3hjLGdCQUFnQixFQUN4QztRQUNKLE1BQU15ZCxTQUFTLElBQU1oTCxXQUFXcnRCLElBQUk7UUFDcENLLFVBQVUrMkIsWUFBWSxDQUFDeGMsZ0JBQWdCLENBQUMsZ0JBQWdCeWQ7UUFDeEQsT0FBTztZQUNIaDRCLFVBQVUrMkIsWUFBWSxDQUFDNWIsbUJBQW1CLENBQUMsZ0JBQWdCNmM7UUFDL0Q7SUFDSixHQUFHdmxCLElBQUksQ0FBQ3R3Qiw0UUFBWUEsQ0FBQyxNQUFNQyx5UUFBU0EsQ0FBQyxJQUFNSCxvUUFBSUEsQ0FBQytkLFVBQVUrMkIsWUFBWSxDQUFDQyxnQkFBZ0IsTUFBTXAxQywyUUFBV0EsQ0FBQztBQUM3RztBQUNBLE1BQU1xMkMsMEJBQTBCSixtQkFBbUI7SUFDL0MsT0FBTzcxQyxxUUFBS0EsQ0FBQzIwQyxXQUFXYSx3QkFBd0IsZUFBZU8sMkJBQTJCdGxCLElBQUksQ0FBQzd3QiwyUUFBV0EsQ0FBQztBQUMvRztBQUNBLE1BQU1zMkMsZ0NBQWdDTCxtQkFBbUI7SUFDckQsT0FBTzcxQyxxUUFBS0EsQ0FBQzIwQyxXQUFXYSx3QkFBd0IsZ0JBQWdCTywyQkFBMkJ0bEIsSUFBSSxDQUFDN3dCLDJRQUFXQSxDQUFDO0FBQ2hIO0FBQ0EsTUFBTXUyQywwQkFBMEJOLG1CQUFtQjtJQUMvQyxPQUFPNzFDLHFRQUFLQSxDQUFDMjBDLFdBQVdpQix3QkFBd0IsZUFBZUcsMkJBQTJCdGxCLElBQUksQ0FBQzd3QiwyUUFBV0EsQ0FBQztBQUMvRztBQUNBOztDQUVDLEdBQ0QsTUFBTXcyQyxrQkFBa0I7SUFDcEIsT0FBT0gsMEJBQTBCeGxCLElBQUksQ0FBQzl3QixtUUFBS0EsQ0FBQyxDQUFDb0ssU0FBV0EsT0FBT3hKLE1BQU0sQ0FBQyxDQUFDNkcsSUFBTUEsRUFBRW5DLElBQUksS0FBSztBQUM1RjtBQUNBOztDQUVDLEdBQ0QsTUFBTW94QyxrQkFBa0I7SUFDcEIsT0FBT0YsMEJBQTBCMWxCLElBQUksQ0FBQzl3QixtUUFBS0EsQ0FBQyxDQUFDb0ssU0FBV0EsT0FBT3hKLE1BQU0sQ0FBQyxDQUFDNkcsSUFBTUEsRUFBRW5DLElBQUksS0FBSztBQUM1RjtBQUNBOztDQUVDLEdBQ0QsTUFBTXF4Qyx3QkFBd0I7SUFDMUIsT0FBT0osZ0NBQWdDemxCLElBQUksQ0FBQzl3QixtUUFBS0EsQ0FBQyxDQUFDb0ssU0FBV0EsT0FBT3hKLE1BQU0sQ0FBQyxDQUFDNkcsSUFBTUEsRUFBRW5DLElBQUksS0FBSztBQUNsRztBQUNBLE1BQU1zeEMsWUFBWSxPQUFPM0I7SUFDckIsSUFBSTtRQUNBLE9BQU8sTUFBTTUyQixVQUFVKzJCLFlBQVksQ0FBQ0ksWUFBWSxDQUFDUDtJQUNyRCxFQUNBLE9BQU85bUMsR0FBRztRQUNOcVIsVUFBVTtZQUFDO1NBQVUsRUFBRSxTQUFTLENBQUMscUJBQXFCLENBQUMsRUFBRTtZQUNyRC9MLE9BQU90RjtZQUNQOG1DLGFBQWFBO1FBQ2pCO1FBQ0EsTUFBTTltQztJQUNWO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsTUFBTTBvQyxpQkFBaUIsT0FBT0M7SUFDMUIsTUFBTTdCLGNBQWM7UUFDaEJYLE9BQU87WUFDSCxHQUFHdUIsdUJBQXVCdkIsS0FBSztZQUMvQixHQUFHd0MsZ0JBQWdCO1FBQ3ZCO0lBQ0o7SUFDQSxPQUFPRixVQUFVM0I7QUFDckI7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsTUFBTThCLGlCQUFpQixPQUFPRDtJQUMxQixNQUFNN0IsY0FBYztRQUNoQi9hLE9BQU87WUFDSCxHQUFHK2IsdUJBQXVCL2IsS0FBSztZQUMvQixHQUFHNGMsZ0JBQWdCO1FBQ3ZCO0lBQ0o7SUFDQSxPQUFPRixVQUFVM0I7QUFDckI7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNK0IsdUJBQXVCLE9BQU9ueEM7SUFDaEMsSUFBSTtRQUNBLE9BQU8sTUFBTXdZLFVBQVUrMkIsWUFBWSxDQUFDNkIsZUFBZSxDQUFDO1lBQ2hEL2MsT0FBTztZQUNQb2EsT0FBTztnQkFDSHg1QixjQUFjO29CQUNWbzhCLE9BQU87Z0JBQ1g7Z0JBQ0FsQixrQkFBa0I7Z0JBQ2xCRixpQkFBaUI7Z0JBQ2pCQyxrQkFBa0I7WUFDdEI7WUFDQSw4Q0FBOEM7WUFDOUNvQixhQUFhO1lBQ2IsR0FBR3R4QyxPQUFPO1FBQ2Q7SUFDSixFQUNBLE9BQU9zSSxHQUFHO1FBQ05xUixVQUFVO1lBQUM7U0FBVSxFQUFFLFNBQVMscUNBQXFDclI7UUFDckUsTUFBTUE7SUFDVjtBQUNKO0FBQ0EsTUFBTWlwQyxhQUFhLE9BQU8vNEIsY0FBYyxlQUNwQyxPQUFPQSxVQUFVKzJCLFlBQVksS0FBSyxjQUNoQ2MsbUJBQW1CLElBQU03MUMscVFBQUtBLENBQUNDLG9RQUFJQSxDQUFDK2QsVUFBVSsyQixZQUFZLENBQUNDLGdCQUFnQixLQUFLZSwyQkFBMkJ0bEIsSUFBSSxDQUFDN3dCLDJRQUFXQSxDQUFDLFNBQzVINEc7QUFDTjs7Ozs7Q0FLQyxHQUNELE1BQU00dUMsdUJBQXVCLENBQUN0RztJQUMxQixJQUFJLENBQUNBLE9BQU96ekIsTUFBTSxFQUNkO0lBQ0p5ekIsT0FBT3hPLFNBQVMsR0FBR25nQixPQUFPLENBQUMsQ0FBQ21aO1FBQ3hCQSxNQUFNblksSUFBSTtRQUNWMnRCLE9BQU96VCxXQUFXLENBQUMvQjtJQUN2QjtJQUNBLHdHQUF3RztJQUN4RyxJQUFJLE9BQU93VixPQUFPa0ksT0FBTyxLQUFLLFlBQVk7UUFDdEMsbUJBQW1CO1FBQ25CbEksT0FBT2tJLE9BQU87SUFDbEI7QUFDSjtBQUVBLE1BQU1DO0lBQ0ZueUMsWUFBWTRjLElBQUksRUFBRXlLLEtBQUssRUFBRXBjLFNBQVMsQ0FBRTtRQUNoQyxJQUFJLENBQUMyUixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDeUssS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3BjLFNBQVMsR0FBR0E7UUFDakI7O1NBRUMsR0FDRCxJQUFJLENBQUNtbkMsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQzc5QixhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUM4OUIsMkJBQTJCLEdBQUc7UUFDbkMsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN2QixJQUFJLENBQUMvOUIsYUFBYSxDQUFDOEcsT0FBTyxDQUFDLENBQUMrQyxJQUFNQSxFQUFFa0UsV0FBVztRQUNuRDtRQUNBLElBQUksQ0FBQ3pILE1BQU0sR0FBR1IsVUFBVTtZQUFDLENBQUMsRUFBRWxULFNBQVMsQ0FBQzhELFVBQVUsQ0FBQ21PLFdBQVcsR0FBRyxRQUFRLENBQUM7U0FBQztRQUN6RSxJQUFJNjRCLGNBQ0EsQ0FBQ2g1QixtQkFDQSxLQUFJLENBQUNoTyxTQUFTLEtBQUs5RCxVQUFVdWEsS0FBSyxJQUFJLElBQUksQ0FBQ3pXLFNBQVMsS0FBSzlELFVBQVVzYSxLQUFLLEdBQUc7WUFDNUUsSUFBSSxDQUFDOHdCLG1DQUFtQztRQUM1QztJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0RDLGNBQWM7UUFDVixPQUFPLElBQUksQ0FBQzNDLFVBQVU7SUFDMUI7SUFDQTs7S0FFQyxHQUNELE1BQU10ZSxTQUFTO1FBQ1gsSUFBSSxJQUFJLENBQUNsSyxLQUFLLENBQUNvckIsTUFBTSxLQUFLLFdBQ3RCO1FBQ0osSUFBSSxDQUFDQyxhQUFhLEdBQUcsSUFBSSxDQUFDQyxZQUFZO1FBQ3RDLElBQUk7WUFDQSxNQUFNLElBQUksQ0FBQ0QsYUFBYTtZQUN4QixJQUFJLENBQUNyckIsS0FBSyxDQUFDdXJCLFNBQVMsQ0FBQztZQUNyQixJQUFJLENBQUNGLGFBQWEsR0FBR2h4QztRQUN6QixFQUNBLE9BQU80TSxPQUFPO1lBQ1YsSUFBSSxDQUFDb2tDLGFBQWEsR0FBR2h4QztZQUNyQixNQUFNNE07UUFDVjtJQUNKO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTWsxQixRQUFRcVAsWUFBWSxLQUFLLEVBQUU7UUFDN0IsSUFBSSxDQUFDeHJCLEtBQUssQ0FBQ3lyQixVQUFVLEdBQUcsSUFBSSxDQUFDenJCLEtBQUssQ0FBQ29yQixNQUFNO1FBQ3pDLElBQUksQ0FBQ0ksYUFBYSxJQUFJLENBQUN4ckIsS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxZQUNwQztRQUNKLE1BQU16ZSxhQUFhNmUsYUFBYSxJQUFJLENBQUN4ckIsS0FBSyxDQUFDMHJCLFdBQVcsS0FBSztRQUMzRCxJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJLENBQUNDLFVBQVUsQ0FBQ2pmO1FBQ3RDLElBQUk7WUFDQSxNQUFNLElBQUksQ0FBQ2dmLGNBQWM7WUFDekIsSUFBSSxDQUFDM3JCLEtBQUssQ0FBQ3VyQixTQUFTLENBQUM7WUFDckIsSUFBSSxDQUFDSSxjQUFjLEdBQUd0eEM7UUFDMUIsRUFDQSxPQUFPNE0sT0FBTztZQUNWLElBQUksQ0FBQzBrQyxjQUFjLEdBQUd0eEM7WUFDdEIsTUFBTTRNO1FBQ1Y7SUFDSjtJQUNBOztLQUVDLEdBQ0QsTUFBTTRrQyxTQUFTO1FBQ1gsSUFBSSxJQUFJLENBQUM3ckIsS0FBSyxDQUFDeXJCLFVBQVUsS0FBSyxhQUMxQixJQUFJLENBQUN6ckIsS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxZQUFZO1lBQ2xDLE1BQU0sSUFBSSxDQUFDbGhCLE1BQU07UUFDckI7SUFDSjtJQUNBOzs7S0FHQyxHQUNELE1BQU00aEIsU0FBUztRQUNYLElBQUksSUFBSSxDQUFDOXJCLEtBQUssQ0FBQ29yQixNQUFNLEtBQUssV0FBVztZQUNqQyxPQUFPLElBQUksQ0FBQ2pQLE9BQU87UUFDdkIsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDalMsTUFBTTtRQUN0QjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNENmhCLHNCQUFzQnRELFdBQVcsRUFBRTtRQUMvQixJQUFJLENBQUN6b0IsS0FBSyxDQUFDK3JCLHFCQUFxQixDQUFDdEQ7SUFDckM7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU11RCxPQUFPNUUsUUFBUSxFQUFFO1FBQ25CLElBQUl4MUIsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSXBaLE1BQU07UUFDcEI7UUFDQSxJQUFJNHVDLGFBQWEsSUFBSSxDQUFDcG5CLEtBQUssQ0FBQyttQixjQUFjLEVBQUU7WUFDeEM7UUFDSjtRQUNBLElBQUksQ0FBQy9tQixLQUFLLENBQUNpc0IsU0FBUyxDQUFDN0U7UUFDckIsTUFBTSxJQUFJLENBQUM4RSxxQkFBcUI7SUFDcEM7SUFDQSxNQUFNQSx3QkFBd0I7UUFDMUIsSUFBSSxJQUFJLENBQUNsc0IsS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxXQUFXO1lBQ2pDLE1BQU0sSUFBSSxDQUFDUSxVQUFVO1lBQ3JCLE1BQU0sSUFBSSxDQUFDTixZQUFZO1FBQzNCO0lBQ0o7SUFDQW5YLFlBQVk7UUFDUixPQUFPLElBQUksQ0FBQ25VLEtBQUssQ0FBQ2tOLFdBQVcsRUFBRWlILGVBQWUsRUFBRTtJQUNwRDtJQUNBLE1BQU15WCxXQUFXamYsYUFBYSxJQUFJLEVBQUU7UUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQzNNLEtBQUssQ0FBQ2tOLFdBQVcsRUFDdkI7UUFDSixJQUFJLENBQUMxWixNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUVtWixhQUFhLGFBQWEsWUFBWSxPQUFPLENBQUM7UUFDdEUsSUFBSSxJQUFJLENBQUNwWCxJQUFJLENBQUN5SyxLQUFLLENBQUMyRyxZQUFZLEtBQUs3SSxhQUFhK2MsTUFBTSxFQUFFO1lBQ3RELE1BQU0sSUFBSSxDQUFDc1IsaUJBQWlCLENBQUN4ZjtRQUNqQztRQUNBLElBQUksQ0FBQ3lmLGVBQWUsQ0FBQ3pmO1FBQ3JCLE1BQU0wZixXQUFXLElBQUksQ0FBQ2xZLFNBQVMsR0FBR3VHLEtBQUssQ0FBQyxDQUFDM2xCLElBQU1BLEVBQUVzWSxVQUFVLEtBQUs7UUFDaEUsSUFBSWdmLFVBQVU7WUFDVixJQUFJLElBQUksQ0FBQ3JzQixLQUFLLENBQUNrTixXQUFXLElBQ3RCLCtEQUErRDtZQUMvRCxPQUFPLElBQUksQ0FBQ2xOLEtBQUssQ0FBQ2tOLFdBQVcsQ0FBQzJkLE9BQU8sS0FBSyxZQUFZO2dCQUN0RCxzREFBc0Q7Z0JBQ3RELElBQUksQ0FBQzdxQixLQUFLLENBQUNrTixXQUFXLENBQUMyZCxPQUFPO1lBQ2xDO1lBQ0EsSUFBSSxDQUFDN3FCLEtBQUssQ0FBQ3NzQixjQUFjLENBQUNqeUM7UUFDOUI7SUFDSjtJQUNBa3lDLGFBQWE7UUFDVCxJQUFJLENBQUNwWSxTQUFTLEdBQUduZ0IsT0FBTyxDQUFDLENBQUNtWjtZQUN0QixJQUFJQSxNQUFNYyxPQUFPLEVBQ2JkLE1BQU1jLE9BQU8sR0FBRztRQUN4QjtJQUNKO0lBQ0F1ZSxlQUFlO1FBQ1gsSUFBSSxDQUFDclksU0FBUyxHQUFHbmdCLE9BQU8sQ0FBQyxDQUFDbVo7WUFDdEIsSUFBSSxDQUFDQSxNQUFNYyxPQUFPLEVBQ2RkLE1BQU1jLE9BQU8sR0FBRztRQUN4QjtJQUNKO0lBQ0F0QixhQUFhO1FBQ1QsSUFBSSxDQUFDd0gsU0FBUyxHQUFHbmdCLE9BQU8sQ0FBQyxDQUFDbVo7WUFDdEIsSUFBSUEsTUFBTUUsVUFBVSxLQUFLLFFBQ3JCRixNQUFNblksSUFBSTtRQUNsQjtJQUNKO0lBQ0FvM0IsZ0JBQWdCemYsVUFBVSxFQUFFO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMzTSxLQUFLLENBQUNrTixXQUFXLEVBQUU7WUFDekI7UUFDSjtRQUNBLElBQUlQLFlBQVk7WUFDWixJQUFJLENBQUNBLFVBQVU7UUFDbkIsT0FDSztZQUNELElBQUksQ0FBQzRmLFVBQVU7UUFDbkI7SUFDSjtJQUNBLE1BQU1qQixlQUFlO1FBQ2pCLElBQUksQ0FBQzkzQixNQUFNLENBQUMsU0FBUztRQUNyQixJQUFJbXZCO1FBQ0osSUFBSSxJQUFJLENBQUMzaUIsS0FBSyxDQUFDa04sV0FBVyxJQUN0QixJQUFJLENBQUNpSCxTQUFTLEdBQUd1RyxLQUFLLENBQUMsQ0FBQzNsQixJQUFNQSxFQUFFc1ksVUFBVSxLQUFLLFNBQVM7WUFDeERzVixTQUFTLElBQUksQ0FBQzNpQixLQUFLLENBQUNrTixXQUFXO1lBQy9CLElBQUksQ0FBQ3NmLFlBQVk7UUFDckIsT0FDSztZQUNELE1BQU1DLHFCQUFxQixJQUFJLENBQUN6c0IsS0FBSyxDQUFDeXNCLGtCQUFrQjtZQUN4RCxNQUFNaEUsY0FBYztnQkFDaEIsR0FBR2dFLGtCQUFrQjtnQkFDckJyRixVQUFVLElBQUksQ0FBQ3BuQixLQUFLLENBQUMrbUIsY0FBYztZQUN2QztZQUNBcEUsU0FBUyxNQUFNLElBQUksQ0FBQ3lILFNBQVMsQ0FBQzNCO1FBQ2xDO1FBQ0EsSUFBSSxJQUFJLENBQUNsekIsSUFBSSxDQUFDeUssS0FBSyxDQUFDMkcsWUFBWSxLQUFLN0ksYUFBYStjLE1BQU0sRUFBRTtZQUN0RCxNQUFNLElBQUksQ0FBQzVOLGFBQWEsQ0FBQzBWO1FBQzdCO1FBQ0EsSUFBSSxJQUFJLENBQUMzaUIsS0FBSyxDQUFDa04sV0FBVyxLQUFLeVYsUUFBUTtZQUNuQyxJQUFJLENBQUMzaUIsS0FBSyxDQUFDc3NCLGNBQWMsQ0FBQzNKO1lBQzFCLElBQUksQ0FBQ3hPLFNBQVMsR0FBR25nQixPQUFPLENBQUMsQ0FBQ21aO2dCQUN0QkEsTUFBTWYsZ0JBQWdCLENBQUMsU0FBUztvQkFDNUIsSUFBSSxJQUFJLENBQUNpZixhQUFhLEVBQUU7d0JBQ3BCLE1BQU0sSUFBSSxDQUFDQSxhQUFhO29CQUM1QjtvQkFDQSxJQUFJLElBQUksQ0FBQ00sY0FBYyxFQUFFO3dCQUNyQixNQUFNLElBQUksQ0FBQ0EsY0FBYztvQkFDN0I7b0JBQ0EsSUFBSSxJQUFJLENBQUMzckIsS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxXQUFXO3dCQUNqQyxJQUFJLENBQUNKLDJCQUEyQixHQUFHO3dCQUNuQzNZLFdBQVc7NEJBQ1AsSUFBSSxDQUFDMlksMkJBQTJCLEdBQUc7d0JBQ3ZDLEdBQUc7d0JBQ0gsTUFBTSxJQUFJLENBQUM3TyxPQUFPO29CQUN0QjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLElBQUl1USxrQkFBa0I7UUFDbEIsSUFBSSxJQUFJLENBQUM5b0MsU0FBUyxLQUFLOUQsVUFBVXVhLEtBQUssRUFBRTtZQUNwQyxPQUFPO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ3pXLFNBQVMsS0FBSzlELFVBQVVzYSxLQUFLLEVBQUU7WUFDcEMsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0E4d0Isc0NBQXNDO1FBQ2xDLElBQUksQ0FBQ2grQixhQUFhLENBQUNyUCxJQUFJLENBQUN4Syw2UUFBYUEsQ0FBQztZQUNsQ3UzQyxXQUFXdG1CLElBQUksQ0FBQ3B3Qix3UUFBUUE7WUFDeEIsSUFBSSxDQUFDOHJCLEtBQUssQ0FBQ21uQixlQUFlO1NBQzdCLEVBQUVuc0IsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDMnhCLGFBQWFDLGVBQWUsRUFBRXhGLFNBQVM7WUFDekQsSUFBSSxDQUFDQSxVQUFVO2dCQUNYO1lBQ0o7WUFDQSxJQUFJLElBQUksQ0FBQ2lFLGFBQWEsRUFBRTtnQkFDcEIsTUFBTSxJQUFJLENBQUNBLGFBQWE7WUFDNUI7WUFDQSxJQUFJLElBQUksQ0FBQ00sY0FBYyxFQUFFO2dCQUNyQixNQUFNLElBQUksQ0FBQ0EsY0FBYztZQUM3QjtZQUNBLElBQUlrQix1QkFBdUI7WUFDM0IsSUFBSUMsbUJBQW1CO1lBQ3ZCLE1BQU1DLGdCQUFnQixJQUFJLENBQUNDLGdCQUFnQixDQUFDSixnQkFBZ0J4RjtZQUM1RCxNQUFNNkYsYUFBYSxJQUFJLENBQUNELGdCQUFnQixDQUFDTCxhQUFhdkY7WUFDdEQsSUFBSSxDQUFDMkYsaUJBQWlCRSxZQUFZO2dCQUM5QkosdUJBQXVCO1lBQzNCLE9BQ0ssSUFBSUUsaUJBQ0xFLGNBQ0FGLGNBQWMzRixRQUFRLEtBQUs2RixXQUFXN0YsUUFBUSxJQUM5QzJGLGNBQWNHLE9BQU8sS0FBS0QsV0FBV0MsT0FBTyxFQUFFO2dCQUM5Q0osbUJBQW1CO1lBQ3ZCO1lBQ0EsSUFBSUQsc0JBQXNCO2dCQUN0QixNQUFNLElBQUksQ0FBQzFRLE9BQU87Z0JBQ2xCLElBQUksQ0FBQzZQLE1BQU0sQ0FBQzN4QztZQUNoQjtZQUNBLElBQUl5eUMsa0JBQWtCO2dCQUNsQixJQUFJLElBQUksQ0FBQzlCLDJCQUEyQixJQUNoQyxJQUFJLENBQUNockIsS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxZQUFZO29CQUNsQyxNQUFNLElBQUksQ0FBQ2xoQixNQUFNO29CQUNqQixJQUFJLENBQUM4Z0IsMkJBQTJCLEdBQUc7Z0JBQ3ZDLE9BQ0s7b0JBQ0QsTUFBTSxJQUFJLENBQUNrQixxQkFBcUI7Z0JBQ3BDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FjLGlCQUFpQnJFLE9BQU8sRUFBRXZCLFFBQVEsRUFBRTtRQUNoQyxPQUFPdUIsUUFBUS9yQyxJQUFJLENBQUMsQ0FBQzNCLElBQU1BLEVBQUVtc0MsUUFBUSxLQUFLQSxZQUFZbnNDLEVBQUVuQyxJQUFJLEtBQUssSUFBSSxDQUFDNHpDLGVBQWU7SUFDekY7QUFDSjtBQUVBLE1BQU1TO0lBQ0Y7Ozs7OztLQU1DLEdBQ0R4MEMsWUFBWSt5QyxjQUFjLGFBQWEsRUFBRTBCLGlCQUFpQi95QyxTQUFTLENBQUU7UUFDakUsSUFBSSxDQUFDcXhDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDMEIsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRyxJQUFJLzVDLDJRQUFlQSxDQUFDK0c7UUFDekMsSUFBSSxDQUFDaXpDLGtCQUFrQixHQUFHLElBQUloNkMsMlFBQWVBLENBQUMrRztRQUM5QyxJQUFJLENBQUNrekMscUJBQXFCLEdBQUcsSUFBSWo2QywyUUFBZUEsQ0FBQytHO1FBQ2pELElBQUksQ0FBQ216Qyx5QkFBeUIsR0FBRyxJQUFJbDZDLDJRQUFlQSxDQUFDK0c7UUFDckQ7OztTQUdDLEdBQ0QsSUFBSSxDQUFDb3pDLFlBQVksR0FBRyxJQUFJLENBQUNILGtCQUFrQixDQUFDanBCLFlBQVk7UUFDeEQ7O1NBRUMsR0FDRCxJQUFJLENBQUM4aUIsZUFBZSxHQUFHLElBQUksQ0FBQ29HLHFCQUFxQixDQUM1Q2xwQixZQUFZLEdBQ1pDLElBQUksQ0FBQzV3QixvUkFBb0JBO1FBQzlCOztTQUVDLEdBQ0QsSUFBSSxDQUFDZzZDLE9BQU8sR0FBRyxJQUFJLENBQUNMLGFBQWEsQ0FBQ2hwQixZQUFZLEdBQUdDLElBQUksQ0FBQzV3QixvUkFBb0JBO1FBQzFFOztTQUVDLEdBQ0QsSUFBSSxDQUFDaTZDLG1CQUFtQixHQUFHLElBQUksQ0FBQ0gseUJBQXlCLENBQUNucEIsWUFBWTtRQUN0RTs7O1NBR0MsR0FDRCxJQUFJLENBQUN1cEIscUJBQXFCLEdBQUcsSUFBSTc1QyxzUUFBVUEsQ0FBQyxDQUFDOHFDO1lBQ3pDLE1BQU1nUCxnQkFBZ0IsSUFBTWhQLFdBQVdydEIsSUFBSSxDQUFDO1lBQzVDLE1BQU1zOEIsMEJBQTBCLENBQUMsQ0FBQ2o4QixXQUFXNDFCLGFBQWFzRztZQUMxRCxJQUFJbjhCLG1CQUFtQixDQUFDLElBQUksQ0FBQ3c3QixjQUFjLElBQUksQ0FBQ1UseUJBQXlCO2dCQUNyRTk2QixVQUFVO29CQUFDO2lCQUFVLEVBQUUsUUFBUSxDQUFDLCtDQUErQyxDQUFDO2dCQUNoRixPQUFPNjZCO1lBQ1g7WUFDQSxJQUFJRztZQUNKLE1BQU1uRSxTQUFTLElBQU1oTCxXQUFXcnRCLElBQUksQ0FDcEMsaUVBQWlFO2dCQUNqRSxtREFBbUQ7Z0JBQ25ELDhFQUE4RTtnQkFDOUUyeUIsYUFDTTZKLGdCQUFnQmh1QixLQUFLLEtBQUssV0FDMUJndUIsZ0JBQWdCaHVCLEtBQUssS0FBSztZQUNoQ25PLFVBQVU0MUIsV0FBVyxDQUNoQnNHLEtBQUssQ0FBQztnQkFBRWwxQyxNQUFNLElBQUksQ0FBQ3UwQyxjQUFjO1lBQUMsR0FDbEM3VSxJQUFJLENBQUMsQ0FBQzBWO2dCQUNQRCxrQkFBa0JDO2dCQUNsQkQsZ0JBQWdCNWhCLGdCQUFnQixDQUFDLFVBQVV5ZDtnQkFDM0NBO1lBQ0osR0FDSzloQixLQUFLLENBQUM7Z0JBQ1Asc0VBQXNFO2dCQUN0RSwrQkFBK0I7Z0JBQy9CLDREQUE0RDtnQkFDNUQ4bEI7WUFDSjtZQUNBLE9BQU87Z0JBQ0hHLGlCQUFpQmhoQixvQkFBb0IsVUFBVTZjO1lBQ25EO1FBQ0osR0FBR3ZsQixJQUFJLENBQUM3d0IsMlFBQVdBLENBQUM7UUFDcEI7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNvbkIsZUFBZSxHQUFHQTtRQUN2Qjs7Ozs7Ozs7OztTQVVDLEdBQ0QsSUFBSSxDQUFDSyxlQUFlLEdBQUdBO0lBQzNCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJa3dCLFNBQVM7UUFDVCxPQUFPLElBQUksQ0FBQ3Z3QixlQUFlLENBQUMsSUFBSSxDQUFDNnlCLE9BQU87SUFDNUM7SUFDQTs7S0FFQyxHQUNELElBQUkzRyxpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNsc0IsZUFBZSxDQUFDLElBQUksQ0FBQ3NzQixlQUFlO0lBQ3BEO0lBQ0E7O0tBRUMsR0FDRCxJQUFJamEsY0FBYztRQUNkLE9BQU8sSUFBSSxDQUFDclMsZUFBZSxDQUFDLElBQUksQ0FBQzR5QixZQUFZO0lBQ2pEO0lBQ0E7OztLQUdDLEdBQ0RsQyxVQUFVSCxNQUFNLEVBQUU7UUFDZCxJQUFJLENBQUNsd0IsZUFBZSxDQUFDLElBQUksQ0FBQ215QixhQUFhLEVBQUVqQztJQUM3QztJQUNBOzs7S0FHQyxHQUNEa0IsZUFBZTNKLE1BQU0sRUFBRTtRQUNuQixJQUFJLENBQUN6bkIsZUFBZSxDQUFDLElBQUksQ0FBQ295QixrQkFBa0IsRUFBRTNLO1FBQzlDLElBQUlBLFFBQVE7WUFDUixJQUFJLENBQUNzSixTQUFTLENBQUMsSUFBSSxDQUFDaUMscUJBQXFCLENBQUN2TDtRQUM5QztJQUNKO0lBQ0E7OztLQUdDLEdBQ0RzSixVQUFVN0UsUUFBUSxFQUFFO1FBQ2hCLElBQUksQ0FBQ2xzQixlQUFlLENBQUMsSUFBSSxDQUFDcXlCLHFCQUFxQixFQUFFbkc7SUFDckQ7SUFDQTs7S0FFQyxHQUNELElBQUlxRixxQkFBcUI7UUFDckIsT0FBTyxJQUFJLENBQUM1eEIsZUFBZSxDQUFDLElBQUksQ0FBQzh5QixtQkFBbUI7SUFDeEQ7SUFDQTs7Ozs7S0FLQyxHQUNENUIsc0JBQXNCdEQsV0FBVyxFQUFFO1FBQy9CLElBQUksQ0FBQ3Z0QixlQUFlLENBQUMsSUFBSSxDQUFDc3lCLHlCQUF5QixFQUFFL0U7SUFDekQ7QUFDSjtBQUVBLE1BQU0wRiwyQkFBMkJoQjtJQUM3QngwQyxhQUFjO1FBQ1YsS0FBSyxDQUFDLGVBQ04sMkNBQTJDO1FBQzNDLDJDQUEyQztRQUMzQztRQUNBLElBQUksQ0FBQ3kxQyxnQkFBZ0IsR0FBRyxJQUFJOTZDLDJRQUFlQSxDQUFDK0c7UUFDNUMsSUFBSSxDQUFDZzBDLFVBQVUsR0FBRyxJQUFJLENBQUNELGdCQUFnQixDQUNsQy9wQixZQUFZLEdBQ1pDLElBQUksQ0FBQzV3QixvUkFBb0JBO0lBQ2xDO0lBQ0E7Ozs7S0FJQyxHQUNELElBQUk4Z0IsWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDcUcsZUFBZSxDQUFDLElBQUksQ0FBQ3d6QixVQUFVO0lBQy9DO0lBQ0E7O0tBRUMsR0FDREMsYUFBYTk1QixTQUFTLEVBQUU7UUFDcEIsSUFBSSxDQUFDMEcsZUFBZSxDQUFDLElBQUksQ0FBQ2t6QixnQkFBZ0IsRUFBRTU1QjtJQUNoRDtJQUNBOztLQUVDLEdBQ0Q4M0IsZUFBZTNKLE1BQU0sRUFBRTtRQUNuQixLQUFLLENBQUMySixlQUFlM0o7UUFDckIsSUFBSUEsUUFBUTtZQUNSLGtGQUFrRjtZQUNsRixNQUFNbnVCLFlBQVk1QyxrQkFDWixJQUFJLENBQUM0QyxTQUFTLEdBQ2RtdUIsT0FBTzVDLGNBQWMsRUFBRSxDQUFDLEVBQUUsRUFBRXRuQixjQUFjODFCLGVBQWUsZ0JBQ3JELFNBQ0E7WUFDVixJQUFJLENBQUNELFlBQVksQ0FBQzk1QjtRQUN0QjtJQUNKO0lBQ0EwNUIsc0JBQXNCdkwsTUFBTSxFQUFFO1FBQzFCLE9BQU9BLE9BQU81QyxjQUFjLEVBQUUsQ0FBQyxFQUFFLEVBQUV0bkIsY0FBYzJ1QjtJQUNyRDtBQUNKO0FBRUEsTUFBTW9ILHNCQUFzQjFEO0lBQ3hCbnlDLFlBQVk0YyxJQUFJLENBQUU7UUFDZCxLQUFLLENBQUNBLE1BQU0sSUFBSTQ0QixzQkFBc0JydUMsVUFBVXNhLEtBQUs7UUFDckQsSUFBSSxDQUFDOUIsZ0JBQWdCLEdBQUc7WUFDcEJsVyxPQUFPO1lBQ1BDLFFBQVE7UUFDWjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1vc0MsZ0JBQWdCajZCLFNBQVMsRUFBRTtRQUM3QixJQUFJLENBQUN3TCxLQUFLLENBQUNzdUIsWUFBWSxDQUFDOTVCO1FBQ3hCLGlGQUFpRjtRQUNqRixJQUFJLENBQUN3TCxLQUFLLENBQUNpc0IsU0FBUyxDQUFDNXhDO1FBQ3JCLE1BQU0sSUFBSSxDQUFDNnhDLHFCQUFxQjtJQUNwQztJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTXdDLE9BQU87UUFDVCxNQUFNQyxlQUFlLElBQUksQ0FBQzN1QixLQUFLLENBQUN4TCxTQUFTLEtBQUssVUFBVSxTQUFTO1FBQ2pFLE1BQU0sSUFBSSxDQUFDaTZCLGVBQWUsQ0FBQ0U7SUFDL0I7SUFDQTs7S0FFQyxHQUNELE1BQU1DLHVCQUF1QkMsVUFBVSxFQUFFO1FBQ3JDLElBQUksQ0FBQ3YyQixnQkFBZ0IsQ0FBQ2pXLE1BQU0sR0FBR3dzQyxXQUFXeHNDLE1BQU07UUFDaEQsSUFBSSxDQUFDaVcsZ0JBQWdCLENBQUNsVyxLQUFLLEdBQUd5c0MsV0FBV3pzQyxLQUFLO1FBQzlDLElBQUksSUFBSSxDQUFDaXBDLGFBQWEsRUFBRTtZQUNwQixJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDQSxhQUFhO1lBQzVCLEVBQ0EsT0FBT3BrQyxPQUFPO2dCQUNWLDRHQUE0RztnQkFDNUcsSUFBSSxDQUFDdU0sTUFBTSxDQUFDLFFBQVEscUNBQXFDdk07WUFDN0Q7UUFDSjtRQUNBLElBQUksSUFBSSxDQUFDK1ksS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxXQUFXO1lBQ2pDLE1BQU0sRUFBRWhwQyxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQzJkLEtBQUssQ0FDL0JrTixXQUFXLENBQUM2UyxjQUFjLEVBQUUsQ0FBQyxFQUFFLEVBQzlCdG5CO1lBQ04sSUFBSXJXLFVBQVUsSUFBSSxDQUFDa1csZ0JBQWdCLENBQUNsVyxLQUFLLElBQ3JDQyxXQUFXLElBQUksQ0FBQ2lXLGdCQUFnQixDQUFDalcsTUFBTSxFQUFFO2dCQUN6QyxNQUFNLElBQUksQ0FBQzZwQyxxQkFBcUI7Z0JBQ2hDLElBQUksQ0FBQzE0QixNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUVwUixNQUFNLENBQUMsRUFBRUMsT0FBTywwQ0FBMEMsQ0FBQztZQUN2RjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEeXNDLGtCQUFrQnBnQyxLQUFLLEVBQUU7UUFDckIsSUFBSSxDQUFDNEUsY0FBYyxHQUFHNUU7SUFDMUI7SUFDQTg1QixhQUFhO1FBQ1QsT0FBTzBCO0lBQ1g7SUFDQUUsVUFBVTNCLFdBQVcsRUFBRTtRQUNuQkEsWUFBWXJtQyxLQUFLLEdBQUcsSUFBSSxDQUFDa1csZ0JBQWdCLENBQUNsVyxLQUFLO1FBQy9DcW1DLFlBQVlwbUMsTUFBTSxHQUFHLElBQUksQ0FBQ2lXLGdCQUFnQixDQUFDalcsTUFBTTtRQUNqRCw4Q0FBOEM7UUFDOUMsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQ29tQyxZQUFZckIsUUFBUSxJQUFJLElBQUksQ0FBQ3BuQixLQUFLLENBQUN4TCxTQUFTLEVBQUU7WUFDL0NpMEIsWUFBWThGLFVBQVUsR0FDbEIsSUFBSSxDQUFDdnVCLEtBQUssQ0FBQ3hMLFNBQVMsS0FBSyxVQUFVLFNBQVM7UUFDcEQ7UUFDQSxPQUFPKzFCLGVBQWU5QjtJQUMxQjtJQUNBeGIsY0FBYzBWLE1BQU0sRUFBRTtRQUNsQixPQUFPLElBQUksQ0FBQ3B0QixJQUFJLENBQUN3NUIsa0JBQWtCLENBQUNwTSxRQUFRO1lBQ3hDcnZCLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7UUFDdkM7SUFDSjtJQUNBNjRCLGtCQUFrQnhmLFVBQVUsRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQ3BYLElBQUksQ0FBQyttQixXQUFXLENBQUN4OEIsVUFBVXNhLEtBQUssRUFBRXVTO0lBQ2xEO0FBQ0o7QUFFQSxNQUFNcWlCLCtCQUErQjdCO0lBQ2pDeDBDLGFBQWM7UUFDVixLQUFLLENBQUMsa0JBQ04sK0NBQStDO1FBQy9DLDJDQUEyQztRQUMzQztRQUNBLElBQUksQ0FBQ3MyQyx5QkFBeUIsR0FBRyxJQUFJMzdDLDJRQUFlQSxDQUFDO1FBQ3JELElBQUksQ0FBQzQ3QyxtQkFBbUIsR0FBRyxJQUFJLENBQUNELHlCQUF5QixDQUNwRDVxQixZQUFZLEdBQ1pDLElBQUksQ0FBQzV3QixvUkFBb0JBO0lBQ2xDO0lBQ0E7Ozs7S0FJQyxHQUNELElBQUl5N0MscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDdDBCLGVBQWUsQ0FBQyxJQUFJLENBQUNxMEIsbUJBQW1CO0lBQ3hEO0lBQ0E7O0tBRUMsR0FDREUsc0JBQXNCOXRDLFVBQVUsRUFBRTtRQUM5QixJQUFJLENBQUM0WixlQUFlLENBQUMsSUFBSSxDQUFDK3pCLHlCQUF5QixFQUFFM3RDO0lBQ3pEO0lBQ0E0c0Msc0JBQXNCdkwsTUFBTSxFQUFFO1FBQzFCLE9BQU9BLE9BQU8xQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLEVBQUV4bkIsY0FBYzJ1QjtJQUNyRDtBQUNKO0FBRUEsTUFBTWlJLDRCQUE0QjtBQUNsQyxNQUFNQywwQkFBMEI7QUFDaEMsTUFBTUMsV0FBVztBQUNqQjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUMsc0JBQXNCLENBQUN4UCxhQUFheVAsNkJBQTZCcDJDLFVBQVUsQ0FBQyxDQUFDO0lBQy9FLE1BQU0sRUFBRXEyQyx5QkFBeUJMLHlCQUF5QixFQUFFTSxzQkFBc0JMLHVCQUF1QixFQUFFTSxVQUFVTCxRQUFRLEVBQUVNLHNCQUFzQixJQUFJLEVBQUcsR0FBR3gyQztJQUMvSixNQUFNeTJDLGVBQWUsSUFBSUM7SUFDekIsTUFBTUMsV0FBV0YsYUFBYUcsY0FBYztJQUM1Q0QsU0FBU0osT0FBTyxHQUFHQTtJQUNuQixNQUFNeFQsYUFBYTBULGFBQWFJLHVCQUF1QixDQUFDbFE7SUFDeEQ1RCxXQUFXK1QsT0FBTyxDQUFDSDtJQUNuQixNQUFNSSxhQUFhdlgsWUFBWTtRQUMzQixNQUFNbEUsT0FBTyxJQUFJRyxXQUFXa2IsU0FBU0ssaUJBQWlCO1FBQ3RETCxTQUFTTSxvQkFBb0IsQ0FBQzNiO1FBQzlCLE1BQU00YixrQkFBa0I1YixLQUFLeFgsSUFBSSxDQUFDLENBQUNoakIsUUFBVUEsU0FBU3cxQztRQUN0RCxNQUFNYSxvQkFBb0I3YixLQUFLbFUsTUFBTSxDQUFDLENBQUNnd0IsSUFBSUMsS0FBT0QsS0FBS0MsSUFBSSxLQUFLL2IsS0FBS242QixNQUFNO1FBQzNFLE1BQU1tMkMsYUFBYUgsb0JBQW9CYixzQkFDakMsTUFDQXR4QyxLQUFLMmEsS0FBSyxDQUFDLG9CQUFxQjIyQixzQkFBdUI7UUFDN0Qsb0VBQW9FO1FBQ3BFLDhFQUE4RTtRQUM5RSxJQUFJM1AsWUFBWUMsY0FBYyxFQUFFLENBQUMsRUFBRSxFQUFFaFMsU0FBUztZQUMxQ3doQiw0QkFBNEI7Z0JBQUVjO2dCQUFpQi91QyxZQUFZbXZDO1lBQVc7UUFDMUUsT0FDSztZQUNEbEIsNEJBQTRCO2dCQUFFYyxpQkFBaUI7Z0JBQU8vdUMsWUFBWTtZQUFFO1FBQ3hFO0lBQ0osR0FBR2t1QztJQUNILE9BQU8sZUFBZTE2QjtRQUNsQmdqQixjQUFjb1k7UUFDZCxxQ0FBcUM7UUFDckNoVSxXQUFXa0gsVUFBVTtRQUNyQjBNLFNBQVMxTSxVQUFVO1FBQ25CLE1BQU13TSxhQUFhNzZCLEtBQUs7UUFDeEIsa0JBQWtCO1FBQ2xCLElBQUk0NkIscUJBQXFCO1lBQ3JCN1AsWUFBWTdMLFNBQVMsR0FBR25nQixPQUFPLENBQUMsQ0FBQ21aO2dCQUM3QkEsTUFBTW5ZLElBQUk7Z0JBQ1ZnckIsWUFBWTlRLFdBQVcsQ0FBQy9CO1lBQzVCO1FBQ0o7SUFDSjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU15akIsVUFBVSxDQUFDMXdCO0lBQ2IsTUFBTWdmLFFBQVEsRUFBRTtJQUNoQmhmLE9BQU9sTSxPQUFPLENBQUMsQ0FBQytDO1FBQ1ptb0IsTUFBTXJoQyxJQUFJLENBQUNrWjtJQUNmO0lBQ0EsT0FBT21vQjtBQUNYO0FBQ0EsTUFBTTJSLHdCQUF3QjtBQUM5QixNQUFNQztJQUNGbjRDLGFBQWM7UUFDVixJQUFJLENBQUNvNEMsR0FBRyxHQUFHLElBQUlyOEIsa0JBQWtCLENBQUM7UUFDbEMsSUFBSSxDQUFDczhCLEdBQUcsR0FBRyxJQUFJdDhCLGtCQUFrQixDQUFDO0lBQ3RDO0lBQ0E7O0tBRUMsR0FDRCxNQUFNdThCLFFBQVE7UUFDVixJQUFJO1lBQ0EsTUFBTWpSLGNBQWMsTUFBTW51QixVQUFVKzJCLFlBQVksQ0FBQ0ksWUFBWSxDQUFDO2dCQUMxRGxCLE9BQU87WUFDWDtZQUNBLElBQUksQ0FBQ2lKLEdBQUcsQ0FBQzNrQixnQkFBZ0IsQ0FBQyxnQkFBZ0IsT0FBT3pxQjtnQkFDN0MsTUFBTSxJQUFJLENBQUNxdkMsR0FBRyxDQUFDN2YsZUFBZSxDQUFDeHZCLEVBQUU4VSxTQUFTO1lBQzlDO1lBQ0EsSUFBSSxDQUFDdTZCLEdBQUcsQ0FBQzVrQixnQkFBZ0IsQ0FBQyxnQkFBZ0IsT0FBT3pxQjtnQkFDN0MsTUFBTSxJQUFJLENBQUNvdkMsR0FBRyxDQUFDNWYsZUFBZSxDQUFDeHZCLEVBQUU4VSxTQUFTO1lBQzlDO1lBQ0F1cEIsWUFDSzdMLFNBQVMsR0FDVG5nQixPQUFPLENBQUMsQ0FBQ21aLFFBQVUsSUFBSSxDQUFDNGpCLEdBQUcsQ0FBQ0csUUFBUSxDQUFDL2pCLE9BQU82UztZQUNqRCxNQUFNcHJCLFFBQVEsTUFBTSxJQUFJLENBQUNtOEIsR0FBRyxDQUFDbDhCLFdBQVcsQ0FBQyxDQUFDO1lBQzFDLE1BQU0sSUFBSSxDQUFDbThCLEdBQUcsQ0FBQy9mLG9CQUFvQixDQUFDcmM7WUFDcEMsTUFBTSxJQUFJLENBQUNtOEIsR0FBRyxDQUFDaGdCLG1CQUFtQixDQUFDbmM7WUFDbkMsTUFBTXdmLFNBQVMsTUFBTSxJQUFJLENBQUM0YyxHQUFHLENBQUMzYyxZQUFZO1lBQzFDLE1BQU0sSUFBSSxDQUFDMGMsR0FBRyxDQUFDOWYsb0JBQW9CLENBQUNtRDtZQUNwQyxNQUFNLElBQUksQ0FBQzRjLEdBQUcsQ0FBQ2pnQixtQkFBbUIsQ0FBQ3FEO1lBQ25DLE1BQU0rYyxjQUFjblIsWUFBWUMsY0FBYztZQUM5QyxxSEFBcUg7WUFDckhrUixZQUFZbjlCLE9BQU8sQ0FBQyxDQUFDbVosUUFBV0EsTUFBTWMsT0FBTyxHQUFHO1FBQ3BELEVBQ0EsT0FBT2huQixPQUFPO1lBQ1Z5TCxRQUFRekwsS0FBSyxDQUFDLDZEQUE2REE7UUFDL0U7SUFDSjtJQUNBOztLQUVDLEdBQ0QrTixPQUFPO1FBQ0gsSUFBSSxDQUFDKzdCLEdBQUcsQ0FBQzk3QixLQUFLO1FBQ2QsSUFBSSxDQUFDKzdCLEdBQUcsQ0FBQy83QixLQUFLO1FBQ2QsSUFBSSxJQUFJLENBQUNtN0IsVUFBVSxFQUFFO1lBQ2pCcFksY0FBYyxJQUFJLENBQUNvWSxVQUFVO1FBQ2pDO0lBQ0o7SUFDQTs7S0FFQyxHQUNEZ0IsOEJBQThCM0IsMkJBQTJCLEVBQUU7UUFDdkQsSUFBSSxDQUFDVyxVQUFVLEdBQUd2WCxZQUFZO1lBQzFCLE1BQU1xRyxRQUFTLE1BQU0sSUFBSSxDQUFDNlIsR0FBRyxDQUFDOWdCLFFBQVE7WUFDdEMsTUFBTS9QLFNBQVMwd0IsUUFBUTFSO1lBQ3ZCLG1GQUFtRjtZQUNuRixNQUFNbVMsd0JBQXdCbnhCLE9BQU90akIsSUFBSSxDQUFDLENBQUNpa0MsT0FBU0EsS0FBS3o4QixJQUFJLEtBQUssa0JBQzlEeThCLEtBQUsvbkMsSUFBSSxLQUFLO1lBQ2xCLElBQUl1NEMsdUJBQXVCO2dCQUN2QixNQUFNLEVBQUU3dkMsVUFBVSxFQUFFLEdBQUc2dkM7Z0JBQ3ZCLElBQUk3dkMsWUFBWTtvQkFDWixJQUFJQSxjQUFjcXZDLHVCQUF1Qjt3QkFDckNwQiw0QkFBNEI7NEJBQ3hCYyxpQkFBaUI7NEJBQ2pCL3VDO3dCQUNKO29CQUNKLE9BQ0s7d0JBQ0RpdUMsNEJBQTRCOzRCQUN4QmMsaUJBQWlCOzRCQUNqQi91QyxZQUFZO3dCQUNoQjtvQkFDSjtnQkFDSjtZQUNKO1FBQ0osR0FBRztRQUNILE9BQU87WUFDSHcyQixjQUFjLElBQUksQ0FBQ29ZLFVBQVU7UUFDakM7SUFDSjtBQUNKO0FBRUEsTUFBTWtCLDBCQUEwQnhHO0lBQzVCbnlDLFlBQVk0YyxJQUFJLENBQUU7UUFDZCxLQUFLLENBQUNBLE1BQU0sSUFBSXk1QiwwQkFBMEJsdkMsVUFBVXVhLEtBQUs7UUFDekRobkIsNlFBQWFBLENBQUM7WUFDVixJQUFJLENBQUNraUIsSUFBSSxDQUFDeUssS0FBSyxDQUFDc0YsYUFBYTtZQUM3QixJQUFJLENBQUMvUCxJQUFJLENBQUN5SyxLQUFLLENBQUNxRixnQkFBZ0I7WUFDaEMsSUFBSSxDQUFDckYsS0FBSyxDQUFDbW5CLGVBQWU7WUFDMUIsSUFBSSxDQUFDbm5CLEtBQUssQ0FBQzB0QixPQUFPO1NBQ3JCLEVBQUUxeUIsU0FBUyxDQUFDLE9BQU8sQ0FBQzJMLGNBQWNFLGlCQUFpQnVnQixVQUFVZ0UsT0FBTztZQUNqRSxJQUFJemtCLGlCQUFpQjdJLGFBQWErYyxNQUFNLEVBQUU7Z0JBQ3RDLElBQUlsVSxpQkFBaUI3SSxhQUFhK0osSUFBSSxFQUFFO29CQUNwQyxNQUFNLElBQUksQ0FBQzBwQiwrQkFBK0I7Z0JBQzlDO2dCQUNBO1lBQ0o7WUFDQSxJQUFJMXFCLGdCQUFnQnZTLFFBQVEsQ0FBQ3plLGNBQWNhLFVBQVUsR0FBRztnQkFDcEQsSUFBSTAwQyxXQUFXLFlBQVk7b0JBQ3ZCLE1BQU0sSUFBSSxDQUFDb0csZ0NBQWdDLENBQUNwSztnQkFDaEQsT0FDSztvQkFDRCxNQUFNLElBQUksQ0FBQ21LLCtCQUErQjtnQkFDOUM7WUFDSixPQUNLO2dCQUNELE1BQU0sSUFBSSxDQUFDQSwrQkFBK0I7WUFDOUM7UUFDSjtJQUNKO0lBQ0EvSSxhQUFhO1FBQ1QsT0FBT3lCO0lBQ1g7SUFDQUcsVUFBVTNCLFdBQVcsRUFBRTtRQUNuQixPQUFPNEIsZUFBZTVCO0lBQzFCO0lBQ0F4YixjQUFjMFYsTUFBTSxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDcHRCLElBQUksQ0FBQ2s4QixrQkFBa0IsQ0FBQzlPO0lBQ3hDO0lBQ0F3SixrQkFBa0J4ZixVQUFVLEVBQUU7UUFDMUIsT0FBTyxJQUFJLENBQUNwWCxJQUFJLENBQUMrbUIsV0FBVyxDQUFDeDhCLFVBQVV1YSxLQUFLLEVBQUVzUztJQUNsRDtJQUNBLE1BQU02a0IsaUNBQWlDcEssUUFBUSxFQUFFO1FBQzdDLE1BQU0sSUFBSSxDQUFDbUssK0JBQStCO1FBQzFDLElBQUkzL0IsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQzgvQixnQkFBZ0IsR0FBRyxJQUFJWjtZQUM1QixNQUFNLElBQUksQ0FBQ1ksZ0JBQWdCLENBQUNULEtBQUs7WUFDakMsTUFBTWgyQixjQUFjLElBQUksQ0FBQ3kyQixnQkFBZ0IsRUFBRU4sOEJBQThCLENBQUNud0I7Z0JBQ3RFLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ292QixxQkFBcUIsQ0FBQ251QixNQUFNc3ZCLGVBQWU7WUFDMUQ7WUFDQSxJQUFJLENBQUNvQixvQkFBb0IsR0FBRztnQkFDeEIxMkI7Z0JBQ0EsSUFBSSxDQUFDeTJCLGdCQUFnQixFQUFFMThCO2dCQUN2QixJQUFJLENBQUMwOEIsZ0JBQWdCLEdBQUdyM0M7WUFDNUI7UUFDSixPQUNLO1lBQ0QsK0RBQStEO1lBQy9ELE1BQU1zb0MsU0FBUyxNQUFNLElBQUksQ0FBQ3lILFNBQVMsQ0FBQztnQkFDaENoRDtZQUNKO1lBQ0EsSUFBSSxDQUFDdUssb0JBQW9CLEdBQUduQyxvQkFBb0I3TSxRQUFRLENBQUMxaEI7Z0JBQ3JELElBQUksQ0FBQ2pCLEtBQUssQ0FBQ292QixxQkFBcUIsQ0FBQ251QixNQUFNc3ZCLGVBQWU7WUFDMUQ7UUFDSjtJQUNKO0lBQ0EsTUFBTWdCLGtDQUFrQztRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDSSxvQkFBb0IsRUFBRTtZQUM1QjtRQUNKO1FBQ0EsSUFBSSxDQUFDM3hCLEtBQUssQ0FBQ292QixxQkFBcUIsQ0FBQztRQUNqQyxJQUFJO1lBQ0EsTUFBTSxJQUFJLENBQUN1QyxvQkFBb0I7UUFDbkMsU0FDUTtZQUNKLElBQUksQ0FBQ0Esb0JBQW9CLEdBQUd0M0M7UUFDaEM7SUFDSjtBQUNKO0FBRUEsTUFBTXUzQyx5QkFBeUJ6RTtJQUMzQngwQyxhQUFjO1FBQ1YsS0FBSyxJQUFJazVDO1FBQ1QsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxJQUFJeCtDLDJRQUFlQSxDQUFDO1FBQy9DLElBQUksQ0FBQ3FyQixlQUFlLEdBQUcsSUFBSXJyQiwyUUFBZUEsQ0FBQytHO1FBQzNDOztTQUVDLEdBQ0QsSUFBSSxDQUFDMDNDLGFBQWEsR0FBRyxJQUFJLENBQUNELG1CQUFtQixDQUN4Q3p0QixZQUFZLEdBQ1pDLElBQUksQ0FBQzV3QixvUkFBb0JBO1FBQzlCOztTQUVDLEdBQ0QsSUFBSSxDQUFDeXlCLFNBQVMsR0FBRyxJQUFJLENBQUN4SCxlQUFlLENBQUMwRixZQUFZO1FBQ2xEOztTQUVDLEdBQ0QsSUFBSSxDQUFDNnBCLHFCQUFxQixHQUFHLENBQUN2TDtZQUMxQixNQUFNLENBQUN4VixNQUFNLEdBQUd3VixPQUFPeE8sU0FBUztZQUNoQyxPQUFPaEgsT0FBTzFVLGNBQWMydUI7UUFDaEM7SUFDSjtJQUNBOztLQUVDLEdBQ0QsSUFBSTRLLGVBQWU7UUFDZixPQUFPLElBQUksQ0FBQ24zQixlQUFlLENBQUMsSUFBSSxDQUFDazNCLGFBQWE7SUFDbEQ7SUFDQTs7S0FFQyxHQUNERSxnQkFBZ0JDLFNBQVMsRUFBRTtRQUN2QixJQUFJLENBQUNoM0IsZUFBZSxDQUFDLElBQUksQ0FBQzQyQixtQkFBbUIsRUFBRUk7SUFDbkQ7SUFDQTs7S0FFQyxHQUNELElBQUkxNUIsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDcUMsZUFBZSxDQUFDLElBQUksQ0FBQ3NMLFNBQVM7SUFDOUM7SUFDQTs7OztLQUlDLEdBQ0Rnc0IsWUFBWTM1QixRQUFRLEVBQUU7UUFDbEIsSUFBSSxDQUFDMEMsZUFBZSxDQUFDLElBQUksQ0FBQ3lELGVBQWUsRUFBRW5HO0lBQy9DO0FBQ0o7QUFFQSxNQUFNNDVCLDJCQUEyQnRIO0lBQzdCbnlDLFlBQVk0YyxJQUFJLENBQUU7UUFDZCxLQUFLLENBQUNBLE1BQU0sSUFBSXE4QixvQkFBb0I5eEMsVUFBVW9hLFlBQVk7SUFDOUQ7SUFDQTs7Ozs7S0FLQyxHQUNEbTRCLHlCQUF5QjtRQUNyQixJQUFJLENBQUNyeUIsS0FBSyxDQUFDaXlCLGVBQWUsQ0FBQztJQUMvQjtJQUNBOztLQUVDLEdBQ0QsTUFBTUssMEJBQTBCO1FBQzVCLElBQUksQ0FBQ3R5QixLQUFLLENBQUNpeUIsZUFBZSxDQUFDO1FBQzNCLElBQUksSUFBSSxDQUFDMThCLElBQUksQ0FBQzhtQixTQUFTLEVBQUUzTixhQUFhNXVCLFVBQVVxYSxrQkFBa0IsR0FBRztZQUNqRSxNQUFNLElBQUksQ0FBQzVFLElBQUksQ0FBQyttQixXQUFXLENBQUN4OEIsVUFBVXFhLGtCQUFrQixFQUFFO1FBQzlEO0lBQ0o7SUFDQTs7S0FFQyxHQUNEMUIsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDdUgsS0FBSyxDQUFDeEgsUUFBUTtJQUM5QjtJQUNBOzs7O0tBSUMsR0FDRDI1QixZQUFZMzVCLFFBQVEsRUFBRTtRQUNsQixJQUFJLENBQUN3SCxLQUFLLENBQUNteUIsV0FBVyxDQUFDMzVCO0lBQzNCO0lBQ0Fnd0IsYUFBYTtRQUNULE9BQU9yMEMsa1FBQUVBLENBQUMsRUFBRSxHQUFHLHFEQUFxRDtJQUN4RTtJQUNBaTJDLFVBQVUzQixXQUFXLEVBQUU7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQ3pvQixLQUFLLENBQUNneUIsWUFBWSxFQUFFO1lBQzFCdkosWUFBWVgsS0FBSyxHQUFHO1FBQ3hCO1FBQ0EsT0FBTzBDLHFCQUFxQi9CO0lBQ2hDO0lBQ0F4YixjQUFjMFYsTUFBTSxFQUFFO1FBQ2xCLE9BQU8sSUFBSSxDQUFDcHRCLElBQUksQ0FBQ2c5Qix3QkFBd0IsQ0FBQzVQLFFBQVE7WUFDOUM5VSxxQkFBcUIsSUFBSSxDQUFDN04sS0FBSyxDQUFDeEgsUUFBUTtRQUM1QztJQUNKO0lBQ0EsTUFBTTJ6QixrQkFBa0J4ZixVQUFVLEVBQUU7UUFDaEMsTUFBTSxJQUFJLENBQUNwWCxJQUFJLENBQUMrbUIsV0FBVyxDQUFDeDhCLFVBQVVvYSxZQUFZLEVBQUV5UztRQUNwRCxNQUFNLElBQUksQ0FBQ3BYLElBQUksQ0FBQyttQixXQUFXLENBQUN4OEIsVUFBVXFhLGtCQUFrQixFQUFFd1M7SUFDOUQ7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTXFmLE9BQU81RSxRQUFRLEVBQUU7UUFDbkIsTUFBTSxJQUFJNXVDLE1BQU07SUFDcEI7QUFDSjtBQUVBLE1BQU1nNkM7SUFDRjc1QyxhQUFjO1FBQ1YsSUFBSSxDQUFDNDBDLHFCQUFxQixHQUFHLElBQUlqNkMsMlFBQWVBLENBQUM7UUFDakQsSUFBSSxDQUFDbS9DLGFBQWEsR0FBRyxJQUFJbi9DLDJRQUFlQSxDQUFDO1FBQ3pDOztTQUVDLEdBQ0QsSUFBSSxDQUFDby9DLDBCQUEwQixHQUFHdko7UUFDbEM7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUN0dUIsZUFBZSxHQUFHQTtRQUN2Qjs7Ozs7Ozs7OztTQVVDLEdBQ0QsSUFBSSxDQUFDSyxlQUFlLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQ2lzQixlQUFlLEdBQUcsSUFBSSxDQUFDb0cscUJBQXFCLENBQzVDbHBCLFlBQVksR0FDWkMsSUFBSSxDQUFDNXdCLG9SQUFvQkE7UUFDOUIsSUFBSSxDQUFDNHpDLE9BQU8sR0FBRyxJQUFJLENBQUNtTCxhQUFhLENBQzVCcHVCLFlBQVksR0FDWkMsSUFBSSxDQUFDNXdCLG9SQUFvQkE7SUFDbEM7SUFDQTs7OztLQUlDLEdBQ0QsSUFBSXF6QyxpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUNsc0IsZUFBZSxDQUFDLElBQUksQ0FBQ3NzQixlQUFlO0lBQ3BEO0lBQ0E7Ozs7S0FJQyxHQUNELElBQUlJLFNBQVM7UUFDVCxPQUFPLElBQUksQ0FBQzFzQixlQUFlLENBQUMsSUFBSSxDQUFDeXNCLE9BQU87SUFDNUM7SUFDQTs7O0tBR0MsR0FDRDJFLFVBQVU3RSxRQUFRLEVBQUU7UUFDaEIsSUFBSSxDQUFDbHNCLGVBQWUsQ0FBQyxJQUFJLENBQUNxeUIscUJBQXFCLEVBQUVuRztJQUNyRDtJQUNBOzs7S0FHQyxHQUNEdUwsVUFBVXBMLE1BQU0sRUFBRTtRQUNkLElBQUksQ0FBQ3JzQixlQUFlLENBQUMsSUFBSSxDQUFDdTNCLGFBQWEsRUFBRWxMO0lBQzdDO0FBQ0o7QUFFQSxNQUFNcUw7SUFDRmo2QyxhQUFjO1FBQ1YsSUFBSSxDQUFDcW5CLEtBQUssR0FBRyxJQUFJd3lCO1FBQ2pCLElBQUksQ0FBQ3RsQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUMrOUIsbUJBQW1CLEdBQUc7WUFDdkIsSUFBSSxDQUFDLzlCLGFBQWEsQ0FBQzhHLE9BQU8sQ0FBQyxDQUFDK0MsSUFBTUEsRUFBRWtFLFdBQVc7UUFDbkQ7UUFDQSxJQUFJMnZCLGNBQWMsQ0FBQ2g1QixpQkFBaUI7WUFDaEMsSUFBSSxDQUFDMUUsYUFBYSxDQUFDclAsSUFBSSxDQUFDeEssNlFBQWFBLENBQUM7Z0JBQUN1M0M7Z0JBQVksSUFBSSxDQUFDNXFCLEtBQUssQ0FBQ21uQixlQUFlO2FBQUMsRUFBRW5zQixTQUFTLENBQUMsQ0FBQyxDQUFDMnRCLFNBQVN2QixTQUFTO2dCQUMxRyxJQUFJLENBQUNBLFVBQVU7b0JBQ1g7Z0JBQ0o7Z0JBQ0EsTUFBTTVoQyxTQUFTbWpDLFFBQVEvckMsSUFBSSxDQUFDLENBQUMzQixJQUFNQSxFQUFFbXNDLFFBQVEsS0FBS0EsWUFBWW5zQyxFQUFFbkMsSUFBSSxLQUFLO2dCQUN6RSxJQUFJLENBQUMwTSxRQUFRO29CQUNULElBQUksQ0FBQ3dtQyxNQUFNLENBQUM7Z0JBQ2hCO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0RiLGNBQWM7UUFDVixPQUFPaEI7SUFDWDtJQUNBOzs7Ozs7S0FNQyxHQUNENkIsT0FBTzVFLFFBQVEsRUFBRTtRQUNiLElBQUl4MUIsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSXBaLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUN3bkIsS0FBSyxDQUFDaXNCLFNBQVMsQ0FBQzdFO0lBQ3pCO0lBQ0E7Ozs7O0tBS0MsR0FDRHVMLFVBQVVwTCxNQUFNLEVBQUU7UUFDZCxJQUFJMzFCLGlCQUFpQjtZQUNqQixNQUFNLElBQUlwWixNQUFNO1FBQ3BCO1FBQ0EsSUFBSSt1QyxVQUFXQSxDQUFBQSxTQUFTLEtBQUtBLFNBQVMsSUFBSTtZQUN0QyxNQUFNLElBQUkvdUMsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ3duQixLQUFLLENBQUMyeUIsU0FBUyxDQUFDcEw7SUFDekI7QUFDSjtBQUVBOztDQUVDLEdBQ0QsTUFBTTVnQztJQUNGOzs7Ozs7S0FNQyxHQUNEaE8sWUFBWSxFQUFFeUwsSUFBSSxFQUFFQyxFQUFFLEVBQUV3dUMsWUFBWSxFQUFFenlCLE9BQU8sRUFBRXlHLGVBQWUsRUFBRXRILGtCQUFrQixFQUFFdXpCLFdBQVcsRUFBRXhWLFVBQVUsS0FBSyxFQUFFeVYsV0FBVyxLQUFLLEVBQUcsQ0FBRTtRQUNuSTs7U0FFQyxHQUNELElBQUksQ0FBQy95QixLQUFLLEdBQUcsSUFBSXBaO1FBQ2pCOztTQUVDLEdBQ0QsSUFBSSxDQUFDb3NDLGdCQUFnQixHQUFHLElBQUl4TyxpQkFBaUIsSUFBSTtRQUNqRDs7U0FFQyxHQUNELElBQUksQ0FBQzdJLGtCQUFrQixHQUFHLElBQUk2TDtRQUM5Qjs7O1NBR0MsR0FDRCxJQUFJLENBQUNoYyxVQUFVLEdBQUcsSUFBSWhXO1FBQ3RCLElBQUksQ0FBQ3k5Qix5QkFBeUIsR0FBRyxJQUFJMy9DLDJRQUFlQSxDQUFDO1lBQUU4USxNQUFNK0wsYUFBYXUxQixNQUFNO1lBQUUvUSxNQUFNLEVBQUU7UUFBQztRQUMzRixJQUFJLENBQUN1ZSxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJbmdCO1FBQzFCLElBQUksQ0FBQ29nQix5QkFBeUIsR0FBRyxJQUFJdm5CO1FBQ3JDOzs7Ozs7O1NBT0MsR0FDRCxJQUFJLENBQUMvVixFQUFFLEdBQUcsQ0FBQ1gsV0FBV1U7WUFDbEIsSUFBSVgsV0FBV0MsWUFBWTtnQkFDdkIsT0FBTyxJQUFJLENBQUNvVyxVQUFVLENBQUN6VixFQUFFLENBQUNYLFdBQVdVO1lBQ3pDO1lBQ0EsTUFBTXc5QixhQUFhLElBQUksQ0FBQ1QsWUFBWSxDQUFDOThCLEVBQUUsQ0FBQ1gsV0FBVyxDQUFDelQ7Z0JBQ2hELE1BQU1zZixRQUFRdGY7Z0JBQ2QsSUFBSXNmLE1BQU1zeUIsUUFBUSxJQUFJdHlCLE1BQU1zeUIsUUFBUSxLQUFLLElBQUksQ0FBQzdyQixHQUFHLEVBQUU7b0JBQy9DNVIsR0FBR21MO2dCQUNQO1lBQ0o7WUFDQSx5REFBeUQ7WUFDekQsSUFBSSxDQUFDb3lCLHlCQUF5QixDQUFDamxCLEdBQUcsQ0FBQ3RZLElBQUl3OUI7WUFDdkMsT0FBTztnQkFDSCxJQUFJLENBQUNyOUIsR0FBRyxDQUFDYixXQUFXVTtZQUN4QjtRQUNKO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNHLEdBQUcsR0FBRyxDQUFDYixXQUFXVTtZQUNuQixJQUFJWCxXQUFXQyxZQUFZO2dCQUN2QixPQUFPLElBQUksQ0FBQ29XLFVBQVUsQ0FBQ3ZWLEdBQUcsQ0FBQ2IsV0FBV1U7WUFDMUM7WUFDQSx3RUFBd0U7WUFDeEUsTUFBTTA5Qix1QkFBdUIsSUFBSSxDQUFDSCx5QkFBeUIsQ0FBQzVoQixHQUFHLENBQUMzYjtZQUNoRSxJQUFJMDlCLHNCQUFzQjtnQkFDdEJBO1lBQ0o7UUFDSjtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDMXJCLEtBQUssR0FBRyxPQUFPLEVBQUUyckIsU0FBUyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDdkMsTUFBTTlzQixlQUFlLElBQUksQ0FBQzNHLEtBQUssQ0FBQzJHLFlBQVk7WUFDNUMsSUFBSUEsaUJBQWlCN0ksYUFBYStKLElBQUksRUFBRTtnQkFDcEMsTUFBTSxJQUFJcnZCLE1BQU07WUFDcEI7WUFDQSxJQUFJbXVCLGlCQUFpQjdJLGFBQWFnZCxPQUFPLEVBQUU7Z0JBQ3ZDLE1BQU0sSUFBSSxDQUFDNFksZ0JBQWdCO1lBQy9CO1lBQ0EsSUFBSSxJQUFJLENBQUNwVyxPQUFPLEVBQUU7Z0JBQ2QsMkRBQTJEO2dCQUMzRCxNQUFNcVcsdUJBQXVCLElBQUksQ0FBQzN6QixLQUFLLENBQUN3RyxrQkFBa0IsQ0FBQ2hzQixNQUFNLEdBQUc7Z0JBQ3BFLElBQUksSUFBSSxDQUFDZ2dDLGFBQWEsSUFBSSxDQUFDbVosc0JBQXNCO29CQUM3Qyw0REFBNEQ7b0JBQzVELDJCQUEyQjtvQkFDM0IsTUFBTSxJQUFJLENBQUNGLE1BQU07Z0JBQ3JCLE9BQ0ssSUFBSUEsVUFBVTlzQixpQkFBaUI3SSxhQUFhbWMsT0FBTyxFQUFFO29CQUN0RCw4REFBOEQ7b0JBQzlELE1BQU0sSUFBSSxDQUFDd1osTUFBTTtnQkFDckI7WUFDSjtZQUNBLElBQUksQ0FBQ0csYUFBYSxFQUFFNStCO1lBQ3BCLElBQUksQ0FBQzQrQixhQUFhLEdBQUd2NUM7WUFDckIsSUFBSSxDQUFDd2tDLFVBQVUsRUFBRTVwQjtZQUNqQixJQUFJLENBQUM0cEIsVUFBVSxHQUFHeGtDO1lBQ2xCLElBQUksQ0FBQ2dpQyxTQUFTLEVBQUVwbkI7WUFDaEIsSUFBSSxDQUFDb25CLFNBQVMsR0FBR2hpQztZQUNqQixJQUFJLENBQUNreEIsU0FBUyxFQUFFdFc7WUFDaEIsSUFBSSxDQUFDc1csU0FBUyxHQUFHbHhCO1lBQ2pCLElBQUksQ0FBQ214QixVQUFVLENBQUN0VixNQUFNO1lBQ3RCLElBQUksQ0FBQzhKLEtBQUssQ0FBQ0QsZUFBZSxDQUFDakMsYUFBYStKLElBQUk7WUFDNUMsb0VBQW9FO1lBQ3BFLElBQUksQ0FBQ3VyQixjQUFjLENBQUNwL0IsT0FBTyxDQUFDLENBQUM2L0IsT0FBU0E7WUFDdEMsSUFBSSxDQUFDZixXQUFXLENBQUNuckIsY0FBYyxDQUFDLElBQUk7WUFDcEMsSUFBSSxDQUFDdVUsTUFBTSxDQUFDK08sbUJBQW1CO1lBQy9CLElBQUksQ0FBQzdPLFVBQVUsQ0FBQzZPLG1CQUFtQjtZQUNuQyxJQUFJLENBQUM2SSxXQUFXLENBQUM3SSxtQkFBbUI7WUFDcEMsSUFBSSxDQUFDakUsT0FBTyxDQUFDaUUsbUJBQW1CO1lBQ2hDLE1BQU04SSxzQkFBc0IsRUFBRTtZQUM5QixJQUFJLElBQUksQ0FBQzdYLE1BQU0sQ0FBQzZPLFdBQVcsRUFBRTtnQkFDekJnSixvQkFBb0JsMkMsSUFBSSxDQUFDLElBQUksQ0FBQ3ErQixNQUFNLENBQUNDLE9BQU8sQ0FBQztZQUNqRDtZQUNBLElBQUksSUFBSSxDQUFDQyxVQUFVLENBQUMyTyxXQUFXLEVBQUU7Z0JBQzdCZ0osb0JBQW9CbDJDLElBQUksQ0FBQyxJQUFJLENBQUN1K0IsVUFBVSxDQUFDRCxPQUFPLENBQUM7WUFDckQ7WUFDQSxJQUFJLElBQUksQ0FBQzJYLFdBQVcsQ0FBQy9JLFdBQVcsRUFBRTtnQkFDOUJnSixvQkFBb0JsMkMsSUFBSSxDQUFDLElBQUksQ0FBQ2kyQyxXQUFXLENBQUMzWCxPQUFPLENBQUM7WUFDdEQ7WUFDQSxNQUFNbEgsUUFBUW1MLEdBQUcsQ0FBQzJUO1FBQ3RCO1FBQ0E7Ozs7OztTQU1DLEdBQ0QsSUFBSSxDQUFDdGlCLEdBQUcsR0FBRyxPQUFPbkM7WUFDZCxNQUFNMEIsV0FBVyxNQUFNLElBQUksQ0FBQzZoQixZQUFZLENBQUNwaEIsR0FBRyxDQUFDLElBQUksQ0FBQ3VpQixvQkFBb0IsRUFBRTFrQjtZQUN4RSxJQUFJQSxRQUFRMmtCLFFBQVEsQ0FBQyxJQUFJLENBQUMzVyxPQUFPLEVBQUU7Z0JBQy9CLElBQUksQ0FBQzRXLGNBQWMsQ0FBQzFpQyxJQUFJLENBQUM7WUFDN0I7WUFDQSxJQUFJLENBQUN3TyxLQUFLLENBQUN1QixzQkFBc0IsQ0FBQ3lQLFNBQVN6YixJQUFJO1lBQy9DLElBQUksQ0FBQ3lLLEtBQUssQ0FBQ0csVUFBVSxDQUFDNlEsU0FBUzVRLE9BQU87WUFDdEMsSUFBSSxDQUFDSixLQUFLLENBQUNLLGtCQUFrQixDQUFDMlEsU0FBUzdNLGdCQUFnQjtZQUN2RCxJQUFJLElBQUksQ0FBQzB1QixZQUFZLENBQUNzQixnQkFBZ0IsSUFBSTtnQkFDdEMsSUFBSSxDQUFDcEIsUUFBUSxHQUFHO2dCQUNoQixJQUFJLENBQUNELFdBQVcsQ0FBQ3JyQixZQUFZLENBQUMsSUFBSTtZQUN0QztZQUNBLElBQUksQ0FBQzJzQixpQkFBaUI7WUFDdEIsT0FBT3BqQjtRQUNYO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ3FqQixXQUFXLEdBQUcsT0FBTzFmO1lBQ3RCLE1BQU0zRCxXQUFXLE1BQU0sSUFBSSxDQUFDNmhCLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxJQUFJLENBQUM0VixvQkFBb0IsRUFBRXJmO1lBQ3pFLElBQUlBLE1BQU1zZixRQUFRLENBQUMsSUFBSSxDQUFDM1csT0FBTyxFQUFFO2dCQUM3QixJQUFJLENBQUM0VyxjQUFjLENBQUMxaUMsSUFBSSxDQUFDO1lBQzdCO1lBQ0EsSUFBSSxDQUFDd08sS0FBSyxDQUFDdUIsc0JBQXNCLENBQUN5UCxTQUFTemIsSUFBSTtZQUMvQyxJQUFJLENBQUN5SyxLQUFLLENBQUNHLFVBQVUsQ0FBQzZRLFNBQVM1USxPQUFPO1lBQ3RDLElBQUksQ0FBQ0osS0FBSyxDQUFDSyxrQkFBa0IsQ0FBQzJRLFNBQVM3TSxnQkFBZ0I7WUFDdkQsSUFBSSxJQUFJLENBQUMwdUIsWUFBWSxDQUFDc0IsZ0JBQWdCLElBQUk7Z0JBQ3RDLElBQUksQ0FBQ3BCLFFBQVEsR0FBRztnQkFDaEIsSUFBSSxDQUFDRCxXQUFXLENBQUNyckIsWUFBWSxDQUFDLElBQUk7WUFDdEM7WUFDQSxJQUFJLENBQUMyc0IsaUJBQWlCO1lBQ3RCLE9BQU9wakI7UUFDWDtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUMvMkIsTUFBTSxHQUFHLE9BQU8wNkI7WUFDakIsT0FBTyxJQUFJLENBQUMwZixXQUFXLENBQUMxZjtRQUM1QjtRQUNBOzs7U0FHQyxHQUNELElBQUksQ0FBQ3NmLElBQUksR0FBRztZQUNSLE9BQU8sTUFBTSxJQUFJLENBQUN4aUIsR0FBRyxDQUFDO2dCQUFFd2lCLE1BQU07WUFBSztRQUN2QztRQUNBOzs7U0FHQyxHQUNELElBQUksQ0FBQ3BLLE1BQU0sR0FBRztZQUNWLE9BQU8sTUFBTSxJQUFJLENBQUNwWSxHQUFHLENBQUM7Z0JBQUVvWSxRQUFRO1lBQUs7UUFDekM7UUFDQTs7Ozs7O1NBTUMsR0FDRCxJQUFJLENBQUN5SyxNQUFNLEdBQUc7WUFDVixPQUFPLElBQUksQ0FBQ3pCLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDNFYsb0JBQW9CLENBQUMsT0FBTyxDQUFDO1FBQ3ZFO1FBQ0E7Ozs7OztTQU1DLEdBQ0QsSUFBSSxDQUFDUCxNQUFNLEdBQUc7WUFDVixPQUFPLElBQUksQ0FBQ1osWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxPQUFPLENBQUM7UUFDdkU7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDbDRDLElBQUksR0FBRyxPQUFPNjRCO1lBQ2YsTUFBTWhPLGVBQWUsSUFBSSxDQUFDM0csS0FBSyxDQUFDMkcsWUFBWTtZQUM1QyxJQUFJO2dCQUFDN0ksYUFBYStjLE1BQU07Z0JBQUUvYyxhQUFhZ2QsT0FBTzthQUFDLENBQUN4bUIsUUFBUSxDQUFDcVMsZUFBZTtnQkFDcEUsSUFBSSxDQUFDblQsTUFBTSxDQUFDLFFBQVE7Z0JBQ3BCLE1BQU0sSUFBSWhiLE1BQU0sQ0FBQyw4QkFBOEIsQ0FBQztZQUNwRDtZQUNBLElBQUltdUIsaUJBQWlCN0ksYUFBYStKLElBQUksRUFBRTtnQkFDcEMsTUFBTSxJQUFJcnZCLE1BQU07WUFDcEI7WUFDQSxNQUFNKzdDLGNBQWM1dEIsaUJBQWlCN0ksYUFBYTAyQixTQUFTO1lBQzNELE1BQU1DLGlCQUFpQjl0QixpQkFBaUI3SSxhQUFhNDJCLFlBQVk7WUFDakUsSUFBSSxDQUFDMTBCLEtBQUssQ0FBQ0QsZUFBZSxDQUFDakMsYUFBYWdkLE9BQU87WUFDL0MsSUFBSSxDQUFDdG5CLE1BQU0sQ0FBQyxTQUFTO1lBQ3JCLElBQUltaEIsTUFBTXNmLFFBQVEsQ0FBQyxJQUFJLENBQUMzVyxPQUFPLEVBQUU7Z0JBQzdCLElBQUksQ0FBQzRXLGNBQWMsQ0FBQzFpQyxJQUFJLENBQUM7WUFDN0I7WUFDQSxJQUFJLElBQUksQ0FBQzhyQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM5QyxhQUFhLEVBQUU7Z0JBQ3JDLDhEQUE4RDtnQkFDOUQsTUFBTSxJQUFJLENBQUM4WixNQUFNO1lBQ3JCO1lBQ0EsSUFBSS9jO1lBQ0osSUFBSW9kO1lBQ0osSUFBSXJwQjtZQUNKLElBQUk7Z0JBQ0EsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRWtNLG9CQUFvQjtvQkFDcEMsNENBQTRDO29CQUM1Q25NLG1CQUFtQixJQUFJLENBQUMrUSxTQUFTLEVBQUVuUjtvQkFDbkNxTSxZQUFZLElBQUksQ0FBQ2hNLFNBQVMsQ0FBQ2dNLFNBQVM7b0JBQ3BDb2QsV0FBVyxJQUFJLENBQUNwcEIsU0FBUyxDQUFDN2UsS0FBSztnQkFDbkMsT0FDSztvQkFDRCw2REFBNkQ7b0JBQzdELE1BQU02SSxPQUFPLE1BQU16WixLQUFLLElBQUksQ0FBQysyQyxZQUFZLEVBQUUsSUFBSSxDQUFDenVDLElBQUksRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRXN3QjtvQkFDL0QsSUFBSSxDQUFDM1UsS0FBSyxDQUFDdUIsc0JBQXNCLENBQUNoTSxLQUFLeW9CLFFBQVE7b0JBQy9DLElBQUksQ0FBQ2hlLEtBQUssQ0FBQ0csVUFBVSxDQUFDNUssS0FBSzZLLE9BQU87b0JBQ2xDLElBQUksQ0FBQ0osS0FBSyxDQUFDSyxrQkFBa0IsQ0FBQzlLLEtBQUtzUixlQUFlO29CQUNsRHlFLG1CQUFtQi9WLEtBQUsrVixnQkFBZ0I7b0JBQ3hDaU0sWUFBWWhpQixLQUFLZ2lCLFNBQVM7b0JBQzFCb2QsV0FBV3AvQixLQUFLN0ksS0FBSztnQkFDekI7Z0JBQ0EsSUFBSSxJQUFJLENBQUNtbUMsWUFBWSxDQUFDc0IsZ0JBQWdCLElBQUk7b0JBQ3RDLElBQUksQ0FBQ3BCLFFBQVEsR0FBRztvQkFDaEIsSUFBSSxDQUFDRCxXQUFXLENBQUNyckIsWUFBWSxDQUFDLElBQUk7Z0JBQ3RDO1lBQ0osRUFDQSxPQUFPeGdCLE9BQU87Z0JBQ1YseURBQXlEO2dCQUN6RCxJQUFJLENBQUMrWSxLQUFLLENBQUNELGVBQWUsQ0FBQzRHO2dCQUMzQixNQUFNMWY7WUFDVjtZQUNBLE1BQU0ydEMsb0JBQW9CLElBQUksQ0FBQ3JwQixTQUFTO1lBQ3hDLE1BQU1BLFlBQWEsSUFBSSxDQUFDQSxTQUFTLEdBQUcsSUFBSStMLGdCQUFnQjtnQkFDcEQ5TCxZQUFZLElBQUksQ0FBQ0EsVUFBVTtnQkFDM0IrTDtnQkFDQTdxQixPQUFPaW9DO2dCQUNQMXpDLFdBQVcyekMsbUJBQW1CM3pDO1lBQ2xDO1lBQ0E7O2FBRUMsR0FDRCxNQUFNNHpDLFlBQVksT0FBT0MsV0FBVyxNQUFNO2dCQUN0QyxNQUFNQyxlQUFlLElBQUksQ0FBQy8wQixLQUFLLENBQUMyRyxZQUFZO2dCQUM1QyxJQUFJb3VCLGlCQUFpQmozQixhQUFhMDJCLFNBQVMsSUFDdkNPLGlCQUFpQmozQixhQUFhNDJCLFlBQVksRUFBRTtvQkFDNUMseUNBQXlDO29CQUN6QztnQkFDSjtnQkFDQSxJQUFJLENBQUN4QixpQkFBaUI7Z0JBQ3RCLElBQUksQ0FBQ2x6QixLQUFLLENBQUNELGVBQWUsQ0FBQyswQixhQUFhLFlBQ2xDaDNCLGFBQWEwMkIsU0FBUyxHQUN0QjEyQixhQUFhNDJCLFlBQVk7Z0JBQy9CLElBQUlJLGFBQWEsV0FBVztvQkFDeEIsSUFBSSxDQUFDdGhDLE1BQU0sQ0FBQyxTQUFTLENBQUMsNEJBQTRCLEVBQUUsSUFBSSxDQUFDa1UsR0FBRyxDQUFDLFdBQVcsRUFBRTZQLFVBQVUyQixTQUFTLENBQUMsQ0FBQztvQkFDL0YzTixVQUFVaU0sZUFBZSxHQUFHO2dCQUNoQyxPQUNLO29CQUNELElBQUksQ0FBQ2hrQixNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRXNoQyxTQUFTLGFBQWEsRUFBRSxJQUFJLENBQUNwdEIsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUN3ckIsaUJBQWlCLENBQUMsSUFBSSxDQUFDO2dCQUN2RztnQkFDQSwyREFBMkQ7Z0JBQzNELGtFQUFrRTtnQkFDbEUsTUFBTWh2QixtQkFBbUIsSUFBSSxDQUFDbEUsS0FBSyxDQUFDa0UsZ0JBQWdCO2dCQUNwRCxJQUFJNHdCLGFBQWEsUUFBUTtvQkFDckJ2cEIsVUFBVXRXLEtBQUssQ0FBQ3FpQixnQkFBZ0JvQyx1QkFBdUIsRUFBRTtnQkFDN0QsT0FDSyxJQUFJb2IsYUFBYSxRQUFRO29CQUMxQix1REFBdUQ7b0JBQ3ZELHVEQUF1RDtvQkFDdkQsTUFBTTlmLE1BQU1TLGNBQWMsSUFBSSxDQUFDeWQsaUJBQWlCO29CQUNoRCw2REFBNkQ7b0JBQzdELElBQUksQ0FBQ3JVLFVBQVUsRUFBRTVwQjtvQkFDakIsSUFBSSxDQUFDNHBCLFVBQVUsR0FBR3hrQztvQkFDbEIsSUFBSSxDQUFDZ2lDLFNBQVMsRUFBRXBuQixNQUFNO3dCQUFFMFgsWUFBWTtvQkFBTTtvQkFDMUMsSUFBSSxDQUFDMFAsU0FBUyxHQUFHaGlDO29CQUNqQixJQUFJLENBQUN1NUMsYUFBYSxFQUFFNStCO29CQUNwQixJQUFJLENBQUM0K0IsYUFBYSxHQUFHdjVDO29CQUNyQiw4QkFBOEI7b0JBQzlCa3hCLFVBQVV0VyxLQUFLLENBQUNxaUIsZ0JBQWdCTSxjQUFjLEVBQUU7Z0JBQ3BEO2dCQUNBLE1BQU0sSUFBSSxDQUFDOTdCLElBQUksQ0FBQztvQkFDWixHQUFHNjRCLElBQUk7b0JBQ1AsR0FBSW1nQixhQUFhLGFBQWE7d0JBQUVFLGdCQUFnQnpkLFVBQVUyQixTQUFTO29CQUFDLENBQUM7Z0JBQ3pFO2dCQUNBLCtCQUErQjtnQkFDL0IsSUFBSTRiLGFBQWEsV0FBVztvQkFDeEJ2cEIsVUFBVXRXLEtBQUssQ0FBQ3FpQixnQkFBZ0JNLGNBQWMsRUFBRTtnQkFDcEQ7Z0JBQ0EsSUFBSSxDQUFDcGtCLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDMC9CLGlCQUFpQixDQUFDLFlBQVksQ0FBQztnQkFDN0UsOERBQThEO2dCQUM5RCxpRUFBaUU7Z0JBQ2pFLDZCQUE2QjtnQkFDN0IsSUFBSWh2QixvQkFBb0I0d0IsYUFBYSxRQUFRO29CQUN6QyxNQUFNLEVBQUU5VSxXQUFXLEVBQUVGLFdBQVcsRUFBRTBHLGlCQUFpQixFQUFFTSxzQkFBc0IsRUFBRyxHQUFHNWlCO29CQUNqRixJQUFJNHZCO29CQUNKLElBQUl0TixxQkFBcUJNLHdCQUF3Qjt3QkFDN0NnTixjQUFjLElBQUlqVTt3QkFDbEIyRyxtQkFBbUJ6RyxpQkFBaUIvckIsUUFBUSxDQUFDbVo7NEJBQ3pDMm1CLGFBQWE1QyxTQUFTL2pCO3dCQUMxQjt3QkFDQTJaLHdCQUF3QjdHLGlCQUFpQmpzQixRQUFRLENBQUNtWjs0QkFDOUMybUIsYUFBYTVDLFNBQVMvakI7d0JBQzFCO29CQUNKO29CQUNBLG9DQUFvQztvQkFDcEMsSUFBSTZTLGFBQ0EsTUFBTSxJQUFJLENBQUN5UixrQkFBa0IsQ0FBQ3pSO29CQUNsQyxJQUFJRixhQUFhO3dCQUNiLE1BQU0sSUFBSSxDQUFDaVAsa0JBQWtCLENBQUNqUCxhQUFhOzRCQUN2Q3hzQixnQkFBZ0IsSUFBSSxDQUFDNG9CLE1BQU0sQ0FBQzVvQixjQUFjO3dCQUM5QztvQkFDSjtvQkFDQSxJQUFJd2dDLGFBQ0EsTUFBTSxJQUFJLENBQUN2Qix3QkFBd0IsQ0FBQ3VCO29CQUN4QyxJQUFJLENBQUN0Z0MsTUFBTSxDQUFDLFFBQVEsQ0FBQyxtQ0FBbUMsRUFBRSxJQUFJLENBQUMwL0IsaUJBQWlCLENBQUMsQ0FBQztnQkFDdEY7WUFDSjtZQUNBLGdFQUFnRTtZQUNoRSx5QkFBeUI7WUFDekIsbUJBQW1CO1lBQ25CM25CLFVBQVUrTSxXQUFXLENBQUNDLElBQUksQ0FBQztnQkFDdkIsNENBQTRDO2dCQUM1QyxNQUFNMGMsbUJBQW1CLElBQUksQ0FBQ3pwQixVQUFVLENBQUN6VixFQUFFLENBQUMsVUFBVSxDQUFDa0w7b0JBQ25ELE1BQU0sRUFBRWpSLE1BQU0sRUFBRSxHQUFHaVI7b0JBQ25CLElBQUksQ0FBQ3pOLE1BQU0sQ0FBQyxRQUFRLENBQUMsNENBQTRDLEVBQUV0VCxZQUFZLENBQUM4UCxPQUFPLENBQUMsQ0FBQztvQkFDekY2a0MsVUFBVSxXQUFXOXNCLEtBQUssQ0FBQyxDQUFDaE47d0JBQ3hCLElBQUksQ0FBQ3ZILE1BQU0sQ0FBQyxRQUFRLENBQUMsOENBQThDLENBQUMsRUFBRXVIO29CQUMxRTtnQkFDSjtnQkFDQXdRLFVBQVVzTSxRQUFRLENBQUN6TCxnQkFBZ0IsQ0FBQyxTQUFTLENBQUN6cUI7b0JBQzFDLG9GQUFvRjtvQkFDcEYsMERBQTBEO29CQUMxRHN6QztvQkFDQSxxREFBcUQ7b0JBQ3JELElBQUl0ekMsRUFBRWtELElBQUksS0FBS3l5QixnQkFBZ0JNLGNBQWMsRUFDekM7b0JBQ0osd0VBQXdFO29CQUN4RSwyREFBMkQ7b0JBQzNELElBQUlqMkIsRUFBRWtELElBQUksS0FBS3V3QixXQUFXSSxtQkFBbUIsRUFDekM7b0JBQ0osOERBQThEO29CQUM5RCxtRUFBbUU7b0JBQ25FLDhEQUE4RDtvQkFDOUQsMERBQTBEO29CQUMxRCxNQUFNZ0Msa0JBQWtCNzFCLEVBQUVrRCxJQUFJLEtBQUt1d0IsV0FBV0csa0JBQWtCLElBQUloSyxVQUFVaU0sZUFBZTtvQkFDN0YsTUFBTUMscUJBQXFCOTFCLEVBQUVrRCxJQUFJLEtBQUt1d0IsV0FBV0csa0JBQWtCLElBQy9EaEssVUFBVWtNLGtCQUFrQjtvQkFDaEMsSUFBSUQsbUJBQW1CQyxvQkFDbkI7b0JBQ0osc0VBQXNFO29CQUN0RSxJQUFJOTFCLEVBQUVrRCxJQUFJLEtBQUt5eUIsZ0JBQWdCb0MsdUJBQXVCLEVBQ2xEO29CQUNKLElBQUksSUFBSSxDQUFDd1osaUJBQWlCLEdBQUcsSUFBSSxDQUFDQyxvQkFBb0IsRUFBRTt3QkFDcEQ1bkIsVUFBVWtNLGtCQUFrQixHQUFHLElBQUksQ0FBQ3liLGlCQUFpQixLQUFLO3dCQUMxRCxNQUFNNEIsV0FBV3ZwQixVQUFVa00sa0JBQWtCLEdBQUcsU0FBUzt3QkFDekRvZCxVQUFVQyxVQUFVL3NCLEtBQUssQ0FBQyxDQUFDaE47NEJBQ3ZCLElBQUksQ0FBQ3ZILE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFc2hDLFNBQVMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDNUIsaUJBQWlCLENBQUMsa0JBQWtCLENBQUMsRUFBRW40Qjs0QkFDNUcsSUFBSSxDQUFDaUYsS0FBSyxDQUFDRCxlQUFlLENBQUNqQyxhQUFhbzNCLG1CQUFtQjt3QkFDL0Q7b0JBQ0osT0FDSzt3QkFDRCxJQUFJLENBQUMxaEMsTUFBTSxDQUFDLFNBQVM7d0JBQ3JCLElBQUksQ0FBQ3dNLEtBQUssQ0FBQ0QsZUFBZSxDQUFDakMsYUFBYW8zQixtQkFBbUI7b0JBQy9EO2dCQUNKO1lBQ0o7WUFDQSxnREFBZ0Q7WUFDaEQsTUFBTUMseUJBQXlCLElBQUksQ0FBQ3RDLFlBQVksQ0FBQzk4QixFQUFFLENBQUMsc0JBQXNCLE9BQU9wVTtnQkFDN0UsSUFBSUEsRUFBRXlDLElBQUksS0FBSyxzQkFDWDtnQkFDSixJQUFJLENBQUN6QyxFQUFFeXpDLE1BQU0sRUFDVDtnQkFDSkQ7Z0JBQ0EsTUFBTUUsc0JBQXNCLElBQUksQ0FBQ3IxQixLQUFLLENBQUMyRyxZQUFZO2dCQUNuRCxNQUFNMnVCLGtCQUFrQkQsd0JBQXdCdjNCLGFBQWFzVSxPQUFPLElBQ2hFaWpCLHdCQUF3QnYzQixhQUFhbzNCLG1CQUFtQjtnQkFDNUQsSUFBSSxDQUFDSSxpQkFDRDtnQkFDSixJQUFJLENBQUM5aEMsTUFBTSxDQUFDLFFBQVE7Z0JBQ3BCLElBQUkraEMsMEJBQTBCO2dCQUM5QixHQUFHO29CQUNDLElBQUk7d0JBQ0FocUIsVUFBVWtNLGtCQUFrQixHQUFHOGQ7d0JBQy9CLE1BQU1WLFVBQVVVLDBCQUEwQixTQUFTO3dCQUNuRCxRQUFRLHlDQUF5QztvQkFDckQsRUFDQSxPQUFPeDZCLEtBQUs7d0JBQ1IsSUFBSSxDQUFDdkgsTUFBTSxDQUFDLFNBQVMsQ0FBQyw2Q0FBNkMsRUFBRSxJQUFJLENBQUMwL0IsaUJBQWlCLENBQUMsQ0FBQyxFQUFFbjRCO29CQUNuRztvQkFDQSxrREFBa0Q7b0JBQ2xELE1BQU1pYSxNQUFNUyxjQUFjLElBQUksQ0FBQ3lkLGlCQUFpQjtvQkFDaERxQywwQkFBMEI7Z0JBQzlCLFFBQVMsSUFBSSxDQUFDckMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDQyxvQkFBb0IsRUFBRTtnQkFDN0QsMEVBQTBFO2dCQUMxRSxJQUFJLENBQUMzL0IsTUFBTSxDQUFDLFNBQVMsQ0FBQyw0Q0FBNEMsQ0FBQztnQkFDbkUsSUFBSSxDQUFDd00sS0FBSyxDQUFDRCxlQUFlLENBQUNqQyxhQUFhbzNCLG1CQUFtQjtZQUMvRDtZQUNBLE1BQU1NLDBCQUEwQixJQUFJLENBQUMzQyxZQUFZLENBQUM5OEIsRUFBRSxDQUFDLHNCQUFzQixDQUFDcFU7Z0JBQ3hFLElBQUlBLEVBQUV5QyxJQUFJLEtBQUssc0JBQ1g7Z0JBQ0osSUFBSXpDLEVBQUV5ekMsTUFBTSxFQUNSO2dCQUNKSTtnQkFDQSxJQUFJLENBQUN4MUIsS0FBSyxDQUFDRCxlQUFlLENBQUNqQyxhQUFhc1UsT0FBTztZQUNuRDtZQUNBLElBQUksQ0FBQ2doQixjQUFjLENBQUNqZ0IsR0FBRyxDQUFDO2dCQUNwQmdpQjtnQkFDQUs7WUFDSjtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUMzVyxVQUFVLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUlsTSxXQUFXO29CQUM3QnBIO29CQUNBQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtvQkFDM0J4TCxPQUFPLElBQUksQ0FBQ0EsS0FBSztvQkFDakJzTDtnQkFDSjtZQUNKO1lBQ0EsTUFBTW1xQixnQkFBZ0IsSUFBSSxDQUFDejFCLEtBQUssQ0FBQ3hILFFBQVEsRUFBRXN2QjtZQUMzQyxNQUFNcmMsZUFBZSxDQUFDLENBQUNncUIsZUFBZUM7WUFDdEMsTUFBTWhxQixlQUFlLENBQUMsQ0FBQytwQixlQUFlRTtZQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDdFosU0FBUyxFQUFFO2dCQUNqQixJQUFJLENBQUNBLFNBQVMsR0FBRyxJQUFJcFIsVUFBVTtvQkFDM0JNO29CQUNBQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtvQkFDM0J4TCxPQUFPLElBQUksQ0FBQ0EsS0FBSztvQkFDakJzTDtvQkFDQUc7b0JBQ0FDO2dCQUNKO1lBQ0o7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDa29CLGFBQWEsRUFBRTtnQkFDckIsSUFBSSxDQUFDQSxhQUFhLEdBQUdoVixvQkFBb0I7b0JBQ3JDQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtvQkFDM0J4QyxXQUFXLElBQUksQ0FBQ0EsU0FBUztvQkFDekJyYyxPQUFPLElBQUksQ0FBQ0EsS0FBSztnQkFDckI7WUFDSjtZQUNBLElBQUk7Z0JBQ0EseUVBQXlFO2dCQUN6RXVMLFVBQVUrTSxXQUFXLENBQ2hCdlEsS0FBSyxDQUFDLENBQUNoTixNQUFRLElBQUksQ0FBQ3ZILE1BQU0sQ0FBQyxTQUFTLHVCQUF1QnVILEtBQzVELGdEQUFnRDtnQkFDaEQsOERBQThEO2dCQUM5RCx1REFBdUQ7aUJBQ3REd2QsSUFBSSxDQUFDLElBQU1oa0IsY0FBYyxhQUN6QmdrQixJQUFJLENBQUMsQ0FBQ2p3QjtvQkFDUCxNQUFNNEUsZ0JBQWdCMk4sZ0JBQWdCLElBQUksQ0FBQ280Qix5QkFBeUI7b0JBQ3BFLE1BQU1ubUMsWUFBWXluQyxjQUNaO3dCQUNFdm5DLFdBQVcybkIsTUFBTXFnQixrQkFBa0I7d0JBQ25DOW5DLGVBQWVBLGNBQWN5bkIsSUFBSSxJQUFJLEVBQUU7d0JBQ3ZDMW5CLGlCQUFpQixJQUFJLENBQUNvdkIsU0FBUyxFQUFFdkwsMEJBQTBCLEVBQUU7b0JBQ2pFLElBQ0V6MkI7b0JBQ04sT0FBT2t4QixVQUFVenZCLElBQUksQ0FBQzt3QkFDbEI2USxlQUFlckUsT0FBTzt3QkFDdEJ1RSxlQUFlK0s7d0JBQ2Y5Szt3QkFDQUYsZUFBZWdvQyxtQkFBbUJuZCxzQkFBc0I7b0JBQzVEO2dCQUNKO2dCQUNBLGlFQUFpRTtnQkFDakUsa0VBQWtFO2dCQUNsRSwyQkFBMkI7Z0JBQzNCLE1BQU0sRUFBRXBxQixTQUFTLEVBQUVELFdBQVcsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDd29DLG1CQUFtQjtnQkFDakUsSUFBSW5CLGdCQUFnQjtvQkFDaEIsSUFBSSxDQUFDamhDLE1BQU0sQ0FBQyxTQUFTLDhCQUE4QnBHO2dCQUN2RDtnQkFDQSxJQUFJbW5DLGFBQWE7b0JBQ2IsTUFBTSxJQUFJLENBQUMxVixVQUFVLENBQUN4TyxTQUFTLENBQUM5RSxXQUFXRDtvQkFDM0MsTUFBTSxJQUFJLENBQUMrUSxTQUFTLENBQUNoTSxTQUFTLENBQUM5RSxXQUFXRDtnQkFDOUMsT0FDSyxJQUFJbXBCLGdCQUFnQjtvQkFDckIsSUFBSXJuQyxhQUFhO3dCQUNiLGlFQUFpRTt3QkFDakUsSUFBSSxDQUFDeXhCLFVBQVUsQ0FBQ3pPLFlBQVksQ0FBQzdFO3dCQUM3QixJQUFJLENBQUM4USxTQUFTLENBQUNqTSxZQUFZLENBQUM3RTt3QkFDNUIsa0RBQWtEO3dCQUNsRCxNQUFNLElBQUksQ0FBQzhRLFNBQVMsQ0FBQzNMLFVBQVU7b0JBQ25DLE9BQ0ssSUFBSWtrQixtQkFBbUJuZCxvQkFBb0I7d0JBQzVDLCtEQUErRDt3QkFDL0QsT0FBTyxNQUFNb2QsVUFBVSxRQUFROXNCLEtBQUssQ0FBQyxDQUFDaE47NEJBQ2xDLElBQUksQ0FBQ3ZILE1BQU0sQ0FBQyxTQUFTLENBQUMsMkNBQTJDLENBQUMsRUFBRXVIO3dCQUN4RTtvQkFDSjtnQkFDSjtnQkFDQSxNQUFNODZCLHNCQUFzQnhvQyxXQUFXOU0sZ0JBQWdCLEVBQUU7Z0JBQ3pELE1BQU1HLG1CQUFtQjJNLFdBQVczTTtnQkFDcEMsTUFBTUQsWUFBWTRNLFdBQVc1TSxZQUN2QmYsVUFBVWpCLE1BQU0sQ0FBQzRPLFVBQVU1TSxTQUFTLElBQ3BDLElBQUl0QztnQkFDVixNQUFNcUMsT0FBTzZNLFdBQVc3TSxRQUFRLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQ3dmLEtBQUssQ0FBQ0YsZUFBZSxDQUFDO29CQUN2QixNQUFNZzJCLG9CQUFvQixJQUFJLENBQUM5MUIsS0FBSyxDQUFDUSwrQkFBK0I7b0JBQ3BFLE9BQU9xMUIsb0JBQW9CdGlELEdBQUcsQ0FBQyxDQUFDMnBCO3dCQUM1Qix5REFBeUQ7d0JBQ3pELHlEQUF5RDt3QkFDekQscUNBQXFDO3dCQUNyQyxNQUFNNjRCLHNCQUFzQkQsaUJBQWlCLENBQUM1NEIsRUFBRWpjLFNBQVMsQ0FBQzt3QkFDMUQsT0FBT3hILE9BQU9nakMsTUFBTSxDQUFDdmYsR0FBRzY0QixxQkFBcUI7NEJBQ3pDcHhCLG9CQUFvQnpILEVBQUVqYyxTQUFTLEtBQUtzcUIsVUFBVXRxQixTQUFTOzRCQUN2RHFjLHlCQUF5Qnk0QixxQkFBcUJ6NEIsMkJBQTJCO2dDQUNyRWpGLFlBQVluSSxnQkFBZ0J1TixPQUFPO2dDQUNuQ2lmLGtCQUFrQnhzQixnQkFBZ0J1TixPQUFPOzRCQUM3Qzt3QkFDSjtvQkFDSjtnQkFDSjtnQkFDQSxJQUFJLENBQUN1QyxLQUFLLENBQUNOLG1CQUFtQixDQUFDaGYsa0JBQWtCRyxTQUFTO2dCQUMxRCxJQUFJLENBQUNtZixLQUFLLENBQUNILDRCQUE0QixDQUFDbmYsa0JBQWtCSSxhQUFhO2dCQUN2RSxJQUFJLENBQUNrZixLQUFLLENBQUNKLFlBQVksQ0FBQ25mO2dCQUN4QixJQUFJLENBQUN1ZixLQUFLLENBQUNtQixpQkFBaUIsQ0FBQzNnQjtnQkFDN0IsSUFBSSxDQUFDMHlDLGlCQUFpQixHQUFHLEdBQUcsdUNBQXVDO2dCQUNuRSxJQUFJLENBQUNsekIsS0FBSyxDQUFDRCxlQUFlLENBQUNqQyxhQUFhK2MsTUFBTTtnQkFDOUMsSUFBSTtvQkFDQSxNQUFNLElBQUksQ0FBQ21iLFVBQVUsQ0FBQzt3QkFBRXpLLFdBQVc7b0JBQUs7b0JBQ3hDLE1BQU0sSUFBSSxDQUFDMEssT0FBTyxDQUFDO3dCQUFFMUssV0FBVztvQkFBSztnQkFDekMsRUFDQSxPQUFPdGtDLE9BQU87b0JBQ1YsSUFBSSxDQUFDdU0sTUFBTSxDQUFDLFFBQVEsa0RBQWtEdk07Z0JBQzFFO2dCQUNBLDhFQUE4RTtnQkFDOUUscUVBQXFFO2dCQUNyRSxvRUFBb0U7Z0JBQ3BFLE1BQU0sRUFBRXVmLGtCQUFrQixFQUFFLEdBQUcsSUFBSSxDQUFDeEcsS0FBSztnQkFDekMsSUFBSXdHLG1CQUFtQmhzQixNQUFNLEdBQUcsR0FBRztvQkFDL0IsSUFBSSxDQUFDcVcsbUJBQW1CLENBQUMyVixvQkFBb0JyVyxhQUFhZzJCLElBQUk7Z0JBQ2xFO2dCQUNBLElBQUksQ0FBQzN5QixNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUNrVSxHQUFHLENBQUMsQ0FBQztZQUNqRCxFQUNBLE9BQU8zTSxLQUFLO2dCQUNSLDZCQUE2QjtnQkFDN0IsSUFBSSxJQUFJLENBQUNtNEIsaUJBQWlCLEdBQUcsSUFBSSxDQUFDQyxvQkFBb0IsRUFBRTtvQkFDcEQsSUFBSSxDQUFDMy9CLE1BQU0sQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDMC9CLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxFQUFFbjRCO29CQUMzRSxNQUFNODVCO29CQUNOLElBQUksQ0FBQ3JoQyxNQUFNLENBQUMsUUFBUSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQzAvQixpQkFBaUIsQ0FBQyxZQUFZLENBQUM7Z0JBQ2hGLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDMS9CLE1BQU0sQ0FBQyxTQUFTLENBQUMsNEJBQTRCLEVBQUUsSUFBSSxDQUFDMC9CLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDO29CQUM5RixJQUFJLENBQUNsekIsS0FBSyxDQUFDRCxlQUFlLENBQUNqQyxhQUFhbzNCLG1CQUFtQjtvQkFDM0QsTUFBTSxJQUFJMThDLE1BQU07Z0JBQ3BCO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ285QyxtQkFBbUIsR0FBRyxDQUFDMWtDLFVBQVUsSUFBSTtZQUN0QyxPQUFPLElBQUkrakIsUUFBUSxDQUFDdUUsU0FBU2lhO2dCQUN6QixNQUFNeDRCLGNBQWMsSUFBSSxDQUFDbEYsRUFBRSxDQUFDLGdCQUFnQixDQUFDa0w7b0JBQ3pDNEwsYUFBYTZUO29CQUNiemxCO29CQUNBdWUsUUFBUXZZO2dCQUNaO2dCQUNBLE1BQU15ZixZQUFZck8sV0FBVztvQkFDekJwWDtvQkFDQXc0QixPQUFPLElBQUlqN0MsTUFBTTtnQkFDckIsR0FBRzBZO1lBQ1A7UUFDSjtRQUNBOzs7Ozs7Ozs7U0FTQyxHQUNELElBQUksQ0FBQzY5QixrQkFBa0IsR0FBRyxPQUFPalAsYUFBYTFTLE9BQU8sQ0FBQyxDQUFDO1lBQ25ELDJEQUEyRDtZQUMzRCxrREFBa0Q7WUFDbEQsTUFBTSxJQUFJLENBQUNzbUIsZ0JBQWdCO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNyWCxTQUFTLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQzdvQixNQUFNLENBQUMsU0FBUztnQkFDckIsTUFBTSxJQUFJaGIsTUFBTSxDQUFDLG9CQUFvQixDQUFDO1lBQzFDO1lBQ0EsTUFBTSxDQUFDNmYsV0FBVyxHQUFHeW5CLFlBQVlDLGNBQWM7WUFDL0MsSUFBSSxDQUFDMW5CLFlBQVk7Z0JBQ2IsSUFBSSxDQUFDN0UsTUFBTSxDQUFDLFNBQVMsQ0FBQyxpREFBaUQsQ0FBQztnQkFDeEU7WUFDSjtZQUNBLE1BQU0sSUFBSSxDQUFDNm9CLFNBQVMsQ0FBQ3BQLGFBQWEsQ0FBQzZTLGFBQWF6bkIsWUFBWXZZLFVBQVVzYSxLQUFLLEVBQUVnVDtRQUNqRjtRQUNBOzs7Ozs7OztTQVFDLEdBQ0QsSUFBSSxDQUFDcWtCLGtCQUFrQixHQUFHLE9BQU96UjtZQUM3QiwyREFBMkQ7WUFDM0Qsa0RBQWtEO1lBQ2xELE1BQU0sSUFBSSxDQUFDMFQsZ0JBQWdCO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNyWCxTQUFTLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQzdvQixNQUFNLENBQUMsU0FBUztnQkFDckIsTUFBTSxJQUFJaGIsTUFBTSxDQUFDLG9CQUFvQixDQUFDO1lBQzFDO1lBQ0EsTUFBTSxDQUFDMDlDLFdBQVcsR0FBR2xXLFlBQVlDLGNBQWM7WUFDL0MsSUFBSSxDQUFDaVcsWUFBWTtnQkFDYixJQUFJLENBQUMxaUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnREFBZ0QsQ0FBQztnQkFDdkU7WUFDSjtZQUNBLE1BQU0sSUFBSSxDQUFDNm9CLFNBQVMsQ0FBQ3BQLGFBQWEsQ0FBQytTLGFBQWFrVyxZQUFZcDJDLFVBQVV1YSxLQUFLO1FBQy9FO1FBQ0E7Ozs7Ozs7O1NBUUMsR0FDRCxJQUFJLENBQUNrNEIsd0JBQXdCLEdBQUcsT0FBTy9MLG1CQUFtQnBaLE9BQU8sQ0FBQyxDQUFDO1lBQy9ELDJEQUEyRDtZQUMzRCxrREFBa0Q7WUFDbEQsTUFBTSxJQUFJLENBQUNzbUIsZ0JBQWdCO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNyWCxTQUFTLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQzdvQixNQUFNLENBQUMsU0FBUztnQkFDckIsTUFBTSxJQUFJaGIsTUFBTSxDQUFDLG9CQUFvQixDQUFDO1lBQzFDO1lBQ0EsTUFBTSxDQUFDa2tDLGlCQUFpQixHQUFHOEosa0JBQWtCekcsY0FBYztZQUMzRCxJQUFJLENBQUNyRCxrQkFBa0I7Z0JBQ25CLElBQUksQ0FBQ2xwQixNQUFNLENBQUMsU0FBUyxDQUFDLDZEQUE2RCxDQUFDO2dCQUNwRjtZQUNKO1lBQ0EsTUFBTSxJQUFJLENBQUM2b0IsU0FBUyxDQUFDcFAsYUFBYSxDQUFDdVosbUJBQW1COUosa0JBQWtCNThCLFVBQVVvYSxZQUFZLEVBQUVrVDtZQUNoRyxNQUFNLENBQUMrb0Isc0JBQXNCLEdBQUczUCxrQkFBa0J2RyxjQUFjO1lBQ2hFLElBQUlrVyx1QkFBdUI7Z0JBQ3ZCLE1BQU0sSUFBSSxDQUFDOVosU0FBUyxDQUFDcFAsYUFBYSxDQUFDdVosbUJBQW1CMlAsdUJBQXVCcjJDLFVBQVVxYSxrQkFBa0IsRUFBRWlUO1lBQy9HO1FBQ0o7UUFDQTs7Ozs7O1NBTUMsR0FDRCxJQUFJLENBQUNrUCxXQUFXLEdBQUcsT0FBTzE0QixXQUFXNnFCLFlBQVksSUFBSTtZQUNqRCxJQUFJLENBQUNqYixNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRTFULFNBQVMsQ0FBQzhELFVBQVUsQ0FBQyxlQUFlLEVBQUU2cUIsVUFBVSxDQUFDO1lBQ3BGLE1BQU0sSUFBSSxDQUFDNE4sU0FBUyxFQUFFN04sZ0JBQWdCNXFCLFdBQVc2cUI7UUFDckQ7UUFDQTs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQzZXLDBCQUEwQixHQUFHLENBQUMxaEMsV0FBV3d5QyxTQUFTaHlDLE9BQU8rTCxhQUFhODFCLElBQUk7WUFDM0UsSUFBSXJpQyxjQUFjLFNBQVM7Z0JBQ3ZCLElBQUksQ0FBQzRQLE1BQU0sQ0FBQyxRQUFRLENBQUMsNEJBQTRCLEVBQUU1UCxVQUFVLDZDQUE2QyxDQUFDO2dCQUMzR0EsWUFBWTtZQUNoQixPQUNLLElBQUlBLGNBQWMsVUFBVTtnQkFDN0IsSUFBSSxDQUFDNFAsTUFBTSxDQUFDLFFBQVEsQ0FBQyw0QkFBNEIsRUFBRTVQLFVBQVUsbURBQW1ELENBQUM7Z0JBQ2pIQSxZQUFZO1lBQ2hCO1lBQ0EsTUFBTXJELGVBQWUsSUFBSSxDQUFDeWYsS0FBSyxDQUFDZSxrQkFBa0IsQ0FBQ3RuQixPQUFPQyxPQUFPLENBQUMwOEMsU0FBUzMxQixNQUFNLENBQUMsQ0FBQ2lpQixLQUFLLENBQUN6aEMsV0FBV28xQyxPQUFPO2dCQUN2RyxJQUFJQSxPQUFPanVDLFNBQVMsRUFBRS9GLFFBQVE7b0JBQzFCZzBDLE9BQU9qdUMsU0FBUyxDQUFDL0YsTUFBTSxHQUFHaEUsS0FBS00sSUFBSSxDQUFDMDNDLE9BQU9qdUMsU0FBUyxDQUFDL0YsTUFBTTtnQkFDL0Q7Z0JBQ0EsSUFBSWcwQyxPQUFPanVDLFNBQVMsRUFBRWhHLE9BQU87b0JBQ3pCaTBDLE9BQU9qdUMsU0FBUyxDQUFDaEcsS0FBSyxHQUFHL0QsS0FBS00sSUFBSSxDQUFDMDNDLE9BQU9qdUMsU0FBUyxDQUFDaEcsS0FBSztnQkFDN0Q7Z0JBQ0EsTUFBTWswQyxPQUFPMXlDLGNBQWMsZUFDckIsbUJBQ0FBLGNBQWMscUJBQ1YseUJBQ0F2SjtnQkFDVixJQUFJaThDLE1BQU07b0JBQ041VCxHQUFHLENBQUN6aEMsVUFBVSxHQUFHO3dCQUNiLENBQUNxMUMsS0FBSyxFQUFFRCxPQUFPanVDLFNBQVM7b0JBQzVCO2dCQUNKO2dCQUNBLE9BQU9zNkI7WUFDWCxHQUFHLENBQUM7WUFDSixJQUFJbmlDLGNBQWM7Z0JBQ2QsSUFBSSxDQUFDc1EsbUJBQW1CLENBQUN0USxjQUFjNkQ7WUFDM0M7UUFDSjtRQUNBLElBQUksQ0FBQ3lNLG1CQUFtQixHQUFHLENBQUN0USxjQUFjNkQsT0FBTytMLGFBQWE4MUIsSUFBSTtZQUM5RCxNQUFNLzRCLGdCQUFnQixFQUFFO1lBQ3hCLEtBQUssTUFBTWdRLEtBQUszYyxhQUFjO2dCQUMxQiwrQ0FBK0M7Z0JBQy9DLElBQUkyYyxFQUFFeUgsa0JBQWtCLEVBQ3BCO2dCQUNKLDJEQUEyRDtnQkFDM0QsMERBQTBEO2dCQUMxRCw4QkFBOEI7Z0JBQzlCLElBQUl6SCxFQUFFdGEsY0FBYyxJQUFJc2EsRUFBRS9iLGVBQWUsQ0FBQ21ULFFBQVEsQ0FBQ3hVLFVBQVVzYSxLQUFLLEdBQUc7b0JBQ2pFbE4sY0FBY3JQLElBQUksQ0FBQzt3QkFDZm1ELFFBQVFrYyxFQUFFbGMsTUFBTTt3QkFDaEJDLFdBQVdpYyxFQUFFamMsU0FBUzt3QkFDdEIyQyxXQUFXOUQsVUFBVXNhLEtBQUs7d0JBQzFCaFMsV0FBVzhVLEVBQUV0YSxjQUFjO29CQUMvQjtnQkFDSjtnQkFDQSxJQUFJc2EsRUFBRXE1QixvQkFBb0IsSUFDdEJyNUIsRUFBRS9iLGVBQWUsQ0FBQ21ULFFBQVEsQ0FBQ3hVLFVBQVVvYSxZQUFZLEdBQUc7b0JBQ3BEaE4sY0FBY3JQLElBQUksQ0FBQzt3QkFDZm1ELFFBQVFrYyxFQUFFbGMsTUFBTTt3QkFDaEJDLFdBQVdpYyxFQUFFamMsU0FBUzt3QkFDdEIyQyxXQUFXOUQsVUFBVW9hLFlBQVk7d0JBQ2pDOVIsV0FBVzhVLEVBQUVxNUIsb0JBQW9CO29CQUNyQztnQkFDSjtnQkFDQSxJQUFJcjVCLEVBQUUvYixlQUFlLENBQUNtVCxRQUFRLENBQUN4VSxVQUFVcWEsa0JBQWtCLEdBQUc7b0JBQzFEak4sY0FBY3JQLElBQUksQ0FBQzt3QkFDZm1ELFFBQVFrYyxFQUFFbGMsTUFBTTt3QkFDaEJDLFdBQVdpYyxFQUFFamMsU0FBUzt3QkFDdEIyQyxXQUFXOUQsVUFBVXFhLGtCQUFrQjtvQkFDM0M7Z0JBQ0o7WUFDSjtZQUNBLGtCQUFrQjtZQUNsQixJQUFJLENBQUM4NEIseUJBQXlCLENBQUN6aEMsSUFBSSxDQUFDO2dCQUFFcE47Z0JBQU11d0IsTUFBTXpuQjtZQUFjO1FBQ3BFO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNteUIsc0JBQXNCLEdBQUcsQ0FBQ3ArQjtZQUMzQixPQUFPLElBQUksQ0FBQzJ5QyxhQUFhLEVBQUV2VSx1QkFBdUJwK0I7UUFDdEQ7UUFDQTs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ3UrQixxQkFBcUIsR0FBRyxDQUFDditCO1lBQzFCLE9BQU8sSUFBSSxDQUFDMnlDLGFBQWEsRUFBRXBVLHNCQUFzQnYrQjtRQUNyRDtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUN1MUMsYUFBYSxHQUFHLENBQUN2MUM7WUFDbEIsSUFBSSxDQUFDK2UsS0FBSyxDQUFDVyxpQkFBaUIsQ0FBQzFmLFdBQVc7Z0JBQ3BDOGIsVUFBVTFpQjtZQUNkO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDbWxCLHFCQUFxQixHQUFHLENBQUNpM0I7WUFDMUIsT0FBTyxJQUFJLENBQUN6MkIsS0FBSyxDQUFDUixxQkFBcUIsQ0FBQ2kzQjtRQUM1QztRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDcGIsb0JBQW9CLEdBQUcsT0FBT2pNO1lBQy9CLE9BQU8sSUFBSSxDQUFDaU4sU0FBUyxFQUFFbE4sMEJBQTBCQztRQUNyRDtRQUNBLElBQUksQ0FBQ3NrQixnQkFBZ0IsR0FBRztZQUNwQixPQUFPLElBQUl6ZSxRQUFRLENBQUN1RTtnQkFDaEIsSUFBSSxDQUFDeFosS0FBSyxDQUFDc0YsYUFBYSxDQUNuQmhCLElBQUksQ0FBQzN3Qix5UUFBU0EsQ0FBQyxDQUFDcXNCLFFBQVVBLFVBQVVsQyxhQUFhK2MsTUFBTSxFQUFFLE9BQU96bUMsc1FBQU1BLENBQUMsQ0FBQzJpQixJQUFNQSxNQUFNK0csYUFBYStjLE1BQU0sR0FDdkc3ZixTQUFTLENBQUMsSUFBTXdlO1lBQ3pCO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDa2QsWUFBWSxHQUFHLE9BQU8zNUI7WUFDdkIsT0FBTyxJQUFJLENBQUM4MUIsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxTQUFTLENBQUMsRUFBRWozQjtRQUMzRTtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNpSCxTQUFTLEdBQUcsT0FBT2hqQjtZQUNwQixPQUFPLElBQUksQ0FBQzZ4QyxZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNoRXh4QixTQUFTeGhCO1lBQ2I7UUFDSjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUM4aUIsV0FBVyxHQUFHLE9BQU85aUI7WUFDdEIsT0FBTyxJQUFJLENBQUM2eEMsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDbEV4eEIsU0FBU3hoQjtZQUNiO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDMjFDLFFBQVEsR0FBRyxDQUFDdnlDO1lBQ2IsTUFBTXd5QyxXQUFXLElBQUksQ0FBQzVjLGFBQWE7WUFDbkMsSUFBSTRjLFVBQVU7Z0JBQ1YsT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0QsVUFBVXh5QztZQUNuQztRQUNKO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQzB5QyxVQUFVLEdBQUcsQ0FBQzF5QztZQUNmLE1BQU1SLFlBQVk0VyxvQkFBb0JwVztZQUN0QyxJQUFJLENBQUNSLFdBQ0Q7WUFDSixNQUFNbXpDLGdCQUFnQixFQUFFO1lBQ3hCLEtBQUssTUFBTTFxQyxlQUFlLElBQUksQ0FBQzJULEtBQUssQ0FBQ3dHLGtCQUFrQixDQUFFO2dCQUNyRCxJQUFJbmEsWUFBWWxMLGVBQWUsQ0FBQ21ULFFBQVEsQ0FBQzFRLFlBQVk7b0JBQ2pEbXpDLGNBQWNsNUMsSUFBSSxDQUFDd08sWUFBWXJMLE1BQU07Z0JBQ3pDO1lBQ0o7WUFDQSxPQUFPLElBQUksQ0FBQzYxQyxRQUFRLENBQUNFLGVBQWUzeUM7UUFDeEM7UUFDQTs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ3l5QyxRQUFRLEdBQUcsQ0FBQzcxQyxRQUFRb0Q7WUFDckIsT0FBTyxJQUFJLENBQUN5dUMsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDckVnRCxVQUFVNzVDLE1BQU1DLE9BQU8sQ0FBQzRELFVBQVVBLFNBQVM7b0JBQUNBO2lCQUFPO2dCQUNuRCxDQUFDb0QsS0FBSyxFQUFFO1lBQ1o7UUFDSjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUM2eUMsWUFBWSxHQUFHLENBQUM3eUM7WUFDakIsT0FBTyxJQUFJLENBQUN5dUMsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDckVrRCxnQkFBZ0I7Z0JBQ2hCLENBQUM5eUMsS0FBSyxFQUFFO1lBQ1o7UUFDSjtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDK3lDLGNBQWMsR0FBRyxPQUFPaFo7WUFDekIsT0FBTyxJQUFJLENBQUMwVSxZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLGdCQUFnQixDQUFDLEVBQUU3VixVQUFVQSxVQUFVLENBQUM7UUFDdkc7UUFDQTs7U0FFQyxHQUNELElBQUksQ0FBQ2laLGFBQWEsR0FBRztZQUNqQixPQUFPLElBQUksQ0FBQ3ZFLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDNFYsb0JBQW9CLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztRQUNsRjtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDcUQsa0JBQWtCLEdBQUcsT0FBTzFpQjtZQUM3QixNQUFNLEVBQUU4UyxXQUFXLEVBQUUsR0FBRzlTO1lBQ3hCLE1BQU0yaUIsd0JBQXdCN1AsWUFBWS9NLEtBQUssQ0FBQyxDQUFDa04sYUFBZSxJQUFJLENBQUNqTSxrQkFBa0IsQ0FBQ2tNLFVBQVUsQ0FBQ0Q7WUFDbkcsSUFBSSxDQUFDMFAsdUJBQXVCO2dCQUN4QixNQUFNLElBQUk5K0MsTUFBTSxDQUFDLDRDQUE0QyxFQUFFaXZDLFlBQVkzckMsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUMzRjtZQUNBLE9BQU8sSUFBSSxDQUFDKzJDLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDNFYsb0JBQW9CLENBQUMsbUJBQW1CLENBQUMsRUFBRXJmO1FBQ3JGO1FBQ0E7Ozs7Ozs7Ozs7O1NBV0MsR0FDRCxJQUFJLENBQUM0aUIsZ0JBQWdCLEdBQUcsT0FBT3YyQyxRQUFReW1DO1lBQ25DLE9BQU8sSUFBSSxDQUFDK1AscUJBQXFCLENBQUM7Z0JBQzlCaDFCLFNBQVN4aEI7Z0JBQ1R5MkMsbUJBQW1CaFE7WUFDdkI7UUFDSjtRQUNBOzs7Ozs7Ozs7OztTQVdDLEdBQ0QsSUFBSSxDQUFDaVEsaUJBQWlCLEdBQUcsT0FBTzEyQyxRQUFReW1DO1lBQ3BDLE9BQU8sSUFBSSxDQUFDK1AscUJBQXFCLENBQUM7Z0JBQzlCaDFCLFNBQVN4aEI7Z0JBQ1QyMkMsb0JBQW9CbFE7WUFDeEI7UUFDSjtRQUNBOzs7Ozs7Ozs7U0FTQyxHQUNELElBQUksQ0FBQytQLHFCQUFxQixHQUFHLE9BQU83aUI7WUFDaEMsT0FBTyxJQUFJLENBQUNrZSxZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLGlCQUFpQixDQUFDLEVBQUVyZjtRQUNuRjtRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDaWpCLE1BQU0sR0FBRyxPQUFPampCLE9BQU8sQ0FBQyxDQUFDLEVBQUVyRjtZQUM1QixPQUFPLElBQUksQ0FBQ3VqQixZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxFQUFFcmYsTUFBTXJGO1FBQ2hGO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUN1b0IsUUFBUSxHQUFHO1lBQ1osT0FBTyxJQUFJLENBQUNoRixZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7UUFDN0U7UUFDQTs7U0FFQyxHQUNELElBQUksQ0FBQzhELFFBQVEsR0FBRztZQUNaLE9BQU8sSUFBSSxDQUFDakYsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLENBQUM7UUFDdEY7UUFDQTs7U0FFQyxHQUNELElBQUksQ0FBQytELE9BQU8sR0FBRztZQUNYLE9BQU8sSUFBSSxDQUFDbEYsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUM7UUFDckY7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDcDVCLE1BQU0sR0FBRyxPQUFPbzlCO1lBQ2pCLE1BQU1obkIsV0FBVyxNQUFNLElBQUksQ0FBQzZoQixZQUFZLENBQUNodEMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNtdUMsb0JBQW9CLENBQUMsQ0FBQyxFQUFFZ0U7WUFDL0UsTUFBTSxFQUFFemlDLElBQUksRUFBRTZLLE9BQU8sRUFBRStELGdCQUFnQixFQUFFLEdBQUc2TTtZQUM1QyxJQUFJLENBQUNoUixLQUFLLENBQUN1QixzQkFBc0IsQ0FBQ2hNO1lBQ2xDLElBQUksQ0FBQ3lLLEtBQUssQ0FBQ0csVUFBVSxDQUFDQztZQUN0QixJQUFJLENBQUNKLEtBQUssQ0FBQ0ssa0JBQWtCLENBQUM4RDtZQUM5QixPQUFPNk07UUFDWDtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDaW5CLE9BQU8sR0FBRztZQUNYLE9BQU8sSUFBSSxDQUFDcEYsWUFBWSxDQUFDelUsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM0VixvQkFBb0IsQ0FBQyxXQUFXLENBQUM7UUFDM0U7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDcjNCLEdBQUcsR0FBRyxDQUFDMWI7WUFDUixJQUFJLENBQUMrZSxLQUFLLENBQUNXLGlCQUFpQixDQUFDMWYsV0FBVztnQkFDcEMwYixLQUFLO29CQUNEQyxZQUFZO29CQUNaQyxVQUFVMWUsS0FBS0gsR0FBRztnQkFDdEI7WUFDSjtRQUNKO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ2s2QyxLQUFLLEdBQUcsQ0FBQ2ozQztZQUNWLElBQUksQ0FBQytlLEtBQUssQ0FBQ1csaUJBQWlCLENBQUMxZixXQUFXO2dCQUNwQzBiLEtBQUt0aUI7WUFDVDtRQUNKO1FBQ0E7Ozs7OztTQU1DLEdBQ0QsSUFBSSxDQUFDODlDLGNBQWMsR0FBRyxPQUFPaGE7WUFDekIsT0FBTyxJQUFJLENBQUMwVSxZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLElBQUksQ0FBQyxFQUFFN1Y7UUFDdEU7UUFDQTs7Ozs7O1NBTUMsR0FDRCxJQUFJLENBQUNpYSxnQkFBZ0IsR0FBRyxPQUFPamE7WUFDM0IsT0FBTyxJQUFJLENBQUMwVSxZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFN1Y7UUFDeEU7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDa2EsWUFBWSxHQUFHLENBQUNsYTtZQUNqQixPQUFPLElBQUksQ0FBQzBVLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxpQkFBaUI7Z0JBQzNDLEdBQUlELFdBQVcsQ0FBQyxDQUFDO2dCQUNqQjk1QixJQUFJLElBQUksQ0FBQ0EsRUFBRTtnQkFDWEQsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7UUFDSjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNrMEMsaUJBQWlCLEdBQUcsT0FBTzNqQjtZQUM1QixPQUFPLElBQUksQ0FBQ2tlLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDNFYsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEVBQUVyZjtRQUMxRTtRQUNBOzs7U0FHQyxHQUNELElBQUksQ0FBQzRqQixnQkFBZ0IsR0FBRztZQUNwQjFyQixhQUFhLElBQUksQ0FBQzJyQixXQUFXO1lBQzdCLElBQUksQ0FBQ3BGLGNBQWMsQ0FBQ2pnQixHQUFHLENBQUMvWCxtQkFBbUIsSUFBSSxDQUFDNEUsS0FBSyxDQUFDbUcsU0FBUyxFQUFFLENBQUMzTjtnQkFDOUQsSUFBSSxDQUFDQSxVQUNEO2dCQUNKLG9DQUFvQztnQkFDcEMsSUFBSSxJQUFJLENBQUN3SCxLQUFLLENBQUMyRyxZQUFZLEtBQUs3SSxhQUFhbWMsT0FBTyxFQUNoRDtnQkFDSixNQUFNd2UsY0FBY2pnQyxTQUFTeTdCLElBQUksQ0FBQ3lFLHNCQUFzQjtnQkFDeEQsdUJBQXVCO2dCQUN2QixJQUFJRCxlQUFlLEdBQ2Y7Z0JBQ0o1ckIsYUFBYSxJQUFJLENBQUMyckIsV0FBVztnQkFDN0IsSUFBSSxDQUFDQSxXQUFXLEdBQUdubUIsV0FBVztvQkFDMUIsSUFBSSxDQUFDdkssS0FBSyxHQUFHQyxLQUFLLENBQUMsQ0FBQ2hOO3dCQUNoQixJQUFJLENBQUN2SCxNQUFNLENBQUMsU0FBUyx1QkFBdUJ1SDtvQkFDaEQ7Z0JBQ0osR0FBRzA5QjtZQUNQO1FBQ0o7UUFDQTs7Ozs7OztTQU9DLEdBQ0QsSUFBSSxDQUFDRSxlQUFlLEdBQUcsT0FBT0M7WUFDMUIsSUFBSXJrQixXQUFXLElBQUksQ0FBQ3lmLG9CQUFvQjtZQUN4QyxJQUFJNEUsZUFBZTtnQkFDZnJrQixXQUFXLENBQUMsRUFBRUEsU0FBUyxDQUFDLEVBQUVxa0IsY0FBYyxDQUFDO1lBQzdDO1lBQ0EsT0FBTyxJQUFJLENBQUMvRixZQUFZLENBQUNwaEIsR0FBRyxDQUFDLENBQUMsRUFBRThDLFNBQVMsV0FBVyxDQUFDO1FBQ3pEO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ3NrQixlQUFlLEdBQUcsT0FBT2pqQztZQUMxQixPQUFPLElBQUksQ0FBQ2k5QixZQUFZLENBQUN6VSxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzRWLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUFFbHlDLFFBQVE4VDtZQUFRO1FBQzFGO1FBQ0EsSUFBSSxDQUFDdytCLGlCQUFpQixHQUFHO1lBQ3JCLElBQUksQ0FBQzRCLFVBQVUsQ0FBQztnQkFBRXpLLFdBQVc7WUFBTTtZQUNuQyxJQUFJLENBQUMwSyxPQUFPLENBQUM7Z0JBQUUxSyxXQUFXO1lBQU07UUFDcEM7UUFDQTs7Ozs7OztTQU9DLEdBQ0QsSUFBSSxDQUFDN0csc0JBQXNCLEdBQUcsQ0FBQ1YsU0FBUy9pQyxXQUFXMkM7WUFDL0MsT0FBTyxJQUFJLENBQUNvdkMsZ0JBQWdCLENBQUN0TyxzQkFBc0IsQ0FBQ1YsU0FBUy9pQyxXQUFXMkM7UUFDNUU7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDdS9CLFdBQVcsR0FBRyxDQUFDYTtZQUNoQixPQUFPLElBQUksQ0FBQ2dQLGdCQUFnQixDQUFDN1AsV0FBVyxDQUFDYTtRQUM3QztRQUNBOzs7Ozs7Ozs7Ozs7OztTQWNDLEdBQ0QsSUFBSSxDQUFDaUIsZ0JBQWdCLEdBQUcsQ0FBQ0MsY0FBY2prQyxXQUFXMkM7WUFDOUMsTUFBTWsxQyxTQUFTLElBQUksQ0FBQzlGLGdCQUFnQixDQUFDL04sZ0JBQWdCLENBQUNDLGNBQWNqa0MsV0FBVzJDO1lBQy9FLElBQUksQ0FBQ2sxQyxRQUNEO1lBQ0osSUFBSSxDQUFDMUYsY0FBYyxDQUFDamdCLEdBQUcsQ0FBQzJsQjtZQUN4QixPQUFPO2dCQUNILElBQUksQ0FBQzFGLGNBQWMsQ0FBQzdmLE1BQU0sQ0FBQ3VsQjtnQkFDM0JBO1lBQ0o7UUFDSjtRQUNBOzs7Ozs7Ozs7U0FTQyxHQUNELElBQUksQ0FBQ25TLGdCQUFnQixHQUFHLENBQUNDLGNBQWMzbEMsV0FBVzJDLFlBQVksWUFBWTtZQUN0RSxNQUFNazFDLFNBQVMsSUFBSSxDQUFDOUYsZ0JBQWdCLENBQUNyTSxnQkFBZ0IsQ0FBQ0MsY0FBYzNsQyxXQUFXMkM7WUFDL0UsSUFBSSxDQUFDazFDLFFBQ0Q7WUFDSixJQUFJLENBQUMxRixjQUFjLENBQUNqZ0IsR0FBRyxDQUFDMmxCO1lBQ3hCLE9BQU87Z0JBQ0gsSUFBSSxDQUFDMUYsY0FBYyxDQUFDN2YsTUFBTSxDQUFDdWxCO2dCQUMzQkE7WUFDSjtRQUNKO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNDLHdCQUF3QixHQUFHLENBQUNDLGNBQWM1ckIsT0FBTyxDQUFDLENBQUM7WUFDcEQsTUFBTTZyQixjQUFjO2dCQUNoQkQsYUFBYUUsR0FBRyxHQUNaOXJCLEtBQUsrckIsbUJBQW1CLElBQ3BCO1lBQ1o7WUFDQSxNQUFNbCtCLGNBQWNHLG1CQUFtQixJQUFJLENBQUM0RSxLQUFLLENBQUNzRyxXQUFXLEVBQUUsQ0FBQ2xFO2dCQUM1RCxJQUFJLENBQUNBLFlBQ0Q7Z0JBQ0o0MkIsYUFBYTVzQixnQkFBZ0IsQ0FBQyxTQUFTNnNCO2dCQUN2QyxNQUFNRyxlQUFlLElBQUlDLElBQUlqM0IsV0FBV2szQixTQUFTO2dCQUNqREYsYUFBYUcsWUFBWSxDQUFDbnJCLEdBQUcsQ0FBQyxLQUFLeEQsT0FBT291QixhQUFhclQsV0FBVztnQkFDbEV5VCxhQUFhRyxZQUFZLENBQUNuckIsR0FBRyxDQUFDLEtBQUt4RCxPQUFPb3VCLGFBQWFwVCxZQUFZO2dCQUNuRW9ULGFBQWFFLEdBQUcsR0FBR0UsYUFBYTc2QyxRQUFRO1lBQzVDO1lBQ0EsT0FBTztnQkFDSDBjO2dCQUNBKzlCLGFBQWFoc0IsbUJBQW1CLENBQUMsU0FBU2lzQjtZQUM5QztRQUNKO1FBQ0EsSUFBSSxDQUFDNzBDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNxakIsR0FBRyxHQUFHLENBQUMsRUFBRXRqQixLQUFLLENBQUMsRUFBRUMsR0FBRyxDQUFDO1FBQzFCLElBQUksQ0FBQzZ2QyxjQUFjLEdBQUcsSUFBSTVnRCwyUUFBZUEsQ0FBQ2dxQztRQUMxQyxJQUFJLENBQUN5VixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0YsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDa0Isb0JBQW9CLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDNXZDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxFQUFFLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUNtUCxNQUFNLEdBQUdSLFVBQVU7WUFBQztTQUFPO1FBQ2hDLE1BQU13bUMsaUJBQWlCalIsVUFBVTlXLEdBQUcsQ0FBQ3J0QjtRQUNyQyxNQUFNcTFDLG9CQUFvQmw2QixzQkFBc0JpNkIsZUFBZW5nRCxPQUFPLENBQUNrbUIsa0JBQWtCO1FBQ3pGLElBQUlrNkIsbUJBQW1CO1lBQ25CLElBQUksQ0FBQ3o1QixLQUFLLENBQUNSLHFCQUFxQixDQUFDaTZCO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDejVCLEtBQUssQ0FBQ0csVUFBVSxDQUFDQyxXQUFXLEVBQUU7UUFDbkMsSUFBSSxDQUFDSixLQUFLLENBQUNLLGtCQUFrQixDQUFDd0csbUJBQW1CLEVBQUU7UUFDbkQsSUFBSSxDQUFDN0csS0FBSyxDQUFDRCxlQUFlLENBQUN1ZCxVQUFVeGYsYUFBYW1jLE9BQU8sR0FBR25jLGFBQWE0N0IsSUFBSTtRQUM3RSxJQUFJLENBQUMzakMsRUFBRSxDQUFDLE9BQU8sQ0FBQ2tMO1lBQ1osMENBQTBDO1lBQzFDLElBQUksQ0FBQ2pCLEtBQUssQ0FBQ2dCLGVBQWUsQ0FBQ0M7UUFDL0I7UUFDQSxJQUFJLENBQUNteUIsY0FBYyxDQUFDamdCLEdBQUcsQ0FBQ2tLLHNCQUFzQixJQUFJLEVBQUUsSUFBSSxDQUFDcmQsS0FBSyxFQUFFLElBQUksQ0FBQ3dMLFVBQVU7UUFDL0UsSUFBSSxDQUFDbXVCLGVBQWU7UUFDcEIsSUFBSSxDQUFDdkcsY0FBYyxDQUFDamdCLEdBQUcsQ0FBQy9YLG1CQUFtQixJQUFJLENBQUM2M0IseUJBQXlCLENBQUMzdUIsSUFBSSxDQUFDandCLHdRQUFRQSxDQUFDLENBQUNtRixJQUFNbEYscVFBQUtBLENBQUNrRixFQUFFNEssSUFBSSxJQUFJNVEsbVFBQUtBLENBQUMsQ0FBQ2dHLElBQU1BLEVBQUVtN0IsSUFBSSxJQUFJLENBQUN6bkIsZ0JBQWtCLElBQUksQ0FBQ3FlLFNBQVMsRUFBRTFhLG9CQUFvQjNEO1FBQzdMLElBQUksQ0FBQ2d2QixNQUFNLEdBQUcsSUFBSXNTLGNBQWMsSUFBSTtRQUNwQyxJQUFJLENBQUNwUyxVQUFVLEdBQUcsSUFBSWtWLGtCQUFrQixJQUFJO1FBQzVDLElBQUksQ0FBQ3RLLE9BQU8sR0FBRyxJQUFJNEw7UUFDbkIsSUFBSSxDQUFDa0IsV0FBVyxHQUFHLElBQUkxQixtQkFBbUIsSUFBSTtJQUNsRDtJQUNBdUgsa0JBQWtCO1FBQ2QsSUFBSSxDQUFDdkcsY0FBYyxDQUFDamdCLEdBQUcsQ0FDdkIscUVBQXFFO1FBQ3JFL1gsbUJBQW1CLElBQUksQ0FBQzRFLEtBQUssQ0FBQ21HLFNBQVMsRUFBRSxDQUFDM047WUFDdEMsSUFBSSxDQUFDQSxVQUNEO1lBQ0osSUFBSSxDQUFDbWpCLGtCQUFrQixDQUFDZ00sZUFBZSxDQUFDbnZCO1FBQzVDO1FBQ0EsSUFBSSxDQUFDNDZCLGNBQWMsQ0FBQ2pnQixHQUFHLENBQ3ZCLDBEQUEwRDtRQUMxRC9YLG1CQUFtQixJQUFJLENBQUM0RSxLQUFLLENBQUNxRixnQkFBZ0IsRUFBRSxDQUFDd0I7WUFDN0MsaUNBQWlDO1lBQ2pDLElBQUksQ0FBQzhVLGtCQUFrQixDQUFDK0wsY0FBYyxDQUFDN2dCO1lBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUN3VixTQUFTLEVBQ2Y7WUFDSixpRkFBaUY7WUFDakYsTUFBTXVkLHdCQUF3QjtnQkFDMUIsQ0FBQy9qRCxjQUFjYSxVQUFVLENBQUMsRUFBRW9KLFVBQVV1YSxLQUFLO2dCQUMzQyxDQUFDeGtCLGNBQWNjLFVBQVUsQ0FBQyxFQUFFbUosVUFBVXNhLEtBQUs7Z0JBQzNDLENBQUN2a0IsY0FBY1ksV0FBVyxDQUFDLEVBQUVxSixVQUFVb2EsWUFBWTtZQUN2RDtZQUNBLEtBQUssTUFBTSxDQUFDMHRCLFlBQVloa0MsVUFBVSxJQUFJbkssT0FBT0MsT0FBTyxDQUFDa2dELHVCQUF3QjtnQkFDekUsTUFBTWhlLGdCQUFnQixJQUFJLENBQUNELGtCQUFrQixDQUFDQyxhQUFhLENBQUNnTTtnQkFDNUQsSUFBSSxDQUFDaE0saUJBQ0EsS0FBSSxDQUFDUyxTQUFTLENBQUMzTixZQUFZLENBQUM5cUIsY0FDekIsSUFBSSxDQUFDeTRCLFNBQVMsQ0FBQ3pOLE1BQU0sQ0FBQ2hyQixVQUFTLEdBQUk7b0JBQ3ZDLDBDQUEwQztvQkFDMUMsSUFBSSxDQUFDMDRCLFdBQVcsQ0FBQzE0QixXQUNabWtCLEtBQUssQ0FBQyxDQUFDaE47d0JBQ1IsSUFBSSxDQUFDdkgsTUFBTSxDQUFDLFNBQVMsQ0FBQyx1QkFBdUIsRUFBRTVQLFVBQVUsQ0FBQyxFQUFFbVg7b0JBQ2hFLEdBQ0t3ZCxJQUFJLENBQUM7d0JBQ04sSUFBSTMwQixjQUFjOUQsVUFBVXNhLEtBQUssSUFDN0IsSUFBSSxDQUFDOGhCLE1BQU0sQ0FBQ2xjLEtBQUssQ0FBQ29yQixNQUFNLEtBQUssV0FBVzs0QkFDeEMsSUFBSSxDQUFDbFAsTUFBTSxDQUNOQyxPQUFPLEdBQ1BwVSxLQUFLLENBQUMsQ0FBQ2hOLE1BQVEsSUFBSSxDQUFDdkgsTUFBTSxDQUFDLFNBQVMsQ0FBQywrQ0FBK0MsQ0FBQyxFQUFFdUg7d0JBQ2hHO3dCQUNBLElBQUluWCxjQUFjOUQsVUFBVXVhLEtBQUssSUFDN0IsSUFBSSxDQUFDK2hCLFVBQVUsQ0FBQ3BjLEtBQUssQ0FBQ29yQixNQUFNLEtBQUssV0FBVzs0QkFDNUMsSUFBSSxDQUFDaFAsVUFBVSxDQUNWRCxPQUFPLEdBQ1BwVSxLQUFLLENBQUMsQ0FBQ2hOLE1BQVEsSUFBSSxDQUFDdkgsTUFBTSxDQUFDLFNBQVMsQ0FBQyxtREFBbUQsQ0FBQyxFQUFFdUg7d0JBQ3BHO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ3E0QixjQUFjLENBQUNqZ0IsR0FBRyxDQUN2QiwrREFBK0Q7UUFDL0QvWCxtQkFBbUIsSUFBSSxDQUFDNEUsS0FBSyxDQUFDd0YsZUFBZSxFQUFFLE9BQU9zQjtZQUNsRCxJQUFJLENBQUNBLGtCQUFrQkEsZUFBZXRzQixNQUFNLEtBQUssR0FDN0M7WUFDSixNQUFNdy9CLGdCQUFnQixJQUFJLENBQUNBLGFBQWE7WUFDeEMsSUFBSUEsaUJBQWlCbFQsZUFBZXhTLFFBQVEsQ0FBQzBsQixnQkFBZ0I7Z0JBQ3pELElBQUksQ0FBQ3htQixNQUFNLENBQUMsUUFBUTtnQkFDcEIsTUFBTSxJQUFJLENBQUNzVSxLQUFLO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJLENBQUNzckIsY0FBYyxDQUFDamdCLEdBQUcsQ0FDdkIsbUNBQW1DO1FBQ25DL1gsbUJBQW1CLElBQUksQ0FBQzRFLEtBQUssQ0FBQ3NGLGFBQWEsRUFBRSxDQUFDcUI7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQzJXLE9BQU8sRUFDYjtZQUNKLElBQUkzVyxpQkFBaUI3SSxhQUFhK2MsTUFBTSxJQUNwQ2xVLGlCQUFpQjdJLGFBQWFnZCxPQUFPLElBQ3JDblUsaUJBQWlCN0ksYUFBYStKLElBQUksRUFBRTtnQkFDcENnRixhQUFhLElBQUksQ0FBQzJyQixXQUFXO2dCQUM3QixJQUFJLENBQUNBLFdBQVcsR0FBR24rQztZQUN2QjtRQUNKO1FBQ0EsSUFBSSxDQUFDKzRDLGNBQWMsQ0FBQ2pnQixHQUFHLENBQ3ZCLDRDQUE0QztRQUM1Qy9YLG1CQUFtQixJQUFJLENBQUM4NEIsY0FBYyxFQUFFLENBQUMyRjtZQUNyQyxJQUFJLENBQUNBLFdBQ0Q7WUFDSixJQUFJLENBQUN0QixnQkFBZ0I7WUFDckIsSUFBSSxJQUFJLENBQUN2NEIsS0FBSyxDQUFDMkcsWUFBWSxLQUFLN0ksYUFBYTQ3QixJQUFJLEVBQUU7Z0JBQy9DLElBQUksQ0FBQzE1QixLQUFLLENBQUNELGVBQWUsQ0FBQ2pDLGFBQWFtYyxPQUFPO1lBQ25EO1lBQ0EsSUFBSSxDQUFDbVosY0FBYyxDQUFDamdCLEdBQUcsQ0FBQ29LLGlDQUFpQyxJQUFJO1FBQ2pFO0lBQ0o7SUFDQTs7S0FFQyxHQUNELElBQUlELFVBQVU7UUFDVixPQUFPemlCLGdCQUFnQixJQUFJLENBQUNxNUIsY0FBYztJQUM5QztJQUNBOztLQUVDLEdBQ0QsSUFBSWxhLGdCQUFnQjtRQUNoQixPQUFPLElBQUksQ0FBQzhZLFdBQVcsQ0FBQzlxQixhQUFhLEVBQUUzakI7SUFDM0M7SUFDQTs7S0FFQyxHQUNELElBQUltMkIsZ0JBQWdCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDeGEsS0FBSyxDQUFDaUgsU0FBUyxFQUFFNWlCLE9BQU8sSUFBSSxDQUFDMjFCLGFBQWE7SUFDMUQ7SUFDQSxNQUFNZ2MsV0FBVzM4QyxPQUFPLEVBQUU7UUFDdEIsNENBQTRDO1FBQzVDLElBQUksSUFBSSxDQUFDNmlDLE1BQU0sQ0FBQ21QLGFBQWEsRUFBRTtZQUMzQixNQUFNLElBQUksQ0FBQ25QLE1BQU0sQ0FBQ21QLGFBQWE7UUFDbkM7UUFDQSxJQUFJLElBQUksQ0FBQ25QLE1BQU0sQ0FBQ3lQLGNBQWMsRUFBRTtZQUM1QixNQUFNLElBQUksQ0FBQ3pQLE1BQU0sQ0FBQ3lQLGNBQWM7UUFDcEM7UUFDQSxJQUFJLElBQUksQ0FBQzNyQixLQUFLLENBQUNrRSxnQkFBZ0IsRUFBRTRiLGVBQzdCLENBQUMsSUFBSSxDQUFDbkUsa0JBQWtCLENBQUNDLGFBQWEsQ0FBQyxlQUFlO1lBQ3REO1FBQ0o7UUFDQSwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQ00sTUFBTSxDQUFDbGMsS0FBSyxDQUFDeEwsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDMG5CLE1BQU0sQ0FBQ2xjLEtBQUssQ0FBQyttQixjQUFjLEVBQUU7WUFDbkUsSUFBSStTLG1CQUFtQjtZQUN2QixNQUFNQyxpQkFBaUIsSUFBSSxDQUFDLzVCLEtBQUssQ0FBQ3hILFFBQVEsRUFBRWtWLE1BQU1zc0I7WUFDbEQsSUFBSUQsZ0JBQWdCO2dCQUNoQkQsbUJBQW1CQyxtQkFBbUIsVUFBVSxVQUFVO1lBQzlEO1lBQ0EsSUFBSSxDQUFDN2QsTUFBTSxDQUFDbGMsS0FBSyxDQUFDc3VCLFlBQVksQ0FBQ3dMO1FBQ25DO1FBQ0Esd0JBQXdCO1FBQ3hCLE1BQU14aEMsbUJBQW1CLElBQUksQ0FBQzBILEtBQUssQ0FBQ3hILFFBQVEsRUFBRWtWLE1BQU1DO1FBQ3BELElBQUlyVixrQkFBa0I7WUFDbEIsTUFBTSxJQUFJLENBQUM0akIsTUFBTSxDQUFDMFMsc0JBQXNCLENBQUN0MkI7UUFDN0M7UUFDQSxJQUFJamYsUUFBUWt5QyxTQUFTLEVBQUU7WUFDbkIsZ0RBQWdEO1lBQ2hELElBQUksSUFBSSxDQUFDclAsTUFBTSxDQUFDbGMsS0FBSyxDQUFDb3JCLE1BQU0sS0FBSyxhQUM3QixJQUFJLENBQUNsUCxNQUFNLENBQUNsYyxLQUFLLENBQUNrTixXQUFXLElBQzdCLENBQUMsSUFBSSxDQUFDbVAsU0FBUyxFQUFFM04sYUFBYTV1QixVQUFVc2EsS0FBSyxHQUFHO2dCQUNoRCxNQUFNLElBQUksQ0FBQzIwQixrQkFBa0IsQ0FBQyxJQUFJLENBQUM3UyxNQUFNLENBQUNsYyxLQUFLLENBQUNrTixXQUFXLEVBQUU7b0JBQ3pENVosZ0JBQWdCLElBQUksQ0FBQzRvQixNQUFNLENBQUM1b0IsY0FBYztnQkFDOUM7WUFDSjtZQUNBLDBFQUEwRTtZQUMxRSxJQUFJLElBQUksQ0FBQzRvQixNQUFNLENBQUNsYyxLQUFLLENBQUNvckIsTUFBTSxLQUFLL3dDLGFBQzdCLElBQUksQ0FBQzJsQixLQUFLLENBQUN4SCxRQUFRLEVBQUVrVixNQUFNdXNCLG1CQUFtQjtnQkFDOUMsTUFBTSxJQUFJLENBQUMvZCxNQUFNLENBQUNoUyxNQUFNO1lBQzVCO1FBQ0o7SUFDSjtJQUNBLE1BQU0rckIsUUFBUTU4QyxPQUFPLEVBQUU7UUFDbkIseUNBQXlDO1FBQ3pDLElBQUksSUFBSSxDQUFDK2lDLFVBQVUsQ0FBQ2lQLGFBQWEsRUFBRTtZQUMvQixNQUFNLElBQUksQ0FBQ2pQLFVBQVUsQ0FBQ2lQLGFBQWE7UUFDdkM7UUFDQSxJQUFJLElBQUksQ0FBQ2pQLFVBQVUsQ0FBQ3VQLGNBQWMsRUFBRTtZQUNoQyxNQUFNLElBQUksQ0FBQ3ZQLFVBQVUsQ0FBQ3VQLGNBQWM7UUFDeEM7UUFDQSxJQUFJLElBQUksQ0FBQzNyQixLQUFLLENBQUNrRSxnQkFBZ0IsRUFBRThiLGVBQzdCLENBQUMsSUFBSSxDQUFDckUsa0JBQWtCLENBQUNDLGFBQWEsQ0FBQyxlQUFlO1lBQ3REO1FBQ0o7UUFDQSxJQUFJdmlDLFFBQVFreUMsU0FBUyxFQUFFO1lBQ25CLHFEQUFxRDtZQUNyRCxJQUFJLElBQUksQ0FBQ25QLFVBQVUsQ0FBQ3BjLEtBQUssQ0FBQ29yQixNQUFNLEtBQUssYUFDakMsSUFBSSxDQUFDaFAsVUFBVSxDQUFDcGMsS0FBSyxDQUFDa04sV0FBVyxJQUNqQyxDQUFDLElBQUksQ0FBQ21QLFNBQVMsRUFBRTNOLGFBQWE1dUIsVUFBVXVhLEtBQUssR0FBRztnQkFDaEQsTUFBTSxJQUFJLENBQUNvM0Isa0JBQWtCLENBQUMsSUFBSSxDQUFDclYsVUFBVSxDQUFDcGMsS0FBSyxDQUFDa04sV0FBVztZQUNuRTtZQUNBLHVFQUF1RTtZQUN2RSxJQUFJLElBQUksQ0FBQ2tQLFVBQVUsQ0FBQ3BjLEtBQUssQ0FBQ29yQixNQUFNLEtBQUsvd0MsYUFDakMsSUFBSSxDQUFDMmxCLEtBQUssQ0FBQ3hILFFBQVEsRUFBRXN2QixNQUFNb1MsZ0JBQWdCO2dCQUMzQyxNQUFNLElBQUksQ0FBQzlkLFVBQVUsQ0FBQ2xTLE1BQU07WUFDaEM7UUFDSjtJQUNKO0FBQ0o7QUFFQSxNQUFNaXdCO0lBQ0Z4aEQsYUFBYztRQUNWLElBQUksQ0FBQ3loRCx3QkFBd0IsR0FBRztRQUNoQyxJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLHFCQUFxQixHQUFHO1FBQzdCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcza0I7SUFDNUI7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU00a0IsZUFBZSxPQUFPQyxhQUFhQztJQUNyQyxNQUFNQyxjQUFjO0lBQ3BCLElBQUssSUFBSTc4QyxJQUFJLEdBQUdBLElBQUk2OEMsYUFBYTc4QyxJQUFLO1FBQ2xDLElBQUk7WUFDQSxNQUFNOUssOENBQUtBLENBQUNvckMsSUFBSSxDQUFDLENBQUMsNENBQTRDLEVBQUVxYyxZQUFZLENBQUMsRUFBRUM7UUFDbkYsRUFDQSxPQUFPLzRDLEdBQUc7WUFDTixNQUFNcXpCLE1BQU0sQ0FBQ2wzQixJQUFJLEtBQUs7WUFDdEI7UUFDSjtRQUNBO0lBQ0o7QUFDSjtBQUNBLFNBQVM4OEMsb0JBQW9CQyxVQUFVLEVBQUU1NUIsS0FBSztJQUMxQyxPQUFPO1FBQ0gsR0FBR0EsS0FBSztRQUNSLEdBQUc2NUIsbUJBQW1CRCxXQUFXO0lBQ3JDO0FBQ0o7QUFDQSxTQUFTQyxtQkFBbUJELFVBQVU7SUFDbEMsTUFBTSxFQUFFRSxNQUFNLEVBQUUsR0FBR0Y7SUFDbkIsT0FBTztRQUNIRyxhQUFhSCxXQUFXcG1CLEVBQUUsRUFBRXBIO1FBQzVCK0wsS0FBS3loQixXQUFXSSxTQUFTO1FBQ3pCQyxTQUFTSCxPQUFPei9DLEdBQUc7UUFDbkI2L0MsVUFBVUosT0FBT0ssY0FBYyxDQUFDaEIsd0JBQXdCO1FBQ3hEaUIsUUFBUSxJQUFJbDlDLE9BQU9XLE9BQU87UUFDMUJ3OEMsV0FBV1AsT0FBT1EsV0FBVztRQUM3Qjd1QyxPQUFPcXVDLE9BQU9TLFlBQVksQ0FBQzl1QyxLQUFLO1FBQ2hDOFYsU0FBU3U0QixPQUFPVSxNQUFNO1FBQ3RCQyxjQUFjWCxPQUFPWSxLQUFLO1FBQzFCLGlDQUFpQztRQUNqQ24yQyxRQUFRO1FBQ1JvMkMsV0FBV2YsV0FBV2dCLFlBQVk7UUFDbENDLFlBQVlqQixXQUFXcG1CLEVBQUU7UUFDekJzbkIseUJBQXlCaEIsT0FBT0ssY0FBYyxDQUFDZCxxQkFBcUI7UUFDcEUwQixtQkFBbUJqQixPQUFPSyxjQUFjLENBQUNmLGVBQWU7UUFDeEQ0QixZQUFZcEIsV0FBV3FCLFNBQVM7UUFDaEM5RyxRQUFRLE9BQU92akMsY0FBYyxjQUFjQSxXQUFXcWxCLFNBQVM7UUFDL0RpbEIsWUFBWSxPQUFPdHFDLGNBQWMsY0FBY0EsV0FBV2dHLFlBQVk7UUFDdEV1a0Msb0JBQW9CckIsT0FBT0ssY0FBYyxDQUFDYixnQkFBZ0I7SUFDOUQ7QUFDSjtBQUNBLFNBQVM4QixrQ0FBa0N4QixVQUFVO0lBQ2pELE9BQU9DLG1CQUFtQkQ7QUFDOUI7QUFFQSw0Q0FBNEM7QUFDNUMsTUFBTXlCLGVBQWUsQ0FBQ0MsTUFBUUEsSUFBSTEzQyxJQUFJLEtBQUt4SztBQUMzQyxNQUFNbWlELGVBQWUsQ0FBQ0QsTUFBUUEsSUFBSXQxQyxLQUFLLEtBQUs1TTtBQUM1Qzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNELE1BQU1vaUQ7SUFDRjlqRCxZQUFZb2lELE1BQU0sQ0FBRTtRQUNoQixJQUFJLENBQUMyQixJQUFJLEdBQUcsQ0FBQ3orQyxLQUFLMCtDLFFBQVEsQ0FBQyxDQUFDLEVBQUUxdUMsUUFBUSxNQUFNO1lBQ3hDLElBQUksQ0FBQzhzQyxNQUFNLENBQUN2bkMsTUFBTSxDQUFDdkYsT0FBTyxnQkFBZ0JoUSxLQUFLO2dCQUMzQyxHQUFHMCtDLEtBQUs7WUFDWjtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQzdCO1lBQ2QsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO1FBQ2xCO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ0UsU0FBUyxHQUFHO1lBQ2IsTUFBTTNyQixTQUFTLElBQUl1dEI7WUFDbkIsOEVBQThFO1lBQzlFLDBCQUEwQjtZQUMxQnZ0QixPQUFPbEIsR0FBRyxDQUFDLFdBQVcsSUFBSSxDQUFDMnNCLE1BQU0sQ0FBQ3ovQyxHQUFHO1lBQ3JDZzBCLE9BQU9sQixHQUFHLENBQUMsb0JBQW9CLElBQUksQ0FBQzJzQixNQUFNLENBQUNRLFdBQVc7WUFDdERqc0IsT0FBT2xCLEdBQUcsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDMnNCLE1BQU0sQ0FBQytCLFlBQVk7WUFDdEQsNERBQTREO1lBQzVELE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQy9CLE1BQU0sQ0FBQ2dDLFNBQVMsQ0FBQyxTQUFTLEVBQUV6dEIsT0FBTy93QixRQUFRLEdBQUcsQ0FBQztRQUNsRTtRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDeStDLG1CQUFtQixHQUFHLENBQUMvN0I7WUFDeEIsSUFBSUEsTUFBTTdjLElBQUksS0FBSyxXQUFXO2dCQUMxQiw4QkFBOEI7Z0JBQzlCLElBQUksQ0FBQ3M0QyxJQUFJLENBQUM7Z0JBQ1YseUZBQXlGO2dCQUN6RixJQUFJLENBQUNPLFVBQVUsQ0FBQyxPQUFPO1lBQzNCLE9BQ0ssSUFBSWg4QixNQUFNN2MsSUFBSSxLQUFLLFVBQVU7Z0JBQzlCLHFCQUFxQjtnQkFDckIsbURBQW1EO2dCQUNuRCw4RUFBOEU7Z0JBQzlFLCtGQUErRjtnQkFDL0YsSUFBSSxDQUFDczRDLElBQUksQ0FBQyxDQUFDLDhEQUE4RCxFQUFFLElBQUksQ0FBQ1EsU0FBUyxDQUFDLENBQUM7Z0JBQzNGLElBQUksQ0FBQyxJQUFJLENBQUNBLFNBQVMsRUFBRTtvQkFDakIsSUFBSSxDQUFDQyxVQUFVLENBQUM7d0JBQUVDLFVBQVU7b0JBQUc7Z0JBQ25DO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUNDO1lBQ1gsSUFBSSxJQUFJLENBQUNBLElBQUksS0FBS0EsTUFDZDtZQUNKLE1BQU1uNkIsT0FBTyxJQUFJLENBQUM0M0IsTUFBTSxDQUFDNTNCLElBQUk7WUFDN0IsSUFBSSxDQUFDQSxNQUFNO2dCQUNQLElBQUksQ0FBQzQzQixNQUFNLENBQUN2bkMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxpQ0FBaUMsQ0FBQztnQkFDL0Q7WUFDSjtZQUNBLE1BQU05RyxRQUFRLElBQUksQ0FBQ3F1QyxNQUFNLENBQUN3QyxTQUFTO1lBQ25DLElBQUksQ0FBQzd3QyxPQUFPO2dCQUNSLElBQUksQ0FBQ3F1QyxNQUFNLENBQUN2bkMsTUFBTSxDQUFDLFNBQVMsQ0FBQyx5Q0FBeUMsQ0FBQztnQkFDdkU7WUFDSjtZQUNBLE1BQU1ncUMsY0FBYztnQkFDaEI5d0M7Z0JBQ0FndkMsY0FBYztvQkFDVnIzQyxJQUFJOGUsS0FBSzllLEVBQUU7b0JBQ1h4TCxNQUFNc3FCLEtBQUt0cUIsSUFBSTtvQkFDZjRJLE9BQU8waEIsS0FBSzFoQixLQUFLO29CQUNqQkssUUFBUXFoQixLQUFLcmhCLE1BQU07Z0JBQ3ZCO1lBQ0o7WUFDQSxJQUFJLENBQUMyN0Msa0JBQWtCLEdBQUc7WUFDMUIsSUFBSSxDQUFDaHBCLEVBQUUsRUFBRTRELEtBQUtyaEIsS0FBS0MsU0FBUyxDQUFDdW1DO1lBQzdCLElBQUksQ0FBQ2QsSUFBSSxDQUFDLDhCQUE4QjtnQkFBRVk7WUFBSztRQUNuRDtRQUNBLElBQUksQ0FBQ0ksU0FBUyxHQUFHLENBQUNKLE1BQU1yOEI7WUFDcEIsSUFBSSxJQUFJLENBQUNxOEIsSUFBSSxLQUFLQSxNQUNkO1lBQ0osSUFBSSxDQUFDWixJQUFJLENBQUMsb0NBQW9DO2dCQUFFejdCO2dCQUFPcThCO1lBQUs7WUFDNUQsTUFBTTNvQixPQUFPLE9BQU8xVCxNQUFNMFQsSUFBSSxLQUFLLFdBQzdCM2QsS0FBS2pZLEtBQUssQ0FBQ2tpQixNQUFNMFQsSUFBSSxJQUNyQjtZQUNOLHlFQUF5RTtZQUN6RSxpR0FBaUc7WUFDakcsMkJBQTJCO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUNncEIsVUFBVSxJQUFJaHBCLFFBQVFBLEtBQUt2d0IsSUFBSSxLQUFLLG9CQUFvQjtnQkFDOUQsSUFBSSxDQUFDdTVDLFVBQVUsR0FBRztnQkFDbEIsSUFBSWhwQixLQUFLMXRCLEtBQUssRUFBRTtvQkFDWixrRUFBa0U7b0JBQ2xFLElBQUksQ0FBQzIyQyxhQUFhLEdBQUcsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ2xwQixNQUFNO29CQUNsRDtnQkFDSjtZQUNKO1lBQ0Esc0JBQXNCO1lBQ3RCLElBQUksQ0FBQ21wQixTQUFTLEdBQUcsSUFBSTMvQztZQUNyQixJQUFJdzJCLFFBQ0NBLENBQUFBLEtBQUt2d0IsSUFBSSxLQUFLLGtCQUFrQnV3QixLQUFLdndCLElBQUksS0FBSyxlQUFjLEdBQUk7Z0JBQ2pFLHVEQUF1RDtnQkFDdkQsSUFBSSxDQUFDMjVDLGdCQUFnQjtZQUN6QjtZQUNBLElBQUlwcEIsUUFBUUEsS0FBS3Z3QixJQUFJLEtBQUssaUJBQWlCO2dCQUN2QyxJQUFJLENBQUM0NUMsY0FBYyxHQUFHcnBCO2dCQUN0QixJQUFJLENBQUNzb0IsVUFBVSxDQUFDO1lBQ3BCO1lBQ0EsSUFBSXRvQixRQUFRQSxLQUFLdndCLElBQUksS0FBSyxzQkFBc0J1d0IsS0FBSzF0QixLQUFLLEVBQUU7Z0JBQ3hELE1BQU0sRUFBRXBDLElBQUksRUFBRSxHQUFHOHZCLEtBQUsxdEIsS0FBSztnQkFDM0IsSUFBSSxDQUFDaTJDLFNBQVMsR0FBRztnQkFDakIsSUFBSSxDQUFDZSxZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQ0MsbUJBQW1CLElBQUk7Z0JBQzVCLElBQUlyNUMsU0FBU3V3QixXQUFXQyxhQUFhLElBQ2pDLENBQUMsSUFBSSxDQUFDMGxCLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDMkMsUUFBUSxJQUFJO29CQUN0Q3R4QixhQUFhLElBQUksQ0FBQ3V4Qix5QkFBeUI7b0JBQzNDLElBQUksQ0FBQzFCLElBQUksQ0FBQztvQkFDVixJQUFJLENBQUNTLFVBQVUsQ0FBQzt3QkFBRWtCLGNBQWM7b0JBQUs7Z0JBQ3pDO1lBQ0o7WUFDQSxJQUFJMXBCLE1BQU07Z0JBQ04sSUFBSSxDQUFDb21CLE1BQU0sQ0FBQ3VELGFBQWEsQ0FBQzNwQjtZQUM5QjtZQUNBLElBQUksQ0FBQ21FLHVCQUF1QjtRQUNoQztRQUNBLElBQUksQ0FBQ3lsQixPQUFPLEdBQUcsQ0FBQ2pCLE1BQU1yOEI7WUFDbEIsSUFBSSxJQUFJLENBQUNxOEIsSUFBSSxLQUFLQSxNQUNkO1lBQ0osSUFBSSxDQUFDWixJQUFJLENBQUMsb0NBQW9DejdCLE1BQU1wYyxJQUFJLEVBQUU7Z0JBQUVvYztnQkFBT3E4QjtZQUFLO1lBQ3hFLElBQUlyOEIsTUFBTXBjLElBQUksS0FBS3V3QixXQUFXRSxpQkFBaUIsRUFBRTtnQkFDN0MsK0NBQStDO2dCQUMvQyx5Q0FBeUM7Z0JBQ3pDLE1BQU1ydUIsUUFBUSxJQUFJek8sTUFBTSxDQUFDLGdDQUFnQyxFQUFFeW9CLE1BQU1qUixNQUFNLENBQUMsQ0FBQztnQkFDekUvSSxNQUFNK0ksTUFBTSxHQUFHaVIsTUFBTWpSLE1BQU07Z0JBQzNCL0ksTUFBTXBDLElBQUksR0FBR29jLE1BQU1wYyxJQUFJO2dCQUN2Qm9DLE1BQU11M0MsUUFBUSxHQUFHdjlCLE1BQU11OUIsUUFBUTtnQkFDL0J2M0MsTUFBTW5OLE1BQU0sR0FBR21uQixNQUFNbm5CLE1BQU07Z0JBQzNCLElBQUksQ0FBQzhqRCxhQUFhLEdBQUczMkM7Z0JBQ3JCLElBQUksQ0FBQ3kxQyxJQUFJLENBQUMsQ0FBQyw0Q0FBNEMsRUFBRXo3QixNQUFNalIsTUFBTSxDQUFDLENBQUMsRUFBRTtvQkFDckVpUjtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDaTlCLG1CQUFtQixJQUFJO2dCQUM1QixJQUFJLENBQUNPLGFBQWEsSUFBSTtnQkFDdEIsSUFBSSxDQUFDeEIsVUFBVSxDQUFDO2dCQUNoQixJQUFJLENBQUNnQixZQUFZLEdBQUc7Z0JBQ3BCLElBQUksQ0FBQ0wsYUFBYSxHQUFHLElBQUksQ0FBQ0MsaUJBQWlCLENBQUM1OEI7Z0JBQzVDLElBQUksQ0FBQ3k3QixJQUFJLENBQUMsQ0FBQyx1REFBdUQsQ0FBQyxFQUFFO29CQUNqRXo3QjtnQkFDSjtnQkFDQSx1Q0FBdUM7Z0JBQ3ZDLElBQUksQ0FBQ2s4QixVQUFVO1lBQ25CO1FBQ0o7UUFDQSxJQUFJLENBQUN1QixPQUFPLEdBQUcsQ0FBQ3BCLE1BQU1yOEI7WUFDbEIsSUFBSSxJQUFJLENBQUNxOEIsSUFBSSxLQUFLQSxNQUNkO1lBQ0osSUFBSSxDQUFDWSxtQkFBbUIsSUFBSTtZQUM1QixJQUFJLENBQUNPLGFBQWEsSUFBSTtZQUN0QixJQUFJLENBQUN4QixVQUFVLENBQUM7WUFDaEIsSUFBSSxDQUFDZ0IsWUFBWSxHQUFHO1lBQ3BCLElBQUksQ0FBQ0wsYUFBYSxHQUFHLElBQUksQ0FBQ0MsaUJBQWlCLENBQUM1OEI7WUFDNUMsSUFBSSxDQUFDeTdCLElBQUksQ0FBQyxDQUFDLDZDQUE2QyxDQUFDLEVBQUU7Z0JBQUV6N0I7WUFBTTtZQUNuRSxJQUFJLENBQUNrOEIsVUFBVTtRQUNuQjtRQUNBOzs7Ozs7O1NBT0MsR0FDRCxJQUFJLENBQUNGLFVBQVUsR0FBRyxDQUFDMEIsU0FBU0Msc0JBQXNCLEtBQUs7WUFDbkQsSUFBSUQsWUFBWSxJQUFJLENBQUN6QixTQUFTLEVBQzFCO1lBQ0osSUFBSSxDQUFDQSxTQUFTLEdBQUd5QjtZQUNqQixJQUFJLElBQUksQ0FBQ3pCLFNBQVMsSUFBSTBCLHFCQUFxQjtnQkFDdkMsSUFBSSxDQUFDN0QsTUFBTSxDQUFDdUQsYUFBYSxDQUFDO29CQUN0Qmw2QyxNQUFNO29CQUNOZ3hDLFFBQVEsSUFBSSxDQUFDOEgsU0FBUztnQkFDMUI7Z0JBQ0E7WUFDSjtZQUNBLHNFQUFzRTtZQUN0RTdxQixXQUFXO2dCQUNQLElBQUksSUFBSSxDQUFDNnFCLFNBQVMsRUFDZDtnQkFDSixJQUFJLENBQUNuQyxNQUFNLENBQUN1RCxhQUFhLENBQUM7b0JBQ3RCbDZDLE1BQU07b0JBQ05neEMsUUFBUSxJQUFJLENBQUM4SCxTQUFTO2dCQUMxQjtZQUNKLEdBQUc7UUFDUDtRQUNBOzs7U0FHQyxHQUNELElBQUksQ0FBQ1csaUJBQWlCLEdBQUcsQ0FBQzU4QixPQUFPNDlCLGNBQWMsSUFBSTtZQUMvQyxJQUFJaDZDO1lBQ0osSUFBSWk2QztZQUNKLElBQUkxbEQ7WUFDSixJQUFJa2pELGFBQWFyN0IsUUFBUTtnQkFDckJwYyxPQUFPb2MsTUFBTXBjLElBQUk7Z0JBQ2pCaTZDLGFBQWE7Z0JBQ2IxbEQsVUFBVTZuQixNQUFNalIsTUFBTTtZQUMxQjtZQUNBLElBQUl3c0MsYUFBYXY3QixRQUFRO2dCQUNyQnBjLE9BQU9vYyxNQUFNaGEsS0FBSyxDQUFDcEMsSUFBSTtnQkFDdkJpNkMsYUFBYTc5QixNQUFNaGEsS0FBSyxDQUFDODNDLFVBQVU7Z0JBQ25DM2xELFVBQVU2bkIsTUFBTWhhLEtBQUssQ0FBQzdOLE9BQU87WUFDakM7WUFDQSxxRkFBcUY7WUFDckYsSUFBSSxDQUFDc2pELElBQUksQ0FBQyxDQUFDLDBDQUEwQyxFQUFFNzNDLEtBQUssQ0FBQyxFQUFFO2dCQUFFb2M7WUFBTSxHQUFHO1lBQzFFLE1BQU1oYSxRQUFRLElBQUl6TyxNQUFNLENBQUMsb0JBQW9CLEVBQUVxTSxLQUFLLGNBQWMsRUFBRXpMLFFBQVEsQ0FBQztZQUM3RTZOLE1BQU1wQyxJQUFJLEdBQUdBO1lBQ2I7OzthQUdDLEdBQ0RvQyxNQUFNODNDLFVBQVUsR0FBR0Q7WUFDbkI3M0MsTUFBTTQzQyxXQUFXLEdBQUdBO1lBQ3BCLE9BQU81M0M7UUFDWDtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDKzNDLHVCQUF1QixHQUFHO1lBQzNCLElBQUksQ0FBQ3JCLFVBQVUsR0FBRztZQUNsQixzREFBc0QsR0FDdEQsSUFBSSxDQUFDc0IsY0FBYyxHQUFHLElBQUlocUIsUUFBUSxDQUFDdUUsU0FBU2lhO2dCQUN4QyxJQUFJLENBQUN1SyxjQUFjLEdBQUd4a0I7Z0JBQ3RCLElBQUksQ0FBQ29rQixhQUFhLEdBQUduSztZQUN6QjtRQUNKO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUNzSyxnQkFBZ0IsR0FBRztZQUNwQixJQUFJLElBQUksQ0FBQ21CLHFCQUFxQixFQUFFO2dCQUM1QnJ5QixhQUFhLElBQUksQ0FBQ3F5QixxQkFBcUI7WUFDM0M7WUFDQSwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDQSxxQkFBcUIsR0FBRzdzQixXQUFXO2dCQUNwQyxvRUFBb0U7Z0JBQ3BFLE1BQU1zQyxPQUFPO29CQUFDO3dCQUFFdndCLE1BQU07d0JBQWdCdzNDLFdBQVcsSUFBSSxDQUFDYixNQUFNLENBQUNvRSxRQUFRO29CQUFDO2lCQUFFO2dCQUN4RSxnQ0FBZ0M7Z0JBQ2hDLElBQUk7b0JBQ0EsSUFBSSxDQUFDMXFCLEVBQUUsRUFBRTRELEtBQUtyaEIsS0FBS0MsU0FBUyxDQUFDMGQ7Z0JBQ2pDLEVBQ0EsT0FBT2h6QixHQUFHO2dCQUNOLDJDQUEyQztnQkFDL0M7WUFDSixHQUFHLElBQUksQ0FBQ3k5QyxZQUFZO1FBQ3hCO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ3RtQix1QkFBdUIsR0FBRztZQUMzQixJQUFJLElBQUksQ0FBQ3NsQix5QkFBeUIsRUFBRTtnQkFDaEN2eEIsYUFBYSxJQUFJLENBQUN1eEIseUJBQXlCO1lBQy9DO1lBQ0EsSUFBSSxDQUFDQSx5QkFBeUIsR0FBRy9yQixXQUFXO2dCQUN4QyxNQUFNcjBCLE1BQU0sSUFBSUc7Z0JBQ2hCLElBQUksSUFBSSxDQUFDMi9DLFNBQVMsSUFDZDkvQyxJQUFJYyxPQUFPLEtBQUssSUFBSSxDQUFDZy9DLFNBQVMsQ0FBQ2gvQyxPQUFPLEtBQUssSUFBSSxDQUFDbzVCLHNCQUFzQixFQUFFO29CQUN4RSxJQUFJLENBQUN3a0IsSUFBSSxDQUFDO29CQUNWLElBQUksQ0FBQ08sVUFBVSxDQUFDO29CQUNoQixJQUFJLENBQUNFLFVBQVU7Z0JBQ25CO1lBQ0osR0FBRyxJQUFJLENBQUNqbEIsc0JBQXNCO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDNmlCLE1BQU0sR0FBR0E7UUFDZCwrREFBK0QsR0FDL0QsSUFBSSxDQUFDbUQsbUJBQW1CLEdBQUc7UUFDM0IsK0NBQStDLEdBQy9DLElBQUksQ0FBQ08sYUFBYSxHQUFHO1FBQ3JCLDJEQUEyRCxHQUMzRCxJQUFJLENBQUNSLFlBQVksR0FBRztRQUNwQixzREFBc0QsR0FDdEQsSUFBSSxDQUFDUixrQkFBa0IsR0FBRztRQUMxQixpREFBaUQsR0FDakQsSUFBSSxDQUFDNEIsY0FBYyxHQUFHO1FBQ3RCLGlFQUFpRSxHQUNqRSxJQUFJLENBQUMxQixVQUFVLEdBQUc7UUFDbEIseUVBQXlFLEdBQ3pFLElBQUksQ0FBQ1QsU0FBUyxHQUFHO1FBQ2pCLGlEQUFpRCxHQUNqRCxJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLGdEQUFnRCxHQUNoRCxJQUFJLENBQUNRLFNBQVMsR0FBRztRQUNqQixpREFBaUQsR0FDakQsSUFBSSxDQUFDc0IsWUFBWSxHQUFHLEtBQUs7UUFDekIsSUFBSSxDQUFDbG5CLHNCQUFzQixHQUFHLElBQUksQ0FBQ2tuQixZQUFZLEdBQUcsS0FBSztRQUN2RGpvQiw0QkFBNEIsSUFBSSxDQUFDNmxCLG1CQUFtQjtJQUN4RDtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNN00sUUFBUWovQixVQUFVLEtBQUssRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQytzQyxZQUFZLEVBQUU7WUFDbkIsTUFBTXpsRCxNQUFNLENBQUMsc0VBQXNFLENBQUM7UUFDeEY7UUFDQSxJQUFJLENBQUM2bUQsY0FBYyxHQUFHO1FBQ3RCLElBQUk7WUFDQSxNQUFNQyxjQUFjLE1BQU0sSUFBSSxDQUFDQyxRQUFRO1lBQ3ZDLElBQUksQ0FBQ3JCLG1CQUFtQixHQUFHO1lBQzNCLElBQUksQ0FBQ3hCLElBQUksQ0FBQyxDQUFDLHdEQUF3RCxFQUFFNEMsWUFBWSxDQUFDO1FBQ3RGLEVBQ0EsT0FBT3I0QyxPQUFPO1lBQ1YsSUFBSSxDQUFDaTJDLFNBQVMsR0FBRztZQUNqQixJQUFJLENBQUNnQixtQkFBbUIsSUFBSTtZQUM1QixJQUNBLGFBQWE7WUFDYmozQyxNQUFNcEMsSUFBSSxLQUFLdXdCLFdBQVdDLGFBQWEsSUFDbkMsQ0FBQyxJQUFJLENBQUMwbEIsTUFBTSxDQUFDUyxZQUFZLENBQUMyQyxRQUFRLElBQUk7Z0JBQ3RDLElBQUksQ0FBQ3pCLElBQUksQ0FBQztnQkFDVixJQUFJLENBQUNTLFVBQVUsQ0FBQztvQkFBRWtCLGNBQWM7Z0JBQUs7WUFDekMsT0FDSztnQkFDRCxhQUFhO2dCQUNiLElBQUksQ0FBQ3AzQyxNQUFNNDNDLFdBQVcsRUFBRTtvQkFDcEIsc0RBQXNEO29CQUN0RCxNQUFNLElBQUlybUQsTUFBTXdlLEtBQUtDLFNBQVMsQ0FBQzt3QkFDM0IsYUFBYTt3QkFDYnBTLE1BQU1vQyxNQUFNcEMsSUFBSTt3QkFDaEIsYUFBYTt3QkFDYms2QyxZQUFZOTNDLE1BQU04M0MsVUFBVTt3QkFDNUIsYUFBYTt3QkFDYjNsRCxTQUFTNk4sTUFBTTdOLE9BQU87d0JBQ3RCLGFBQWE7d0JBQ2J5bEQsYUFBYTUzQyxNQUFNNDNDLFdBQVc7b0JBQ2xDO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU8sTUFBTSxJQUFJLENBQUNXLGVBQWUsQ0FBQ3R1QztJQUN0QztJQUNBOzs7O0tBSUMsR0FDRCxNQUFNc3VDLGdCQUFnQnR1QyxVQUFVLEtBQUssRUFBRTtRQUNuQyxPQUFPK2pCLFFBQVF3cUIsSUFBSSxDQUFDO1lBQ2Y7Z0JBQ0csTUFBTXJDLFdBQVcsSUFBSSxLQUFLO2dCQUMxQixJQUFLLElBQUl0L0MsSUFBSSxHQUFHQSxLQUFLb1QsU0FBU3BULEtBQUtzL0MsU0FBVTtvQkFDekMsSUFBSTt3QkFDQSxPQUFPLE1BQU0sSUFBSSxDQUFDNkIsY0FBYztvQkFDcEMsRUFDQSxPQUFPaDRDLE9BQU87d0JBQ1YsSUFBSW5KLE1BQU1vVCxTQUFTOzRCQUNmLE1BQU0sSUFBSTFZLE1BQU13ZSxLQUFLQyxTQUFTLENBQUM7Z0NBQzNCcFMsTUFBTW9DLE1BQU1wQyxJQUFJO2dDQUNoQms2QyxZQUFZOTNDLE1BQU04M0MsVUFBVTtnQ0FDNUIzbEQsU0FBUzZOLE1BQU03TixPQUFPO2dDQUN0QnlsRCxhQUFhNTNDLE1BQU00M0MsV0FBVzs0QkFDbEM7d0JBQ0o7d0JBQ0EsTUFBTTdwQixNQUFNb29CO29CQUNoQjtnQkFDSjtZQUNKO1lBQ0M7Z0JBQ0csTUFBTXBvQixNQUFNOWpCO2dCQUNaLElBQUksQ0FBQytzQyxZQUFZLEdBQUc7Z0JBQ3BCLE1BQU0sSUFBSXpsRCxNQUFNd2UsS0FBS0MsU0FBUyxDQUFDO29CQUMzQnBTLE1BQU07b0JBQ05rNkMsWUFBWTtvQkFDWjNsRCxTQUFTO29CQUNUeWxELGFBQWE7Z0JBQ2pCO1lBQ0o7U0FDSDtJQUNMO0lBQ0E7OztLQUdDLEdBQ0R2YixXQUFXcHlCLE9BQU8sRUFBRTtRQUNoQixJQUFJLENBQUN3ckMsSUFBSSxDQUFDLENBQUMseURBQXlELEVBQUUsSUFBSSxDQUFDWSxJQUFJLENBQUMsQ0FBQztRQUNqRixJQUFJLENBQUNBLElBQUksSUFBSTtRQUNiLElBQUksQ0FBQ1csWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ29CLGNBQWMsR0FBRztRQUN0QixzQ0FBc0M7UUFDdEMsSUFBSSxJQUFJLENBQUNILHFCQUFxQixFQUFFO1lBQzVCbG5CLGNBQWMsSUFBSSxDQUFDa25CLHFCQUFxQjtRQUM1QztRQUNBLElBQUksSUFBSSxDQUFDZCx5QkFBeUIsRUFBRTtZQUNoQ3BtQixjQUFjLElBQUksQ0FBQ29tQix5QkFBeUI7UUFDaEQ7UUFDQS9tQiwrQkFBK0IsSUFBSSxDQUFDMmxCLG1CQUFtQjtRQUN2RCxJQUFJLENBQUNFLFNBQVMsR0FBRztRQUNqQix3QkFBd0I7UUFDeEIsSUFBSSxJQUFJLENBQUN6b0IsRUFBRSxJQUFJLElBQUksQ0FBQ0EsRUFBRSxDQUFDaXJCLGtCQUFrQixFQUFFO1lBQ3ZDLElBQUksQ0FBQ2pyQixFQUFFLENBQUNpckIsa0JBQWtCO1FBQzlCO1FBQ0EsSUFBSUM7UUFDSix1QkFBdUI7UUFDdkIseUVBQXlFO1FBQ3pFLG9CQUFvQjtRQUNwQixNQUFNLEVBQUVsckIsRUFBRSxFQUFFLEdBQUcsSUFBSTtRQUNuQixJQUFJQSxNQUFNQSxHQUFHeGYsS0FBSyxJQUFJd2YsR0FBR3BILFVBQVUsS0FBS29ILEdBQUdnRSxJQUFJLEVBQUU7WUFDN0NrbkIsa0JBQWtCLElBQUkxcUIsUUFBUSxDQUFDdUU7Z0JBQzNCLE1BQU0ra0IsVUFBVSxDQUFDdDlCO29CQUNiLElBQUksQ0FBQ3k3QixJQUFJLENBQUMsQ0FBQyx5Q0FBeUMsRUFBRXo3QixRQUFRLFNBQVMsVUFBVSxZQUFZLENBQUMsRUFBRTt3QkFBRUE7b0JBQU07b0JBQ3hHdVk7Z0JBQ0o7Z0JBQ0EvRSxHQUFHOHBCLE9BQU8sR0FBR0E7Z0JBQ2IsaUVBQWlFO2dCQUNqRSx3Q0FBd0M7Z0JBQ3hDbHNCLFdBQVdrc0IsU0FBU3J0QyxXQUFXLE9BQU9BLFVBQVU7WUFDcEQ7WUFDQSxJQUFJLENBQUN3ckMsSUFBSSxDQUFDLENBQUMsd0VBQXdFLENBQUM7WUFDcEZqb0IsR0FBR3hmLEtBQUssQ0FBQ21nQixXQUFXRSxpQkFBaUIsRUFBRTtRQUMzQyxPQUNLO1lBQ0QsSUFBSSxDQUFDb25CLElBQUksQ0FBQyxDQUFDLG1FQUFtRSxDQUFDO1lBQy9FaUQsa0JBQWtCMXFCLFFBQVF1RSxPQUFPO1FBQ3JDO1FBQ0EsT0FBTyxJQUFJLENBQUMvRSxFQUFFO1FBQ2QsT0FBT2tyQjtJQUNYO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1KLFdBQVc7UUFDYixJQUFJLElBQUksQ0FBQ3RCLFlBQVksSUFDaEIsSUFBSSxDQUFDb0IsY0FBYyxJQUFJLElBQUksQ0FBQ3RFLE1BQU0sQ0FBQzFoRCxPQUFPLENBQUN1bUQsZ0JBQWdCLEVBQzVELFFBQVEsNkRBQTZEO1FBQ3pFLElBQUksQ0FBQzNCLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUMvQixTQUFTLEdBQUd0bUI7UUFDakIsSUFBSSxDQUFDbWxCLE1BQU0sQ0FBQ0ssY0FBYyxDQUFDaEIsd0JBQXdCLEdBQUcsSUFBSWo4QyxPQUFPVyxPQUFPO1FBQ3hFLElBQUkrZ0QsZUFBZTtRQUNuQixJQUFJO1lBQ0EsSUFBSSxDQUFDbkQsSUFBSSxDQUFDLENBQUMsOEJBQThCLENBQUM7WUFDMUMsTUFBTSxJQUFJLENBQUMzQixNQUFNLENBQUNTLFlBQVksQ0FBQ3NFLFVBQVU7WUFDekNELGVBQWU7UUFDbkIsRUFDQSxPQUFPbCtDLEdBQUc7UUFDTixpREFBaUQ7UUFDckQ7UUFDQSxJQUFJO1lBQ0EsSUFBSSxDQUFDaytDLGNBQWM7Z0JBQ2YsSUFBSSxDQUFDbkQsSUFBSSxDQUFDLENBQUMsMkRBQTJELENBQUM7Z0JBQ3ZFLE1BQU0sSUFBSSxDQUFDM0IsTUFBTSxDQUFDUyxZQUFZLENBQUN1RSxTQUFTO1lBQzVDO1lBQ0EsSUFBSSxDQUFDZix1QkFBdUI7WUFDNUIsTUFBTWdCLFFBQVEsSUFBSSxDQUFDL0UsU0FBUztZQUM1QixJQUFJLENBQUN5QixJQUFJLENBQUMsQ0FBQywyQkFBMkIsRUFBRXNELE1BQU0sQ0FBQyxFQUFFO2dCQUM3Q0E7Z0JBQ0E5RCxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUM3QjtZQUNBLElBQUksQ0FBQ3puQixFQUFFLEdBQUcsSUFBSWhnQyxzREFBU0EsQ0FBQ3VyRDtZQUN4QixJQUFJLENBQUN2ckIsRUFBRSxDQUFDNG9CLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQzdtQixJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzhtQixJQUFJO1lBQ2pELElBQUksQ0FBQzdvQixFQUFFLENBQUM4cEIsT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDL25CLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDOG1CLElBQUk7WUFDbkQsSUFBSSxDQUFDN29CLEVBQUUsQ0FBQ2lxQixPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNsb0IsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM4bUIsSUFBSTtZQUNuRCxJQUFJLENBQUM3b0IsRUFBRSxDQUFDaXBCLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ2xuQixJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzhtQixJQUFJO1lBQ3ZELE1BQU10c0IsV0FBVyxNQUFNLElBQUksQ0FBQ2l1QixjQUFjO1lBQzFDLElBQUksQ0FBQ2hCLFlBQVksR0FBRztZQUNwQixJQUFJanRCLFVBQVU7Z0JBQ1YsSUFBSSxDQUFDNnFCLFlBQVksR0FBRzdxQixTQUFTaXZCLGFBQWE7Z0JBQzFDLElBQUksQ0FBQ2xGLE1BQU0sQ0FBQ21GLG1CQUFtQixHQUFHLElBQUksQ0FBQ3JFLFlBQVk7Z0JBQ25ELElBQUksSUFBSSxDQUFDZCxNQUFNLENBQUNLLGNBQWMsQ0FBQ2QscUJBQXFCLEdBQUcsS0FDbkQsSUFBSSxDQUFDUyxNQUFNLENBQUMxaEQsT0FBTyxDQUFDOG1ELGNBQWMsRUFBRTtvQkFDcEMzRixhQUFhLDRCQUE0QjZCLGtDQUFrQyxJQUFJO29CQUMvRSxJQUFJLENBQUN0QixNQUFNLENBQUNLLGNBQWMsQ0FBQ2QscUJBQXFCLEdBQUc7Z0JBQ3ZEO2dCQUNBLE9BQU90cEI7WUFDWDtRQUNKLEVBQ0EsT0FBT2pXLEtBQUs7WUFDUixJQUFJLENBQUNrakMsWUFBWSxHQUFHO1lBQ3BCLGFBQWE7WUFDYixJQUFJLENBQUN2QixJQUFJLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFM2hDO1lBQ25DLElBQUksSUFBSSxDQUFDZ2dDLE1BQU0sQ0FBQzFoRCxPQUFPLENBQUM4bUQsY0FBYyxFQUFFO2dCQUNwQyxJQUFJLENBQUNwRixNQUFNLENBQUNLLGNBQWMsQ0FBQ2QscUJBQXFCO2dCQUNoRCxJQUFJLENBQUNTLE1BQU0sQ0FBQ0ssY0FBYyxDQUFDZixlQUFlO2dCQUMxQyxNQUFNSyxXQUFXRSxvQkFBb0IsSUFBSSxFQUFFbGtCLG1CQUFtQjNiO2dCQUM5RHkvQixlQUFlLFlBQVlFO1lBQy9CO1lBQ0EsSUFBSSxDQUFDSyxNQUFNLENBQUNxRixrQkFBa0I7WUFDOUIsTUFBTXJsQztRQUNWO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTW9pQyxXQUFXOWpELFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxDQUFDcWpELElBQUksQ0FBQztRQUNWLHNDQUFzQztRQUN0QyxJQUFJLElBQUksQ0FBQ3VCLFlBQVksSUFBSSxJQUFJLENBQUNmLFNBQVMsRUFBRTtZQUNyQyxJQUFJLENBQUNSLElBQUksQ0FBQztZQUNWO1FBQ0o7UUFDQSw0Q0FBNEM7UUFDNUMsaURBQWlEO1FBQ2pELElBQUlVLFdBQVcvakQsUUFBUStqRCxRQUFRO1FBQy9CLElBQUksQ0FBQ0EsVUFBVTtZQUNYQSxXQUFXM25CLGNBQWMsSUFBSSxDQUFDeW9CLG1CQUFtQjtRQUNyRDtRQUNBLGtEQUFrRDtRQUNsRCxNQUFNbHBCLE1BQU1vb0I7UUFDWixrRkFBa0Y7UUFDbEYsNkNBQTZDO1FBQzdDLElBQUksSUFBSSxDQUFDYSxZQUFZLElBQUksSUFBSSxDQUFDZixTQUFTLEVBQUU7WUFDckMsSUFBSSxDQUFDUixJQUFJLENBQUM7WUFDVjtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUMyQyxjQUFjLElBQUksSUFBSSxDQUFDdEUsTUFBTSxDQUFDMWhELE9BQU8sQ0FBQ3VtRCxnQkFBZ0IsRUFBRTtZQUM3RCxJQUFJLENBQUNsRCxJQUFJLENBQUM7WUFDVjtRQUNKO1FBQ0EsSUFBSSxDQUFDQSxJQUFJLENBQUM7UUFDViw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDMkQsMkJBQTJCO1FBQ2hDLElBQUlobkQsUUFBUWdsRCxZQUFZLEVBQUU7WUFDdEIsTUFBTSxJQUFJLENBQUN0RCxNQUFNLENBQUNTLFlBQVksQ0FBQ3VFLFNBQVM7UUFDNUM7UUFDQSxJQUFJO1lBQ0EsTUFBTSxJQUFJLENBQUNSLFFBQVE7WUFDbkIsSUFBSSxDQUFDN0MsSUFBSSxDQUFDO1lBQ1Ysb0NBQW9DO1lBQ3BDLElBQUksQ0FBQ0EsSUFBSSxDQUFDO1lBQ1YsSUFBSSxDQUFDd0IsbUJBQW1CLEdBQUc7UUFDL0IsRUFDQSxPQUFPajNDLE9BQU87WUFDVixJQUFJLENBQUNpMkMsU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ2dCLG1CQUFtQixJQUFJO1lBQzVCLElBQUlqM0MsTUFBTXBDLElBQUksS0FBS3V3QixXQUFXQyxhQUFhLElBQ3ZDLENBQUMsSUFBSSxDQUFDMGxCLE1BQU0sQ0FBQ1MsWUFBWSxDQUFDMkMsUUFBUSxJQUFJO2dCQUN0QyxJQUFJLENBQUN6QixJQUFJLENBQUM7Z0JBQ1YsT0FBTyxJQUFJLENBQUNTLFVBQVUsQ0FBQztvQkFBRWtCLGNBQWM7Z0JBQUs7WUFDaEQ7WUFDQSxtRUFBbUU7WUFDbkUsSUFBSXAzQyxNQUFNNDNDLFdBQVcsRUFBRTtnQkFDbkIsSUFBSSxDQUFDbkMsSUFBSSxDQUFDO2dCQUNWLElBQUksQ0FBQ1MsVUFBVTtZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDVCxJQUFJLENBQUM7SUFDZDtJQUNBOzs7S0FHQyxHQUNEMkQsOEJBQThCO1FBQzFCLHFFQUFxRTtRQUNyRSw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDL0MsSUFBSSxJQUFJO1FBQ2IsSUFBSTtZQUNBLElBQUksRUFBRTdvQixJQUFJaXJCO1lBQ1YsSUFBSSxFQUFFanJCLElBQUl4ZjtRQUNkLEVBQ0EsT0FBT3RULEdBQUc7UUFDTixnQkFBZ0I7UUFDcEI7SUFDSjtBQUNKO0FBRUEsU0FBUzIrQyxTQUFTQyxhQUFhO0lBQzNCLE9BQU8sT0FBT0Esa0JBQWtCO0FBQ3BDO0FBQ0EsU0FBU0Msb0JBQW9CRCxhQUFhLEVBQUVFLFFBQVE7SUFDaEQsT0FBTyxDQUFDLENBQUNBLFlBQVlILFNBQVNDO0FBQ2xDO0FBQ0EsU0FBU2h0RCxJQUFJZ3RELGFBQWEsRUFBRUUsUUFBUTtJQUNoQyxNQUFNbEUsTUFBTSxFQUFFO0lBQ2QsSUFBSStELFNBQVNDLGtCQUFrQkMsb0JBQW9CRCxlQUFlRSxXQUFXO1FBQ3pFLElBQUssSUFBSWxuRCxJQUFJLEdBQUc2QixNQUFNbWxELGNBQWMvbEQsTUFBTSxFQUFFakIsSUFBSTZCLEtBQUs3QixJQUFLO1lBQ3RELElBQUlnbkQsY0FBY0csTUFBTSxDQUFDbm5ELElBQUk7Z0JBQ3pCLE1BQU1vbkQsU0FBU0osY0FBY0csTUFBTSxDQUFDbm5EO2dCQUNwQyxNQUFNcW5ELGNBQWNILFNBQVNFLFFBQVFwbkQsR0FBR2duRDtnQkFDeENoRSxHQUFHLENBQUNoakQsRUFBRSxHQUFHcW5EO1lBQ2I7UUFDSjtJQUNKLE9BQ0ssSUFBSSxDQUFDTixTQUFTQyxrQkFDZixDQUFDQyxvQkFBb0JELGVBQWVFLFdBQVc7UUFDL0MsSUFBSyxJQUFJbG5ELElBQUksR0FBRzZCLE1BQU1tbEQsY0FBYy9sRCxNQUFNLEVBQUVqQixJQUFJNkIsS0FBSzdCLElBQUs7WUFDdEQsSUFBSUEsS0FBS2duRCxlQUFlO2dCQUNwQixNQUFNSSxTQUFTSixhQUFhLENBQUNobkQsRUFBRTtnQkFDL0IsTUFBTXFuRCxjQUFjSCxTQUFTRSxRQUFRcG5ELEdBQUdnbkQ7Z0JBQ3hDaEUsR0FBRyxDQUFDaGpELEVBQUUsR0FBR3FuRDtZQUNiO1FBQ0o7SUFDSjtJQUNBLE9BQU9yRTtBQUNYO0FBQ0EsTUFBTXNFLGVBQWUsQ0FBQ2xzQixPQUFTLy9CLHdEQUFhQSxDQUFDLElBQUlrZ0MsV0FBV3ZoQyxJQUFJb2hDLE1BQU0sQ0FBQ21zQixPQUFTQSxLQUFLQyxVQUFVLENBQUM7QUFDaEcsZ0dBQWdHO0FBQ2hHLGtHQUFrRztBQUNsRyxtRUFBbUU7QUFDbkUsTUFBTUMsZUFBZSxDQUFDanFDO0lBQ2xCLE1BQU1wVixJQUFJLENBQUMsR0FBRytXLElBQUlrUyxPQUFPcTJCLFlBQVksRUFBRUMsSUFBSW5xQyxFQUFFdmMsTUFBTTtJQUNuRCxJQUFJc0QsR0FBRzhkLElBQUksR0FBRzNILEdBQUdrdEMsR0FBR3R1QyxJQUFJLEdBQUc4SSxHQUFHeUIsSUFBSTtJQUNsQyxNQUFNZ2tDLElBQUk7SUFDVixJQUFLdGpELElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1FBQ3JCNkQsQ0FBQyxDQUFDeS9DLEVBQUVWLE1BQU0sQ0FBQzVpRCxHQUFHLEdBQUdBO0lBQ3JCO0lBQ0EsSUFBS3FqRCxJQUFJLEdBQUdBLElBQUlELEdBQUdDLElBQUs7UUFDcEJsdEMsSUFBSXRTLENBQUMsQ0FBQ29WLEVBQUUycEMsTUFBTSxDQUFDUyxHQUFHO1FBQ2xCdmxDLElBQUksQ0FBQ0EsS0FBSyxLQUFLM0g7UUFDZnBCLEtBQUs7UUFDTCxNQUFPQSxLQUFLLEVBQUc7WUFDVixFQUFDOEksSUFBSSxNQUFROUksQ0FBQUEsS0FBSyxLQUFNLElBQUcsS0FBTXN1QyxJQUFJRCxJQUFJLE1BQU85akMsQ0FBQUEsS0FBSzFFLEVBQUVpRCxFQUFDO1FBQzdEO0lBQ0o7SUFDQSxPQUFPeUI7QUFDWDtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTaWtDLGFBQWFDLFNBQVMsRUFBRXRnRCxNQUFNLEVBQUV1Z0QsWUFBWSxDQUFDLENBQUMsRUFBRUMsYUFBYSxDQUFDLENBQUM7SUFDcEUsSUFBSSxPQUFPeGdELFdBQVcsVUFBVTtRQUM1QixNQUFNLElBQUl5Z0QsVUFBVTtJQUN4QjtJQUNBLE1BQU03ckMsVUFBVTtRQUNaNE0sU0FBU3hoQjtRQUNULEdBQUd1Z0QsU0FBUztJQUNoQjtJQUNBLDRFQUE0RTtJQUM1RSxJQUFJNXNELHFEQUFHQSxJQUFJLFFBQVFBLDBEQUFRLElBQUksTUFBTTtRQUNqQyxNQUFNNkQsTUFBTSxDQUFDLG1RQUFtUSxDQUFDO0lBQ3JSO0lBQ0EsTUFBTTQwQixPQUFPM3pCLE9BQU9nakMsTUFBTSxDQUFDO1FBQUVrbEIsV0FBVztRQUFTQyxhQUFhO0lBQUssR0FBR0o7SUFDdEUsSUFBSTVyQyxRQUFRaXNDLEdBQUcsRUFBRTtRQUNiejBCLEtBQUt3MEIsV0FBVyxHQUFHO0lBQ3ZCO0lBQ0EsT0FBT2p0RCx3REFBUSxDQUFDaWhCLFNBQVMwckMsV0FBV2wwQjtBQUN4QztBQUNBLFNBQVMwMEIsZUFBZVIsU0FBUyxFQUFFRSxhQUFhLENBQUMsQ0FBQztJQUM5QyxNQUFNNXJDLFVBQVU7UUFDWm1vQixRQUFRO0lBQ1o7SUFDQSxNQUFNM1EsT0FBTzN6QixPQUFPZ2pDLE1BQU0sQ0FBQztRQUFFa2xCLFdBQVc7UUFBU0MsYUFBYTtJQUFLLEdBQUdKO0lBQ3RFLE9BQU83c0Qsd0RBQVEsQ0FBQ2loQixTQUFTMHJDLFdBQVdsMEI7QUFDeEM7QUFDQSxTQUFTMjBCLGNBQWNyMUMsS0FBSztJQUN4QixNQUFNczFDLFlBQVl0MUMsTUFBTWtLLEtBQUssQ0FBQztJQUM5QixJQUFJb3JDLFVBQVV4bkQsTUFBTSxLQUFLLEdBQUc7UUFDeEIsT0FBTztJQUNYO0lBQ0EsTUFBTXluRCxhQUFhRCxTQUFTLENBQUMsRUFBRTtJQUMvQixNQUFNcHNDLFVBQVVvckMsYUFBYWlCO0lBQzdCLE1BQU10dEIsT0FBTzNkLEtBQUtqWSxLQUFLLENBQUM2VztJQUN4QixPQUFPK2UsS0FBS25TLE9BQU87QUFDdkI7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzAvQixTQUFTbGhELE1BQU07SUFDcEIsT0FBTztRQUNIO1FBQ0E2L0MsYUFBYTdwQyxLQUFLQyxTQUFTLENBQUM7WUFBRXVMLFNBQVN4aEI7UUFBTztRQUM5QztLQUNILENBQUNsRixJQUFJLENBQUM7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNcW1EO0lBQ0Y7Ozs7S0FJQyxHQUNEeHBELFlBQVl5cEQsTUFBTSxDQUFFO1FBQ2hCOzs7Ozs7O1NBT0MsR0FDRCxJQUFJLENBQUNDLGtCQUFrQixHQUFHLE9BQU9DLGlCQUFpQm4vQixNQUFNby9CO1lBQ3BELElBQUksQ0FBQ0MsYUFBYSxDQUFDRixpQkFBaUJuL0IsTUFBTW8vQjtZQUMxQyxJQUFJLENBQUNwL0IsSUFBSSxHQUFHQTtZQUNaLElBQUkrUixXQUFXb3RCLGtCQUFrQjtnQkFDN0IsSUFBSSxDQUFDRyxhQUFhLEdBQUdIO2dCQUNyQixJQUFJLENBQUNsK0MsSUFBSSxHQUFHO1lBQ2hCO1lBQ0EsSUFBSSxPQUFPaytDLG9CQUFvQixVQUFVO2dCQUNyQyxJQUFJLENBQUM1MUMsS0FBSyxHQUFHNDFDO2dCQUNiLElBQUksQ0FBQ2wrQyxJQUFJLEdBQUc7WUFDaEI7WUFDQSxJQUFJLENBQUNrK0MsbUJBQW1CLElBQUksQ0FBQ24vQixJQUFJLElBQUksSUFBSSxDQUFDaS9CLE1BQU0sRUFBRTtnQkFDOUMsSUFBSSxDQUFDMTFDLEtBQUssR0FBRzIwQyxhQUFhLElBQUksQ0FBQ2UsTUFBTSxFQUFFai9CLEtBQUs5ZSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUM7Z0JBQ3JELElBQUksQ0FBQ0QsSUFBSSxHQUFHO1lBQ2hCO1lBQ0EsTUFBTSxJQUFJLENBQUMyN0MsU0FBUztRQUN4QjtRQUNBOzs7U0FHQyxHQUNELElBQUksQ0FBQzJDLEtBQUssR0FBRztZQUNULElBQUksQ0FBQ2gyQyxLQUFLLEdBQUdyUztZQUNiLElBQUksQ0FBQzhvQixJQUFJLEdBQUc5b0I7WUFDWixJQUFJLENBQUNzb0QsZ0JBQWdCLEdBQUc7UUFDNUI7UUFDQSw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDSCxhQUFhLEdBQUcsQ0FBQ0YsaUJBQWlCbi9CLE1BQU1vL0I7WUFDekMsa0NBQWtDO1lBQ2xDLElBQUlwL0IsUUFBUW8vQixlQUFlLENBQUNELGlCQUN4QjtZQUNKLHNEQUFzRDtZQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDRixNQUFNLElBQUksQ0FBQ0UsaUJBQWlCO2dCQUNsQyxNQUFNLElBQUk5cEQsTUFBTTtZQUNwQjtZQUNBLElBQUk4cEQsbUJBQ0EsT0FBT0Esb0JBQW9CLFlBQzNCLENBQUNwdEIsV0FBV290QixrQkFBa0I7Z0JBQzlCLE1BQU0sSUFBSTlwRCxNQUFNO1lBQ3BCO1lBQ0EsSUFBSSxPQUFPOHBELG9CQUFvQixVQUFVO2dCQUNyQyx3Q0FBd0M7Z0JBQ3hDLElBQUlDLGVBQWVELG9CQUFvQixJQUNuQztnQkFDSixNQUFNTSxjQUFjYixjQUFjTztnQkFDbEMsSUFBSUEsbUJBQW1CLFFBQ2xCTSxDQUFBQSxlQUFlLFFBQ1pBLGdCQUFnQixNQUNmLENBQUNMLGVBQWVLLGdCQUFnQnovQixLQUFLOWUsRUFBRSxHQUFJO29CQUNoRCxNQUFNLElBQUk3TCxNQUFNO2dCQUNwQjtZQUNKO1FBQ0o7UUFDQSx1R0FBdUc7UUFDdkcsK0JBQStCO1FBQy9CLElBQUksQ0FBQ3NuRCxVQUFVLEdBQUcsSUFBTSxJQUFJLENBQUM2QyxnQkFBZ0I7UUFDN0Msd0VBQXdFO1FBQ3hFLG1FQUFtRTtRQUNuRSxJQUFJLENBQUM1QyxTQUFTLEdBQUc7WUFDYixxREFBcUQ7WUFDckQsSUFBSSxDQUFDNEMsZ0JBQWdCLEdBQUcsSUFBSTF0QixRQUFRLE9BQU91RSxTQUFTaWE7Z0JBQ2hELElBQUksSUFBSSxDQUFDcnZDLElBQUksS0FBSyxVQUFVO29CQUN4QixPQUFPbzFCLFFBQVEsSUFBSSxDQUFDOXNCLEtBQUs7Z0JBQzdCO2dCQUNBLElBQUksSUFBSSxDQUFDKzFDLGFBQWEsSUFBSSxPQUFPLElBQUksQ0FBQ0EsYUFBYSxLQUFLLFVBQVU7b0JBQzlELElBQUk7d0JBQ0EsSUFBSSxDQUFDLzFDLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQysxQyxhQUFhO29CQUN6QyxFQUNBLE9BQU85Z0QsR0FBRzt3QkFDTixPQUFPOHhDLE9BQU8sSUFBSWo3QyxNQUFNLENBQUMsMkNBQTJDLEVBQUVtSixFQUFFLENBQUM7b0JBQzdFO29CQUNBNjNCLFFBQVEsSUFBSSxDQUFDOXNCLEtBQUs7Z0JBQ3RCO1lBQ0o7WUFDQSxPQUFPLElBQUksQ0FBQ2kyQyxnQkFBZ0I7UUFDaEM7UUFDQSwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDRSxRQUFRLEdBQUc7WUFDWixJQUFJLElBQUksQ0FBQ24yQyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDckI7WUFDQSxJQUFJLElBQUksQ0FBQ3lXLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQ3pXLEtBQUssRUFBRTtnQkFDMUIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDckI7WUFDQSxJQUFJLElBQUksQ0FBQzAxQyxNQUFNLEVBQUU7Z0JBQ2IsT0FBT04sZUFBZSxJQUFJLENBQUNNLE1BQU07WUFDckM7WUFDQSxNQUFNLElBQUk1cEQsTUFBTSxDQUFDLGdIQUFnSCxDQUFDO1FBQ3RJO1FBQ0EsSUFBSSxDQUFDMmxELFFBQVEsR0FBRyxJQUFNLElBQUksQ0FBQy81QyxJQUFJLEtBQUs7UUFDcEMsSUFBSSxDQUFDdStDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUlQLFFBQVE7WUFDUixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDbEI7UUFDQSxJQUFJLENBQUNoK0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxJQUFJLENBQUNnK0MsTUFBTSxFQUFFO1lBQ2IsSUFBSSxDQUFDMTFDLEtBQUssR0FBR28xQyxlQUFlLElBQUksQ0FBQ00sTUFBTTtRQUMzQztJQUNKO0FBQ0o7QUFFQSxNQUFNVSxnQkFBZ0I7SUFDbEIsTUFBTTtRQUFFanFELE1BQU07UUFBdUJzL0IsV0FBVztJQUFLO0lBQ3JELEtBQUs7UUFBRXQvQixNQUFNO1FBQWtCcy9CLFdBQVc7SUFBTTtJQUNoRCxLQUFLO1FBQUV0L0IsTUFBTTtRQUE2QnMvQixXQUFXO0lBQUs7SUFDMUQsS0FBSztRQUFFdC9CLE1BQU07UUFBY3MvQixXQUFXO0lBQU07SUFDNUMsS0FBSztRQUFFdC9CLE1BQU07UUFBMEJzL0IsV0FBVztJQUFNO0lBQ3hELEtBQUs7UUFBRXQvQixNQUFNO1FBQWtCcy9CLFdBQVc7SUFBSztJQUMvQyxNQUFNO1FBQUV0L0IsTUFBTTtRQUFxQnMvQixXQUFXO0lBQU07SUFDcEQsTUFBTTtRQUFFdC9CLE1BQU07UUFBbUJzL0IsV0FBVztJQUFNO0lBQ2xELE1BQU07UUFBRXQvQixNQUFNO1FBQTBCcy9CLFdBQVc7SUFBTTtJQUN6RCxNQUFNO1FBQUV0L0IsTUFBTTtRQUFtQ3MvQixXQUFXO0lBQU07SUFDbEUsTUFBTTtRQUFFdC9CLE1BQU07UUFBdUJzL0IsV0FBVztJQUFNO0lBQ3RELE1BQU07UUFBRXQvQixNQUFNO1FBQTZCcy9CLFdBQVc7SUFBTTtJQUM1RCxNQUFNO1FBQUV0L0IsTUFBTTtRQUFzQnMvQixXQUFXO0lBQU07SUFDckQsTUFBTTtRQUFFdC9CLE1BQU07UUFBdUJzL0IsV0FBVztJQUFLO0lBQ3JELE1BQU07UUFBRXQvQixNQUFNO1FBQThCcy9CLFdBQVc7SUFBTTtJQUM3RCxNQUFNO1FBQUV0L0IsTUFBTTtRQUF5QnMvQixXQUFXO0lBQU07SUFDeEQsTUFBTTtRQUFFdC9CLE1BQU07UUFBNkJzL0IsV0FBVztJQUFNO0lBQzVELE1BQU07UUFBRXQvQixNQUFNO1FBQW9Dcy9CLFdBQVc7SUFBTTtJQUNuRSxNQUFNO1FBQUV0L0IsTUFBTTtRQUFrQ3MvQixXQUFXO0lBQU07SUFDakUsTUFBTTtRQUFFdC9CLE1BQU07UUFBcUNzL0IsV0FBVztJQUFNO0lBQ3BFLE1BQU07UUFBRXQvQixNQUFNO1FBQWtDcy9CLFdBQVc7SUFBSztJQUNoRSxNQUFNO1FBQUV0L0IsTUFBTTtRQUE2QnMvQixXQUFXO0lBQU07SUFDNUQsTUFBTTtRQUFFdC9CLE1BQU07UUFBaUJzL0IsV0FBVztJQUFLO0lBQy9DLE1BQU07UUFBRXQvQixNQUFNO1FBQWtCcy9CLFdBQVc7SUFBTTtJQUNqRCxNQUFNO1FBQUV0L0IsTUFBTTtRQUE4QnMvQixXQUFXO0lBQU07SUFDN0QsTUFBTTtRQUFFdC9CLE1BQU07UUFBeUJzL0IsV0FBVztJQUFLO0lBQ3ZELE1BQU07UUFBRXQvQixNQUFNO1FBQXFCcy9CLFdBQVc7SUFBTTtBQUN4RDtBQUNBLFNBQVM0cUIsV0FBVzk3QyxLQUFLO0lBQ3JCLE9BQU9BLE1BQU1wQyxJQUFJLEtBQUt4SztBQUMxQjtBQUNBLFNBQVMyb0QsaUJBQWlCLzdDLEtBQUs7SUFDM0IsSUFBSSxDQUFDQSxNQUFNcEMsSUFBSSxFQUNYLE9BQU87SUFDWCxNQUFNa1csTUFBTStuQyxhQUFhLENBQUMsQ0FBQyxFQUFFNzdDLE1BQU1wQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzFDLElBQUksQ0FBQ2tXLEtBQ0QsT0FBTztJQUNYLE9BQU9BLElBQUlvZCxTQUFTO0FBQ3hCO0FBQ0EsU0FBUzhxQixvQkFBb0JoOEMsS0FBSztJQUM5QixPQUFPQSxNQUFNcEMsSUFBSSxLQUFLLElBQUksNEJBQTRCO0FBQzFEO0FBQ0EsU0FBU2c2QyxZQUFZOWpDLEdBQUc7SUFDcEIsSUFBSSxPQUFPQSxJQUFJOGpDLFdBQVcsS0FBSyxXQUFXO1FBQ3RDLE9BQU85akMsSUFBSThqQyxXQUFXO0lBQzFCO0lBQ0EsSUFBSTtRQUNBLE9BQU83bkMsS0FBS2pZLEtBQUssQ0FBQ2djLElBQUkzaEIsT0FBTyxFQUFFeWxELFdBQVc7SUFDOUMsRUFDQSxPQUFPL25CLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNvc0IsZ0JBQWdCM0csR0FBRztJQUN4QixPQUFPLENBQUNBLElBQUluUixNQUFNLElBQUltUixJQUFJblIsTUFBTSxHQUFHLE9BQU8sT0FBT21SLElBQUluUixNQUFNO0FBQy9EO0FBRUEsSUFBSStYO0FBQ0gsVUFBVUEsZUFBZTtJQUN0QkEsZUFBZSxDQUFDLFNBQVMsR0FBRztJQUM1QkEsZUFBZSxDQUFDLFlBQVksR0FBRztJQUMvQkEsZUFBZSxDQUFDLGFBQWEsR0FBRztJQUNoQ0EsZUFBZSxDQUFDLGVBQWUsR0FBRztJQUNsQ0EsZUFBZSxDQUFDLE9BQU8sR0FBRztBQUM5QixHQUFHQSxtQkFBb0JBLENBQUFBLGtCQUFrQixDQUFDO0FBQzFDLE1BQU1DO0lBQ0Z6cUQsWUFBWW9pRCxNQUFNLENBQUU7UUFDaEIsYUFBYSxHQUNiLElBQUksQ0FBQ3NJLG9CQUFvQixHQUFHLENBQUNwaUM7WUFDekIsSUFBSSxDQUFDeTdCLElBQUksQ0FBQyxDQUFDLHlCQUF5QixFQUFFejdCLE1BQU03YyxJQUFJLENBQUMsQ0FBQztZQUNsRCxJQUFJNmMsTUFBTTdjLElBQUksS0FBSyxXQUFXO2dCQUMxQixJQUFJLENBQUNrL0MsU0FBUyxDQUFDSCxnQkFBZ0JJLE1BQU07Z0JBQ3JDLElBQUksQ0FBQ0MsV0FBVyxFQUFFQyxPQUFPO2dCQUN6QixJQUFJLENBQUNELFdBQVcsR0FBR25wRDtnQkFDbkI7WUFDSjtZQUNBLElBQUk0bUIsTUFBTTdjLElBQUksS0FBSyxZQUFZLElBQUksQ0FBQzRiLEtBQUssS0FBS21qQyxnQkFBZ0JJLE1BQU0sRUFBRTtnQkFDbEUsSUFBSSxDQUFDcFQsT0FBTyxDQUFDO1lBQ2pCO1FBQ0o7UUFDQSxhQUFhLEdBQ2IsSUFBSSxDQUFDdVQsSUFBSSxHQUFHLE9BQU9wMEIsUUFBUXhHLFFBQVE2NkI7WUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ0gsV0FBVyxJQUFJLENBQUNsMEIsT0FBT3JhLEtBQUssRUFBRTtnQkFDcEMsSUFBSSxDQUFDdXVDLFdBQVcsR0FBR3h3RCw4Q0FBS0EsQ0FBQzR3RCxXQUFXLENBQUNyZCxNQUFNO1lBQy9DO1lBQ0EsSUFBSTtnQkFDQSxNQUFNZ1csTUFBTSxNQUFNLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQzhJLGNBQWMsQ0FBQyxPQUFPLElBQUksQ0FBQzlJLE1BQU0sQ0FBQytJLE9BQU8sQ0FBQzFrRCxPQUFPLENBQUMsU0FBUyxXQUFXLGFBQ3BHL0UsV0FBVztvQkFDUHl1QixRQUFRO3dCQUFFLEdBQUdBLE1BQU07d0JBQUUwNkIsYUFBYSxJQUFJLENBQUNBLFdBQVcsRUFBRTkyQztvQkFBTTtvQkFDMUQ0aUI7b0JBQ0F5MEIsZ0JBQWdCO2dCQUNwQjtnQkFDQSxJQUFJLENBQUM3RixtQkFBbUIsR0FBRyxHQUFHLG1DQUFtQztnQkFDakUsT0FBTzNCO1lBQ1gsRUFDQSxPQUFPeGhDLEtBQUs7Z0JBQ1IsSUFBSSxDQUFDbWpDLG1CQUFtQixJQUFJO2dCQUM1QixhQUFhO2dCQUNiLElBQUl5RixTQUFTWCxpQkFBaUJqb0MsTUFBTTtvQkFDaEMsSUFBSSxDQUFDMmhDLElBQUksQ0FBQyxDQUFDLDBDQUEwQyxDQUFDO29CQUN0RCxNQUFNMW5CLE1BQU1TLGNBQWMsSUFBSSxDQUFDeW9CLG1CQUFtQjtvQkFDbEQsT0FBTyxJQUFJLENBQUN3RixJQUFJLENBQUNwMEIsUUFBUXhHLFFBQVE2NkI7Z0JBQ3JDO2dCQUNBLE1BQU01b0M7WUFDVjtRQUNKO1FBQ0EsYUFBYSxHQUNiLElBQUksQ0FBQ2lwQyxLQUFLLEdBQUc7WUFDVCxNQUFPLElBQUksQ0FBQ2hrQyxLQUFLLEtBQUttakMsZ0JBQWdCYyxTQUFTLENBQUU7Z0JBQzdDLElBQUk7b0JBQ0EsTUFBTXR2QixPQUFPLE1BQU0sSUFBSSxDQUFDK3VCLElBQUksQ0FBQyxDQUFDLEdBQUc7d0JBQzdCeHlDLFNBQVM7b0JBQ2IsR0FBRyxPQUFPLGtEQUFrRDtvQkFDNUQsSUFBSXlqQixLQUFLMWtCLE1BQU0sRUFBRXpWLFFBQVE7d0JBQ3JCLElBQUssSUFBSXNELElBQUksR0FBR0EsSUFBSTYyQixLQUFLMWtCLE1BQU0sQ0FBQ3pWLE1BQU0sRUFBRXNELElBQUs7NEJBQ3pDLElBQUksQ0FBQ2k5QyxNQUFNLENBQUN1RCxhQUFhLENBQUMzcEIsS0FBSzFrQixNQUFNLENBQUNuUyxFQUFFO3dCQUM1QztvQkFDSjtnQkFDSixFQUNBLE9BQU9pZCxLQUFLO29CQUNSLElBQUkvbkIsOENBQUtBLENBQUNreEQsUUFBUSxDQUFDbnBDLE1BQU07d0JBQ3JCLElBQUksQ0FBQzJoQyxJQUFJLENBQUMsQ0FBQyxnQ0FBZ0MsQ0FBQzt3QkFDNUM7b0JBQ0o7b0JBQ0EsZ0VBQWdFLEdBQ2hFLGFBQWE7b0JBQ2IsSUFBSXVHLG9CQUFvQmxvQyxNQUFNO3dCQUMxQixJQUFJLENBQUMyaEMsSUFBSSxDQUFDLENBQUMsc0RBQXNELENBQUM7d0JBQ2xFLElBQUksQ0FBQzRHLFNBQVMsQ0FBQ0gsZ0JBQWdCZ0IsWUFBWTt3QkFDM0MsSUFBSSxDQUFDaFUsT0FBTyxDQUFDO3dCQUNiO29CQUNKO29CQUNBLGFBQWE7b0JBQ2IsSUFBSTRTLFdBQVdob0MsUUFBUSxDQUFDaW9DLGlCQUFpQmpvQyxNQUFNO3dCQUMzQyxJQUFJLENBQUN1b0MsU0FBUyxDQUFDSCxnQkFBZ0JJLE1BQU07d0JBQ3JDO29CQUNKO29CQUNBLE1BQU12dUIsTUFBTVMsY0FBYyxJQUFJLENBQUN5b0IsbUJBQW1CO2dCQUN0RDtZQUNKO1FBQ0o7UUFDQTs7O1NBR0MsR0FDRCxJQUFJLENBQUMvTixPQUFPLEdBQUcsT0FBTzBFLFlBQVksS0FBSztZQUNuQyxJQUFJLElBQUksQ0FBQzcwQixLQUFLLEtBQUttakMsZ0JBQWdCaUIsVUFBVSxFQUFFO2dCQUMzQyxJQUFJLENBQUMxSCxJQUFJLENBQUMsOENBQThDO29CQUFFN0g7Z0JBQVUsR0FBRztnQkFDdkU7WUFDSjtZQUNBLElBQUksSUFBSSxDQUFDNzBCLEtBQUssS0FBS21qQyxnQkFBZ0JjLFNBQVMsRUFBRTtnQkFDMUMsSUFBSSxDQUFDdkgsSUFBSSxDQUFDLDZDQUE2QztvQkFBRTdIO2dCQUFVLEdBQUc7Z0JBQ3RFO1lBQ0o7WUFDQSxJQUFJLENBQUN5TyxTQUFTLENBQUNILGdCQUFnQmlCLFVBQVU7WUFDekMsSUFBSSxDQUFDdkksWUFBWSxHQUFHeGhELFdBQVcscUVBQXFFO1lBQ3BHLElBQUk7Z0JBQ0EsTUFBTSxFQUFFNG1CLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDeWlDLElBQUksQ0FBQztvQkFBRXBxRCxNQUFNLElBQUksQ0FBQ3loRCxNQUFNLENBQUNzSixlQUFlO2dCQUFHLEdBQUc7b0JBQ3ZFbnpDLFNBQVM7Z0JBQ2IsR0FBRzJqQztnQkFDSCxJQUFJLENBQUN5TyxTQUFTLENBQUNILGdCQUFnQmMsU0FBUztnQkFDeEMsSUFBSSxDQUFDcEksWUFBWSxHQUFHNTZCLE1BQU1nL0IsYUFBYTtnQkFDdkMsSUFBSSxDQUFDbEYsTUFBTSxDQUFDbUYsbUJBQW1CO2dCQUMvQixtQkFBbUI7Z0JBQ25CLElBQUksQ0FBQ25GLE1BQU0sQ0FBQ3VELGFBQWEsQ0FBQ3I5QjtnQkFDMUIsSUFBSSxDQUFDK2lDLEtBQUs7Z0JBQ1YsT0FBTy9pQztZQUNYLEVBQ0EsT0FBT2xHLEtBQUs7Z0JBQ1IsSUFBSSxDQUFDdW9DLFNBQVMsQ0FBQ0gsZ0JBQWdCSSxNQUFNO2dCQUNyQyxJQUFJLENBQUN4SSxNQUFNLENBQUNxRixrQkFBa0I7Z0JBQzlCLE1BQU1ybEM7WUFDVjtRQUNKO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUNtaUMsU0FBUyxHQUFHO1lBQ2IsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDckIsWUFBWSxJQUFJLElBQUksQ0FBQzc3QixLQUFLLEtBQUttakMsZ0JBQWdCYyxTQUFTO1FBQzFFO1FBQ0EsSUFBSSxDQUFDM2dCLFVBQVUsR0FBRyxPQUFPcHlCLFVBQVUsSUFBSTtZQUNuQ21tQiwrQkFBK0IsSUFBSSxDQUFDZ3NCLG9CQUFvQjtZQUN4RCxJQUFJLENBQUNDLFNBQVMsQ0FBQ0gsZ0JBQWdCZ0IsWUFBWTtZQUMzQyxJQUFJLENBQUNYLFdBQVcsRUFBRUMsT0FBTztZQUN6QixJQUFJLENBQUNELFdBQVcsR0FBR25wRDtZQUNuQixNQUFNNGxELGdCQUFnQixJQUFJLENBQUNwRSxZQUFZO1lBQ3ZDLElBQUksQ0FBQ0EsWUFBWSxHQUFHeGhEO1lBQ3BCLElBQUk7Z0JBQ0EsTUFBTSxJQUFJLENBQUNxcEQsSUFBSSxDQUFDO29CQUFFenVDLE9BQU87b0JBQU1nckM7Z0JBQWMsR0FBRztvQkFDNUMvdUM7Z0JBQ0osR0FBRztnQkFDSCxJQUFJLENBQUN3ckMsSUFBSSxDQUFDLENBQUMsa0NBQWtDLENBQUM7WUFDbEQsRUFDQSxPQUFPM2hDLEtBQUs7Z0JBQ1IsSUFBSSxDQUFDMmhDLElBQUksQ0FBQyxDQUFDLHFCQUFxQixDQUFDLEVBQUU7b0JBQUUzaEM7Z0JBQUksR0FBRztZQUNoRDtRQUNKO1FBQ0EsSUFBSSxDQUFDZ2dDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUMvNkIsS0FBSyxHQUFHbWpDLGdCQUFnQm1CLElBQUk7UUFDakMsSUFBSSxDQUFDcEcsbUJBQW1CLEdBQUc7UUFDM0IvbUIsNEJBQTRCLElBQUksQ0FBQ2tzQixvQkFBb0I7SUFDekQ7SUFDQTNHLEtBQUt6K0MsR0FBRyxFQUFFMCtDLFFBQVEsQ0FBQyxDQUFDLEVBQUUxdUMsUUFBUSxNQUFNLEVBQUU7UUFDbEMsSUFBSSxDQUFDOHNDLE1BQU0sQ0FBQ3ZuQyxNQUFNLENBQUN2RixPQUFPLDBCQUEwQmhRLEtBQUs7WUFDckQsR0FBRzArQyxLQUFLO1FBQ1o7SUFDSjtJQUNBMkcsVUFBVXRqQyxLQUFLLEVBQUU7UUFDYixJQUFJLENBQUMwOEIsSUFBSSxDQUFDLENBQUMsY0FBYyxFQUFFMThCLE1BQU0sQ0FBQztRQUNsQywwQ0FBMEM7UUFDMUMsSUFBSSxJQUFJLENBQUNBLEtBQUssS0FBS21qQyxnQkFBZ0JpQixVQUFVLElBQ3pDcGtDLFVBQVVtakMsZ0JBQWdCYyxTQUFTLEVBQUU7WUFDckMsSUFBSSxDQUFDbEosTUFBTSxDQUFDdUQsYUFBYSxDQUFDO2dCQUFFbDZDLE1BQU07Z0JBQXNCZ3hDLFFBQVE7WUFBSztRQUN6RTtRQUNBLElBQUlwMUIsVUFBVW1qQyxnQkFBZ0JJLE1BQU0sSUFDaEN2akMsVUFBVW1qQyxnQkFBZ0JnQixZQUFZLEVBQUU7WUFDeEMsSUFBSSxDQUFDcEosTUFBTSxDQUFDdUQsYUFBYSxDQUFDO2dCQUFFbDZDLE1BQU07Z0JBQXNCZ3hDLFFBQVE7WUFBTTtRQUMxRTtRQUNBLElBQUksQ0FBQ3AxQixLQUFLLEdBQUdBO0lBQ2pCO0FBQ0o7QUFFQSxNQUFNeE0sU0FBU1IsVUFBVTtJQUFDO0NBQVc7QUFDckMsTUFBTXV4QyxXQUFXLENBQUMsaUNBQWlDLENBQUM7QUFDcEQsTUFBTXJtQixrQkFBa0IsT0FBT3NtQixVQUFVRCxRQUFRLEVBQUVyekMsVUFBVSxJQUFJO0lBQzdELE1BQU11ekMsa0JBQWtCLElBQUlDO0lBQzVCLE1BQU1oa0IsWUFBWXJPLFdBQVcsSUFBTW95QixnQkFBZ0JFLEtBQUssSUFBSXp6QztJQUM1RCxJQUFJO1FBQ0EsTUFBTThmLFdBQVcsTUFBTTR6QixNQUFNTCxVQUFVO1lBQ25DOXpDLFFBQVE7WUFDUituQixRQUFRaXNCLGdCQUFnQmpzQixNQUFNO1FBQ2xDO1FBQ0EsTUFBTXFzQixTQUFTN3pCLFNBQVMxZixPQUFPLENBQUNtZ0IsR0FBRyxDQUFDLG1CQUFtQjtRQUN2RGplLE9BQU8sU0FBUyxDQUFDLGlCQUFpQixFQUFFcXhDLE9BQU8sQ0FBQztRQUM1QyxPQUFPQSxPQUFPM2xELFNBQVMsQ0FBQyxHQUFHLElBQUksaUJBQWlCO0lBQ3BELEVBQ0EsT0FBT3lDLEdBQUc7UUFDTjZSLE9BQU8sUUFBUSxDQUFDLGlDQUFpQyxFQUFFK3dDLFNBQVMsQ0FBQyxFQUFFNWlEO1FBQy9ELE9BQU87SUFDWCxTQUNRO1FBQ0prckIsYUFBYTZUO0lBQ2pCO0FBQ0o7QUFFQSxNQUFNb2tCO0lBQ0Y7Ozs7Ozs7Ozs7O0tBV0MsR0FDRG5zRCxZQUFZMkMsR0FBRyxFQUFFakMsT0FBTyxDQUFFO1FBQ3RCLElBQUksQ0FBQ3djLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQ2t2QywwQkFBMEIsR0FBRztRQUNsQyxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDdko7WUFDYixPQUFPeUcsU0FBU3pHO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRixXQUFXLEdBQUc7WUFDZixPQUFPLElBQUksQ0FBQ3o2QyxTQUFTLEdBQUcsY0FBYztRQUMxQztRQUNBLElBQUksQ0FBQ21rRCxVQUFVLEdBQUcsQ0FBQ25CO1lBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1lBQ2YsSUFBSSxDQUFDL0csU0FBUyxHQUFHLElBQUksQ0FBQytHLE9BQU8sQ0FDeEIxa0QsT0FBTyxDQUFDLFFBQVEsTUFDaEJBLE9BQU8sQ0FBQyxTQUFTO1FBQzFCO1FBQ0EsSUFBSSxDQUFDOCtCLGVBQWUsR0FBRyxPQUFPc21CLFNBQVN0ekM7WUFDbkMsTUFBTWcwQyxPQUFPLE1BQU0sSUFBSSxDQUFDQyxZQUFZO1lBQ3BDLElBQUksQ0FBQ0QsUUFBUUEsU0FBUyxPQUFPO2dCQUN6QixJQUFJLENBQUNDLFlBQVksR0FBR2puQixnQkFBZ0JzbUIsV0FBVyxJQUFJLENBQUNuckQsT0FBTyxDQUFDK3JELGVBQWUsRUFBRWwwQyxXQUFXLElBQUksQ0FBQzdYLE9BQU8sQ0FBQ2dzRCxtQkFBbUI7Z0JBQ3hILE9BQU8sSUFBSSxDQUFDRixZQUFZO1lBQzVCO1lBQ0EsT0FBT0Q7UUFDWDtRQUNBLElBQUksQ0FBQ0ksZ0JBQWdCLEdBQUcsSUFBTSxJQUFJLENBQUNDLFlBQVksRUFBRTFKLGdCQUFnQixJQUFJLENBQUMySixVQUFVLEVBQUUzSjtRQUNsRixJQUFJLENBQUMxSCxnQkFBZ0IsR0FBRyxJQUFNdFIsUUFBUSxJQUFJLENBQUN5aUIsZ0JBQWdCO1FBQzNEOzs7Ozs7O1NBT0MsR0FDRCxJQUFJLENBQUNHLFdBQVcsR0FBRyxPQUFPdGlDLE1BQU11aUM7WUFDNUIsSUFBSSxDQUFDdmlDLEtBQUs5ZSxFQUFFLEVBQUU7Z0JBQ1YsTUFBTSxJQUFJN0wsTUFBTTtZQUNwQjtZQUNBOzs7YUFHQyxHQUNELElBQUksSUFBSSxDQUFDaWpELE1BQU0sS0FBS3Q0QixLQUFLOWUsRUFBRSxJQUFJLElBQUksQ0FBQ3NoRCxjQUFjLEVBQUU7Z0JBQ2hELElBQUksQ0FBQ255QyxNQUFNLENBQUMsUUFBUTtnQkFDcEIsT0FBTyxJQUFJLENBQUNteUMsY0FBYztZQUM5QjtZQUNBLElBQUksSUFBSSxDQUFDbEssTUFBTSxFQUFFO2dCQUNiLE1BQU0sSUFBSWpqRCxNQUFNO1lBQ3BCO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ290RCxrQkFBa0IsTUFBTSxJQUFJLENBQUNDLElBQUksS0FDdkMsQ0FBQyxJQUFJLENBQUN4c0QsT0FBTyxDQUFDeXNELHNCQUFzQixFQUFFO2dCQUN0QyxJQUFJLENBQUN0eUMsTUFBTSxDQUFDLFFBQVE7WUFDeEI7WUFDQSx3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDaW9DLE1BQU0sR0FBR3Q0QixLQUFLOWUsRUFBRTtZQUNyQixJQUFJLENBQUN2RCxTQUFTLEdBQUc7WUFDakIsTUFBTWlsRCxrQkFBa0IsSUFBSSxDQUFDQyxTQUFTLENBQUM3aUMsTUFBTXVpQyxxQkFBcUIsSUFBSSxDQUFDNWtELFNBQVM7WUFDaEYsSUFBSSxDQUFDbWxELFFBQVEsQ0FBQzlpQztZQUNkLE1BQU0raUMsWUFBWSxJQUFJLENBQUNDLGNBQWM7WUFDckMsSUFBSSxDQUFDUixjQUFjLEdBQUcxd0IsUUFBUW1MLEdBQUcsQ0FBQztnQkFBQzJsQjtnQkFBaUJHO2FBQVUsRUFBRTN0QixJQUFJLENBQUMsQ0FBQ25sQixTQUFXQSxNQUFNLENBQUMsRUFBRTtZQUMxRixJQUFJO2dCQUNBLE9BQU8sTUFBTSxJQUFJLENBQUN1eUMsY0FBYztZQUNwQyxFQUNBLE9BQU81cUMsS0FBSztnQkFDUixJQUFJLElBQUksQ0FBQ3FyQyw4QkFBOEIsRUFBRTtvQkFDckMsOERBQThEO29CQUM5RCxJQUFJLENBQUNDLGVBQWU7Z0JBQ3hCLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDQyxjQUFjO2dCQUN2QjtnQkFDQSxNQUFNdnJDO1lBQ1Y7UUFDSjtRQUNBLElBQUksQ0FBQ2lyQyxTQUFTLEdBQUcsQ0FBQzdpQyxNQUFNdWlDLHFCQUFxQm5ELGNBQWdCLElBQUksQ0FBQy9HLFlBQVksQ0FBQzZHLGtCQUFrQixDQUFDcUQscUJBQXFCdmlDLE1BQU1vL0I7UUFDN0gsSUFBSSxDQUFDMEQsUUFBUSxHQUFHLENBQUM5aUM7WUFDYjs7O2FBR0MsR0FDRCxJQUFJLENBQUNBLElBQUksR0FBR0E7WUFDWixJQUFJLENBQUNzNEIsTUFBTSxHQUFHdDRCLEtBQUs5ZSxFQUFFO1lBQ3JCLDZHQUE2RztZQUM3RyxJQUFJLENBQUNzM0MsS0FBSyxHQUFHO2dCQUFFLEdBQUd4NEIsSUFBSTtZQUFDO1FBQzNCO1FBQ0E7Ozs7Ozs7Ozs7OztTQVlDLEdBQ0QsSUFBSSxDQUFDa2pDLGVBQWUsR0FBRyxPQUFPbjFDO1lBQzFCLElBQUksSUFBSSxDQUFDcTFDLG1CQUFtQixJQUFJLE1BQU07Z0JBQ2xDdnVCLGNBQWMsSUFBSSxDQUFDdXVCLG1CQUFtQjtnQkFDdEMsSUFBSSxDQUFDQSxtQkFBbUIsR0FBR2xzRDtZQUMvQjtZQUNBLE1BQU00NkIsUUFBUW1MLEdBQUcsQ0FBQztnQkFDZCxJQUFJLENBQUNtbEIsWUFBWSxFQUFFamlCLFdBQVdweUI7Z0JBQzlCLElBQUksQ0FBQ3MwQyxVQUFVLEVBQUVsaUIsV0FBV3B5QjthQUMvQjtZQUNELE9BQU8rakIsUUFBUXVFLE9BQU87UUFDMUI7UUFDQTs7U0FFQyxHQUNELElBQUksQ0FBQzJzQixjQUFjLEdBQUc7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQzFLLE1BQU0sRUFBRTtnQkFDZCxNQUFNampELE1BQU07WUFDaEI7WUFDQSxJQUFJLElBQUksQ0FBQytzRCxZQUFZLEVBQUV0SCxnQkFBZ0IsSUFBSSxDQUFDaUksU0FBUyxFQUFFO2dCQUNuRCxJQUFJLENBQUMxeUMsTUFBTSxDQUFDLFFBQVE7Z0JBQ3BCLE9BQU8sSUFBSSxDQUFDMHlDLFNBQVM7WUFDekI7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDWCxZQUFZLEVBQUVySSxhQUFhLElBQUksQ0FBQ3NJLFVBQVUsRUFBRXRJLFdBQVUsS0FDNUQsSUFBSSxDQUFDL0ksZ0JBQWdCLElBQUk7Z0JBQ3pCLElBQUksQ0FBQzNnQyxNQUFNLENBQUMsUUFBUTtnQkFDcEIsT0FBT3loQixRQUFRdUUsT0FBTztZQUMxQjtZQUNBLElBQUksQ0FBQ2d0QixtQkFBbUIsR0FBRyxJQUFJdnhCLFFBQVEsQ0FBQ3VFLFNBQVNpYTtnQkFDN0MsSUFBSSxDQUFDeU0sbUJBQW1CLEdBQUcxbUI7Z0JBQzNCLElBQUksQ0FBQzRtQixrQkFBa0IsR0FBRzNNO1lBQzlCO1lBQ0EsSUFBSSxDQUFDMEwsUUFBUSxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMxRCxNQUFNLENBQUMsRUFBRSxFQUFFN2xCLFdBQVcsQ0FBQztZQUMvQyxJQUFJLENBQUNzd0IsU0FBUyxHQUFHLElBQUksQ0FBQy9WLE9BQU87WUFDN0IsT0FBTyxJQUFJLENBQUMrVixTQUFTO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDTyxjQUFjLEdBQUcsQ0FBQ0M7WUFDbkIsSUFBSUEsa0JBQWtCdm9ELE1BQU07Z0JBQ3hCdW9ELFNBQVNBLE9BQU92bkQsV0FBVztZQUMvQjtZQUNBLElBQUl1bkQsV0FBVyxJQUFJO2dCQUNmLE1BQU0sSUFBSWx1RCxNQUFNO1lBQ3BCO1lBQ0EsT0FBT2t1RDtRQUNYO1FBQ0E7Ozs7O1NBS0MsR0FDRCxJQUFJLENBQUNKLGNBQWMsR0FBRyxPQUFPcDFDO1lBQ3pCLElBQUksQ0FBQ3NDLE1BQU0sQ0FBQyxRQUFRO1lBQ3BCLGtDQUFrQztZQUNsQyxPQUFPLElBQUksQ0FBQzJQLElBQUk7WUFDaEIsT0FBTyxJQUFJLENBQUN3NEIsS0FBSztZQUNqQixPQUFPLElBQUksQ0FBQ0YsTUFBTTtZQUNsQixJQUFJLENBQUMzNkMsU0FBUyxHQUFHO1lBQ2pCLE1BQU0sSUFBSSxDQUFDdWxELGVBQWUsQ0FBQ24xQztZQUMzQixJQUFJLENBQUNzcUMsWUFBWSxDQUFDa0gsS0FBSztZQUN2QixJQUFJLENBQUM4RCxtQkFBbUIsR0FBR25zRDtZQUMzQixJQUFJLENBQUMrbEQsa0JBQWtCLEdBQUcvbEQ7WUFDMUIsSUFBSSxDQUFDNmxELG1CQUFtQixHQUFHN2xEO1FBQy9CO1FBQ0EsSUFBSSxDQUFDc3NELGdCQUFnQixHQUFHLE9BQU94akM7WUFDM0IsSUFBSSxDQUFDeWpDLHNCQUFzQixHQUFHLElBQUksQ0FBQy9DLGNBQWMsQ0FBQyxRQUFRLFVBQVU7Z0JBQ2hFMWdDLE1BQU07b0JBQ0YsR0FBR0EsSUFBSTtvQkFDUG5HLE1BQU07Z0JBQ1Y7WUFDSixHQUFHO2dCQUFFK21DLGdCQUFnQjtZQUFLO1lBQzFCLE1BQU0veUIsV0FBVyxNQUFNLElBQUksQ0FBQzQxQixzQkFBc0I7WUFDbEQsSUFBSSxDQUFDQSxzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLElBQU8sSUFBSSxDQUFDRCxzQkFBc0IsR0FBR3ZzRDtZQUN6RSxPQUFPLElBQUksQ0FBQ29yRCxXQUFXLENBQUN6MEIsU0FBUzdOLElBQUksRUFBRTZOLFNBQVM4MUIsWUFBWTtRQUNoRTtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxPQUFPNWpDLE1BQU1tL0I7WUFDckMsSUFBSSxDQUFDa0UsbUJBQW1CLEdBQUcsSUFBSXZ4QixRQUFRLENBQUN1RSxTQUFTaWE7Z0JBQzdDLElBQUksQ0FBQ3lNLG1CQUFtQixHQUFHMW1CO2dCQUMzQixJQUFJLENBQUM0bUIsa0JBQWtCLEdBQUczTTtZQUM5QjtZQUNBLElBQUksQ0FBQzN5QyxTQUFTLEdBQUc7WUFDakIsTUFBTSxJQUFJLENBQUNrbEQsU0FBUyxDQUFDN2lDLE1BQU1tL0IsaUJBQWlCLElBQUksQ0FBQ3hoRCxTQUFTO1lBQzFELElBQUksQ0FBQ21sRCxRQUFRLENBQUM5aUM7WUFDZCx5REFBeUQ7WUFDekQsb0VBQW9FO1lBQ3BFLGtDQUFrQztZQUNsQyxJQUFJLENBQUMrOEIsbUJBQW1CO1FBQzVCO1FBQ0E7Ozs7Ozs7OztTQVNDLEdBQ0QsSUFBSSxDQUFDbnFDLEVBQUUsR0FBRyxDQUFDWCxXQUFXcXJDO1lBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUM1cUMsU0FBUyxDQUFDVCxVQUFVLEVBQUU7Z0JBQzVCLElBQUksQ0FBQ1MsU0FBUyxDQUFDVCxVQUFVLEdBQUcsRUFBRTtZQUNsQztZQUNBLElBQUksQ0FBQzVCLE1BQU0sQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUU0QixVQUFVLE1BQU0sQ0FBQztZQUM3RCxJQUFJLENBQUNTLFNBQVMsQ0FBQ1QsVUFBVSxFQUFFdlgsS0FBSzRpRDtZQUNoQyxPQUFPO2dCQUNILElBQUksQ0FBQ3hxQyxHQUFHLENBQUNiLFdBQVdxckM7WUFDeEI7UUFDSjtRQUNBOztTQUVDLEdBQ0QsSUFBSSxDQUFDeHFDLEdBQUcsR0FBRyxDQUFDYixXQUFXcXJDO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUM1cUMsU0FBUyxDQUFDVCxVQUFVLEVBQUU7Z0JBQzVCLElBQUksQ0FBQ1MsU0FBUyxDQUFDVCxVQUFVLEdBQUcsRUFBRTtZQUNsQztZQUNBLElBQUksQ0FBQzVCLE1BQU0sQ0FBQyxTQUFTLENBQUMsc0JBQXNCLEVBQUU0QixVQUFVLE1BQU0sQ0FBQztZQUMvRCxJQUFJLENBQUNTLFNBQVMsQ0FBQ1QsVUFBVSxHQUFHLElBQUksQ0FBQ1MsU0FBUyxDQUFDVCxVQUFVLEVBQUVoaEIsT0FBTyxDQUFDK0YsUUFBVUEsVUFBVXNtRDtRQUN2RjtRQUNBLElBQUksQ0FBQ3VHLGNBQWMsR0FBRyxDQUFDNWlELE1BQU1nMUIsS0FBS3pFLE1BQU03TDtZQUNwQyxJQUFJLENBQUN0VixNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRXBQLEtBQUssYUFBYSxFQUFFZzFCLElBQUksQ0FBQyxFQUFFO2dCQUN2RHhqQixTQUFTK2U7Z0JBQ1Q3TDtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNtK0IsZUFBZSxHQUFHLENBQUM3aUQsTUFBTWcxQixLQUFLcEk7WUFDL0IsSUFBSSxDQUFDeGQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUVwUCxLQUFLLG1CQUFtQixFQUFFZzFCLElBQUksVUFBVSxFQUFFcEksU0FBU29hLE1BQU0sQ0FBQyxDQUFDLEVBQUU7Z0JBQ3hGcGE7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDazJCLFlBQVksR0FBRyxDQUFDOWlELE1BQU1nMUIsS0FBS255QjtZQUM1QixJQUFJLENBQUN1TSxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRXBQLEtBQUssZ0JBQWdCLEVBQUVnMUIsSUFBSSxDQUFDLEVBQUU7Z0JBQ3pEQTtnQkFDQW55QjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUM0OEMsY0FBYyxHQUFHLE9BQU96L0MsTUFBTWcxQixLQUFLekUsTUFBTXQ3QixVQUFVLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUNBLFFBQVEwcUQsY0FBYyxFQUFFO2dCQUN6QixNQUFNOXVCLFFBQVFtTCxHQUFHLENBQUM7b0JBQ2QsSUFBSSxDQUFDb2IsWUFBWSxDQUFDc0UsVUFBVTtvQkFDNUIsSUFBSSxDQUFDOEcsc0JBQXNCO29CQUMzQixJQUFJLENBQUNKLG1CQUFtQjtpQkFDM0I7WUFDTDtZQUNBLE1BQU1XLGdCQUFnQixJQUFJLENBQUNDLG1CQUFtQixDQUFDL3REO1lBQy9DLElBQUk7Z0JBQ0EsSUFBSTIzQjtnQkFDSixJQUFJLENBQUNnMkIsY0FBYyxDQUFDNWlELE1BQU1nMUIsS0FBS3pFLE1BQU13eUI7Z0JBQ3JDLE9BQVEvaUQ7b0JBQ0osS0FBSzt3QkFDRDRzQixXQUFXLE1BQU0sSUFBSSxDQUFDcTJCLGFBQWEsQ0FBQzUxQixHQUFHLENBQUMySCxLQUFLK3RCO3dCQUM3QztvQkFDSixLQUFLO3dCQUNEbjJCLFdBQVcsTUFBTSxJQUFJLENBQUNxMkIsYUFBYSxDQUFDOXpCLE1BQU0sQ0FBQzZGLEtBQUsrdEI7d0JBQ2hEO29CQUNKLEtBQUs7d0JBQ0RuMkIsV0FBVyxNQUFNLElBQUksQ0FBQ3EyQixhQUFhLENBQUNqcEIsSUFBSSxDQUFDaEYsS0FBS3pFLE1BQU13eUI7d0JBQ3BEO29CQUNKLEtBQUs7d0JBQ0RuMkIsV0FBVyxNQUFNLElBQUksQ0FBQ3EyQixhQUFhLENBQUNDLEdBQUcsQ0FBQ2x1QixLQUFLekUsTUFBTXd5Qjt3QkFDbkQ7b0JBQ0osS0FBSzt3QkFDRG4yQixXQUFXLE1BQU0sSUFBSSxDQUFDcTJCLGFBQWEsQ0FBQ3hoRCxLQUFLLENBQUN1ekIsS0FBS3pFLE1BQU13eUI7d0JBQ3JEO29CQUNKLEtBQUs7d0JBQ0RuMkIsV0FBVyxNQUFNLElBQUksQ0FBQ3EyQixhQUFhLENBQUNodUQsT0FBTyxDQUFDKy9CLEtBQUsrdEI7d0JBQ2pEO29CQUNKO3dCQUNJLE1BQU0sSUFBSTN1RCxNQUFNO2dCQUN4QjtnQkFDQSxJQUFJLENBQUN5dUQsZUFBZSxDQUFDN2lELE1BQU1nMUIsS0FBS3BJO2dCQUNoQyxJQUFJLENBQUNrdEIsbUJBQW1CLEdBQUc7Z0JBQzNCLE9BQU8sSUFBSSxDQUFDcUosY0FBYyxDQUFDdjJCO1lBQzNCLDhEQUE4RDtZQUNsRSxFQUNBLE9BQU9ydkIsRUFBRSxpQ0FBaUMsS0FBSTtnQkFDMUNBLEVBQUU2bEQsaUJBQWlCLEdBQUdMLGNBQWM3MUMsT0FBTyxFQUFFLENBQUMsc0JBQXNCO2dCQUNwRSxJQUFJLENBQUM0c0MsbUJBQW1CLElBQUk7Z0JBQzVCLElBQUl2OEMsRUFBRXF2QixRQUFRLEVBQUU7b0JBQ1osSUFBSSxDQUFDazJCLFlBQVksQ0FBQzlpRCxNQUFNZzFCLEtBQUt6M0IsRUFBRXF2QixRQUFRO29CQUN2QywrREFBK0QsR0FDL0QsSUFBSXJ2QixFQUFFcXZCLFFBQVEsQ0FBQzJELElBQUksQ0FBQzl2QixJQUFJLEtBQUt1d0IsV0FBV0MsYUFBYSxJQUNqRCxDQUFDLElBQUksQ0FBQ21tQixZQUFZLENBQUMyQyxRQUFRLElBQUk7d0JBQy9CLElBQUksSUFBSSxDQUFDRCxtQkFBbUIsR0FBRyxHQUFHOzRCQUM5QixNQUFNbHBCLE1BQU1TLGNBQWMsSUFBSSxDQUFDeW9CLG1CQUFtQjt3QkFDdEQ7d0JBQ0EsTUFBTSxJQUFJLENBQUMxQyxZQUFZLENBQUN1RSxTQUFTO3dCQUNqQyxPQUFPLE1BQU0sSUFBSSxDQUFDOEQsY0FBYyxDQUFDei9DLE1BQU1nMUIsS0FBS3pFLE1BQU10N0I7b0JBQ3REO29CQUNBLE9BQU8sSUFBSSxDQUFDa3VELGNBQWMsQ0FBQzVsRCxFQUFFcXZCLFFBQVE7Z0JBQ3pDLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDazJCLFlBQVksQ0FBQzlpRCxNQUFNZzFCLEtBQUt6M0I7b0JBQzdCLDRDQUE0QztvQkFDNUMsTUFBTUE7Z0JBQ1Y7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDOHZCLEdBQUcsR0FBRyxDQUFDMkgsS0FBSzlKO1lBQ2IsT0FBTyxJQUFJLENBQUN1MEIsY0FBYyxDQUFDLE9BQU96cUIsS0FBSyxNQUFNO2dCQUN6QzlKO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ2c0QixHQUFHLEdBQUcsQ0FBQ2x1QixLQUFLekUsTUFBTXJGO1lBQ25CLE9BQU8sSUFBSSxDQUFDdTBCLGNBQWMsQ0FBQyxPQUFPenFCLEtBQUt6RSxNQUFNO2dCQUFFckY7WUFBTztRQUMxRDtRQUNBLElBQUksQ0FBQzhPLElBQUksR0FBRyxDQUFDaEYsS0FBS3pFLE1BQU1yRjtZQUNwQixPQUFPLElBQUksQ0FBQ3UwQixjQUFjLENBQUMsUUFBUXpxQixLQUFLekUsTUFBTTtnQkFBRXJGO1lBQU87UUFDM0Q7UUFDQSxJQUFJLENBQUN6cEIsS0FBSyxHQUFHLENBQUN1ekIsS0FBS3pFLE1BQU1yRjtZQUNyQixPQUFPLElBQUksQ0FBQ3UwQixjQUFjLENBQUMsU0FBU3pxQixLQUFLekUsTUFBTTtnQkFBRXJGO1lBQU87UUFDNUQ7UUFDQSxJQUFJLENBQUNpRSxNQUFNLEdBQUcsQ0FBQzZGLEtBQUs5SjtZQUNoQixPQUFPLElBQUksQ0FBQ3UwQixjQUFjLENBQUMsVUFBVXpxQixLQUFLLE1BQU07Z0JBQzVDOUo7WUFDSjtRQUNKO1FBQ0EsSUFBSSxDQUFDbTRCLGlCQUFpQixHQUFHLENBQUN6MkI7WUFDdEIsSUFBSWpXO1lBQ0pBLE1BQU0sSUFBSXhpQixrQkFBa0IsQ0FBQyx3QkFBd0IsRUFBRXk0QixTQUFTb2EsTUFBTSxDQUFDLENBQUM7WUFDeEUsSUFBSXBhLFNBQVMyRCxJQUFJLElBQUkzRCxTQUFTMkQsSUFBSSxDQUFDOXZCLElBQUksRUFBRTtnQkFDckNrVyxNQUFNLElBQUl2aUIsTUFBTSxDQUFDLGtCQUFrQixFQUFFdzRCLFNBQVMyRCxJQUFJLENBQUM5dkIsSUFBSSxDQUFDLEVBQUUsRUFBRW1zQixTQUFTMkQsSUFBSSxDQUFDdjdCLE9BQU8sQ0FBQyxDQUFDO2dCQUNuRjJoQixJQUFJbFcsSUFBSSxHQUFHbXNCLFNBQVMyRCxJQUFJLENBQUM5dkIsSUFBSTtZQUNqQztZQUNBa1csSUFBSWlXLFFBQVEsR0FBR0E7WUFDZmpXLElBQUlxd0IsTUFBTSxHQUFHcGEsU0FBU29hLE1BQU07WUFDNUIsT0FBT3J3QjtRQUNYO1FBQ0EsSUFBSSxDQUFDd3NDLGNBQWMsR0FBRyxDQUFDdjJCO1lBQ25CLE1BQU0yRCxPQUFPM0QsU0FBUzJELElBQUk7WUFDMUIsSUFBSXV1QixnQkFBZ0JseUIsV0FBVztnQkFDM0IsTUFBTSxJQUFJLENBQUN5MkIsaUJBQWlCLENBQUN6MkI7WUFDakM7WUFDQSxPQUFPMkQ7UUFDWDtRQUNBLElBQUksQ0FBQzJwQixhQUFhLEdBQUcsQ0FBQ3I5QjtZQUNsQixJQUFJLENBQUNBLE1BQU15bUMsV0FBVyxFQUNsQnptQyxNQUFNeW1DLFdBQVcsR0FBRyxJQUFJdnBEO1lBQzVCLElBQUksQ0FBQ3FWLE1BQU0sQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEVBQUV5TixNQUFNN2MsSUFBSSxDQUFDLENBQUMsRUFBRTZjO1lBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNwTCxTQUFTLEVBQ2Y7WUFDSix5QkFBeUI7WUFDekIsS0FBSyxNQUFNOHhDLFlBQVksSUFBSSxDQUFDOXhDLFNBQVMsQ0FBQ3VxQixHQUFHLElBQUksRUFBRSxDQUFFO2dCQUM3Q3VuQixTQUFTMW1DO1lBQ2I7WUFDQSwrQkFBK0I7WUFDL0IsS0FBSyxNQUFNMG1DLFlBQVksSUFBSSxDQUFDOXhDLFNBQVMsQ0FBQ29MLE1BQU03YyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUU7Z0JBQ3JEdWpELFNBQVMxbUM7WUFDYjtRQUNKO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUNrdkIsT0FBTyxHQUFHO1lBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ3NMLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQ0UsS0FBSyxFQUFFO2dCQUM3QixNQUFNbmpELE1BQU07WUFDaEI7WUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDdWtELFNBQVMsRUFBRTtnQkFDakIsTUFBTXZrRCxNQUFNO1lBQ2hCO1lBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQzJtRCxRQUFRLEVBQUU7Z0JBQ2hCLE1BQU0zbUQsTUFBTTtZQUNoQjtZQUNBLElBQUksQ0FBQyxJQUFJLENBQUMrc0QsWUFBWSxJQUNqQixLQUFJLENBQUNsc0QsT0FBTyxDQUFDdXVELE1BQU0sSUFBSSxJQUFJLENBQUN2dUQsT0FBTyxDQUFDOG1ELGNBQWMsR0FBRztnQkFDdEQsSUFBSSxDQUFDMEgsTUFBTTtZQUNmO1lBQ0EsNkRBQTZEO1lBQzdELElBQUksSUFBSSxDQUFDeHVELE9BQU8sQ0FBQ2tzRCxZQUFZLElBQUksSUFBSSxDQUFDTSxJQUFJLEVBQUU7Z0JBQ3hDLG9IQUFvSDtnQkFDcEgsSUFBSSxDQUFDeHNELE9BQU8sQ0FBQ2tzRCxZQUFZLENBQUMzSSxTQUFTLENBQUMsSUFBSTtnQkFDeEMsSUFBSSxDQUFDMkksWUFBWSxHQUFHLElBQUksQ0FBQ2xzRCxPQUFPLENBQzNCa3NELFlBQVk7WUFDckIsT0FDSztnQkFDRCxJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJOUksbUJBQW1CLElBQUk7WUFDbkQ7WUFDQSxJQUFJO2dCQUNBLGtGQUFrRjtnQkFDbEYsSUFBSSxJQUFJLENBQUMrSSxVQUFVLEVBQUU7b0JBQ2pCLE9BQU8sTUFBTSxJQUFJLENBQUNBLFVBQVUsQ0FBQ3JWLE9BQU87Z0JBQ3hDO2dCQUNBLElBQUksQ0FBQzM4QixNQUFNLENBQUMsUUFBUTtnQkFDcEIsaUZBQWlGO2dCQUNqRixPQUFPLE1BQU0sSUFBSSxDQUFDK3hDLFlBQVksQ0FBQ3BWLE9BQU8sQ0FBQyxJQUFJLENBQUM5MkMsT0FBTyxDQUFDdW1ELGdCQUFnQixHQUM5RCxJQUFJLENBQUNrSSw0QkFBNEIsR0FDakMsSUFBSSxDQUFDQyxnQkFBZ0I7WUFDL0IsRUFDQSxPQUFPaHRDLEtBQUs7Z0JBQ1Isd0VBQXdFO2dCQUN4RSw4REFBOEQ7Z0JBQzlELElBQUksSUFBSSxDQUFDMWhCLE9BQU8sQ0FBQ3VtRCxnQkFBZ0IsSUFDN0IsYUFBYTtnQkFDYmYsWUFBWTlqQyxRQUNaZ2MsU0FBUyxJQUFJLENBQUN2akIsTUFBTSxHQUFHO29CQUN2QixJQUFJLENBQUNBLE1BQU0sQ0FBQyxRQUFRO29CQUNwQixJQUFJLENBQUM4cUMsYUFBYSxDQUFDO3dCQUFFbDZDLE1BQU07d0JBQXFCNGpELE1BQU07b0JBQVc7b0JBQ2pFLElBQUksQ0FBQ3pDLFlBQVksQ0FBQ2xGLDJCQUEyQjtvQkFDN0MsSUFBSSxDQUFDa0YsWUFBWSxDQUFDamlCLFVBQVUsR0FBRy9LLElBQUksSUFBSSx1QkFBdUI7b0JBQzlELElBQUksQ0FBQ2l0QixVQUFVLEdBQUcsSUFBSXBDLHFCQUFxQixJQUFJO29CQUMvQyxPQUFPLE1BQU0sSUFBSSxDQUFDb0MsVUFBVSxDQUFDclYsT0FBTztnQkFDeEM7Z0JBQ0EsTUFBTXAxQjtZQUNWO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDOHNDLE1BQU0sR0FBRztZQUNWLE1BQU1MLG9CQUFvQjV4QjtZQUMxQixNQUFNeEksT0FBTztnQkFDVDliLFNBQVNyZSwrQ0FBWUEsQ0FBQ2EsSUFBSSxDQUFDO29CQUN2Qix1QkFBdUIwekQ7Z0JBQzNCO1lBQ0o7WUFDQSxJQUFJLENBQUMzRCxjQUFjLENBQUMsT0FBTyxJQUFJLENBQUNDLE9BQU8sR0FBRyxPQUFPLE1BQU0xMkIsTUFBTXJGLEtBQUssQ0FBQyxDQUFDcG1CO2dCQUNoRSxJQUFJLElBQUksQ0FBQ3RJLE9BQU8sQ0FBQzhtRCxjQUFjLEVBQUU7b0JBQzdCM0YsYUFBYSxrQkFBa0I7d0JBQzNCVSxTQUFTLElBQUksQ0FBQzUvQyxHQUFHO3dCQUNqQnlmLEtBQUtwWjt3QkFDTDZsRDtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUMxSyxZQUFZLEdBQUc7WUFDaEIsTUFBTS8yQyxVQUFVO1lBQ2hCLE9BQVEsSUFBSSxDQUFDOFIsU0FBUyxJQUNsQixDQUFDLCtCQUErQixFQUFFLElBQUksQ0FBQ2d1QyxJQUFJLEdBQUcsU0FBUyxVQUFVLENBQUMsRUFBRTkvQyxRQUFRLENBQUM7UUFDckY7UUFDQSxJQUFJLENBQUNraUQsWUFBWSxHQUFHLENBQUNwd0M7WUFDakIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO1FBQ3JCO1FBQ0E7O1NBRUMsR0FDRCxJQUFJLENBQUMrdEMsa0JBQWtCLEdBQUcsSUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDeEQsTUFBTTtRQUM3QyxJQUFJLENBQUNnRixtQkFBbUIsR0FBRyxDQUFDL3RELFVBQVU7WUFDbENpMkIsUUFBUSxDQUFDO1lBQ1RoZSxTQUFTLENBQUM7WUFDVndYLFFBQVEsQ0FBQztRQUNiLENBQUM7WUFDRyxNQUFNcGMsUUFBUXJULFFBQVEwcUQsY0FBYyxJQUFJLENBQUMsSUFBSSxDQUFDNWdDLElBQUksR0FBRzlvQixZQUFZLElBQUksQ0FBQ2tqRCxTQUFTO1lBQy9FLE1BQU0ySyxnQkFBZ0J4N0MsUUFBUTtnQkFBRTRzQixlQUFlNXNCO1lBQU0sSUFBSXJTO1lBQ3pELElBQUltK0IsU0FBUztZQUNiLElBQUksSUFBSSxDQUFDdXNCLDBCQUEwQixLQUFLLE1BQU07Z0JBQzFDdnNCLFNBQVMsSUFBSSxDQUFDdXNCLDBCQUEwQixDQUFDdnNCLE1BQU07Z0JBQy9DLElBQUksQ0FBQ3VzQiwwQkFBMEIsR0FBRztZQUN0QztZQUNBLElBQUksQ0FBQzFyRCxRQUFRaVksT0FBTyxFQUFFLENBQUMsc0JBQXNCLEVBQUU7Z0JBQzNDalksUUFBUWlZLE9BQU8sR0FBRztvQkFDZCxHQUFHalksUUFBUWlZLE9BQU87b0JBQ2xCLHVCQUF1QnNrQjtnQkFDM0I7WUFDSjtZQUNBLE9BQU87Z0JBQ0h0RyxRQUFRO29CQUNKOU0sU0FBUyxJQUFJLENBQUNpNUIsTUFBTTtvQkFDcEJ3RSxlQUFlLElBQUksQ0FBQ3FGLGdCQUFnQjtvQkFDcENwSyxTQUFTLElBQUksQ0FBQzUvQyxHQUFHO29CQUNqQixHQUFHakMsUUFBUWkyQixNQUFNO2dCQUNyQjtnQkFDQWhlLFNBQVM7b0JBQ0wsR0FBRzQyQyxhQUFhO29CQUNoQixvQkFBb0I3dUQsUUFBUTBxRCxjQUFjLElBQUksQ0FBQyxJQUFJLENBQUM1Z0MsSUFBSSxHQUNsRCxjQUNBLElBQUksQ0FBQ280QixXQUFXO29CQUN0QixtQkFBbUIsSUFBSSxDQUFDdUIsWUFBWTtvQkFDcEMsR0FBR3pqRCxRQUFRaVksT0FBTztnQkFDdEI7Z0JBQ0EsR0FBSWtuQixTQUFTO29CQUFFQTtnQkFBTyxJQUFJLENBQUMsQ0FBQztnQkFDNUIsR0FBR24vQixRQUFReXZCLE1BQU07Z0JBQ2pCLEdBQUcsSUFBSSxDQUFDenZCLE9BQU8sQ0FBQzh1RCxrQkFBa0I7WUFDdEM7UUFDSjtRQUNBLElBQUksQ0FBQzVLLFNBQVMsR0FBRztZQUNiLElBQUksQ0FBQyxJQUFJLENBQUMvQixZQUFZLEVBQ2xCLE9BQU87WUFDWCxPQUFPLElBQUksQ0FBQ0EsWUFBWSxDQUFDcUgsUUFBUTtRQUNyQztRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUN3QixlQUFlLEdBQUcsQ0FBQ21EO1lBQ3BCLE9BQU94d0MsS0FBS0MsU0FBUyxDQUFDO2dCQUNsQnVMLFNBQVMsSUFBSSxDQUFDaTVCLE1BQU07Z0JBQ3BCQyxjQUFjLElBQUksQ0FBQ0MsS0FBSztnQkFDeEI2TDtZQUNKO1FBQ0o7UUFDQTs7U0FFQyxHQUNELElBQUksQ0FBQ1ksbUNBQW1DLEdBQUc7WUFDdkMsT0FBUSxJQUFJLENBQUNyRCwwQkFBMEIsR0FBRyxJQUFJTDtRQUNsRDtRQUNBOzs7Ozs7Ozs7U0FTQyxHQUNELElBQUksQ0FBQzJELFdBQVcsR0FBRyxDQUFDNU0sUUFBUTZNLEtBQUt6RyxLQUFLMEc7WUFDbEMsSUFBSSxJQUFJLENBQUNuRyxNQUFNLElBQUksTUFBTTtnQkFDckIsTUFBTTVwRCxNQUFNLENBQUMsMkRBQTJELENBQUM7WUFDN0U7WUFDQSxNQUFNbWtELFFBQVEsQ0FBQztZQUNmLElBQUkyTCxLQUFLO2dCQUNMM0wsTUFBTTJMLEdBQUcsR0FBR0E7WUFDaEI7WUFDQSxJQUFJekcsS0FBSztnQkFDTGxGLE1BQU1rRixHQUFHLEdBQUdBO1lBQ2hCO1lBQ0EsSUFBSTBHLFdBQVc7Z0JBQ1g1TCxNQUFNNEwsU0FBUyxHQUFHQTtZQUN0QjtZQUNBLE9BQU9sSCxhQUFhLElBQUksQ0FBQ2UsTUFBTSxFQUFFM0csUUFBUWtCLE9BQU8sQ0FBQztRQUNyRDtRQUNBLGNBQWM7UUFDZCxJQUFJLENBQUNyaEQsR0FBRyxHQUFHQTtRQUNYLGlCQUFpQjtRQUNqQixJQUFJLENBQUM4bUQsTUFBTSxHQUFHL29ELFNBQVMrb0Q7UUFDdkIsZ0RBQWdEO1FBQ2hELE1BQU1vRyxlQUFlbnZELFVBQ2ZBLFVBQ0E7WUFDRWtNLFNBQVMsZ0JBQWtCO1FBQy9CO1FBQ0osSUFBSSxDQUFDQSxPQUFPLEdBQUdpakQsYUFBYWpqRCxPQUFPLElBQUksZ0JBQWtCO1FBQ3pELElBQUksQ0FBQ3NnRCxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUN0Z0QsT0FBTztRQUN6QixJQUFJLElBQUksQ0FBQ0EsT0FBTyxFQUFFO1lBQ2QsSUFBSSxDQUFDNC9DLFlBQVksR0FBR2puQixnQkFBZ0I3a0MsU0FBUytyRCxpQkFBaUIvckQsU0FBU2dzRDtRQUMzRTtRQUNBLElBQUksQ0FBQ2hzRCxPQUFPLEdBQUc7WUFDWDZYLFNBQVM7WUFDVHUzQyxpQkFBaUI7WUFDakJiLFFBQVE7WUFDUixHQUFHWSxZQUFZO1FBQ25CO1FBQ0EsSUFBSSxJQUFJLENBQUMzQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUN4c0QsT0FBTyxDQUFDcXZELFVBQVUsRUFBRTtZQUN2QyxJQUFJLENBQUNydkQsT0FBTyxDQUFDcXZELFVBQVUsR0FBRyxJQUFJaDBELG9EQUFXLENBQUM7Z0JBQ3RDa2tDLFdBQVc7Z0JBQ1hnd0IsZ0JBQWdCO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJLENBQUMzRCxVQUFVLENBQUMsSUFBSSxDQUFDNXJELE9BQU8sQ0FBQ3lxRCxPQUFPLElBQUk7UUFDeEMsSUFBSSxPQUFPK0UsWUFBWSxlQUFlQSxRQUFRQyxHQUFHLENBQUNDLHFCQUFxQixFQUFFO1lBQ3JFLElBQUksQ0FBQzlELFVBQVUsQ0FBQztRQUNwQjtRQUNBLElBQUksT0FBTzRELFlBQVksZUFBZUEsUUFBUUMsR0FBRyxDQUFDRSxzQkFBc0IsRUFBRTtZQUN0RSxJQUFJLENBQUMvRCxVQUFVLENBQUMsQ0FBQyxPQUFPLEVBQUU0RCxRQUFRQyxHQUFHLENBQUNFLHNCQUFzQixDQUFDLE1BQU0sQ0FBQztRQUN4RTtRQUNBLElBQUksQ0FBQzNCLGFBQWEsR0FBR3IwRCw4Q0FBS0EsQ0FBQ2lILE1BQU0sQ0FBQztZQUM5QixHQUFHLElBQUksQ0FBQ1osT0FBTztZQUNmeXFELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQ3pCO1FBQ0Esc0RBQXNEO1FBQ3RELElBQUksQ0FBQ3lCLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNXLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNQLGNBQWMsR0FBRztRQUN0Qiw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDN2tELFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNzbEQsOEJBQThCLEdBQy9CLElBQUksQ0FBQy9zRCxPQUFPLEVBQUUrc0Q7UUFDbEIsNEZBQTRGO1FBQzVGLHlCQUF5QjtRQUN6QixJQUFJLENBQUM1SyxZQUFZLEdBQUcsSUFBSTJHLGFBQWEsSUFBSSxDQUFDQyxNQUFNO1FBQ2hELElBQUksQ0FBQ2xFLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQzlDLGNBQWMsR0FBRyxJQUFJakI7UUFDMUIsSUFBSSxDQUFDMk4sNEJBQTRCLEdBQUc7UUFDcEMsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUN2MEMsTUFBTSxHQUFHMGhCLFdBQVdzekIsYUFBYWgxQyxNQUFNLElBQ3RDZzFDLGFBQWFoMUMsTUFBTSxHQUNuQixJQUFNO0lBQ2hCO0FBQ0o7QUFFQTs7Q0FFQyxHQUNELE1BQU15MUM7SUFDRnR3RCxZQUFZdXdELFlBQVksRUFBRTk3QixJQUFJLENBQUU7UUFDNUIsSUFBSSxDQUFDN2EsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQzQyQyx5QkFBeUIsR0FBRyxFQUFFO1FBQ25DOzs7Ozs7O1NBT0MsR0FDRCxJQUFJLENBQUM3QyxjQUFjLEdBQUcsT0FBT3AxQztZQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDMmhDLFlBQVksQ0FBQzF2QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUNpbUMsaUJBQWlCLEVBQUU7Z0JBQ3BEO1lBQ0o7WUFDQSxNQUFNOUMsaUJBQWlCLElBQU0sSUFBSSxDQUFDelQsWUFBWSxDQUFDeVQsY0FBYyxDQUFDcDFDO1lBQzlELElBQUksQ0FBQ200QyxvQkFBb0IsR0FBRyxJQUFJLENBQUNELGlCQUFpQixHQUM1QyxJQUFJLENBQUNBLGlCQUFpQixDQUFDN3dCLElBQUksQ0FBQyxJQUFNK3RCLG9CQUNsQ0E7WUFDTixJQUFJLENBQUMrQyxvQkFBb0IsQ0FBQ3hDLE9BQU8sQ0FBQyxJQUFPLElBQUksQ0FBQ3dDLG9CQUFvQixHQUFHaHZEO1lBQ3JFLE1BQU0sSUFBSSxDQUFDZ3ZELG9CQUFvQjtZQUMvQixJQUFJLENBQUNGLHlCQUF5QixDQUFDbjFDLE9BQU8sQ0FBQyxDQUFDczBCLGFBQWVBO1lBQ3ZELElBQUksQ0FBQzZnQix5QkFBeUIsR0FBRyxFQUFFO1lBQ25DLElBQUksQ0FBQ0csbUJBQW1CLENBQUNoaUMsZ0JBQWdCLENBQUNqdEI7UUFDOUM7UUFDQTs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQzBiLEVBQUUsR0FBRyxDQUFDWCxXQUFXcXJDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDNU4sWUFBWSxDQUFDOThCLEVBQUUsQ0FBQ1gsV0FBV3FyQztRQUMzQztRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDeHFDLEdBQUcsR0FBRyxDQUFDYixXQUFXcXJDO1lBQ25CLE9BQU8sSUFBSSxDQUFDNU4sWUFBWSxDQUFDNThCLEdBQUcsQ0FBQ2IsV0FBV3FyQztRQUM1QztRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDbHJDLElBQUksR0FBRyxDQUFDblIsTUFBTUM7WUFDZixPQUFPLElBQUlzQyxLQUFLO2dCQUNaa3NDLGNBQWMsSUFBSSxDQUFDQSxZQUFZO2dCQUMvQnh1QyxJQUFJQTtnQkFDSkQsTUFBTUE7Z0JBQ04wdUMsYUFBYSxJQUFJLENBQUN3VyxtQkFBbUI7WUFDekM7UUFDSjtRQUNBOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLGVBQWUsR0FBRyxPQUFPNTBCO1lBQzFCLE9BQU8sSUFBSSxDQUFDa2UsWUFBWSxDQUFDZ1IsY0FBYyxDQUFDLFFBQVEsVUFBVWx2QixNQUFNO2dCQUFFb3ZCLGdCQUFnQjtZQUFLO1FBQzNGO1FBQ0E7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ3lGLFVBQVUsR0FBRyxPQUFPNzBCLE9BQU8sQ0FBQyxDQUFDO1lBQzlCLE1BQU0zRCxXQUFXLE1BQU0sSUFBSSxDQUFDNmhCLFlBQVksQ0FBQ3pVLElBQUksQ0FBQyxVQUFVeko7WUFDeEQsTUFBTW5OLFFBQVF3SixTQUFTeEosS0FBSyxDQUFDajBCLEdBQUcsQ0FBQyxDQUFDMGdCO2dCQUM5QixNQUFNc0IsT0FBTyxJQUFJNU8sS0FBSztvQkFDbEJrc0MsY0FBYyxJQUFJLENBQUNBLFlBQVk7b0JBQy9CeHVDLElBQUk0UCxFQUFFc0IsSUFBSSxDQUFDbFIsRUFBRTtvQkFDYkQsTUFBTTZQLEVBQUVzQixJQUFJLENBQUNuUixJQUFJO29CQUNqQmdjLFNBQVNuTSxFQUFFbU0sT0FBTztvQkFDbEJ5RyxpQkFBaUI1UyxFQUFFa1EsZ0JBQWdCO29CQUNuQzR1QixVQUFVcGUsS0FBSzgwQixLQUFLO29CQUNwQjNXLGFBQWEsSUFBSSxDQUFDd1csbUJBQW1CO2dCQUN6QztnQkFDQS96QyxLQUFLeUssS0FBSyxDQUFDdUIsc0JBQXNCLENBQUN0TixFQUFFc0IsSUFBSTtnQkFDeENBLEtBQUs2K0IsaUJBQWlCO2dCQUN0QixJQUFJemYsS0FBSzgwQixLQUFLLEVBQUU7b0JBQ1osSUFBSSxDQUFDSCxtQkFBbUIsQ0FBQzdoQyxZQUFZLENBQUNsUztnQkFDMUM7Z0JBQ0EsT0FBT0E7WUFDWDtZQUNBLE9BQU87Z0JBQ0gsR0FBR3liLFFBQVE7Z0JBQ1h4SixPQUFPQTtZQUNYO1FBQ0o7UUFDQTs7U0FFQyxHQUNELElBQUksQ0FBQ2tpQyxLQUFLLEdBQUc7WUFDVCxPQUFPLElBQUksQ0FBQzdXLFlBQVksQ0FBQ3BoQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDekM7UUFDQTs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQ2s0QixTQUFTLEdBQUcsT0FBT3RsRCxJQUFJdWxELGVBQWVDLG9CQUFvQnBPLFFBQVFxTztZQUNuRSxPQUFPLE1BQU0sSUFBSSxDQUFDalgsWUFBWSxDQUFDelUsSUFBSSxDQUFDLFlBQVk7Z0JBQzVDLzVCO2dCQUNBdWxEO2dCQUNBRTtnQkFDQSxHQUFJck8sVUFBVSxPQUFPO29CQUFFajVCLFNBQVNpNUI7Z0JBQU8sSUFBSSxDQUFDLENBQUM7Z0JBQzdDLEdBQUlvTyxzQkFBc0IsT0FBTztvQkFBRUE7Z0JBQW1CLElBQUksQ0FBQyxDQUFDO1lBQ2hFO1FBQ0o7UUFDQTs7O1NBR0MsR0FDRCxJQUFJLENBQUNyaEIsVUFBVSxHQUFHLE9BQU9pVDtZQUNyQixPQUFPLE1BQU0sSUFBSSxDQUFDNUksWUFBWSxDQUFDcGhCLEdBQUcsQ0FBQyxZQUFZZ3FCLFNBQVM7Z0JBQUVqNUIsU0FBU2k1QjtZQUFPLElBQUksQ0FBQztRQUNuRjtRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDc08sWUFBWSxHQUFHLE9BQU8xbEQsSUFBSW8zQztZQUMzQixPQUFPLE1BQU0sSUFBSSxDQUFDNUksWUFBWSxDQUFDdGYsTUFBTSxDQUFDLFlBQVk7Z0JBQzlDbHZCO2dCQUNBLEdBQUlvM0MsU0FBUztvQkFBRWo1QixTQUFTaTVCO2dCQUFPLElBQUksQ0FBQyxDQUFDO1lBQ3pDO1FBQ0o7UUFDQTs7OztTQUlDLEdBQ0QsSUFBSSxDQUFDdU8sYUFBYSxHQUFHLE9BQU96VztZQUN4QixpRkFBaUY7WUFDakYsbUhBQW1IO1lBQ25ILElBQUloK0IsT0FBTyxJQUFJLENBQUMwMEMsa0JBQWtCLENBQUN6aUMsS0FBSyxDQUFDNXFCLElBQUksQ0FBQyxDQUFDcVgsSUFBTUEsRUFBRXlULEdBQUcsS0FBSzZyQixZQUFZdC9CLEVBQUVxcEIsT0FBTztZQUNwRixJQUFJLENBQUMvbkIsTUFBTTtnQkFDUCwyR0FBMkc7Z0JBQzNHLE1BQU0sQ0FBQzh5QixVQUFVNmhCLE9BQU8sR0FBRzNXLFNBQVMzOEIsS0FBSyxDQUFDO2dCQUMxQ3JCLE9BQU8sSUFBSTVPLEtBQUs7b0JBQ1prc0MsY0FBYyxJQUFJLENBQUNBLFlBQVk7b0JBQy9CenVDLE1BQU1pa0M7b0JBQ05oa0MsSUFBSTZsRDtvQkFDSnBYLGFBQWEsSUFBSSxDQUFDd1csbUJBQW1CO29CQUNyQ2hzQixTQUFTO2dCQUNiO2dCQUNBLE1BQU0vbkIsS0FBS2tjLEdBQUc7WUFDbEI7WUFDQSxPQUFPbGM7UUFDWDtRQUNBOzs7OztTQUtDLEdBQ0QsSUFBSSxDQUFDd3hDLG9CQUFvQixHQUFHLE9BQU81akMsTUFBTW0vQjtZQUNyQyxNQUFNeUUsdUJBQXVCLElBQU0sSUFBSSxDQUFDbFUsWUFBWSxDQUFDa1Usb0JBQW9CLENBQUM1akMsTUFBTW0vQjtZQUNoRixJQUFJLENBQUM4RyxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLG9CQUFvQixHQUM1QyxJQUFJLENBQUNBLG9CQUFvQixDQUFDOXdCLElBQUksQ0FBQyxJQUFNd3VCLDBCQUNyQ0E7WUFDTixJQUFJLENBQUNxQyxpQkFBaUIsQ0FBQ3ZDLE9BQU8sQ0FBQyxJQUFPLElBQUksQ0FBQ3VDLGlCQUFpQixHQUFHL3VEO1lBQy9ELE9BQU8sSUFBSSxDQUFDK3VELGlCQUFpQjtRQUNqQztRQUNBLElBQUk1MUMsU0FBU2xCO1FBQ2IsSUFBSUMsV0FBVztRQUNmLElBQUksT0FBTzIyQyxpQkFBaUIsVUFBVTtZQUNsQzMyQyxXQUFXNmEsTUFBTTdhLFlBQVlBO1lBQzdCaUIsU0FBUzRaLE1BQU01WixVQUFVQTtRQUM3QixPQUNLO1lBQ0RqQixXQUFXMjJDLGFBQWE3dkQsT0FBTyxFQUFFa1osWUFBWUE7WUFDN0NpQixTQUFTMDFDLGFBQWE3dkQsT0FBTyxFQUFFbWEsVUFBVUE7UUFDN0M7UUFDQVosVUFBVVksUUFBUWpCO1FBQ2xCLElBQUksQ0FBQ2lCLE1BQU0sR0FBR1IsVUFBVTtZQUFDO1NBQVM7UUFDbEMsSUFBSSxPQUFPazJDLGlCQUFpQixVQUFVO1lBQ2xDLElBQUksQ0FBQ3JXLFlBQVksR0FBRyxJQUFJaVMsYUFBYW9FLGNBQWM7Z0JBQy9DOUMsZ0NBQWdDO2dCQUNoQyxHQUFHaDVCLElBQUk7Z0JBQ1A3YTtnQkFDQWlCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1FBQ0osT0FDSztZQUNELElBQUksQ0FBQ3EvQixZQUFZLEdBQUcsSUFBSWlTLGFBQWFvRSxhQUFhaUIsTUFBTSxFQUFFO2dCQUN0RC9ELGdDQUFnQztnQkFDaEMsR0FBRzhDLGFBQWE3dkQsT0FBTztnQkFDdkJrWjtnQkFDQWlCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1lBQ0EsTUFBTTJELFVBQVVJO1lBQ2hCLElBQUlKLFNBQVM7Z0JBQ1QsSUFBSSxDQUFDMDdCLFlBQVksQ0FBQ29WLFlBQVksQ0FBQyxJQUFJLENBQUNwVixZQUFZLENBQUNpSyxZQUFZLEtBQ3pELENBQUMsT0FBTyxFQUFFOThDLE9BQU8sQ0FBQ21YLFFBQVEvUyxJQUFJLENBQUMsQ0FBQzJOLFdBQVcsR0FBRyxLQUFLLEVBQUVvRixRQUFReFIsS0FBSyxDQUFDLENBQUMsRUFBRXdSLFFBQVF2UixLQUFLLENBQUMsQ0FBQyxFQUFFdVIsUUFBUXRSLEtBQUssQ0FBQyxDQUFDO1lBQzlHO1FBQ0o7UUFDQSxJQUFJLENBQUN5akQsbUJBQW1CLEdBQUcsSUFBSW5pQztRQUMvQixJQUFJLENBQUM4aUMsa0JBQWtCLEdBQUcsSUFBSWhpQyw4QkFBOEIsSUFBSSxDQUFDcWhDLG1CQUFtQjtRQUNwRixJQUFJLE9BQU9KLGlCQUFpQixVQUFVO1lBQ2xDLE1BQU0vbEMsT0FBTytsQyxhQUFhL2xDLElBQUk7WUFDOUIsTUFBTXpXLFFBQVF3OEMsYUFBYXg4QyxLQUFLLElBQUl3OEMsYUFBYXpHLGFBQWE7WUFDOUQsSUFBSXQvQixNQUFNO2dCQUNOLElBQUksQ0FBQ3NpQyxXQUFXLENBQUN0aUMsTUFBTXpXO1lBQzNCO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0QsSUFBSXNULFFBQVE7UUFDUixPQUFPLElBQUksQ0FBQ2lxQyxrQkFBa0I7SUFDbEM7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTXhFLFlBQVl0aUMsSUFBSSxFQUFFelcsS0FBSyxFQUFFO1FBQzNCLElBQUl5VyxLQUFLL2UsSUFBSSxLQUFLLGFBQWE7WUFDM0IrZSxLQUFLOWUsRUFBRSxHQUFHO1lBQ1YsT0FBTyxJQUFJLENBQUMwaUQsb0JBQW9CLENBQUM1akMsTUFBTXpXO1FBQzNDO1FBQ0EsSUFBSSs0QyxjQUFjO1lBQ2QsT0FBTyxJQUFJLENBQUM1UyxZQUFZLENBQUM0UyxXQUFXLENBQUN0aUMsTUFBTXpXO1FBQy9DO1FBQ0EsSUFBSXlXLEtBQUsvZSxJQUFJLEtBQUssU0FBUztZQUN2QnFoRCxjQUFjO2dCQUNWLE9BQU8sSUFBSSxDQUFDNVMsWUFBWSxDQUFDOFQsZ0JBQWdCLENBQUN4akM7WUFDOUM7UUFDSjtRQUNBLElBQUksQ0FBQ2ltQyxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLG9CQUFvQixHQUM1QyxJQUFJLENBQUNBLG9CQUFvQixDQUFDOXdCLElBQUksQ0FBQyxJQUFNa3RCLGlCQUNyQ0E7UUFDTixJQUFJLENBQUMyRCxpQkFBaUIsRUFBRXZDLFFBQVEsSUFBTyxJQUFJLENBQUN1QyxpQkFBaUIsR0FBRy91RDtRQUNoRSxNQUFNK3ZELHNCQUFzQixNQUFNLElBQUksQ0FBQ2hCLGlCQUFpQjtRQUN4RCxpRkFBaUY7UUFDakYsSUFBSWdCLHFCQUFxQkMsSUFBSTtZQUN6QixJQUFJLENBQUNmLG1CQUFtQixDQUFDaGlDLGdCQUFnQixDQUFDOGlDLG9CQUFvQkMsRUFBRTtRQUNwRTtRQUNBLElBQUksQ0FBQ2xCLHlCQUF5QixDQUFDdHJELElBQUksQ0FBQyxJQUFJLENBQUNrWSxFQUFFLENBQUMsc0JBQXNCLENBQUNrTDtZQUMvRCxJQUFJQSxNQUFNbTBCLE1BQU0sRUFBRTtnQkFDZCxNQUFNa1YsaUJBQWlCLElBQUksQ0FBQ2hCLG1CQUFtQixDQUFDOWhDLEtBQUssQ0FDaERwekIsTUFBTSxDQUFDLENBQUNtaEIsT0FBU0EsS0FBS3c5QixRQUFRLEVBQzlCeC9DLEdBQUcsQ0FBQyxDQUFDZ2lCLE9BQVNBLEtBQUttUyxHQUFHO2dCQUMzQixJQUFJLENBQUNsVSxNQUFNLENBQUMsUUFBUSxDQUFDLDBDQUEwQyxFQUFFODJDLGVBQWV4dUQsSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDNUYsSUFBSXd1RCxlQUFlOXZELE1BQU0sR0FBRyxHQUFHO29CQUMzQixJQUFJLENBQUNndkQsVUFBVSxDQUFDO3dCQUNaQyxPQUFPO3dCQUNQYyxtQkFBbUI7NEJBQ2Y3aUMsS0FBSztnQ0FBRThpQyxLQUFLRjs0QkFBZTt3QkFDL0I7d0JBQ0EvbEMsTUFBTTs0QkFBQztnQ0FBRWttQyxPQUFPO2dDQUFPajJDLFdBQVc7NEJBQUU7eUJBQUU7b0JBQzFDLEdBQUd1VCxLQUFLLENBQUMsQ0FBQ2hOO3dCQUNOLElBQUksQ0FBQ3ZILE1BQU0sQ0FBQyxTQUFTLDRCQUE0QnVIO29CQUNyRDtnQkFDSjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNvdUMseUJBQXlCLENBQUN0ckQsSUFBSSxDQUFDLElBQUksQ0FBQ2tZLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQ2tMO1lBQ3pELE1BQU0sRUFBRTFMLElBQUksRUFBRTZLLE9BQU8sRUFBRSxHQUFHYTtZQUMxQixJQUFJa0MsS0FBSzllLEVBQUUsS0FBS2tSLEtBQUt1TSxVQUFVLENBQUN6ZCxFQUFFLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQ21QLE1BQU0sQ0FBQyxRQUFRO2dCQUNwQjtZQUNKO1lBQ0EsSUFBSSxDQUFDQSxNQUFNLENBQUMsUUFBUSxDQUFDLGlDQUFpQyxFQUFFK0IsS0FBS21TLEdBQUcsQ0FBQyxDQUFDO1lBQ2xFLE1BQU1nakMsVUFBVSxJQUFJL2pELEtBQUs7Z0JBQ3JCa3NDLGNBQWMsSUFBSSxDQUFDQSxZQUFZO2dCQUMvQnp1QyxNQUFNbVIsS0FBS25SLElBQUk7Z0JBQ2ZDLElBQUlrUixLQUFLbFIsRUFBRTtnQkFDWCtiO2dCQUNBMHlCLGFBQWEsSUFBSSxDQUFDd1csbUJBQW1CO1lBQ3pDO1lBQ0FvQixRQUFRMXFDLEtBQUssQ0FBQ3VCLHNCQUFzQixDQUFDaE07WUFDckMsSUFBSSxDQUFDK3pDLG1CQUFtQixDQUFDN2hDLFlBQVksQ0FBQ2lqQztRQUMxQztRQUNBLElBQUksQ0FBQ3ZCLHlCQUF5QixDQUFDdHJELElBQUksQ0FBQyxJQUFJLENBQUNrWSxFQUFFLENBQUMsYUFBYSxPQUFPa0w7WUFDNUQsTUFBTSxFQUFFMUwsSUFBSSxFQUFFNkssT0FBTyxFQUFFLEdBQUdhO1lBQzFCLElBQUlrQyxLQUFLOWUsRUFBRSxLQUFLa1IsS0FBS3VNLFVBQVUsQ0FBQ3pkLEVBQUUsRUFBRTtnQkFDaEMsSUFBSSxDQUFDbVAsTUFBTSxDQUFDLFNBQVM7Z0JBQ3JCO1lBQ0o7WUFDQSxtREFBbUQ7WUFDbkQscURBQXFEO1lBQ3JELHFEQUFxRDtZQUNyRCxNQUFNbTNDLFdBQVcsSUFBSSxDQUFDckIsbUJBQW1CLENBQUMxaEMsUUFBUSxDQUFDclMsS0FBS25SLElBQUksRUFBRW1SLEtBQUtsUixFQUFFO1lBQ3JFLE1BQU1zbUQsVUFBVTdpQztZQUNoQix1QkFBdUI7WUFDdkIsTUFBTThpQyxVQUFVLElBQUlqa0QsS0FBSztnQkFDckJrc0MsY0FBYyxJQUFJLENBQUNBLFlBQVk7Z0JBQy9CenVDLE1BQU1tUixLQUFLblIsSUFBSTtnQkFDZkMsSUFBSWtSLEtBQUtsUixFQUFFO2dCQUNYK2I7Z0JBQ0EweUIsYUFBYSxJQUFJLENBQUN3VyxtQkFBbUI7Z0JBQ3JDaHNCLFNBQVM7WUFDYjtZQUNBc3RCLFFBQVE1cUMsS0FBSyxDQUFDdUIsc0JBQXNCLENBQUNoTTtZQUNyQyw0REFBNEQ7WUFDNUQsTUFBTXExQyxRQUFRbjVCLEdBQUc7WUFDakIsSUFBSSxDQUFDNjNCLG1CQUFtQixDQUFDN2hDLFlBQVksQ0FBQ21qQztRQUMxQztRQUNBLE9BQU9SO0lBQ1g7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsTUFBTVMsY0FBY3htRCxFQUFFLEVBQUV1bEQsYUFBYSxFQUFFQyxrQkFBa0IsRUFBRXBPLE1BQU0sRUFBRTtRQUMvRCxPQUFPLE1BQU0sSUFBSSxDQUFDa08sU0FBUyxDQUFDdGxELElBQUl1bEQsZUFBZUMsb0JBQW9CcE8sUUFBUTtJQUMvRTtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1xUCxnQ0FBZ0M3QjtJQUNsQ3R3RCxZQUFZd3hELE1BQU0sRUFBRTl3RCxPQUFPLENBQUU7UUFDekIsS0FBSyxDQUFDO1lBQUU4d0Q7WUFBUTl3RDtRQUFRO1FBQ3hCLElBQUksQ0FBQzB4RCxZQUFZLEdBQUc7WUFDaEIsT0FBTyxJQUFJLENBQUNsWSxZQUFZLENBQUNwaEIsR0FBRyxDQUFDO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDdTVCLFdBQVcsR0FBRyxDQUFDbnlEO1lBQ2hCLE9BQU8sSUFBSSxDQUFDZzZDLFlBQVksQ0FBQ3BoQixHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUU1NEIsS0FBSyxDQUFDO1FBQ3JEO1FBQ0EsSUFBSSxDQUFDb3lELGNBQWMsR0FBRyxDQUFDdDJCO1lBQ25CLE9BQU8sSUFBSSxDQUFDa2UsWUFBWSxDQUFDelUsSUFBSSxDQUFDLGNBQWN6SjtRQUNoRDtRQUNBLElBQUksQ0FBQ3UyQixjQUFjLEdBQUcsQ0FBQ3J5RDtZQUNuQixPQUFPLElBQUksQ0FBQ2c2QyxZQUFZLENBQUN0ZixNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUxNkIsS0FBSyxDQUFDO1FBQ3hEO1FBQ0EsSUFBSSxDQUFDc3lELGNBQWMsR0FBRyxDQUFDdHlELE1BQU04N0I7WUFDekIsT0FBTyxJQUFJLENBQUNrZSxZQUFZLENBQUN5VSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUV6dUQsS0FBSyxDQUFDLEVBQUU4N0I7UUFDdkQ7UUFDQSxJQUFJLENBQUN5MkIsbUJBQW1CLEdBQUc7WUFDdkIsT0FBTyxJQUFJLENBQUN2WSxZQUFZLENBQUNwaEIsR0FBRyxDQUFDO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDNDVCLHFCQUFxQixHQUFHLENBQUNsdEI7WUFDMUIsT0FBTyxJQUFJLENBQUMwVSxZQUFZLENBQUN6VSxJQUFJLENBQUMscUJBQXFCRDtRQUN2RDtRQUNBLElBQUksQ0FBQ210QixxQkFBcUIsR0FBRyxDQUFDenlEO1lBQzFCLE9BQU8sSUFBSSxDQUFDZzZDLFlBQVksQ0FBQ3RmLE1BQU0sQ0FBQyxDQUFDLGtCQUFrQixFQUFFMTZCLEtBQUssQ0FBQztRQUMvRDtRQUNBLElBQUksQ0FBQzB5RCxxQkFBcUIsR0FBRyxDQUFDMXlELE1BQU1zbEM7WUFDaEMsT0FBTyxJQUFJLENBQUMwVSxZQUFZLENBQUN5VSxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRXp1RCxLQUFLLENBQUMsRUFBRXNsQztRQUM5RDtRQUNBLElBQUksQ0FBQ3F0QixvQkFBb0IsR0FBRyxDQUFDM3lEO1lBQ3pCLE9BQU8sSUFBSSxDQUFDZzZDLFlBQVksQ0FBQ3BoQixHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRTU0QixLQUFLLE1BQU0sQ0FBQztRQUNsRTtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNEd3ZELFlBQVk1TSxNQUFNLEVBQUU2TSxHQUFHLEVBQUV6RyxHQUFHLEVBQUUwRyxTQUFTLEVBQUU7UUFDckMsT0FBTyxJQUFJLENBQUMxVixZQUFZLENBQUN3VixXQUFXLENBQUM1TSxRQUFRNk0sS0FBS3pHLEtBQUswRztJQUMzRDtBQUNKO0FBRStoRCxDQUMvaEQsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWFnbGVzLXJpbmcvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1jbGllbnQvZGlzdC9pbmRleC5lcy5qcz9jOTY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnd2VicnRjLWFkYXB0ZXInO1xuaW1wb3J0IHsgTWVzc2FnZVR5cGUsIGlzSnNvbk9iamVjdCwgdHlwZW9mSnNvblZhbHVlLCByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsLCBVbmtub3duRmllbGRIYW5kbGVyLCBXaXJlVHlwZSwgUGJMb25nIH0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUnO1xuaW1wb3J0IHsgU2VydmljZVR5cGUsIHN0YWNrSW50ZXJjZXB0IH0gZnJvbSAnQHByb3RvYnVmLXRzL3J1bnRpbWUtcnBjJztcbmltcG9ydCBheGlvcywgeyBBeGlvc0hlYWRlcnMgfSBmcm9tICdheGlvcyc7XG5leHBvcnQgeyBBeGlvc0Vycm9yIH0gZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgVHdpcnBGZXRjaFRyYW5zcG9ydCB9IGZyb20gJ0Bwcm90b2J1Zi10cy90d2lycC10cmFuc3BvcnQnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCwgY29tYmluZUxhdGVzdCwgQmVoYXZpb3JTdWJqZWN0LCBtYXAgYXMgbWFwJDEsIHNoYXJlUmVwbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgdGFrZVdoaWxlLCBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCwgbWVyZ2UsIGZyb20sIE9ic2VydmFibGUsIGRlYm91bmNlVGltZSwgY29uY2F0TWFwLCBwYWlyd2lzZSwgb2YsIGZpbHRlciwgZGVib3VuY2UsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgKiBhcyBTRFAgZnJvbSAnc2RwLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBVQVBhcnNlciB9IGZyb20gJ3VhLXBhcnNlci1qcyc7XG5pbXBvcnQgV2ViU29ja2V0IGZyb20gJ2lzb21vcnBoaWMtd3MnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCBqd3QgZnJvbSAnanNvbndlYnRva2VuJztcbmltcG9ydCAnY3J5cHRvJztcbmltcG9ydCB7IGZyb21CeXRlQXJyYXkgfSBmcm9tICdiYXNlNjQtanMnO1xuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtID0ge1xuICAgIFNQRUFLRVI6ICdzcGVha2VyJyxcbiAgICBFQVJQSUVDRTogJ2VhcnBpZWNlJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZScsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBMYXlvdXRTZXR0aW5nc05hbWVFbnVtID0ge1xuICAgIFNQT1RMSUdIVDogJ3Nwb3RsaWdodCcsXG4gICAgR1JJRDogJ2dyaWQnLFxuICAgIFNJTkdMRV9QQVJUSUNJUEFOVDogJ3NpbmdsZS1wYXJ0aWNpcGFudCcsXG4gICAgTU9CSUxFOiAnbW9iaWxlJyxcbiAgICBDVVNUT006ICdjdXN0b20nLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBMYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJyxcbn07XG4vKipcbiAqIEFsbCBwb3NzaWJpbGl0eSBvZiBzdHJpbmcgdG8gdXNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE93bkNhcGFiaWxpdHkgPSB7XG4gICAgQkxPQ0tfVVNFUlM6ICdibG9jay11c2VycycsXG4gICAgQ1JFQVRFX0NBTEw6ICdjcmVhdGUtY2FsbCcsXG4gICAgQ1JFQVRFX1JFQUNUSU9OOiAnY3JlYXRlLXJlYWN0aW9uJyxcbiAgICBFTkRfQ0FMTDogJ2VuZC1jYWxsJyxcbiAgICBKT0lOX0JBQ0tTVEFHRTogJ2pvaW4tYmFja3N0YWdlJyxcbiAgICBKT0lOX0NBTEw6ICdqb2luLWNhbGwnLFxuICAgIEpPSU5fRU5ERURfQ0FMTDogJ2pvaW4tZW5kZWQtY2FsbCcsXG4gICAgTVVURV9VU0VSUzogJ211dGUtdXNlcnMnLFxuICAgIFBJTl9GT1JfRVZFUllPTkU6ICdwaW4tZm9yLWV2ZXJ5b25lJyxcbiAgICBSRUFEX0NBTEw6ICdyZWFkLWNhbGwnLFxuICAgIFJFTU9WRV9DQUxMX01FTUJFUjogJ3JlbW92ZS1jYWxsLW1lbWJlcicsXG4gICAgU0NSRUVOU0hBUkU6ICdzY3JlZW5zaGFyZScsXG4gICAgU0VORF9BVURJTzogJ3NlbmQtYXVkaW8nLFxuICAgIFNFTkRfVklERU86ICdzZW5kLXZpZGVvJyxcbiAgICBTVEFSVF9CUk9BRENBU1RfQ0FMTDogJ3N0YXJ0LWJyb2FkY2FzdC1jYWxsJyxcbiAgICBTVEFSVF9SRUNPUkRfQ0FMTDogJ3N0YXJ0LXJlY29yZC1jYWxsJyxcbiAgICBTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdGFydC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICAgIFNUT1BfQlJPQURDQVNUX0NBTEw6ICdzdG9wLWJyb2FkY2FzdC1jYWxsJyxcbiAgICBTVE9QX1JFQ09SRF9DQUxMOiAnc3RvcC1yZWNvcmQtY2FsbCcsXG4gICAgU1RPUF9UUkFOU0NSSVBUSU9OX0NBTEw6ICdzdG9wLXRyYW5zY3JpcHRpb24tY2FsbCcsXG4gICAgVVBEQVRFX0NBTEw6ICd1cGRhdGUtY2FsbCcsXG4gICAgVVBEQVRFX0NBTExfTUVNQkVSOiAndXBkYXRlLWNhbGwtbWVtYmVyJyxcbiAgICBVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUzogJ3VwZGF0ZS1jYWxsLXBlcm1pc3Npb25zJyxcbiAgICBVUERBVEVfQ0FMTF9TRVRUSU5HUzogJ3VwZGF0ZS1jYWxsLXNldHRpbmdzJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0gPSB7XG4gICAgQVZBSUxBQkxFOiAnYXZhaWxhYmxlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBBVVRPX09OOiAnYXV0by1vbicsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtID0ge1xuICAgIF8zNjBQOiAnMzYwcCcsXG4gICAgXzQ4MFA6ICc0ODBwJyxcbiAgICBfNzIwUDogJzcyMHAnLFxuICAgIF8xMDgwUDogJzEwODBwJyxcbiAgICBfMTQ0MFA6ICcxNDQwcCcsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nLFxufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0gPSB7XG4gICAgQVZBSUxBQkxFOiAnYXZhaWxhYmxlJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBBVVRPX09OOiAnYXV0by1vbicsXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJyxcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9TZXR0aW5nc1JlcXVlc3RDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJyxcbn07XG5cbmNsYXNzIEVycm9yRnJvbVJlc3BvbnNlIGV4dGVuZHMgRXJyb3Ige1xufVxuXG4vKipcbiAqIGBOdWxsVmFsdWVgIGlzIGEgc2luZ2xldG9uIGVudW1lcmF0aW9uIHRvIHJlcHJlc2VudCB0aGUgbnVsbCB2YWx1ZSBmb3IgdGhlXG4gKiBgVmFsdWVgIHR5cGUgdW5pb24uXG4gKlxuICogIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBgTnVsbFZhbHVlYCBpcyBKU09OIGBudWxsYC5cbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXG4gKi9cbnZhciBOdWxsVmFsdWU7XG4oZnVuY3Rpb24gKE51bGxWYWx1ZSkge1xuICAgIC8qKlxuICAgICAqIE51bGwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogTlVMTF9WQUxVRSA9IDA7XG4gICAgICovXG4gICAgTnVsbFZhbHVlW051bGxWYWx1ZVtcIk5VTExfVkFMVUVcIl0gPSAwXSA9IFwiTlVMTF9WQUxVRVwiO1xufSkoTnVsbFZhbHVlIHx8IChOdWxsVmFsdWUgPSB7fSkpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3RydWN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdnb29nbGUucHJvdG9idWYuU3RydWN0JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmaWVsZHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtYXAnLFxuICAgICAgICAgICAgICAgIEs6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgICAgIFY6IHsga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBWYWx1ZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBgU3RydWN0YCB0byBKU09OIG9iamVjdC5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25Xcml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBqc29uID0ge307XG4gICAgICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhtZXNzYWdlLmZpZWxkcykpIHtcbiAgICAgICAgICAgIGpzb25ba10gPSBWYWx1ZS50b0pzb24odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBgU3RydWN0YCBmcm9tIEpTT04gb2JqZWN0LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvblJlYWQoanNvbiwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBtZXNzYWdlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICAgICAgICcgZnJvbSBKU09OICcgK1xuICAgICAgICAgICAgICAgIHR5cGVvZkpzb25WYWx1ZShqc29uKSArXG4gICAgICAgICAgICAgICAgJy4nKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICBmb3IgKGxldCBbaywgdl0gb2YgZ2xvYmFsVGhpcy5PYmplY3QuZW50cmllcyhqc29uKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZpZWxkc1trXSA9IFZhbHVlLmZyb21Kc29uKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuZmllbGRzID0ge307XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIG1hcDxzdHJpbmcsIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZT4gZmllbGRzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UmVhZE1hcDEobWVzc2FnZS5maWVsZHMsIHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGJpbmFyeVJlYWRNYXAxKG1hcCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBsZW4gPSByZWFkZXIudWludDMyKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW4sIGtleSwgdmFsO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBWYWx1ZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndW5rbm93biBtYXAgZW50cnkgZmllbGQgZm9yIGZpZWxkIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QuZmllbGRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFwW2tleSA/PyAnJ10gPSB2YWwgPz8gVmFsdWUuY3JlYXRlKCk7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIG1hcDxzdHJpbmcsIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZT4gZmllbGRzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgayBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKG1lc3NhZ2UuZmllbGRzKSkge1xuICAgICAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAgICAgLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgICAgICAgICAgLmZvcmsoKVxuICAgICAgICAgICAgICAgIC50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKVxuICAgICAgICAgICAgICAgIC5zdHJpbmcoayk7XG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpO1xuICAgICAgICAgICAgVmFsdWUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmZpZWxkc1trXSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHdyaXRlci5qb2luKCkuam9pbigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuU3RydWN0XG4gKi9cbmNvbnN0IFN0cnVjdCA9IG5ldyBTdHJ1Y3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVmFsdWUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5WYWx1ZScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbnVsbF92YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAna2luZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlJywgTnVsbFZhbHVlXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ251bWJlcl92YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAxIC8qU2NhbGFyVHlwZS5ET1VCTEUqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N0cmluZ192YWx1ZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Jvb2xfdmFsdWUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAna2luZCcsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3RydWN0X3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBTdHJ1Y3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdsaXN0X3ZhbHVlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdraW5kJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBMaXN0VmFsdWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGBWYWx1ZWAgdG8gSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25Xcml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgICAgICBjYXNlICdib29sVmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLmtpbmQuYm9vbFZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnbnVsbFZhbHVlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlclZhbHVlJzpcbiAgICAgICAgICAgICAgICBsZXQgbnVtYmVyVmFsdWUgPSBtZXNzYWdlLmtpbmQubnVtYmVyVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW1iZXJWYWx1ZSA9PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzRmluaXRlKG51bWJlclZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmdWYWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2Uua2luZC5zdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJ2xpc3RWYWx1ZSc6XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZUZpZWxkID0gdGhpcy5maWVsZHMuZmluZCgoZikgPT4gZi5ubyA9PT0gNik7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RWYWx1ZUZpZWxkPy5raW5kICE9PSAnbWVzc2FnZScpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RWYWx1ZUZpZWxkLlQoKS50b0pzb24obWVzc2FnZS5raW5kLmxpc3RWYWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdzdHJ1Y3RWYWx1ZSc6XG4gICAgICAgICAgICAgICAgbGV0IHN0cnVjdFZhbHVlRmllbGQgPSB0aGlzLmZpZWxkcy5maW5kKChmKSA9PiBmLm5vID09PSA1KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RydWN0VmFsdWVGaWVsZD8ua2luZCAhPT0gJ21lc3NhZ2UnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3RWYWx1ZUZpZWxkLlQoKS50b0pzb24obWVzc2FnZS5raW5kLnN0cnVjdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYFZhbHVlYCBmcm9tIEpTT04gdmFsdWUuXG4gICAgICovXG4gICAgaW50ZXJuYWxKc29uUmVhZChqc29uLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdudW1iZXJWYWx1ZScsIG51bWJlclZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0geyBvbmVvZktpbmQ6ICdzdHJpbmdWYWx1ZScsIHN0cmluZ1ZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICB0YXJnZXQua2luZCA9IHsgb25lb2ZLaW5kOiAnYm9vbFZhbHVlJywgYm9vbFZhbHVlOiBqc29uIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChqc29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnbnVsbFZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGxWYWx1ZTogTnVsbFZhbHVlLk5VTExfVkFMVUUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShqc29uKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2xpc3RWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0VmFsdWU6IExpc3RWYWx1ZS5mcm9tSnNvbihqc29uKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5raW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnc3RydWN0VmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0VmFsdWU6IFN0cnVjdC5mcm9tSnNvbihqc29uKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCdVbmFibGUgdG8gcGFyc2UgJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnIGZyb20gSlNPTiAnICtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mSnNvblZhbHVlKGpzb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmtpbmQgPSB7IG9uZW9mS2luZDogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWUgbnVsbF92YWx1ZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdudWxsVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFZhbHVlOiByZWFkZXIuaW50MzIoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBkb3VibGUgbnVtYmVyX3ZhbHVlICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ251bWJlclZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlclZhbHVlOiByZWFkZXIuZG91YmxlKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHN0cmluZ192YWx1ZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdzdHJpbmdWYWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogcmVhZGVyLnN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgYm9vbF92YWx1ZSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdib29sVmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbFZhbHVlOiByZWFkZXIuYm9vbCgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3Qgc3RydWN0X3ZhbHVlICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2luZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ3N0cnVjdFZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdFZhbHVlOiBTdHJ1Y3QuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmtpbmQuc3RydWN0VmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbGlzdF92YWx1ZSAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtpbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdsaXN0VmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFZhbHVlOiBMaXN0VmFsdWUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmtpbmQubGlzdFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZSBudWxsX3ZhbHVlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09ICdudWxsVmFsdWUnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2Uua2luZC5udWxsVmFsdWUpO1xuICAgICAgICAvKiBkb3VibGUgbnVtYmVyX3ZhbHVlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2luZC5vbmVvZktpbmQgPT09ICdudW1iZXJWYWx1ZScpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkJpdDY0KS5kb3VibGUobWVzc2FnZS5raW5kLm51bWJlclZhbHVlKTtcbiAgICAgICAgLyogc3RyaW5nIHN0cmluZ192YWx1ZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmtpbmQub25lb2ZLaW5kID09PSAnc3RyaW5nVmFsdWUnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmtpbmQuc3RyaW5nVmFsdWUpO1xuICAgICAgICAvKiBib29sIGJvb2xfdmFsdWUgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ2Jvb2xWYWx1ZScpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmtpbmQuYm9vbFZhbHVlKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCBzdHJ1Y3RfdmFsdWUgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ3N0cnVjdFZhbHVlJylcbiAgICAgICAgICAgIFN0cnVjdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uua2luZC5zdHJ1Y3RWYWx1ZSwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlIGxpc3RfdmFsdWUgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5raW5kLm9uZW9mS2luZCA9PT0gJ2xpc3RWYWx1ZScpXG4gICAgICAgICAgICBMaXN0VmFsdWUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmtpbmQubGlzdFZhbHVlLCB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVmFsdWVcbiAqL1xuY29uc3QgVmFsdWUgPSBuZXcgVmFsdWUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgTGlzdFZhbHVlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2YWx1ZXMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZhbHVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBgTGlzdFZhbHVlYCB0byBKU09OIGFycmF5LlxuICAgICAqL1xuICAgIGludGVybmFsSnNvbldyaXRlKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UudmFsdWVzLm1hcCgodikgPT4gVmFsdWUudG9Kc29uKHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGBMaXN0VmFsdWVgIGZyb20gSlNPTiBhcnJheS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25SZWFkKGpzb24sIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBpZiAoIWdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCdVbmFibGUgdG8gcGFyc2UgJyArXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlTmFtZSArXG4gICAgICAgICAgICAgICAgJyBmcm9tIEpTT04gJyArXG4gICAgICAgICAgICAgICAgdHlwZW9mSnNvblZhbHVlKGpzb24pKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmNyZWF0ZSgpO1xuICAgICAgICBsZXQgdmFsdWVzID0ganNvbi5tYXAoKHYpID0+IFZhbHVlLmZyb21Kc29uKHYpKTtcbiAgICAgICAgdGFyZ2V0LnZhbHVlcy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSB2YWx1ZXMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaChWYWx1ZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIHZhbHVlcyA9IDE7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBWYWx1ZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UudmFsdWVzW2ldLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuTGlzdFZhbHVlXG4gKi9cbmNvbnN0IExpc3RWYWx1ZSA9IG5ldyBMaXN0VmFsdWUkVHlwZSgpO1xuXG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUaW1lc3RhbXAkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ2dvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2Vjb25kcycsIGtpbmQ6ICdzY2FsYXInLCBUOiAzIC8qU2NhbGFyVHlwZS5JTlQ2NCovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnbmFub3MnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGltZXN0YW1wYCBmb3IgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgKi9cbiAgICBub3coKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGNvbnN0IG1zID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbXNnLnNlY29uZHMgPSBQYkxvbmcuZnJvbShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLnRvU3RyaW5nKCk7XG4gICAgICAgIG1zZy5uYW5vcyA9IChtcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgRGF0ZS5cbiAgICAgKi9cbiAgICB0b0RhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoUGJMb25nLmZyb20obWVzc2FnZS5zZWNvbmRzKS50b051bWJlcigpICogMTAwMCArXG4gICAgICAgICAgICBNYXRoLmNlaWwobWVzc2FnZS5uYW5vcyAvIDEwMDAwMDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBKYXZhU2NyaXB0IERhdGUgdG8gYSBgVGltZXN0YW1wYC5cbiAgICAgKi9cbiAgICBmcm9tRGF0ZShkYXRlKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuY3JlYXRlKCk7XG4gICAgICAgIGNvbnN0IG1zID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIG1zZy5zZWNvbmRzID0gUGJMb25nLmZyb20oTWF0aC5mbG9vcihtcyAvIDEwMDApKS50b1N0cmluZygpO1xuICAgICAgICBtc2cubmFub3MgPSAobXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluIEpTT04gZm9ybWF0LCB0aGUgYFRpbWVzdGFtcGAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nXG4gICAgICogaW4gdGhlIFJGQyAzMzM5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25Xcml0ZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBtcyA9IFBiTG9uZy5mcm9tKG1lc3NhZ2Uuc2Vjb25kcykudG9OdW1iZXIoKSAqIDEwMDA7XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoJzAwMDEtMDEtMDFUMDA6MDA6MDBaJykgfHxcbiAgICAgICAgICAgIG1zID4gRGF0ZS5wYXJzZSgnOTk5OS0xMi0zMVQyMzo1OTo1OVonKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGVuY29kZSBUaW1lc3RhbXAgdG8gSlNPTi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS4nKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubmFub3MgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZW5jb2RlIGludmFsaWQgVGltZXN0YW1wIHRvIEpTT04uIE5hbm9zIG11c3Qgbm90IGJlIG5lZ2F0aXZlLicpO1xuICAgICAgICBsZXQgeiA9ICdaJztcbiAgICAgICAgaWYgKG1lc3NhZ2UubmFub3MgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbmFub3NTdHIgPSAobWVzc2FnZS5uYW5vcyArIDEwMDAwMDAwMDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKG5hbm9zU3RyLnN1YnN0cmluZygzKSA9PT0gJzAwMDAwMCcpXG4gICAgICAgICAgICAgICAgeiA9ICcuJyArIG5hbm9zU3RyLnN1YnN0cmluZygwLCAzKSArICdaJztcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gJzAwMCcpXG4gICAgICAgICAgICAgICAgeiA9ICcuJyArIG5hbm9zU3RyLnN1YnN0cmluZygwLCA2KSArICdaJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB6ID0gJy4nICsgbmFub3NTdHIgKyAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1zKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJy4wMDBaJywgeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluIEpTT04gZm9ybWF0LCB0aGUgYFRpbWVzdGFtcGAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nXG4gICAgICogaW4gdGhlIFJGQyAzMzM5IGZvcm1hdC5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEpzb25SZWFkKGpzb24sIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgVGltZXN0YW1wIGZyb20gSlNPTiAnICsgdHlwZW9mSnNvblZhbHVlKGpzb24pICsgJy4nKTtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBqc29uLm1hdGNoKC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgVGltZXN0YW1wIGZyb20gSlNPTi4gSW52YWxpZCBmb3JtYXQuJyk7XG4gICAgICAgIGxldCBtcyA9IERhdGUucGFyc2UobWF0Y2hlc1sxXSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbWF0Y2hlc1syXSArXG4gICAgICAgICAgICAnLScgK1xuICAgICAgICAgICAgbWF0Y2hlc1szXSArXG4gICAgICAgICAgICAnVCcgK1xuICAgICAgICAgICAgbWF0Y2hlc1s0XSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgbWF0Y2hlc1s1XSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgbWF0Y2hlc1s2XSArXG4gICAgICAgICAgICAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiAnWicpKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBUaW1lc3RhbXAgZnJvbSBKU09OLiBJbnZhbGlkIHZhbHVlLicpO1xuICAgICAgICBpZiAobXMgPCBEYXRlLnBhcnNlKCcwMDAxLTAxLTAxVDAwOjAwOjAwWicpIHx8XG4gICAgICAgICAgICBtcyA+IERhdGUucGFyc2UoJzk5OTktMTItMzFUMjM6NTk6NTlaJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcignVW5hYmxlIHRvIHBhcnNlIFRpbWVzdGFtcCBmcm9tIEpTT04uIE11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuJyk7XG4gICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgICAgdGFyZ2V0LnNlY29uZHMgPSBQYkxvbmcuZnJvbShtcyAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIHRhcmdldC5uYW5vcyA9IDA7XG4gICAgICAgIGlmIChtYXRjaGVzWzddKVxuICAgICAgICAgICAgdGFyZ2V0Lm5hbm9zID1cbiAgICAgICAgICAgICAgICBwYXJzZUludCgnMScgKyBtYXRjaGVzWzddICsgJzAnLnJlcGVhdCg5IC0gbWF0Y2hlc1s3XS5sZW5ndGgpKSAtXG4gICAgICAgICAgICAgICAgICAgIDEwMDAwMDAwMDA7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vjb25kcyA9ICcwJztcbiAgICAgICAgbWVzc2FnZS5uYW5vcyA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDY0IHNlY29uZHMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWNvbmRzID0gcmVhZGVyLmludDY0KCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBuYW5vcyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbm9zID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGludDY0IHNlY29uZHMgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZWNvbmRzICE9PSAnMCcpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50NjQobWVzc2FnZS5zZWNvbmRzKTtcbiAgICAgICAgLyogaW50MzIgbmFub3MgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5uYW5vcyAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm5hbm9zKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcbiAqL1xuY29uc3QgVGltZXN0YW1wID0gbmV3IFRpbWVzdGFtcCRUeXBlKCk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGVcbiAqL1xudmFyIFBlZXJUeXBlO1xuKGZ1bmN0aW9uIChQZWVyVHlwZSkge1xuICAgIC8qKlxuICAgICAqIHRvZG8gZml4IG1lIChtYXJjZWxvKVxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBFRVJfVFlQRV9QVUJMSVNIRVJfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFBlZXJUeXBlW1BlZXJUeXBlW1wiUFVCTElTSEVSX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlBVQkxJU0hFUl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBQRUVSX1RZUEVfU1VCU0NSSUJFUiA9IDE7XG4gICAgICovXG4gICAgUGVlclR5cGVbUGVlclR5cGVbXCJTVUJTQ1JJQkVSXCJdID0gMV0gPSBcIlNVQlNDUklCRVJcIjtcbn0pKFBlZXJUeXBlIHx8IChQZWVyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5XG4gKi9cbnZhciBDb25uZWN0aW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogQ09OTkVDVElPTl9RVUFMSVRZX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IENPTk5FQ1RJT05fUVVBTElUWV9QT09SID0gMTtcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uUXVhbGl0eVtDb25uZWN0aW9uUXVhbGl0eVtcIlBPT1JcIl0gPSAxXSA9IFwiUE9PUlwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBDT05ORUNUSU9OX1FVQUxJVFlfR09PRCA9IDI7XG4gICAgICovXG4gICAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJHT09EXCJdID0gMl0gPSBcIkdPT0RcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogQ09OTkVDVElPTl9RVUFMSVRZX0VYQ0VMTEVOVCA9IDM7XG4gICAgICovXG4gICAgQ29ubmVjdGlvblF1YWxpdHlbQ29ubmVjdGlvblF1YWxpdHlbXCJFWENFTExFTlRcIl0gPSAzXSA9IFwiRVhDRUxMRU5UXCI7XG59KShDb25uZWN0aW9uUXVhbGl0eSB8fCAoQ29ubmVjdGlvblF1YWxpdHkgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHlcbiAqL1xudmFyIFZpZGVvUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9RdWFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFZJREVPX1FVQUxJVFlfTE9XX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiTE9XX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkxPV19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBWSURFT19RVUFMSVRZX01JRCA9IDE7XG4gICAgICovXG4gICAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk1JRFwiXSA9IDFdID0gXCJNSURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVklERU9fUVVBTElUWV9ISUdIID0gMjtcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiSElHSFwiXSA9IDJdID0gXCJISUdIXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFZJREVPX1FVQUxJVFlfT0ZGID0gMztcbiAgICAgKi9cbiAgICBWaWRlb1F1YWxpdHlbVmlkZW9RdWFsaXR5W1wiT0ZGXCJdID0gM10gPSBcIk9GRlwiO1xufSkoVmlkZW9RdWFsaXR5IHx8IChWaWRlb1F1YWxpdHkgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGVcbiAqL1xudmFyIFRyYWNrVHlwZTtcbihmdW5jdGlvbiAoVHJhY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJVTlNQRUNJRklFRFwiXSA9IDBdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX0FVRElPID0gMTtcbiAgICAgKi9cbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiQVVESU9cIl0gPSAxXSA9IFwiQVVESU9cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVFlQRV9WSURFTyA9IDI7XG4gICAgICovXG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlZJREVPXCJdID0gMl0gPSBcIlZJREVPXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFID0gMztcbiAgICAgKi9cbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiU0NSRUVOX1NIQVJFXCJdID0gM10gPSBcIlNDUkVFTl9TSEFSRVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19UWVBFX1NDUkVFTl9TSEFSRV9BVURJTyA9IDQ7XG4gICAgICovXG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcIlNDUkVFTl9TSEFSRV9BVURJT1wiXSA9IDRdID0gXCJTQ1JFRU5fU0hBUkVfQVVESU9cIjtcbn0pKFRyYWNrVHlwZSB8fCAoVHJhY2tUeXBlID0ge30pKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlXG4gKi9cbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QVUJMSVNIX1RSQUNLX05PVF9GT1VORCA9IDEwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUFVCTElTSF9UUkFDS19OT1RfRk9VTkRcIl0gPSAxMDBdID0gXCJQVUJMSVNIX1RSQUNLX05PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BVQkxJU0hfVFJBQ0tTX01JU01BVENIID0gMTAxO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQVUJMSVNIX1RSQUNLU19NSVNNQVRDSFwiXSA9IDEwMV0gPSBcIlBVQkxJU0hfVFJBQ0tTX01JU01BVENIXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUFVCTElTSF9UUkFDS19PVVRfT0ZfT1JERVIgPSAxMDI7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBVQkxJU0hfVFJBQ0tfT1VUX09GX09SREVSXCJdID0gMTAyXSA9IFwiUFVCTElTSF9UUkFDS19PVVRfT0ZfT1JERVJcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QVUJMSVNIX1RSQUNLX1ZJREVPX0xBWUVSX05PVF9GT1VORCA9IDEwMztcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiUFVCTElTSF9UUkFDS19WSURFT19MQVlFUl9OT1RfRk9VTkRcIl0gPSAxMDNdID0gXCJQVUJMSVNIX1RSQUNLX1ZJREVPX0xBWUVSX05PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX0xJVkVfRU5ERUQgPSAxMDQ7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkxJVkVfRU5ERURcIl0gPSAxMDRdID0gXCJMSVZFX0VOREVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTk9UX0ZPVU5EID0gMjAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9OT1RfRk9VTkRcIl0gPSAyMDBdID0gXCJQQVJUSUNJUEFOVF9OT1RfRk9VTkRcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9NSUdSQVRJTkdfT1VUID0gMjAxO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdfT1VUXCJdID0gMjAxXSA9IFwiUEFSVElDSVBBTlRfTUlHUkFUSU5HX09VVFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX01JR1JBVElPTl9GQUlMRUQgPSAyMDI7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBBUlRJQ0lQQU5UX01JR1JBVElPTl9GQUlMRURcIl0gPSAyMDJdID0gXCJQQVJUSUNJUEFOVF9NSUdSQVRJT05fRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEFSVElDSVBBTlRfTUlHUkFUSU5HID0gMjAzO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdcIl0gPSAyMDNdID0gXCJQQVJUSUNJUEFOVF9NSUdSQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9QQVJUSUNJUEFOVF9SRUNPTk5FQ1RfRkFJTEVEID0gMjA0O1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9SRUNPTk5FQ1RfRkFJTEVEXCJdID0gMjA0XSA9IFwiUEFSVElDSVBBTlRfUkVDT05ORUNUX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1BBUlRJQ0lQQU5UX01FRElBX1RSQU5TUE9SVF9GQUlMVVJFID0gMjA1O1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJQQVJUSUNJUEFOVF9NRURJQV9UUkFOU1BPUlRfRkFJTFVSRVwiXSA9IDIwNV0gPSBcIlBBUlRJQ0lQQU5UX01FRElBX1RSQU5TUE9SVF9GQUlMVVJFXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfQ0FMTF9OT1RfRk9VTkQgPSAzMDA7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNBTExfTk9UX0ZPVU5EXCJdID0gMzAwXSA9IFwiQ0FMTF9OT1RfRk9VTkRcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9SRVFVRVNUX1ZBTElEQVRJT05fRkFJTEVEID0gNDAwO1xuICAgICAqL1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJSRVFVRVNUX1ZBTElEQVRJT05fRkFJTEVEXCJdID0gNDAwXSA9IFwiUkVRVUVTVF9WQUxJREFUSU9OX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX1VOQVVUSEVOVElDQVRFRCA9IDQwMTtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gNDAxXSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfUEVSTUlTU0lPTl9ERU5JRUQgPSA0MDM7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gNDAzXSA9IFwiUEVSTUlTU0lPTl9ERU5JRURcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9UT09fTUFOWV9SRVFVRVNUUyA9IDQyOTtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVE9PX01BTllfUkVRVUVTVFNcIl0gPSA0MjldID0gXCJUT09fTUFOWV9SRVFVRVNUU1wiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBFUlJPUl9DT0RFX0lOVEVSTkFMX1NFUlZFUl9FUlJPUiA9IDUwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCJdID0gNTAwXSA9IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEVSUk9SX0NPREVfU0ZVX1NIVVRUSU5HX0RPV04gPSA2MDA7XG4gICAgICovXG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlNGVV9TSFVUVElOR19ET1dOXCJdID0gNjAwXSA9IFwiU0ZVX1NIVVRUSU5HX0RPV05cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogRVJST1JfQ09ERV9TRlVfRlVMTCA9IDcwMDtcbiAgICAgKi9cbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU0ZVX0ZVTExcIl0gPSA3MDBdID0gXCJTRlVfRlVMTFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlXG4gKi9cbnZhciBTZGtUeXBlO1xuKGZ1bmN0aW9uIChTZGtUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBTZGtUeXBlW1Nka1R5cGVbXCJVTlNQRUNJRklFRFwiXSA9IDBdID0gXCJVTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9SRUFDVCA9IDE7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiUkVBQ1RcIl0gPSAxXSA9IFwiUkVBQ1RcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfQU5HVUxBUiA9IDI7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiQU5HVUxBUlwiXSA9IDJdID0gXCJBTkdVTEFSXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX0FORFJPSUQgPSAzO1xuICAgICAqL1xuICAgIFNka1R5cGVbU2RrVHlwZVtcIkFORFJPSURcIl0gPSAzXSA9IFwiQU5EUk9JRFwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9JT1MgPSA0O1xuICAgICAqL1xuICAgIFNka1R5cGVbU2RrVHlwZVtcIklPU1wiXSA9IDRdID0gXCJJT1NcIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogU0RLX1RZUEVfRkxVVFRFUiA9IDU7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiRkxVVFRFUlwiXSA9IDVdID0gXCJGTFVUVEVSXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFNES19UWVBFX1JFQUNUX05BVElWRSA9IDY7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiUkVBQ1RfTkFUSVZFXCJdID0gNl0gPSBcIlJFQUNUX05BVElWRVwiO1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBTREtfVFlQRV9VTklUWSA9IDc7XG4gICAgICovXG4gICAgU2RrVHlwZVtTZGtUeXBlW1wiVU5JVFlcIl0gPSA3XSA9IFwiVU5JVFlcIjtcbn0pKFNka1R5cGUgfHwgKFNka1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1VucHVibGlzaFJlYXNvblxuICovXG52YXIgVHJhY2tVbnB1Ymxpc2hSZWFzb247XG4oZnVuY3Rpb24gKFRyYWNrVW5wdWJsaXNoUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZSB3aGljaCBpcyB1c2VkIHdoZW4gdGhlIHNwZWNpZmljIHJlYXNvblxuICAgICAqIGZvciBtdXRpbmcgdGhlIHRyYWNrIGlzIG5vdCBrbm93bi5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX1VOU1BFQ0lGSUVEID0gMDtcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyB1c2VyIG11dGluZyB0aGVpciB0cmFja3MuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl9VU0VSX01VVEVEID0gMTtcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIlVTRVJfTVVURURcIl0gPSAxXSA9IFwiVVNFUl9NVVRFRFwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgbXV0aW5nIHRoZSB0cmFjayBiZWNhdXNlIHRoZSBwZXJtaXNzaW9uIHRvXG4gICAgICogcHVibGlzaCB0aGUgdHJhY2sgaGFzIGJlZW4gcmV2b2tlZC5cbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBUUkFDS19VTlBVQkxJU0hfUkVBU09OX1BFUk1JU1NJT05fUkVWT0tFRCA9IDI7XG4gICAgICovXG4gICAgVHJhY2tVbnB1Ymxpc2hSZWFzb25bVHJhY2tVbnB1Ymxpc2hSZWFzb25bXCJQRVJNSVNTSU9OX1JFVk9LRURcIl0gPSAyXSA9IFwiUEVSTUlTU0lPTl9SRVZPS0VEXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBtdXRpbmcgdGhlIHRyYWNrIGR1ZSB0byBtb2RlcmF0aW9uIGFjdGlvbnMuXG4gICAgICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBwZXJtaXNzaW9uIHJldm9rZWQgYmVjYXVzZSB0aGVcbiAgICAgKiBwYXJ0aWNpcGFudCBjYW4gdW5tdXRlIHRoZW1zZWx2ZXMgaGVyZSB3aGVyZWFzIGluIGNhc2VcbiAgICAgKiBvZiBcInBlcm1pc3Npb24gcmV2b2tlXCIgaXQgaXMgbm90IHBvc3NpYmxlIHVudGlsIHRoZVxuICAgICAqIGNhbGwgcGVybWlzc2lvbnMgYXJlIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl9NT0RFUkFUSU9OID0gMztcbiAgICAgKi9cbiAgICBUcmFja1VucHVibGlzaFJlYXNvbltUcmFja1VucHVibGlzaFJlYXNvbltcIk1PREVSQVRJT05cIl0gPSAzXSA9IFwiTU9ERVJBVElPTlwiO1xufSkoVHJhY2tVbnB1Ymxpc2hSZWFzb24gfHwgKFRyYWNrVW5wdWJsaXNoUmVhc29uID0ge30pKTtcbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuR29Bd2F5UmVhc29uXG4gKi9cbnZhciBHb0F3YXlSZWFzb247XG4oZnVuY3Rpb24gKEdvQXdheVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBlbnVtIHZhbHVlOiBHT19BV0FZX1JFQVNPTl9VTlNQRUNJRklFRCA9IDA7XG4gICAgICovXG4gICAgR29Bd2F5UmVhc29uW0dvQXdheVJlYXNvbltcIlVOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IEdPX0FXQVlfUkVBU09OX1NIVVRUSU5HX0RPV04gPSAxO1xuICAgICAqL1xuICAgIEdvQXdheVJlYXNvbltHb0F3YXlSZWFzb25bXCJTSFVUVElOR19ET1dOXCJdID0gMV0gPSBcIlNIVVRUSU5HX0RPV05cIjtcbiAgICAvKipcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZW51bSB2YWx1ZTogR09fQVdBWV9SRUFTT05fUkVCQUxBTkNFID0gMjtcbiAgICAgKi9cbiAgICBHb0F3YXlSZWFzb25bR29Bd2F5UmVhc29uW1wiUkVCQUxBTkNFXCJdID0gMl0gPSBcIlJFQkFMQU5DRVwiO1xufSkoR29Bd2F5UmVhc29uIHx8IChHb0F3YXlSZWFzb24gPSB7fSkpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2FsbFN0YXRlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGUnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BhcnRpY2lwYW50cycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3N0YXJ0ZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9jb3VudCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50Q291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwaW5zJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZS5waW5zID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50cyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50cy5wdXNoKFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgc3RhcnRlZF9hdCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0YXJ0ZWRBdCA9IFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uuc3RhcnRlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudENvdW50IHBhcnRpY2lwYW50X2NvdW50ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFydGljaXBhbnRDb3VudCA9IFBhcnRpY2lwYW50Q291bnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGlucy5wdXNoKFBpbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnRzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcnRpY2lwYW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudHNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBzdGFydGVkX2F0ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhcnRlZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5zdGFydGVkQXQsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudENvdW50LCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zID0gNDsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBQaW4uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBpbnNbaV0sIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZVxuICovXG5jb25zdCBDYWxsU3RhdGUkMSA9IG5ldyBDYWxsU3RhdGUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRDb3VudCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd0b3RhbCcsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdhbm9ueW1vdXMnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnRvdGFsID0gMDtcbiAgICAgICAgbWVzc2FnZS5hbm9ueW1vdXMgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgdG90YWwgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3RhbCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgYW5vbnltb3VzICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYW5vbnltb3VzID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiB1aW50MzIgdG90YWwgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50b3RhbCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS50b3RhbCk7XG4gICAgICAgIC8qIHVpbnQzMiBhbm9ueW1vdXMgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5hbm9ueW1vdXMgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuYW5vbnltb3VzKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50Q291bnRcbiAqL1xuY29uc3QgUGFydGljaXBhbnRDb3VudCA9IG5ldyBQYXJ0aWNpcGFudENvdW50JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBpbiRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluXG4gKi9cbmNvbnN0IFBpbiA9IG5ldyBQaW4kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3B1Ymxpc2hlZF90cmFja3MnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdqb2luZWRfYXQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFRpbWVzdGFtcCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja19sb29rdXBfcHJlZml4JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICdDT05ORUNUSU9OX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDcsIG5hbWU6ICdpc19zcGVha2luZycsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaXNfZG9taW5hbnRfc3BlYWtlcicsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDksIG5hbWU6ICdhdWRpb19sZXZlbCcsIGtpbmQ6ICdzY2FsYXInLCBUOiAyIC8qU2NhbGFyVHlwZS5GTE9BVCovIH0sXG4gICAgICAgICAgICB7IG5vOiAxMCwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDExLCBuYW1lOiAnaW1hZ2UnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDEyLCBuYW1lOiAnY3VzdG9tJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBTdHJ1Y3QgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMTMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3JvbGVzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDIgLypSZXBlYXRUeXBlLlVOUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MgPSBbXTtcbiAgICAgICAgbWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCA9ICcnO1xuICAgICAgICBtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ID0gMDtcbiAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuaW1hZ2UgPSAnJztcbiAgICAgICAgbWVzc2FnZS5yb2xlcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgcHVibGlzaGVkX3RyYWNrcyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSByZWFkZXIuaW50MzIoKSArIHJlYWRlci5wb3M7IHJlYWRlci5wb3MgPCBlOylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1Ymxpc2hlZFRyYWNrcy5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBqb2luZWRfYXQgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5qb2luZWRBdCA9IFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uuam9pbmVkQXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0cmFja19sb29rdXBfcHJlZml4ICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tMb29rdXBQcmVmaXggPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkgY29ubmVjdGlvbl9xdWFsaXR5ICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGlzX3NwZWFraW5nICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNTcGVha2luZyA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpc19kb21pbmFudF9zcGVha2VyICovIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGZsb2F0IGF1ZGlvX2xldmVsICovIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGltYWdlICovIDExOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmltYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tICovIDEyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmN1c3RvbSA9IFN0cnVjdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJpbmcgcm9sZXMgKi8gMTM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uucm9sZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSBwdWJsaXNoZWRfdHJhY2tzID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5wdWJsaXNoZWRUcmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgd3JpdGVyLmludDMyKG1lc3NhZ2UucHVibGlzaGVkVHJhY2tzW2ldKTtcbiAgICAgICAgICAgIHdyaXRlci5qb2luKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBqb2luZWRfYXQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5qb2luZWRBdClcbiAgICAgICAgICAgIFRpbWVzdGFtcC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uuam9pbmVkQXQsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyaW5nIHRyYWNrX2xvb2t1cF9wcmVmaXggPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS50cmFja0xvb2t1cFByZWZpeCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHJhY2tMb29rdXBQcmVmaXgpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db25uZWN0aW9uUXVhbGl0eSBjb25uZWN0aW9uX3F1YWxpdHkgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5KTtcbiAgICAgICAgLyogYm9vbCBpc19zcGVha2luZyA9IDc7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmlzU3BlYWtpbmcgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg3LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pc1NwZWFraW5nKTtcbiAgICAgICAgLyogYm9vbCBpc19kb21pbmFudF9zcGVha2VyID0gODsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNEb21pbmFudFNwZWFrZXIgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg4LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5pc0RvbWluYW50U3BlYWtlcik7XG4gICAgICAgIC8qIGZsb2F0IGF1ZGlvX2xldmVsID0gOTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXVkaW9MZXZlbCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoOSwgV2lyZVR5cGUuQml0MzIpLmZsb2F0KG1lc3NhZ2UuYXVkaW9MZXZlbCk7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMTA7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxMCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgLyogc3RyaW5nIGltYWdlID0gMTE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmltYWdlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMTEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaW1hZ2UpO1xuICAgICAgICAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSA9IDEyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jdXN0b20pXG4gICAgICAgICAgICBTdHJ1Y3QuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmN1c3RvbSwgd3JpdGVyLnRhZygxMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyaW5nIHJvbGVzID0gMTM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5yb2xlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMTMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uucm9sZXNbaV0pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRcbiAqL1xuY29uc3QgUGFydGljaXBhbnQgPSBuZXcgUGFydGljaXBhbnQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU3RyZWFtUXVhbGl0eSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU3RyZWFtUXVhbGl0eScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndmlkZW9fcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eScsXG4gICAgICAgICAgICAgICAgICAgIFZpZGVvUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgJ1ZJREVPX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnZpZGVvUXVhbGl0eSA9IDA7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSB2aWRlb19xdWFsaXR5ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmlkZW9RdWFsaXR5ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSB2aWRlb19xdWFsaXR5ID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudmlkZW9RdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudmlkZW9RdWFsaXR5KTtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TdHJlYW1RdWFsaXR5XG4gKi9cbmNvbnN0IFN0cmVhbVF1YWxpdHkgPSBuZXcgU3RyZWFtUXVhbGl0eSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb0RpbWVuc2lvbiRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24nLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnd2lkdGgnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnaGVpZ2h0Jywga2luZDogJ3NjYWxhcicsIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS53aWR0aCA9IDA7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIHdpZHRoICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIGhlaWdodCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogdWludDMyIHdpZHRoID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uud2lkdGggIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2Uud2lkdGgpO1xuICAgICAgICAvKiB1aW50MzIgaGVpZ2h0ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVpZ2h0ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLnVpbnQzMihtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvblxuICovXG5jb25zdCBWaWRlb0RpbWVuc2lvbiA9IG5ldyBWaWRlb0RpbWVuc2lvbiRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb0xheWVyJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3JpZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2aWRlb19kaW1lbnNpb24nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb0RpbWVuc2lvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAnYml0cmF0ZScsIGtpbmQ6ICdzY2FsYXInLCBUOiAxMyAvKlNjYWxhclR5cGUuVUlOVDMyKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6ICdmcHMnLCBraW5kOiAnc2NhbGFyJywgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3F1YWxpdHknLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb1F1YWxpdHknLFxuICAgICAgICAgICAgICAgICAgICBWaWRlb1F1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICdWSURFT19RVUFMSVRZXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnJpZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLmJpdHJhdGUgPSAwO1xuICAgICAgICBtZXNzYWdlLmZwcyA9IDA7XG4gICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyByaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9EaW1lbnNpb24gdmlkZW9fZGltZW5zaW9uICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmlkZW9EaW1lbnNpb24gPSBWaWRlb0RpbWVuc2lvbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UudmlkZW9EaW1lbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBiaXRyYXRlICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYml0cmF0ZSA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiB1aW50MzIgZnBzICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnBzID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvUXVhbGl0eSBxdWFsaXR5ICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgcmlkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmlkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5yaWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbiB2aWRlb19kaW1lbnNpb24gPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS52aWRlb0RpbWVuc2lvbilcbiAgICAgICAgICAgIFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS52aWRlb0RpbWVuc2lvbiwgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiB1aW50MzIgYml0cmF0ZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmJpdHJhdGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuYml0cmF0ZSk7XG4gICAgICAgIC8qIHVpbnQzMiBmcHMgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5mcHMgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLlZhcmludCkudWludDMyKG1lc3NhZ2UuZnBzKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9RdWFsaXR5IHF1YWxpdHkgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5xdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UucXVhbGl0eSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyXG4gKi9cbmNvbnN0IFZpZGVvTGF5ZXIgPSBuZXcgVmlkZW9MYXllciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb2RlYyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BheWxvYWRfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogMTMgLypTY2FsYXJUeXBlLlVJTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnZm10cF9saW5lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDQsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nsb2NrX3JhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDUsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2VuY29kaW5nX3BhcmFtZXRlcnMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnZmVlZGJhY2tzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDIgLypSZXBlYXRUeXBlLlVOUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkVHlwZSA9IDA7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLmZtdHBMaW5lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY2xvY2tSYXRlID0gMDtcbiAgICAgICAgbWVzc2FnZS5lbmNvZGluZ1BhcmFtZXRlcnMgPSAnJztcbiAgICAgICAgbWVzc2FnZS5mZWVkYmFja3MgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIHBheWxvYWRfdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWRUeXBlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBuYW1lICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgZm10cF9saW5lICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZm10cExpbmUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogdWludDMyIGNsb2NrX3JhdGUgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbG9ja1JhdGUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGVuY29kaW5nX3BhcmFtZXRlcnMgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmNvZGluZ1BhcmFtZXRlcnMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyaW5nIGZlZWRiYWNrcyAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZlZWRiYWNrcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHVpbnQzMiBwYXlsb2FkX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5wYXlsb2FkVHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBuYW1lID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIC8qIHN0cmluZyBmbXRwX2xpbmUgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5mbXRwTGluZSAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZm10cExpbmUpO1xuICAgICAgICAvKiB1aW50MzIgY2xvY2tfcmF0ZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNsb2NrUmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5jbG9ja1JhdGUpO1xuICAgICAgICAvKiBzdHJpbmcgZW5jb2RpbmdfcGFyYW1ldGVycyA9IDU7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVuY29kaW5nUGFyYW1ldGVycyAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXJcbiAgICAgICAgICAgICAgICAudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZClcbiAgICAgICAgICAgICAgICAuc3RyaW5nKG1lc3NhZ2UuZW5jb2RpbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyaW5nIGZlZWRiYWNrcyA9IDY7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5mZWVkYmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIudGFnKDYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuZmVlZGJhY2tzW2ldKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjXG4gKi9cbmNvbnN0IENvZGVjID0gbmV3IENvZGVjJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmxldCBJQ0VUcmlja2xlJFR5cGUkMSA9IGNsYXNzIElDRVRyaWNrbGUkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDIsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2ljZV9jYW5kaWRhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5pY2VDYW5kaWRhdGUgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaWNlX2NhbmRpZGF0ZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWNlQ2FuZGlkYXRlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufTtcbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlXG4gKi9cbmNvbnN0IElDRVRyaWNrbGUkMSA9IG5ldyBJQ0VUcmlja2xlJFR5cGUkMSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVHJhY2tJbmZvJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8nLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndHJhY2tfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb0xheWVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDYsIG5hbWU6ICdtaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDcsIG5hbWU6ICdkdHgnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiA4LCBuYW1lOiAnc3RlcmVvJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICAgICAgeyBubzogOSwgbmFtZTogJ3JlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IDA7XG4gICAgICAgIG1lc3NhZ2UubGF5ZXJzID0gW107XG4gICAgICAgIG1lc3NhZ2UubWlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuZHR4ID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2Uuc3RlcmVvID0gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UucmVkID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB0cmFja19pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1R5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0xheWVyIGxheWVycyAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKFZpZGVvTGF5ZXIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1pZCAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGR0eCAqLyA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmR0eCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBzdGVyZW8gKi8gODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdGVyZW8gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgcmVkICovIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHRyYWNrX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudHJhY2tJZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVmlkZW9MYXllciBsYXllcnMgPSA1OyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UubGF5ZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVmlkZW9MYXllci5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubGF5ZXJzW2ldLCB3cml0ZXIudGFnKDUsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmluZyBtaWQgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5taWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1pZCk7XG4gICAgICAgIC8qIGJvb2wgZHR4ID0gNzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZHR4ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoNywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuZHR4KTtcbiAgICAgICAgLyogYm9vbCBzdGVyZW8gPSA4OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zdGVyZW8gIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg4LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5zdGVyZW8pO1xuICAgICAgICAvKiBib29sIHJlZCA9IDk7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnJlZCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDksIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnJlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm9cbiAqL1xuY29uc3QgVHJhY2tJbmZvID0gbmV3IFRyYWNrSW5mbyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDYWxsJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3R5cGUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdpZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjcmVhdGVkX2J5X3VzZXJfaWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaG9zdF91c2VyX2lkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA1LCBuYW1lOiAnY3VzdG9tJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBTdHJ1Y3QgfSxcbiAgICAgICAgICAgIHsgbm86IDYsIG5hbWU6ICdjcmVhdGVkX2F0Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBUaW1lc3RhbXAgfSxcbiAgICAgICAgICAgIHsgbm86IDcsIG5hbWU6ICd1cGRhdGVkX2F0Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBUaW1lc3RhbXAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLmlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuaG9zdFVzZXJJZCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGlkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNyZWF0ZWRfYnlfdXNlcl9pZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0ZWRCeVVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaG9zdF91c2VyX2lkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaG9zdFVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuU3RydWN0IGN1c3RvbSAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmN1c3RvbSA9IFN0cnVjdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY3VzdG9tKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGNyZWF0ZWRfYXQgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkQXQgPSBUaW1lc3RhbXAuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmNyZWF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB1cGRhdGVkX2F0ICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlZEF0ID0gVGltZXN0YW1wLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS51cGRhdGVkQXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnR5cGUpO1xuICAgICAgICAvKiBzdHJpbmcgaWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaWQpO1xuICAgICAgICAvKiBzdHJpbmcgY3JlYXRlZF9ieV91c2VyX2lkID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRlZEJ5VXNlcklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5jcmVhdGVkQnlVc2VySWQpO1xuICAgICAgICAvKiBzdHJpbmcgaG9zdF91c2VyX2lkID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaG9zdFVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuaG9zdFVzZXJJZCk7XG4gICAgICAgIC8qIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgY3VzdG9tID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3VzdG9tKVxuICAgICAgICAgICAgU3RydWN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jdXN0b20sIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBjcmVhdGVkX2F0ID0gNjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRlZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jcmVhdGVkQXQsIHdyaXRlci50YWcoNiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB1cGRhdGVkX2F0ID0gNzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlZEF0KVxuICAgICAgICAgICAgVGltZXN0YW1wLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS51cGRhdGVkQXQsIHdyaXRlci50YWcoNywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxcbiAqL1xuY29uc3QgQ2FsbCQxID0gbmV3IENhbGwkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xubGV0IEVycm9yJFR5cGUkMSA9IGNsYXNzIEVycm9yJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvcicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29kZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yQ29kZScsXG4gICAgICAgICAgICAgICAgICAgIEVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ0VSUk9SX0NPREVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtZXNzYWdlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnc2hvdWxkX3JldHJ5Jywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jb2RlID0gMDtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2hvdWxkUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3JDb2RlIGNvZGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1lc3NhZ2UgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgc2hvdWxkX3JldHJ5ICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hvdWxkUmV0cnkgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvckNvZGUgY29kZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvZGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jb2RlKTtcbiAgICAgICAgLyogc3RyaW5nIG1lc3NhZ2UgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgLyogYm9vbCBzaG91bGRfcmV0cnkgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zaG91bGRSZXRyeSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLnNob3VsZFJldHJ5KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufTtcbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvclxuICovXG5jb25zdCBFcnJvciQyID0gbmV3IEVycm9yJFR5cGUkMSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2xpZW50RGV0YWlscyRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2xpZW50RGV0YWlscycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZGsnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFNkayB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ29zJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBPUyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ2Jyb3dzZXInLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IEJyb3dzZXIgfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdkZXZpY2UnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IERldmljZSB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrIHNkayAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkayA9IFNkay5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2Uuc2RrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUyBvcyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9zID0gT1MuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLm9zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Ccm93c2VyIGJyb3dzZXIgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5icm93c2VyID0gQnJvd3Nlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuYnJvd3Nlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRGV2aWNlIGRldmljZSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRldmljZSA9IERldmljZS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZGV2aWNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrIHNkayA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkaylcbiAgICAgICAgICAgIFNkay5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uuc2RrLCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLk9TIG9zID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3MpXG4gICAgICAgICAgICBPUy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2Uub3MsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlciBicm93c2VyID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYnJvd3NlcilcbiAgICAgICAgICAgIEJyb3dzZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmJyb3dzZXIsIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRGV2aWNlIGRldmljZSA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmRldmljZSlcbiAgICAgICAgICAgIERldmljZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZGV2aWNlLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzXG4gKi9cbmNvbnN0IENsaWVudERldGFpbHMgPSBuZXcgQ2xpZW50RGV0YWlscyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZGskVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlNkaycsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuU2RrVHlwZScsIFNka1R5cGUsICdTREtfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnbWFqb3InLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdtaW5vcicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ3BhdGNoJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICBtZXNzYWdlLm1ham9yID0gJyc7XG4gICAgICAgIG1lc3NhZ2UubWlub3IgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wYXRjaCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5TZGtUeXBlIHR5cGUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1ham9yICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFqb3IgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG1pbm9yICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWlub3IgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHBhdGNoICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0Y2ggPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1R5cGUgdHlwZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyaW5nIG1ham9yID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWFqb3IgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1ham9yKTtcbiAgICAgICAgLyogc3RyaW5nIG1pbm9yID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWlub3IgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1pbm9yKTtcbiAgICAgICAgLyogc3RyaW5nIHBhdGNoID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGF0Y2ggIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnBhdGNoKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlNka1xuICovXG5jb25zdCBTZGsgPSBuZXcgU2RrJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIE9TJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5PUycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhcmNoaXRlY3R1cmUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSAnJztcbiAgICAgICAgbWVzc2FnZS5hcmNoaXRlY3R1cmUgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB2ZXJzaW9uICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgYXJjaGl0ZWN0dXJlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXJjaGl0ZWN0dXJlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICAvKiBzdHJpbmcgYXJjaGl0ZWN0dXJlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXJjaGl0ZWN0dXJlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5hcmNoaXRlY3R1cmUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuT1NcbiAqL1xuY29uc3QgT1MgPSBuZXcgT1MkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQnJvd3NlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlcicsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICduYW1lJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAndmVyc2lvbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5uYW1lID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHZlcnNpb24gKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBzdHJpbmcgdmVyc2lvbiA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQnJvd3NlclxuICovXG5jb25zdCBCcm93c2VyID0gbmV3IEJyb3dzZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgRGV2aWNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5EZXZpY2UnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnbmFtZScsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3ZlcnNpb24nLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9ICcnO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIG5hbWUgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB2ZXJzaW9uICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIG5hbWUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgLyogc3RyaW5nIHZlcnNpb24gPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS52ZXJzaW9uKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkRldmljZVxuICovXG5jb25zdCBEZXZpY2UgPSBuZXcgRGV2aWNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIENhbGxHcmFudHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxHcmFudHMnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nhbl9wdWJsaXNoX2F1ZGlvJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYW5fcHVibGlzaF92aWRlbycsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2FuX3NjcmVlbnNoYXJlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5jYW5TY3JlZW5zaGFyZSA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGNhbl9wdWJsaXNoX2F1ZGlvICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuUHVibGlzaEF1ZGlvID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGNhbl9wdWJsaXNoX3ZpZGVvICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FuUHVibGlzaFZpZGVvID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIGNhbl9zY3JlZW5zaGFyZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhblNjcmVlbnNoYXJlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogYm9vbCBjYW5fcHVibGlzaF9hdWRpbyA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhblB1Ymxpc2hBdWRpbyAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmNhblB1Ymxpc2hBdWRpbyk7XG4gICAgICAgIC8qIGJvb2wgY2FuX3B1Ymxpc2hfdmlkZW8gPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8gIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5jYW5QdWJsaXNoVmlkZW8pO1xuICAgICAgICAvKiBib29sIGNhbl9zY3JlZW5zaGFyZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhblNjcmVlbnNoYXJlICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuY2FuU2NyZWVuc2hhcmUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50c1xuICovXG5jb25zdCBDYWxsR3JhbnRzID0gbmV3IENhbGxHcmFudHMkVHlwZSgpO1xuXG52YXIgbW9kZWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBCcm93c2VyOiBCcm93c2VyLFxuICAgIENhbGw6IENhbGwkMSxcbiAgICBDYWxsR3JhbnRzOiBDYWxsR3JhbnRzLFxuICAgIENhbGxTdGF0ZTogQ2FsbFN0YXRlJDEsXG4gICAgQ2xpZW50RGV0YWlsczogQ2xpZW50RGV0YWlscyxcbiAgICBDb2RlYzogQ29kZWMsXG4gICAgZ2V0IENvbm5lY3Rpb25RdWFsaXR5ICgpIHsgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5OyB9LFxuICAgIERldmljZTogRGV2aWNlLFxuICAgIEVycm9yOiBFcnJvciQyLFxuICAgIGdldCBFcnJvckNvZGUgKCkgeyByZXR1cm4gRXJyb3JDb2RlOyB9LFxuICAgIGdldCBHb0F3YXlSZWFzb24gKCkgeyByZXR1cm4gR29Bd2F5UmVhc29uOyB9LFxuICAgIElDRVRyaWNrbGU6IElDRVRyaWNrbGUkMSxcbiAgICBPUzogT1MsXG4gICAgUGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LFxuICAgIFBhcnRpY2lwYW50Q291bnQ6IFBhcnRpY2lwYW50Q291bnQsXG4gICAgZ2V0IFBlZXJUeXBlICgpIHsgcmV0dXJuIFBlZXJUeXBlOyB9LFxuICAgIFBpbjogUGluLFxuICAgIFNkazogU2RrLFxuICAgIGdldCBTZGtUeXBlICgpIHsgcmV0dXJuIFNka1R5cGU7IH0sXG4gICAgU3RyZWFtUXVhbGl0eTogU3RyZWFtUXVhbGl0eSxcbiAgICBUcmFja0luZm86IFRyYWNrSW5mbyxcbiAgICBnZXQgVHJhY2tUeXBlICgpIHsgcmV0dXJuIFRyYWNrVHlwZTsgfSxcbiAgICBnZXQgVHJhY2tVbnB1Ymxpc2hSZWFzb24gKCkgeyByZXR1cm4gVHJhY2tVbnB1Ymxpc2hSZWFzb247IH0sXG4gICAgVmlkZW9EaW1lbnNpb246IFZpZGVvRGltZW5zaW9uLFxuICAgIFZpZGVvTGF5ZXI6IFZpZGVvTGF5ZXIsXG4gICAgZ2V0IFZpZGVvUXVhbGl0eSAoKSB7IHJldHVybiBWaWRlb1F1YWxpdHk7IH1cbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQGdlbmVyYXRlZCBieSBwcm90b2J1Zi10cyAyLjkuMyB3aXRoIHBhcmFtZXRlciBsb25nX3R5cGVfc3RyaW5nLGNsaWVudF9nZW5lcmljLHNlcnZlcl9ub25lLGVzbGludF9kaXNhYmxlXG4vLyBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgZmlsZSBcInZpZGVvL3NmdS9zaWduYWxfcnBjL3NpZ25hbC5wcm90b1wiIChwYWNrYWdlIFwic3RyZWFtLnZpZGVvLnNmdS5zaWduYWxcIiwgc3ludGF4IHByb3RvMylcbi8vIHRzbGludDpkaXNhYmxlXG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VSZXN0YXJ0UmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwZWVyX3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5wZWVyVHlwZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlIHBlZXJfdHlwZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXF1ZXN0XG4gKi9cbmNvbnN0IElDRVJlc3RhcnRSZXF1ZXN0ID0gbmV3IElDRVJlc3RhcnRSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIElDRVJlc3RhcnRSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXNwb25zZVxuICovXG5jb25zdCBJQ0VSZXN0YXJ0UmVzcG9uc2UgPSBuZXcgSUNFUmVzdGFydFJlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ211dGVfc3RhdGVzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja011dGVTdGF0ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLm11dGVTdGF0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tNdXRlU3RhdGUgbXV0ZV9zdGF0ZXMgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdXRlU3RhdGVzLnB1c2goVHJhY2tNdXRlU3RhdGUuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZSBtdXRlX3N0YXRlcyA9IDM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5tdXRlU3RhdGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVHJhY2tNdXRlU3RhdGUuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLm11dGVTdGF0ZXNbaV0sIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0XG4gKi9cbmNvbnN0IFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0ID0gbmV3IFVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2Vycm9yJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBFcnJvciQyIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZVxuICovXG5jb25zdCBVcGRhdGVNdXRlU3RhdGVzUmVzcG9uc2UgPSBuZXcgVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrTXV0ZVN0YXRlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja011dGVTdGF0ZScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtdXRlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWNrVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgbXV0ZWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tdXRlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0cmFja190eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudHJhY2tUeXBlICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UudHJhY2tUeXBlKTtcbiAgICAgICAgLyogYm9vbCBtdXRlZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm11dGVkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UubXV0ZWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tNdXRlU3RhdGVcbiAqL1xuY29uc3QgVHJhY2tNdXRlU3RhdGUgPSBuZXcgVHJhY2tNdXRlU3RhdGUkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9NdXRlQ2hhbmdlZCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuQXVkaW9NdXRlQ2hhbmdlZCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdtdXRlZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBtdXRlZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm11dGVkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogYm9vbCBtdXRlZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm11dGVkICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UubXV0ZWQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuQXVkaW9NdXRlQ2hhbmdlZFxuICovXG5uZXcgQXVkaW9NdXRlQ2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb011dGVDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5WaWRlb011dGVDaGFuZ2VkJywgW1xuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ211dGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5tdXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBib29sIG11dGVkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXV0ZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBib29sIG11dGVkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubXV0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5tdXRlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5WaWRlb011dGVDaGFuZ2VkXG4gKi9cbm5ldyBWaWRlb011dGVDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RyYWNrcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyB0cmFja3MgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja3MucHVzaChUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5UcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgdHJhY2tzID0gMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UudHJhY2tzW2ldLCB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdFxuICovXG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCA9IG5ldyBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5VcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2VcbiAqL1xuY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlID0gbmV3IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscycsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja190eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgVHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVFlQRV8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNCwgbmFtZTogJ2RpbWVuc2lvbicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gVmlkZW9EaW1lbnNpb24gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UudHJhY2tUeXBlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tUeXBlIHRyYWNrX3R5cGUgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFja1R5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5WaWRlb0RpbWVuc2lvbiBkaW1lbnNpb24gKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1lbnNpb24gPSBWaWRlb0RpbWVuc2lvbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZGltZW5zaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHJhY2tfdHlwZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnRyYWNrVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnRyYWNrVHlwZSk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlZpZGVvRGltZW5zaW9uIGRpbWVuc2lvbiA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmRpbWVuc2lvbilcbiAgICAgICAgICAgIFZpZGVvRGltZW5zaW9uLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5kaW1lbnNpb24sIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlsc1xuICovXG5jb25zdCBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMgPSBuZXcgVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNlbmRBbnN3ZXJSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGVlcl90eXBlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnZW51bScsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gWydzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZScsIFBlZXJUeXBlLCAnUEVFUl9UWVBFXyddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZHAnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QZWVyVHlwZSBwZWVyX3R5cGUgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wZWVyVHlwZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnBlZXJUeXBlKTtcbiAgICAgICAgLyogc3RyaW5nIHNkcCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNkcCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2RwKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVxdWVzdFxuICovXG5jb25zdCBTZW5kQW5zd2VyUmVxdWVzdCA9IG5ldyBTZW5kQW5zd2VyUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZW5kQW5zd2VyUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVzcG9uc2VcbiAqL1xuY29uc3QgU2VuZEFuc3dlclJlc3BvbnNlID0gbmV3IFNlbmRBbnN3ZXJSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VUcmlja2xlUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVRyaWNrbGVSZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VUcmlja2xlUmVzcG9uc2VcbiAqL1xuY29uc3QgSUNFVHJpY2tsZVJlc3BvbnNlID0gbmV3IElDRVRyaWNrbGVSZXNwb25zZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBTZXRQdWJsaXNoZXJSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0JywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBUcmFja0luZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS50cmFja3MgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNkcCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNkcCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja0luZm8gdHJhY2tzICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJhY2tzLnB1c2goVHJhY2tJbmZvLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICAvKiBzdHJpbmcgc2Vzc2lvbl9pZCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnNlc3Npb25JZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2Uuc2Vzc2lvbklkKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIHRyYWNrcyA9IDM7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS50cmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBUcmFja0luZm8uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnRyYWNrc1tpXSwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2V0UHVibGlzaGVyUmVxdWVzdFxuICovXG5jb25zdCBTZXRQdWJsaXNoZXJSZXF1ZXN0ID0gbmV3IFNldFB1Ymxpc2hlclJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2V0UHVibGlzaGVyUmVzcG9uc2UkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlc3BvbnNlJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3NkcCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDMsIG5hbWU6ICdpY2VfcmVzdGFydCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5pY2VSZXN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpY2VfcmVzdGFydCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkVycm9yIGVycm9yICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBFcnJvciQyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBib29sIGljZV9yZXN0YXJ0ID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWNlUmVzdGFydCAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmljZVJlc3RhcnQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5FcnJvciBlcnJvciA9IDQ7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yKVxuICAgICAgICAgICAgRXJyb3IkMi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNldFB1Ymxpc2hlclJlc3BvbnNlXG4gKi9cbmNvbnN0IFNldFB1Ymxpc2hlclJlc3BvbnNlID0gbmV3IFNldFB1Ymxpc2hlclJlc3BvbnNlJFR5cGUoKTtcbi8qKlxuICogQGdlbmVyYXRlZCBTZXJ2aWNlVHlwZSBmb3IgcHJvdG9idWYgc2VydmljZSBzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TaWduYWxTZXJ2ZXJcbiAqL1xuY29uc3QgU2lnbmFsU2VydmVyID0gbmV3IFNlcnZpY2VUeXBlKCdzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TaWduYWxTZXJ2ZXInLCBbXG4gICAge1xuICAgICAgICBuYW1lOiAnU2V0UHVibGlzaGVyJyxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgIEk6IFNldFB1Ymxpc2hlclJlcXVlc3QsXG4gICAgICAgIE86IFNldFB1Ymxpc2hlclJlc3BvbnNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnU2VuZEFuc3dlcicsXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBJOiBTZW5kQW5zd2VyUmVxdWVzdCxcbiAgICAgICAgTzogU2VuZEFuc3dlclJlc3BvbnNlLFxuICAgIH0sXG4gICAgeyBuYW1lOiAnSWNlVHJpY2tsZScsIG9wdGlvbnM6IHt9LCBJOiBJQ0VUcmlja2xlJDEsIE86IElDRVRyaWNrbGVSZXNwb25zZSB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1VwZGF0ZVN1YnNjcmlwdGlvbnMnLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QsXG4gICAgICAgIE86IFVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ1VwZGF0ZU11dGVTdGF0ZXMnLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QsXG4gICAgICAgIE86IFVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ0ljZVJlc3RhcnQnLFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgSTogSUNFUmVzdGFydFJlcXVlc3QsXG4gICAgICAgIE86IElDRVJlc3RhcnRSZXNwb25zZSxcbiAgICB9LFxuXSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZy5Qcmlvcml0eVxuICovXG52YXIgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHk7XG4oZnVuY3Rpb24gKFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5KSB7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX0hJR0hfVU5TUEVDSUZJRUQgPSAwO1xuICAgICAqL1xuICAgIFZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5W1ZpZGVvTGF5ZXJTZXR0aW5nX1ByaW9yaXR5W1wiSElHSF9VTlNQRUNJRklFRFwiXSA9IDBdID0gXCJISUdIX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX0xPVyA9IDE7XG4gICAgICovXG4gICAgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbXCJMT1dcIl0gPSAxXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX01FRElVTSA9IDI7XG4gICAgICovXG4gICAgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHlbXCJNRURJVU1cIl0gPSAyXSA9IFwiTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIGVudW0gdmFsdWU6IFBSSU9SSVRZX1ZFUllfTE9XID0gMztcbiAgICAgKi9cbiAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eVtcIlZFUllfTE9XXCJdID0gM10gPSBcIlZFUllfTE9XXCI7XG59KShWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSB8fCAoVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkgPSB7fSkpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgU2Z1RXZlbnQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1RXZlbnQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3N1YnNjcmliZXJfb2ZmZXInLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gU3Vic2NyaWJlck9mZmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAncHVibGlzaGVyX2Fuc3dlcicsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQdWJsaXNoZXJBbnN3ZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhdWRpb19sZXZlbF9jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEF1ZGlvTGV2ZWxDaGFuZ2VkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaWNlX3RyaWNrbGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSUNFVHJpY2tsZSQxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNixcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hhbmdlX3B1Ymxpc2hfcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDaGFuZ2VQdWJsaXNoUXVhbGl0eSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEwLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9qb2luZWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gUGFydGljaXBhbnRKb2luZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAncGFydGljaXBhbnRfbGVmdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQYXJ0aWNpcGFudExlZnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnZG9taW5hbnRfc3BlYWtlcl9jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IERvbWluYW50U3BlYWtlckNoYW5nZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnam9pbl9yZXNwb25zZScsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAnZXZlbnRQYXlsb2FkJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBKb2luUmVzcG9uc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnaGVhbHRoX2NoZWNrX3Jlc3BvbnNlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEhlYWx0aENoZWNrUmVzcG9uc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxNixcbiAgICAgICAgICAgICAgICBuYW1lOiAndHJhY2tfcHVibGlzaGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFRyYWNrUHVibGlzaGVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMTcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3RyYWNrX3VucHVibGlzaGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFRyYWNrVW5wdWJsaXNoZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxOCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gRXJyb3IkMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDE5LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjYWxsX2dyYW50c191cGRhdGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IENhbGxHcmFudHNVcGRhdGVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMjAsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2dvX2F3YXknLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBvbmVvZjogJ2V2ZW50UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gR29Bd2F5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMjEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2ljZV9yZXN0YXJ0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IElDRVJlc3RhcnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyMixcbiAgICAgICAgICAgICAgICBuYW1lOiAncGluc191cGRhdGVkJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdldmVudFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBpbnNDaGFuZ2VkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlciBzdWJzY3JpYmVyX29mZmVyICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnc3Vic2NyaWJlck9mZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJPZmZlcjogU3Vic2NyaWJlck9mZmVyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuc3Vic2NyaWJlck9mZmVyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlciBwdWJsaXNoZXJfYW5zd2VyICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAncHVibGlzaGVyQW5zd2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlckFuc3dlcjogUHVibGlzaGVyQW5zd2VyLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQucHVibGlzaGVyQW5zd2VyKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCBjb25uZWN0aW9uX3F1YWxpdHlfY2hhbmdlZCAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb0xldmVsQ2hhbmdlZCBhdWRpb19sZXZlbF9jaGFuZ2VkICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnYXVkaW9MZXZlbENoYW5nZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9MZXZlbENoYW5nZWQ6IEF1ZGlvTGV2ZWxDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuYXVkaW9MZXZlbENoYW5nZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLklDRVRyaWNrbGUgaWNlX3RyaWNrbGUgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdpY2VUcmlja2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljZVRyaWNrbGU6IElDRVRyaWNrbGUkMS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmljZVRyaWNrbGUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHkgY2hhbmdlX3B1Ymxpc2hfcXVhbGl0eSAqLyA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2NoYW5nZVB1Ymxpc2hRdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVB1Ymxpc2hRdWFsaXR5OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eS5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNoYW5nZVB1Ymxpc2hRdWFsaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCAqLyAxMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwYXJ0aWNpcGFudEpvaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudEpvaW5lZDogUGFydGljaXBhbnRKb2luZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudEpvaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudExlZnQgcGFydGljaXBhbnRfbGVmdCAqLyAxMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwYXJ0aWNpcGFudExlZnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRMZWZ0OiBQYXJ0aWNpcGFudExlZnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudExlZnQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuRG9taW5hbnRTcGVha2VyQ2hhbmdlZCBkb21pbmFudF9zcGVha2VyX2NoYW5nZWQgKi8gMTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21pbmFudFNwZWFrZXJDaGFuZ2VkOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuZG9taW5hbnRTcGVha2VyQ2hhbmdlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2Ugam9pbl9yZXNwb25zZSAqLyAxMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdqb2luUmVzcG9uc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pblJlc3BvbnNlOiBKb2luUmVzcG9uc2UuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5qb2luUmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXNwb25zZSBoZWFsdGhfY2hlY2tfcmVzcG9uc2UgKi8gMTQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnaGVhbHRoQ2hlY2tSZXNwb25zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFsdGhDaGVja1Jlc3BvbnNlOiBIZWFsdGhDaGVja1Jlc3BvbnNlLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuaGVhbHRoQ2hlY2tSZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZCB0cmFja19wdWJsaXNoZWQgKi8gMTY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZlbnRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAndHJhY2tQdWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tQdWJsaXNoZWQ6IFRyYWNrUHVibGlzaGVkLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tQdWJsaXNoZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCB0cmFja191bnB1Ymxpc2hlZCAqLyAxNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICd0cmFja1VucHVibGlzaGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVW5wdWJsaXNoZWQ6IFRyYWNrVW5wdWJsaXNoZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC50cmFja1VucHVibGlzaGVkKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yIGVycm9yICovIDE4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV2ZW50UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBFcnJvciQxLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5ldmVudFBheWxvYWQuZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQgY2FsbF9ncmFudHNfdXBkYXRlZCAqLyAxOTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdjYWxsR3JhbnRzVXBkYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsR3JhbnRzVXBkYXRlZDogQ2FsbEdyYW50c1VwZGF0ZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5jYWxsR3JhbnRzVXBkYXRlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXkgZ29fYXdheSAqLyAyMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdnb0F3YXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ29Bd2F5OiBHb0F3YXkuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5nb0F3YXkpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCAqLyAyMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdpY2VSZXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGljZVJlc3RhcnQ6IElDRVJlc3RhcnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5pY2VSZXN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkIHBpbnNfdXBkYXRlZCAqLyAyMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ldmVudFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdwaW5zVXBkYXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaW5zVXBkYXRlZDogUGluc0NoYW5nZWQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmV2ZW50UGF5bG9hZC5waW5zVXBkYXRlZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU3Vic2NyaWJlck9mZmVyIHN1YnNjcmliZXJfb2ZmZXIgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnc3Vic2NyaWJlck9mZmVyJylcbiAgICAgICAgICAgIFN1YnNjcmliZXJPZmZlci5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnN1YnNjcmliZXJPZmZlciwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlB1Ymxpc2hlckFuc3dlciBwdWJsaXNoZXJfYW5zd2VyID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3B1Ymxpc2hlckFuc3dlcicpXG4gICAgICAgICAgICBQdWJsaXNoZXJBbnN3ZXIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5wdWJsaXNoZXJBbnN3ZXIsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgY29ubmVjdGlvbl9xdWFsaXR5X2NoYW5nZWQgPSAzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJylcbiAgICAgICAgICAgIENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxDaGFuZ2VkIGF1ZGlvX2xldmVsX2NoYW5nZWQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnYXVkaW9MZXZlbENoYW5nZWQnKVxuICAgICAgICAgICAgQXVkaW9MZXZlbENoYW5nZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5hdWRpb0xldmVsQ2hhbmdlZCwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlIGljZV90cmlja2xlID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2ljZVRyaWNrbGUnKVxuICAgICAgICAgICAgSUNFVHJpY2tsZSQxLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuaWNlVHJpY2tsZSwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNoYW5nZVB1Ymxpc2hRdWFsaXR5IGNoYW5nZV9wdWJsaXNoX3F1YWxpdHkgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnY2hhbmdlUHVibGlzaFF1YWxpdHknKVxuICAgICAgICAgICAgQ2hhbmdlUHVibGlzaFF1YWxpdHkuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5jaGFuZ2VQdWJsaXNoUXVhbGl0eSwgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkIHBhcnRpY2lwYW50X2pvaW5lZCA9IDEwOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncGFydGljaXBhbnRKb2luZWQnKVxuICAgICAgICAgICAgUGFydGljaXBhbnRKb2luZWQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5wYXJ0aWNpcGFudEpvaW5lZCwgd3JpdGVyLnRhZygxMCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QYXJ0aWNpcGFudExlZnQgcGFydGljaXBhbnRfbGVmdCA9IDExOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAncGFydGljaXBhbnRMZWZ0JylcbiAgICAgICAgICAgIFBhcnRpY2lwYW50TGVmdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLnBhcnRpY2lwYW50TGVmdCwgd3JpdGVyLnRhZygxMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Eb21pbmFudFNwZWFrZXJDaGFuZ2VkIGRvbWluYW50X3NwZWFrZXJfY2hhbmdlZCA9IDEyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnZG9taW5hbnRTcGVha2VyQ2hhbmdlZCcpXG4gICAgICAgICAgICBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuZG9taW5hbnRTcGVha2VyQ2hhbmdlZCwgd3JpdGVyLnRhZygxMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVzcG9uc2Ugam9pbl9yZXNwb25zZSA9IDEzOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnam9pblJlc3BvbnNlJylcbiAgICAgICAgICAgIEpvaW5SZXNwb25zZS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmpvaW5SZXNwb25zZSwgd3JpdGVyLnRhZygxMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1Jlc3BvbnNlIGhlYWx0aF9jaGVja19yZXNwb25zZSA9IDE0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnaGVhbHRoQ2hlY2tSZXNwb25zZScpXG4gICAgICAgICAgICBIZWFsdGhDaGVja1Jlc3BvbnNlLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuaGVhbHRoQ2hlY2tSZXNwb25zZSwgd3JpdGVyLnRhZygxNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZCB0cmFja19wdWJsaXNoZWQgPSAxNjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3RyYWNrUHVibGlzaGVkJylcbiAgICAgICAgICAgIFRyYWNrUHVibGlzaGVkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tQdWJsaXNoZWQsIHdyaXRlci50YWcoMTYsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCB0cmFja191bnB1Ymxpc2hlZCA9IDE3OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpXG4gICAgICAgICAgICBUcmFja1VucHVibGlzaGVkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQudHJhY2tVbnB1Ymxpc2hlZCwgd3JpdGVyLnRhZygxNywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5FcnJvciBlcnJvciA9IDE4OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnZXJyb3InKVxuICAgICAgICAgICAgRXJyb3IkMS5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLmVycm9yLCB3cml0ZXIudGFnKDE4LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNhbGxHcmFudHNVcGRhdGVkIGNhbGxfZ3JhbnRzX3VwZGF0ZWQgPSAxOTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2NhbGxHcmFudHNVcGRhdGVkJylcbiAgICAgICAgICAgIENhbGxHcmFudHNVcGRhdGVkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuY2FsbEdyYW50c1VwZGF0ZWQsIHdyaXRlci50YWcoMTksIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5IGdvX2F3YXkgPSAyMDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ2dvQXdheScpXG4gICAgICAgICAgICBHb0F3YXkuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmV2ZW50UGF5bG9hZC5nb0F3YXksIHdyaXRlci50YWcoMjAsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSUNFUmVzdGFydCBpY2VfcmVzdGFydCA9IDIxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudFBheWxvYWQub25lb2ZLaW5kID09PSAnaWNlUmVzdGFydCcpXG4gICAgICAgICAgICBJQ0VSZXN0YXJ0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQuaWNlUmVzdGFydCwgd3JpdGVyLnRhZygyMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QaW5zQ2hhbmdlZCBwaW5zX3VwZGF0ZWQgPSAyMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZCA9PT0gJ3BpbnNVcGRhdGVkJylcbiAgICAgICAgICAgIFBpbnNDaGFuZ2VkLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5ldmVudFBheWxvYWQucGluc1VwZGF0ZWQsIHdyaXRlci50YWcoMjIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlNmdUV2ZW50XG4gKi9cbmNvbnN0IFNmdUV2ZW50ID0gbmV3IFNmdUV2ZW50JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBpbnNDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBpbnNDaGFuZ2VkJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwaW5zJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBQaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5waW5zID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBpbiBwaW5zICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGlucy5wdXNoKFBpbi5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGluIHBpbnMgPSAxOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGlucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFBpbi5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGluc1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QaW5zQ2hhbmdlZFxuICovXG5jb25zdCBQaW5zQ2hhbmdlZCA9IG5ldyBQaW5zQ2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBFcnJvciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5FcnJvcicsIFtcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdlcnJvcicsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gRXJyb3IkMiB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lcnJvciA9IEVycm9yJDIuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuRXJyb3IgZXJyb3IgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgIEVycm9yJDIuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmVycm9yLCB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkVycm9yXG4gKi9cbmNvbnN0IEVycm9yJDEgPSBuZXcgRXJyb3IkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSUNFVHJpY2tsZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VUcmlja2xlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwZWVyX3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlBlZXJUeXBlJywgUGVlclR5cGUsICdQRUVSX1RZUEVfJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdpY2VfY2FuZGlkYXRlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5pY2VDYW5kaWRhdGUgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgaWNlX2NhbmRpZGF0ZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZUNhbmRpZGF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgICAgIC8qIHN0cmluZyBpY2VfY2FuZGlkYXRlID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWNlQ2FuZGlkYXRlICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5JQ0VUcmlja2xlXG4gKi9cbmNvbnN0IElDRVRyaWNrbGUgPSBuZXcgSUNFVHJpY2tsZSRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBJQ0VSZXN0YXJ0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVJlc3RhcnQnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3BlZXJfdHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFsnc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUnLCBQZWVyVHlwZSwgJ1BFRVJfVFlQRV8nXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnBlZXJUeXBlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVlclR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGVlclR5cGUgcGVlcl90eXBlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGVlclR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5wZWVyVHlwZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LklDRVJlc3RhcnRcbiAqL1xuY29uc3QgSUNFUmVzdGFydCA9IG5ldyBJQ0VSZXN0YXJ0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFNmdVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1UmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnam9pbl9yZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgb25lb2Y6ICdyZXF1ZXN0UGF5bG9hZCcsXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gSm9pblJlcXVlc3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdoZWFsdGhfY2hlY2tfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIG9uZW9mOiAncmVxdWVzdFBheWxvYWQnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEhlYWx0aENoZWNrUmVxdWVzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnJlcXVlc3RQYXlsb2FkID0geyBvbmVvZktpbmQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXF1ZXN0IGpvaW5fcmVxdWVzdCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25lb2ZLaW5kOiAnam9pblJlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgam9pblJlcXVlc3Q6IEpvaW5SZXF1ZXN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5qb2luUmVxdWVzdCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1JlcXVlc3QgaGVhbHRoX2NoZWNrX3JlcXVlc3QgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0UGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2hlYWx0aENoZWNrUmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFsdGhDaGVja1JlcXVlc3Q6IEhlYWx0aENoZWNrUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UucmVxdWVzdFBheWxvYWQuaGVhbHRoQ2hlY2tSZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVxdWVzdCBqb2luX3JlcXVlc3QgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5vbmVvZktpbmQgPT09ICdqb2luUmVxdWVzdCcpXG4gICAgICAgICAgICBKb2luUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucmVxdWVzdFBheWxvYWQuam9pblJlcXVlc3QsIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1JlcXVlc3QgaGVhbHRoX2NoZWNrX3JlcXVlc3QgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5vbmVvZktpbmQgPT09ICdoZWFsdGhDaGVja1JlcXVlc3QnKVxuICAgICAgICAgICAgSGVhbHRoQ2hlY2tSZXF1ZXN0LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5yZXF1ZXN0UGF5bG9hZC5oZWFsdGhDaGVja1JlcXVlc3QsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuU2Z1UmVxdWVzdFxuICovXG5jb25zdCBTZnVSZXF1ZXN0ID0gbmV3IFNmdVJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSGVhbHRoQ2hlY2tSZXF1ZXN0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVxdWVzdCcsIFtdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSGVhbHRoQ2hlY2tSZXF1ZXN0XG4gKi9cbmNvbnN0IEhlYWx0aENoZWNrUmVxdWVzdCA9IG5ldyBIZWFsdGhDaGVja1JlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSGVhbHRoQ2hlY2tSZXNwb25zZSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5IZWFsdGhDaGVja1Jlc3BvbnNlJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwYXJ0aWNpcGFudF9jb3VudCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFBhcnRpY2lwYW50Q291bnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQgPSBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5wYXJ0aWNpcGFudENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnRDb3VudCBwYXJ0aWNpcGFudF9jb3VudCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50Q291bnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudENvdW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudENvdW50LCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkhlYWx0aENoZWNrUmVzcG9uc2VcbiAqL1xuY29uc3QgSGVhbHRoQ2hlY2tSZXNwb25zZSA9IG5ldyBIZWFsdGhDaGVja1Jlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFRyYWNrUHVibGlzaGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrUHVibGlzaGVkJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUnLFxuICAgICAgICAgICAgICAgICAgICBUcmFja1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICdUUkFDS19UWVBFXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA0LCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnVzZXJJZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9ICcnO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudCwgd3JpdGVyLnRhZyg0LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1B1Ymxpc2hlZFxuICovXG5jb25zdCBUcmFja1B1Ymxpc2hlZCA9IG5ldyBUcmFja1B1Ymxpc2hlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBUcmFja1VucHVibGlzaGVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlRyYWNrVW5wdWJsaXNoZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndHlwZScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgJ1RSQUNLX1RZUEVfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2F1c2UnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1VucHVibGlzaFJlYXNvbicsXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVW5wdWJsaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAnVFJBQ0tfVU5QVUJMSVNIX1JFQVNPTl8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBubzogNSwgbmFtZTogJ3BhcnRpY2lwYW50Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBQYXJ0aWNpcGFudCB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS51c2VySWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgbWVzc2FnZS5jYXVzZSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVHlwZSB0eXBlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrVW5wdWJsaXNoUmVhc29uIGNhdXNlICovIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F1c2UgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5UcmFja1R5cGUgdHlwZSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tVbnB1Ymxpc2hSZWFzb24gY2F1c2UgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jYXVzZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmNhdXNlKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0aWNpcGFudClcbiAgICAgICAgICAgIFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5wYXJ0aWNpcGFudCwgd3JpdGVyLnRhZyg1LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5UcmFja1VucHVibGlzaGVkXG4gKi9cbmNvbnN0IFRyYWNrVW5wdWJsaXNoZWQgPSBuZXcgVHJhY2tVbnB1Ymxpc2hlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBKb2luUmVxdWVzdCRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Kb2luUmVxdWVzdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd0b2tlbicsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlcl9zZHAnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogNCxcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xpZW50X2RldGFpbHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBDbGllbnREZXRhaWxzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDUsIG5hbWU6ICdtaWdyYXRpb24nLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IE1pZ3JhdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA2LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdmYXN0X3JlY29ubmVjdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudG9rZW4gPSAnJztcbiAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSAnJztcbiAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVyU2RwID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuZmFzdFJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdG9rZW4gKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc3Vic2NyaWJlcl9zZHAgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpYmVyU2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNsaWVudERldGFpbHMgY2xpZW50X2RldGFpbHMgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGllbnREZXRhaWxzID0gQ2xpZW50RGV0YWlscy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY2xpZW50RGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb24gbWlncmF0aW9uICovIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWlncmF0aW9uID0gTWlncmF0aW9uLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5taWdyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgZmFzdF9yZWNvbm5lY3QgKi8gNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mYXN0UmVjb25uZWN0ID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHRva2VuID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW4gIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnRva2VuKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmluZyBzdWJzY3JpYmVyX3NkcCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnN1YnNjcmliZXJTZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnN1YnNjcmliZXJTZHApO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DbGllbnREZXRhaWxzIGNsaWVudF9kZXRhaWxzID0gNDsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2xpZW50RGV0YWlscylcbiAgICAgICAgICAgIENsaWVudERldGFpbHMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNsaWVudERldGFpbHMsIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5NaWdyYXRpb24gbWlncmF0aW9uID0gNTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWlncmF0aW9uKVxuICAgICAgICAgICAgTWlncmF0aW9uLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5taWdyYXRpb24sIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogYm9vbCBmYXN0X3JlY29ubmVjdCA9IDY7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmZhc3RSZWNvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5mYXN0UmVjb25uZWN0KTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuSm9pblJlcXVlc3RcbiAqL1xuY29uc3QgSm9pblJlcXVlc3QgPSBuZXcgSm9pblJlcXVlc3QkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgTWlncmF0aW9uJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50Lk1pZ3JhdGlvbicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnZnJvbV9zZnVfaWQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMixcbiAgICAgICAgICAgICAgICBuYW1lOiAnYW5ub3VuY2VkX3RyYWNrcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tJbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnc3Vic2NyaXB0aW9ucycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuZnJvbVNmdUlkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuYW5ub3VuY2VkVHJhY2tzID0gW107XG4gICAgICAgIG1lc3NhZ2Uuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgZnJvbV9zZnVfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tU2Z1SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuVHJhY2tJbmZvIGFubm91bmNlZF90cmFja3MgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbm5vdW5jZWRUcmFja3MucHVzaChUcmFja0luZm8uaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzIHN1YnNjcmlwdGlvbnMgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzY3JpcHRpb25zLnB1c2goVHJhY2tTdWJzY3JpcHRpb25EZXRhaWxzLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgZnJvbV9zZnVfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5mcm9tU2Z1SWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmZyb21TZnVJZCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlRyYWNrSW5mbyBhbm5vdW5jZWRfdHJhY2tzID0gMjsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmFubm91bmNlZFRyYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFRyYWNrSW5mby5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuYW5ub3VuY2VkVHJhY2tzW2ldLCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyBzdWJzY3JpcHRpb25zID0gMzsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnN1YnNjcmlwdGlvbnNbaV0sIHdyaXRlci50YWcoMywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuTWlncmF0aW9uXG4gKi9cbmNvbnN0IE1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24kVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgSm9pblJlc3BvbnNlJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZScsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdjYWxsX3N0YXRlJywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBDYWxsU3RhdGUkMSB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3JlY29ubmVjdGVkJywga2luZDogJ3NjYWxhcicsIFQ6IDggLypTY2FsYXJUeXBlLkJPT0wqLyB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5yZWNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5DYWxsU3RhdGUgY2FsbF9zdGF0ZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbGxTdGF0ZSA9IENhbGxTdGF0ZSQxLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jYWxsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgcmVjb25uZWN0ZWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWNvbm5lY3RlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxTdGF0ZSBjYWxsX3N0YXRlID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FsbFN0YXRlKVxuICAgICAgICAgICAgQ2FsbFN0YXRlJDEuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNhbGxTdGF0ZSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBib29sIHJlY29ubmVjdGVkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucmVjb25uZWN0ZWQgIT09IGZhbHNlKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5WYXJpbnQpLmJvb2wobWVzc2FnZS5yZWNvbm5lY3RlZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkpvaW5SZXNwb25zZVxuICovXG5jb25zdCBKb2luUmVzcG9uc2UgPSBuZXcgSm9pblJlc3BvbnNlJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFBhcnRpY2lwYW50Sm9pbmVkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50Sm9pbmVkJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ2NhbGxfY2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAncGFydGljaXBhbnQnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IFBhcnRpY2lwYW50IH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmNhbGxDaWQgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIGNhbGxfY2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FsbENpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhcnRpY2lwYW50ID0gUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLnBhcnRpY2lwYW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIGNhbGxfY2lkID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2FsbENpZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UuY2FsbENpZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLlBhcnRpY2lwYW50IHBhcnRpY2lwYW50ID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydGljaXBhbnQpXG4gICAgICAgICAgICBQYXJ0aWNpcGFudC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UucGFydGljaXBhbnQsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuUGFydGljaXBhbnRKb2luZWRcbiAqL1xuY29uc3QgUGFydGljaXBhbnRKb2luZWQgPSBuZXcgUGFydGljaXBhbnRKb2luZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgUGFydGljaXBhbnRMZWZ0JFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICdjYWxsX2NpZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3BhcnRpY2lwYW50Jywga2luZDogJ21lc3NhZ2UnLCBUOiAoKSA9PiBQYXJ0aWNpcGFudCB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jYWxsQ2lkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBjYWxsX2NpZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhbGxDaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuUGFydGljaXBhbnQgcGFydGljaXBhbnQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0aWNpcGFudCA9IFBhcnRpY2lwYW50LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5wYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmluZyBjYWxsX2NpZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNhbGxDaWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLmNhbGxDaWQpO1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5QYXJ0aWNpcGFudCBwYXJ0aWNpcGFudCA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnBhcnRpY2lwYW50KVxuICAgICAgICAgICAgUGFydGljaXBhbnQuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLnBhcnRpY2lwYW50LCB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlBhcnRpY2lwYW50TGVmdFxuICovXG5jb25zdCBQYXJ0aWNpcGFudExlZnQgPSBuZXcgUGFydGljaXBhbnRMZWZ0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFN1YnNjcmliZXJPZmZlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5TdWJzY3JpYmVyT2ZmZXInLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnaWNlX3Jlc3RhcnQnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2RwJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5zZHAgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBpY2VfcmVzdGFydCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmljZVJlc3RhcnQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZHAgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZHAgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGJvb2wgaWNlX3Jlc3RhcnQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pY2VSZXN0YXJ0ICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaWNlUmVzdGFydCk7XG4gICAgICAgIC8qIHN0cmluZyBzZHAgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZHAgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNkcCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlN1YnNjcmliZXJPZmZlclxuICovXG5jb25zdCBTdWJzY3JpYmVyT2ZmZXIgPSBuZXcgU3Vic2NyaWJlck9mZmVyJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFB1Ymxpc2hlckFuc3dlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QdWJsaXNoZXJBbnN3ZXInLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnc2RwJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLnNkcCA9ICcnO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2RwICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2RwID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgc2RwID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2RwICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZHApO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5QdWJsaXNoZXJBbnN3ZXJcbiAqL1xuY29uc3QgUHVibGlzaGVyQW5zd2VyID0gbmV3IFB1Ymxpc2hlckFuc3dlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0aW9uX3F1YWxpdHlfdXBkYXRlcycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQ29ubmVjdGlvblF1YWxpdHlJbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHJlcGVhdGVkIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvIGNvbm5lY3Rpb25fcXVhbGl0eV91cGRhdGVzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHlVcGRhdGVzLnB1c2goQ29ubmVjdGlvblF1YWxpdHlJbmZvLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5SW5mbyBjb25uZWN0aW9uX3F1YWxpdHlfdXBkYXRlcyA9IDE7ICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBDb25uZWN0aW9uUXVhbGl0eUluZm8uaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlc1tpXSwgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcbiAqL1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gbmV3IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDb25uZWN0aW9uUXVhbGl0eUluZm8kVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ29ubmVjdGlvblF1YWxpdHlJbmZvJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ3VzZXJfaWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdzZXNzaW9uX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25fcXVhbGl0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGlvblF1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgICdDT05ORUNUSU9OX1FVQUxJVFlfJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgdXNlcl9pZCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVzZXJJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgc2Vzc2lvbl9pZCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlc3Npb25JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db25uZWN0aW9uUXVhbGl0eSBjb25uZWN0aW9uX3F1YWxpdHkgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb25uZWN0aW9uUXVhbGl0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5IGNvbm5lY3Rpb25fcXVhbGl0eSA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmNvbm5lY3Rpb25RdWFsaXR5ICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5WYXJpbnQpLmludDMyKG1lc3NhZ2UuY29ubmVjdGlvblF1YWxpdHkpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Db25uZWN0aW9uUXVhbGl0eUluZm9cbiAqL1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlJbmZvID0gbmV3IENvbm5lY3Rpb25RdWFsaXR5SW5mbyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBEb21pbmFudFNwZWFrZXJDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkRvbWluYW50U3BlYWtlckNoYW5nZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAndXNlcl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMiwgbmFtZTogJ3Nlc3Npb25faWQnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyB1c2VyX2lkICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudXNlcklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmluZyBzZXNzaW9uX2lkICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgdXNlcl9pZCA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLnVzZXJJZCAhPT0gJycpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuc3RyaW5nKG1lc3NhZ2UudXNlcklkKTtcbiAgICAgICAgLyogc3RyaW5nIHNlc3Npb25faWQgPSAyOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zZXNzaW9uSWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnNlc3Npb25JZCk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkRvbWluYW50U3BlYWtlckNoYW5nZWRcbiAqL1xuY29uc3QgRG9taW5hbnRTcGVha2VyQ2hhbmdlZCA9IG5ldyBEb21pbmFudFNwZWFrZXJDaGFuZ2VkJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEF1ZGlvTGV2ZWwkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbCcsIFtcbiAgICAgICAgICAgIHsgbm86IDEsIG5hbWU6ICd1c2VyX2lkJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnc2Vzc2lvbl9pZCcsIGtpbmQ6ICdzY2FsYXInLCBUOiA5IC8qU2NhbGFyVHlwZS5TVFJJTkcqLyB9LFxuICAgICAgICAgICAgeyBubzogMywgbmFtZTogJ2xldmVsJywga2luZDogJ3NjYWxhcicsIFQ6IDIgLypTY2FsYXJUeXBlLkZMT0FUKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDQsIG5hbWU6ICdpc19zcGVha2luZycsIGtpbmQ6ICdzY2FsYXInLCBUOiA4IC8qU2NhbGFyVHlwZS5CT09MKi8gfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UudXNlcklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2Uuc2Vzc2lvbklkID0gJyc7XG4gICAgICAgIG1lc3NhZ2UubGV2ZWwgPSAwO1xuICAgICAgICBtZXNzYWdlLmlzU3BlYWtpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHVzZXJfaWQgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51c2VySWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyaW5nIHNlc3Npb25faWQgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXNzaW9uSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogZmxvYXQgbGV2ZWwgKi8gMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZXZlbCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGJvb2wgaXNfc3BlYWtpbmcgKi8gNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc1NwZWFraW5nID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogc3RyaW5nIHVzZXJfaWQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS51c2VySWQgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLnVzZXJJZCk7XG4gICAgICAgIC8qIHN0cmluZyBzZXNzaW9uX2lkID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vzc2lvbklkICE9PSAnJylcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5zdHJpbmcobWVzc2FnZS5zZXNzaW9uSWQpO1xuICAgICAgICAvKiBmbG9hdCBsZXZlbCA9IDM7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmxldmVsICE9PSAwKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5CaXQzMikuZmxvYXQobWVzc2FnZS5sZXZlbCk7XG4gICAgICAgIC8qIGJvb2wgaXNfc3BlYWtpbmcgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5pc1NwZWFraW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIHdyaXRlci50YWcoNCwgV2lyZVR5cGUuVmFyaW50KS5ib29sKG1lc3NhZ2UuaXNTcGVha2luZyk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxcbiAqL1xuY29uc3QgQXVkaW9MZXZlbCA9IG5ldyBBdWRpb0xldmVsJFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIEF1ZGlvTGV2ZWxDaGFuZ2VkJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWxDaGFuZ2VkJywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdhdWRpb19sZXZlbHMnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICByZXBlYXQ6IDEgLypSZXBlYXRUeXBlLlBBQ0tFRCovLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEF1ZGlvTGV2ZWwsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5hdWRpb0xldmVscyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWwgYXVkaW9fbGV2ZWxzICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXVkaW9MZXZlbHMucHVzaChBdWRpb0xldmVsLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTGV2ZWwgYXVkaW9fbGV2ZWxzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmF1ZGlvTGV2ZWxzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgQXVkaW9MZXZlbC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuYXVkaW9MZXZlbHNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9MZXZlbENoYW5nZWRcbiAqL1xuY29uc3QgQXVkaW9MZXZlbENoYW5nZWQgPSBuZXcgQXVkaW9MZXZlbENoYW5nZWQkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQXVkaW9NZWRpYVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2NoYW5uZWxfY291bnQnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDUgLypTY2FsYXJUeXBlLklOVDMyKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5jaGFubmVsQ291bnQgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBjaGFubmVsX2NvdW50ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhbm5lbENvdW50ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIGludDMyIGNoYW5uZWxfY291bnQgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jaGFubmVsQ291bnQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5jaGFubmVsQ291bnQpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb01lZGlhUmVxdWVzdFxuICovXG5jb25zdCBBdWRpb01lZGlhUmVxdWVzdCA9IG5ldyBBdWRpb01lZGlhUmVxdWVzdCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBBdWRpb1NlbmRlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb1NlbmRlcicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbWVkaWFfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IEF1ZGlvTWVkaWFSZXF1ZXN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdjb2RlYycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ29kZWMgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVmbGVjdGlvbk1lcmdlUGFydGlhbCh0aGlzLCBtZXNzYWdlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCBsZW5ndGgsIG9wdGlvbnMsIHRhcmdldCkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRhcmdldCA/PyB0aGlzLmNyZWF0ZSgpLCBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgbGV0IFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkTm8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9NZWRpYVJlcXVlc3QgbWVkaWFfcmVxdWVzdCAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lZGlhUmVxdWVzdCA9IEF1ZGlvTWVkaWFSZXF1ZXN0LmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5tZWRpYVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjICovIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZWRpYVJlcXVlc3QpXG4gICAgICAgICAgICBBdWRpb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubWVkaWFSZXF1ZXN0LCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZWMpXG4gICAgICAgICAgICBDb2RlYy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY29kZWMsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQXVkaW9TZW5kZXJcbiAqL1xuY29uc3QgQXVkaW9TZW5kZXIgPSBuZXcgQXVkaW9TZW5kZXIkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgVmlkZW9NZWRpYVJlcXVlc3QkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9NZWRpYVJlcXVlc3QnLCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2lkZWFsX2hlaWdodCcsXG4gICAgICAgICAgICAgICAga2luZDogJ3NjYWxhcicsXG4gICAgICAgICAgICAgICAgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiAyLCBuYW1lOiAnaWRlYWxfd2lkdGgnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAzLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdpZGVhbF9mcmFtZV9yYXRlJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnc2NhbGFyJyxcbiAgICAgICAgICAgICAgICBUOiA1IC8qU2NhbGFyVHlwZS5JTlQzMiovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2xvYmFsVGhpcy5PYmplY3QuY3JlYXRlKHRoaXMubWVzc2FnZVByb3RvdHlwZSk7XG4gICAgICAgIG1lc3NhZ2UuaWRlYWxIZWlnaHQgPSAwO1xuICAgICAgICBtZXNzYWdlLmlkZWFsV2lkdGggPSAwO1xuICAgICAgICBtZXNzYWdlLmlkZWFsRnJhbWVSYXRlID0gMDtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogaW50MzIgaWRlYWxfaGVpZ2h0ICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlYWxIZWlnaHQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBpZGVhbF93aWR0aCAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkZWFsV2lkdGggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBpbnQzMiBpZGVhbF9mcmFtZV9yYXRlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlYWxGcmFtZVJhdGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogaW50MzIgaWRlYWxfaGVpZ2h0ID0gMTsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlYWxIZWlnaHQgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5pZGVhbEhlaWdodCk7XG4gICAgICAgIC8qIGludDMyIGlkZWFsX3dpZHRoID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlYWxXaWR0aCAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLmlkZWFsV2lkdGgpO1xuICAgICAgICAvKiBpbnQzMiBpZGVhbF9mcmFtZV9yYXRlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuaWRlYWxGcmFtZVJhdGUgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDMsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5pZGVhbEZyYW1lUmF0ZSk7XG4gICAgICAgIGxldCB1ID0gb3B0aW9ucy53cml0ZVVua25vd25GaWVsZHM7XG4gICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICh1ID09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uV3JpdGUgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH1cbn1cbi8qKlxuICogQGdlbmVyYXRlZCBNZXNzYWdlVHlwZSBmb3IgcHJvdG9idWYgbWVzc2FnZSBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTWVkaWFSZXF1ZXN0XG4gKi9cbmNvbnN0IFZpZGVvTWVkaWFSZXF1ZXN0ID0gbmV3IFZpZGVvTWVkaWFSZXF1ZXN0JFR5cGUoKTtcbi8vIEBnZW5lcmF0ZWQgbWVzc2FnZSB0eXBlIHdpdGggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiwgbWF5IHByb3ZpZGUgc3BlZWQgb3B0aW1pemVkIG1ldGhvZHNcbmNsYXNzIFZpZGVvTGF5ZXJTZXR0aW5nJFR5cGUgZXh0ZW5kcyBNZXNzYWdlVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nJywgW1xuICAgICAgICAgICAgeyBubzogMSwgbmFtZTogJ25hbWUnLCBraW5kOiAnc2NhbGFyJywgVDogOSAvKlNjYWxhclR5cGUuU1RSSU5HKi8gfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdhY3RpdmUnLCBraW5kOiAnc2NhbGFyJywgVDogOCAvKlNjYWxhclR5cGUuQk9PTCovIH0sXG4gICAgICAgICAgICB7IG5vOiAzLCBuYW1lOiAnbWF4X2JpdHJhdGUnLCBraW5kOiAnc2NhbGFyJywgVDogNSAvKlNjYWxhclR5cGUuSU5UMzIqLyB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA0LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnknLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDIgLypTY2FsYXJUeXBlLkZMT0FUKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiA1LFxuICAgICAgICAgICAgICAgIG5hbWU6ICdwcmlvcml0eScsXG4gICAgICAgICAgICAgICAga2luZDogJ2VudW0nLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHknLFxuICAgICAgICAgICAgICAgICAgICBWaWRlb0xheWVyU2V0dGluZ19Qcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgICAgJ1BSSU9SSVRZXycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IG5vOiA2LCBuYW1lOiAnY29kZWMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENvZGVjIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm86IDcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ21heF9mcmFtZXJhdGUnLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdzY2FsYXInLFxuICAgICAgICAgICAgICAgIFQ6IDEzIC8qU2NhbGFyVHlwZS5VSU5UMzIqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAnJztcbiAgICAgICAgbWVzc2FnZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5tYXhCaXRyYXRlID0gMDtcbiAgICAgICAgbWVzc2FnZS5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSAwO1xuICAgICAgICBtZXNzYWdlLnByaW9yaXR5ID0gMDtcbiAgICAgICAgbWVzc2FnZS5tYXhGcmFtZXJhdGUgPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbmFtZSAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgLyogYm9vbCBhY3RpdmUgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3RpdmUgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGludDMyIG1heF9iaXRyYXRlICovIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4Qml0cmF0ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIGZsb2F0IHNjYWxlX3Jlc29sdXRpb25fZG93bl9ieSAqLyA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHkgcHJpb3JpdHkgKi8gNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmlvcml0eSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjICovIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZWMgPSBDb2RlYy5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UuY29kZWMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC8qIHVpbnQzMiBtYXhfZnJhbWVyYXRlICovIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4RnJhbWVyYXRlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJpbmcgbmFtZSA9IDE7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAvKiBib29sIGFjdGl2ZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGl2ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB3cml0ZXIudGFnKDIsIFdpcmVUeXBlLlZhcmludCkuYm9vbChtZXNzYWdlLmFjdGl2ZSk7XG4gICAgICAgIC8qIGludDMyIG1heF9iaXRyYXRlID0gMzsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4Qml0cmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoMywgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLm1heEJpdHJhdGUpO1xuICAgICAgICAvKiBmbG9hdCBzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgPSA0OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5zY2FsZVJlc29sdXRpb25Eb3duQnkgIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDQsIFdpcmVUeXBlLkJpdDMyKS5mbG9hdChtZXNzYWdlLnNjYWxlUmVzb2x1dGlvbkRvd25CeSk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuVmlkZW9MYXllclNldHRpbmcuUHJpb3JpdHkgcHJpb3JpdHkgPSA1OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5wcmlvcml0eSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNSwgV2lyZVR5cGUuVmFyaW50KS5pbnQzMihtZXNzYWdlLnByaW9yaXR5KTtcbiAgICAgICAgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ29kZWMgY29kZWMgPSA2OyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jb2RlYylcbiAgICAgICAgICAgIENvZGVjLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5jb2RlYywgd3JpdGVyLnRhZyg2LCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiB1aW50MzIgbWF4X2ZyYW1lcmF0ZSA9IDc7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1heEZyYW1lcmF0ZSAhPT0gMClcbiAgICAgICAgICAgIHdyaXRlci50YWcoNywgV2lyZVR5cGUuVmFyaW50KS51aW50MzIobWVzc2FnZS5tYXhGcmFtZXJhdGUpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZ1xuICovXG5jb25zdCBWaWRlb0xheWVyU2V0dGluZyA9IG5ldyBWaWRlb0xheWVyU2V0dGluZyRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBWaWRlb1NlbmRlciRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlcicsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbWVkaWFfcmVxdWVzdCcsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIFQ6ICgpID0+IFZpZGVvTWVkaWFSZXF1ZXN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdjb2RlYycsIGtpbmQ6ICdtZXNzYWdlJywgVDogKCkgPT4gQ29kZWMgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbGF5ZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb0xheWVyU2V0dGluZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmxheWVycyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZWRpYVJlcXVlc3QgPSBWaWRlb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMsIG1lc3NhZ2UubWVkaWFSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Db2RlYyBjb2RlYyAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGVjID0gQ29kZWMuaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpLCBvcHRpb25zLCBtZXNzYWdlLmNvZGVjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTGF5ZXJTZXR0aW5nIGxheWVycyAqLyAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxheWVycy5wdXNoKFZpZGVvTGF5ZXJTZXR0aW5nLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG9wdGlvbnMucmVhZFVua25vd25GaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09ICd0aHJvdycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcihgVW5rbm93biBmaWVsZCAke2ZpZWxkTm99ICh3aXJlIHR5cGUgJHt3aXJlVHlwZX0pIGZvciAke3RoaXMudHlwZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gcmVhZGVyLnNraXAod2lyZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAodSA9PT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25SZWFkIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBpbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAvKiBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvTWVkaWFSZXF1ZXN0IG1lZGlhX3JlcXVlc3QgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5tZWRpYVJlcXVlc3QpXG4gICAgICAgICAgICBWaWRlb01lZGlhUmVxdWVzdC5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UubWVkaWFSZXF1ZXN0LCB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuZm9yaygpLCBvcHRpb25zKS5qb2luKCk7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNvZGVjIGNvZGVjID0gMjsgKi9cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZWMpXG4gICAgICAgICAgICBDb2RlYy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY29kZWMsIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb0xheWVyU2V0dGluZyBsYXllcnMgPSAzOyAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UubGF5ZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgVmlkZW9MYXllclNldHRpbmcuaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLmxheWVyc1tpXSwgd3JpdGVyLnRhZygzLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlclxuICovXG5jb25zdCBWaWRlb1NlbmRlciA9IG5ldyBWaWRlb1NlbmRlciRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBDaGFuZ2VQdWJsaXNoUXVhbGl0eSRUeXBlIGV4dGVuZHMgTWVzc2FnZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DaGFuZ2VQdWJsaXNoUXVhbGl0eScsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBubzogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXVkaW9fc2VuZGVycycsXG4gICAgICAgICAgICAgICAga2luZDogJ21lc3NhZ2UnLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogMSAvKlJlcGVhdFR5cGUuUEFDS0VEKi8sXG4gICAgICAgICAgICAgICAgVDogKCkgPT4gQXVkaW9TZW5kZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAyLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd2aWRlb19zZW5kZXJzJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgcmVwZWF0OiAxIC8qUmVwZWF0VHlwZS5QQUNLRUQqLyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBWaWRlb1NlbmRlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLmF1ZGlvU2VuZGVycyA9IFtdO1xuICAgICAgICBtZXNzYWdlLnZpZGVvU2VuZGVycyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LkF1ZGlvU2VuZGVyIGF1ZGlvX3NlbmRlcnMgKi8gMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdWRpb1NlbmRlcnMucHVzaChBdWRpb1NlbmRlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiByZXBlYXRlZCBzdHJlYW0udmlkZW8uc2Z1LmV2ZW50LlZpZGVvU2VuZGVyIHZpZGVvX3NlbmRlcnMgKi8gMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52aWRlb1NlbmRlcnMucHVzaChWaWRlb1NlbmRlci5pbnRlcm5hbEJpbmFyeVJlYWQocmVhZGVyLCByZWFkZXIudWludDMyKCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBvcHRpb25zLnJlYWRVbmtub3duRmllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSAndGhyb3cnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoYFVua25vd24gZmllbGQgJHtmaWVsZE5vfSAod2lyZSB0eXBlICR7d2lyZVR5cGV9KSBmb3IgJHt0aGlzLnR5cGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHJlYWRlci5za2lwKHdpcmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHUgPT09IHRydWUgPyBVbmtub3duRmllbGRIYW5kbGVyLm9uUmVhZCA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIGZpZWxkTm8sIHdpcmVUeXBlLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlXcml0ZShtZXNzYWdlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5BdWRpb1NlbmRlciBhdWRpb19zZW5kZXJzID0gMTsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmF1ZGlvU2VuZGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIEF1ZGlvU2VuZGVyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS5hdWRpb1NlbmRlcnNbaV0sIHdyaXRlci50YWcoMSwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgLyogcmVwZWF0ZWQgc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5WaWRlb1NlbmRlciB2aWRlb19zZW5kZXJzID0gMjsgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnZpZGVvU2VuZGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIFZpZGVvU2VuZGVyLmludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZS52aWRlb1NlbmRlcnNbaV0sIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCksIG9wdGlvbnMpLmpvaW4oKTtcbiAgICAgICAgbGV0IHUgPSBvcHRpb25zLndyaXRlVW5rbm93bkZpZWxkcztcbiAgICAgICAgaWYgKHUgIT09IGZhbHNlKVxuICAgICAgICAgICAgKHUgPT0gdHJ1ZSA/IFVua25vd25GaWVsZEhhbmRsZXIub25Xcml0ZSA6IHUpKHRoaXMudHlwZU5hbWUsIG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfVxufVxuLyoqXG4gKiBAZ2VuZXJhdGVkIE1lc3NhZ2VUeXBlIGZvciBwcm90b2J1ZiBtZXNzYWdlIHN0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2hhbmdlUHVibGlzaFF1YWxpdHlcbiAqL1xuY29uc3QgQ2hhbmdlUHVibGlzaFF1YWxpdHkgPSBuZXcgQ2hhbmdlUHVibGlzaFF1YWxpdHkkVHlwZSgpO1xuLy8gQGdlbmVyYXRlZCBtZXNzYWdlIHR5cGUgd2l0aCByZWZsZWN0aW9uIGluZm9ybWF0aW9uLCBtYXkgcHJvdmlkZSBzcGVlZCBvcHRpbWl6ZWQgbWV0aG9kc1xuY2xhc3MgQ2FsbEdyYW50c1VwZGF0ZWQkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuQ2FsbEdyYW50c1VwZGF0ZWQnLCBbXG4gICAgICAgICAgICB7IG5vOiAxLCBuYW1lOiAnY3VycmVudF9ncmFudHMnLCBraW5kOiAnbWVzc2FnZScsIFQ6ICgpID0+IENhbGxHcmFudHMgfSxcbiAgICAgICAgICAgIHsgbm86IDIsIG5hbWU6ICdtZXNzYWdlJywga2luZDogJ3NjYWxhcicsIFQ6IDkgLypTY2FsYXJUeXBlLlNUUklORyovIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdsb2JhbFRoaXMuT2JqZWN0LmNyZWF0ZSh0aGlzLm1lc3NhZ2VQcm90b3R5cGUpO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSAnJztcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWZsZWN0aW9uTWVyZ2VQYXJ0aWFsKHRoaXMsIG1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIGxlbmd0aCwgb3B0aW9ucywgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGFyZ2V0ID8/IHRoaXMuY3JlYXRlKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBsZXQgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgICAgICAgICAgIGNhc2UgLyogc3RyZWFtLnZpZGVvLnNmdS5tb2RlbHMuQ2FsbEdyYW50cyBjdXJyZW50X2dyYW50cyAqLyAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmN1cnJlbnRHcmFudHMgPSBDYWxsR3JhbnRzLmludGVybmFsQmluYXJ5UmVhZChyZWFkZXIsIHJlYWRlci51aW50MzIoKSwgb3B0aW9ucywgbWVzc2FnZS5jdXJyZW50R3JhbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJpbmcgbWVzc2FnZSAqLyAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkNhbGxHcmFudHMgY3VycmVudF9ncmFudHMgPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5jdXJyZW50R3JhbnRzKVxuICAgICAgICAgICAgQ2FsbEdyYW50cy5pbnRlcm5hbEJpbmFyeVdyaXRlKG1lc3NhZ2UuY3VycmVudEdyYW50cywgd3JpdGVyLnRhZygxLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKSwgb3B0aW9ucykuam9pbigpO1xuICAgICAgICAvKiBzdHJpbmcgbWVzc2FnZSA9IDI7ICovXG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09ICcnKVxuICAgICAgICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLnN0cmluZyhtZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5DYWxsR3JhbnRzVXBkYXRlZFxuICovXG5jb25zdCBDYWxsR3JhbnRzVXBkYXRlZCA9IG5ldyBDYWxsR3JhbnRzVXBkYXRlZCRUeXBlKCk7XG4vLyBAZ2VuZXJhdGVkIG1lc3NhZ2UgdHlwZSB3aXRoIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24sIG1heSBwcm92aWRlIHNwZWVkIG9wdGltaXplZCBtZXRob2RzXG5jbGFzcyBHb0F3YXkkVHlwZSBleHRlbmRzIE1lc3NhZ2VUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0cmVhbS52aWRlby5zZnUuZXZlbnQuR29Bd2F5JywgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vOiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdyZWFzb24nLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdlbnVtJyxcbiAgICAgICAgICAgICAgICBUOiAoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICdzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb24nLFxuICAgICAgICAgICAgICAgICAgICBHb0F3YXlSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICdHT19BV0FZX1JFQVNPTl8nLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnbG9iYWxUaGlzLk9iamVjdC5jcmVhdGUodGhpcy5tZXNzYWdlUHJvdG90eXBlKTtcbiAgICAgICAgbWVzc2FnZS5yZWFzb24gPSAwO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlZmxlY3Rpb25NZXJnZVBhcnRpYWwodGhpcywgbWVzc2FnZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgaW50ZXJuYWxCaW5hcnlSZWFkKHJlYWRlciwgbGVuZ3RoLCBvcHRpb25zLCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0YXJnZXQgPz8gdGhpcy5jcmVhdGUoKSwgZW5kID0gcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGxldCBbZmllbGRObywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvKiBzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5Hb0F3YXlSZWFzb24gcmVhc29uICovIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gb3B0aW9ucy5yZWFkVW5rbm93bkZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gJ3Rocm93JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKGBVbmtub3duIGZpZWxkICR7ZmllbGROb30gKHdpcmUgdHlwZSAke3dpcmVUeXBlfSkgZm9yICR7dGhpcy50eXBlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1ICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICh1ID09PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vblJlYWQgOiB1KSh0aGlzLnR5cGVOYW1lLCBtZXNzYWdlLCBmaWVsZE5vLCB3aXJlVHlwZSwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGludGVybmFsQmluYXJ5V3JpdGUobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qIHN0cmVhbS52aWRlby5zZnUubW9kZWxzLkdvQXdheVJlYXNvbiByZWFzb24gPSAxOyAqL1xuICAgICAgICBpZiAobWVzc2FnZS5yZWFzb24gIT09IDApXG4gICAgICAgICAgICB3cml0ZXIudGFnKDEsIFdpcmVUeXBlLlZhcmludCkuaW50MzIobWVzc2FnZS5yZWFzb24pO1xuICAgICAgICBsZXQgdSA9IG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzO1xuICAgICAgICBpZiAodSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAodSA9PSB0cnVlID8gVW5rbm93bkZpZWxkSGFuZGxlci5vbldyaXRlIDogdSkodGhpcy50eXBlTmFtZSwgbWVzc2FnZSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9XG59XG4vKipcbiAqIEBnZW5lcmF0ZWQgTWVzc2FnZVR5cGUgZm9yIHByb3RvYnVmIG1lc3NhZ2Ugc3RyZWFtLnZpZGVvLnNmdS5ldmVudC5Hb0F3YXlcbiAqL1xuY29uc3QgR29Bd2F5ID0gbmV3IEdvQXdheSRUeXBlKCk7XG5cbnZhciBldmVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEF1ZGlvTGV2ZWw6IEF1ZGlvTGV2ZWwsXG4gICAgQXVkaW9MZXZlbENoYW5nZWQ6IEF1ZGlvTGV2ZWxDaGFuZ2VkLFxuICAgIEF1ZGlvTWVkaWFSZXF1ZXN0OiBBdWRpb01lZGlhUmVxdWVzdCxcbiAgICBBdWRpb1NlbmRlcjogQXVkaW9TZW5kZXIsXG4gICAgQ2FsbEdyYW50c1VwZGF0ZWQ6IENhbGxHcmFudHNVcGRhdGVkLFxuICAgIENoYW5nZVB1Ymxpc2hRdWFsaXR5OiBDaGFuZ2VQdWJsaXNoUXVhbGl0eSxcbiAgICBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCxcbiAgICBDb25uZWN0aW9uUXVhbGl0eUluZm86IENvbm5lY3Rpb25RdWFsaXR5SW5mbyxcbiAgICBEb21pbmFudFNwZWFrZXJDaGFuZ2VkOiBEb21pbmFudFNwZWFrZXJDaGFuZ2VkLFxuICAgIEVycm9yOiBFcnJvciQxLFxuICAgIEdvQXdheTogR29Bd2F5LFxuICAgIEhlYWx0aENoZWNrUmVxdWVzdDogSGVhbHRoQ2hlY2tSZXF1ZXN0LFxuICAgIEhlYWx0aENoZWNrUmVzcG9uc2U6IEhlYWx0aENoZWNrUmVzcG9uc2UsXG4gICAgSUNFUmVzdGFydDogSUNFUmVzdGFydCxcbiAgICBJQ0VUcmlja2xlOiBJQ0VUcmlja2xlLFxuICAgIEpvaW5SZXF1ZXN0OiBKb2luUmVxdWVzdCxcbiAgICBKb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSxcbiAgICBNaWdyYXRpb246IE1pZ3JhdGlvbixcbiAgICBQYXJ0aWNpcGFudEpvaW5lZDogUGFydGljaXBhbnRKb2luZWQsXG4gICAgUGFydGljaXBhbnRMZWZ0OiBQYXJ0aWNpcGFudExlZnQsXG4gICAgUGluc0NoYW5nZWQ6IFBpbnNDaGFuZ2VkLFxuICAgIFB1Ymxpc2hlckFuc3dlcjogUHVibGlzaGVyQW5zd2VyLFxuICAgIFNmdUV2ZW50OiBTZnVFdmVudCxcbiAgICBTZnVSZXF1ZXN0OiBTZnVSZXF1ZXN0LFxuICAgIFN1YnNjcmliZXJPZmZlcjogU3Vic2NyaWJlck9mZmVyLFxuICAgIFRyYWNrUHVibGlzaGVkOiBUcmFja1B1Ymxpc2hlZCxcbiAgICBUcmFja1VucHVibGlzaGVkOiBUcmFja1VucHVibGlzaGVkLFxuICAgIFZpZGVvTGF5ZXJTZXR0aW5nOiBWaWRlb0xheWVyU2V0dGluZyxcbiAgICBnZXQgVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkgKCkgeyByZXR1cm4gVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHk7IH0sXG4gICAgVmlkZW9NZWRpYVJlcXVlc3Q6IFZpZGVvTWVkaWFSZXF1ZXN0LFxuICAgIFZpZGVvU2VuZGVyOiBWaWRlb1NlbmRlclxufSk7XG5cbnZhciBWaXNpYmlsaXR5U3RhdGU7XG4oZnVuY3Rpb24gKFZpc2liaWxpdHlTdGF0ZSkge1xuICAgIFZpc2liaWxpdHlTdGF0ZVtcIlVOS05PV05cIl0gPSBcIlVOS05PV05cIjtcbiAgICBWaXNpYmlsaXR5U3RhdGVbXCJWSVNJQkxFXCJdID0gXCJWSVNJQkxFXCI7XG4gICAgVmlzaWJpbGl0eVN0YXRlW1wiSU5WSVNJQkxFXCJdID0gXCJJTlZJU0lCTEVcIjtcbn0pKFZpc2liaWxpdHlTdGF0ZSB8fCAoVmlzaWJpbGl0eVN0YXRlID0ge30pKTtcbnZhciBEZWJvdW5jZVR5cGU7XG4oZnVuY3Rpb24gKERlYm91bmNlVHlwZSkge1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJJTU1FRElBVEVcIl0gPSAyMF0gPSBcIklNTUVESUFURVwiO1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJGQVNUXCJdID0gMTAwXSA9IFwiRkFTVFwiO1xuICAgIERlYm91bmNlVHlwZVtEZWJvdW5jZVR5cGVbXCJNRURJVU1cIl0gPSA2MDBdID0gXCJNRURJVU1cIjtcbiAgICBEZWJvdW5jZVR5cGVbRGVib3VuY2VUeXBlW1wiU0xPV1wiXSA9IDEyMDBdID0gXCJTTE9XXCI7XG59KShEZWJvdW5jZVR5cGUgfHwgKERlYm91bmNlVHlwZSA9IHt9KSk7XG5cbi8qKlxuICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHNlcnZpY2Ugc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuU2lnbmFsU2VydmVyXG4gKi9cbmNsYXNzIFNpZ25hbFNlcnZlckNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoX3RyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSBfdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLnR5cGVOYW1lID0gU2lnbmFsU2VydmVyLnR5cGVOYW1lO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBTaWduYWxTZXJ2ZXIubWV0aG9kcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gU2lnbmFsU2VydmVyLm9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldFB1Ymxpc2hlciBzZW5kcyB0aGUgV2ViUlRDIG9mZmVyIGZvciB0aGUgcGVlciBjb25uZWN0aW9uIHVzZWQgdG8gcHVibGlzaCBBL1ZcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFNldFB1Ymxpc2hlcihzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZXRQdWJsaXNoZXJSZXNwb25zZSk7XG4gICAgICovXG4gICAgc2V0UHVibGlzaGVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMubWV0aG9kc1swXSwgb3B0ID0gdGhpcy5fdHJhbnNwb3J0Lm1lcmdlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHN0YWNrSW50ZXJjZXB0KCd1bmFyeScsIHRoaXMuX3RyYW5zcG9ydCwgbWV0aG9kLCBvcHQsIGlucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYW5zd2VyIGlzIHNlbnQgYnkgdGhlIGNsaWVudCB0byB0aGUgU0ZVIGFmdGVyIHJlY2VpdmluZyBhIHN1YnNjcmliZXJfb2ZmZXIuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gcHJvdG9idWYgcnBjOiBTZW5kQW5zd2VyKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlNlbmRBbnN3ZXJSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5TZW5kQW5zd2VyUmVzcG9uc2UpO1xuICAgICAqL1xuICAgIHNlbmRBbnN3ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzFdLCBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQoJ3VuYXJ5JywgdGhpcy5fdHJhbnNwb3J0LCBtZXRob2QsIG9wdCwgaW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kSUNFQ2FuZGlkYXRlIHNlbmRzIGFuIElDRSBjYW5kaWRhdGUgdG8gdGhlIGNsaWVudFxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIHByb3RvYnVmIHJwYzogSWNlVHJpY2tsZShzdHJlYW0udmlkZW8uc2Z1Lm1vZGVscy5JQ0VUcmlja2xlKSByZXR1cm5zIChzdHJlYW0udmlkZW8uc2Z1LnNpZ25hbC5JQ0VUcmlja2xlUmVzcG9uc2UpO1xuICAgICAqL1xuICAgIGljZVRyaWNrbGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2RzWzJdLCBvcHQgPSB0aGlzLl90cmFuc3BvcnQubWVyZ2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc3RhY2tJbnRlcmNlcHQoJ3VuYXJ5JywgdGhpcy5fdHJhbnNwb3J0LCBtZXRob2QsIG9wdCwgaW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVTdWJzY3JpYmVycyBpcyB1c2VkIHRvIG5vdGlmeSB0aGUgU0ZVIGFib3V0IHRoZSBsaXN0IG9mIHZpZGVvIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBUT0RPOiBzeW5jIHN1YnNjcmlwdGlvbnMgYmFzZWQgb24gdGhpcyArIHVwZGF0ZSB0cmFja3MgdXNpbmcgdGhlIGRpbWVuc2lvbiBpbmZvIHNlbnQgYnkgdGhlIHVzZXJcbiAgICAgKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZVN1YnNjcmlwdGlvbnMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZSk7XG4gICAgICovXG4gICAgdXBkYXRlU3Vic2NyaXB0aW9ucyhpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbM10sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IFVwZGF0ZU11dGVTdGF0ZXMoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuVXBkYXRlTXV0ZVN0YXRlc1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSk7XG4gICAgICovXG4gICAgdXBkYXRlTXV0ZVN0YXRlcyhpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbNF0sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBwcm90b2J1ZiBycGM6IEljZVJlc3RhcnQoc3RyZWFtLnZpZGVvLnNmdS5zaWduYWwuSUNFUmVzdGFydFJlcXVlc3QpIHJldHVybnMgKHN0cmVhbS52aWRlby5zZnUuc2lnbmFsLklDRVJlc3RhcnRSZXNwb25zZSk7XG4gICAgICovXG4gICAgaWNlUmVzdGFydChpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZHNbNV0sIG9wdCA9IHRoaXMuX3RyYW5zcG9ydC5tZXJnZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzdGFja0ludGVyY2VwdCgndW5hcnknLCB0aGlzLl90cmFuc3BvcnQsIG1ldGhvZCwgb3B0LCBpbnB1dCk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBiYXNlVXJsOiAnJyxcbiAgICBzZW5kSnNvbjogdHJ1ZSxcbiAgICB0aW1lb3V0OiA1ICogMTAwMCxcbiAgICBqc29uT3B0aW9uczoge1xuICAgICAgICBpZ25vcmVVbmtub3duRmllbGRzOiB0cnVlLFxuICAgIH0sXG59O1xuY29uc3Qgd2l0aEhlYWRlcnMgPSAoaGVhZGVycykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGludGVyY2VwdFVuYXJ5KG5leHQsIG1ldGhvZCwgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWV0YSA9IHsgLi4ub3B0aW9ucy5tZXRhLCAuLi5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4gbmV4dChtZXRob2QsIGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogQ3JlYXRlcyBuZXcgU2lnbmFsU2VydmVyQ2xpZW50IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSB0d2lycCBvcHRpb25zLlxuICovXG5jb25zdCBjcmVhdGVTaWduYWxDbGllbnQgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBUd2lycEZldGNoVHJhbnNwb3J0KHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBTaWduYWxTZXJ2ZXJDbGllbnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgd2UgYXJlIHVzaW5nIFJlYWN0IE5hdGl2ZVxuICovXG5jb25zdCBpc1JlYWN0TmF0aXZlID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdD8udG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJztcbn07XG5cbi8vIGxvZyBsZXZlbHMsIHNvcnRlZCBieSB2ZXJib3NpdHlcbmNvbnN0IGxvZ0xldmVscyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHRyYWNlOiAwLFxuICAgIGRlYnVnOiAxLFxuICAgIGluZm86IDIsXG4gICAgd2FybjogMyxcbiAgICBlcnJvcjogNCxcbn0pO1xubGV0IGxvZ2dlciQ0O1xubGV0IGxldmVsID0gJ2luZm8nO1xuY29uc3QgbG9nVG9Db25zb2xlID0gKGxvZ0xldmVsLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGxvZ01ldGhvZDtcbiAgICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGxvZ01ldGhvZCA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBXQVJOOiAke21lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLmluZm87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLndhcm47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgICAgICBsb2dNZXRob2QgPSBjb25zb2xlLmluZm87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJhY2UnOlxuICAgICAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS50cmFjZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbG9nTWV0aG9kID0gY29uc29sZS5sb2c7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbG9nTWV0aG9kKG1lc3NhZ2UsIC4uLmFyZ3MpO1xufTtcbmNvbnN0IHNldExvZ2dlciA9IChsLCBsdmwpID0+IHtcbiAgICBsb2dnZXIkNCA9IGw7XG4gICAgaWYgKGx2bCkge1xuICAgICAgICBzZXRMb2dMZXZlbChsdmwpO1xuICAgIH1cbn07XG5jb25zdCBzZXRMb2dMZXZlbCA9IChsKSA9PiB7XG4gICAgbGV2ZWwgPSBsO1xufTtcbmNvbnN0IGdldExvZ2dlciA9ICh3aXRoVGFncykgPT4ge1xuICAgIGNvbnN0IGxvZ2dlck1ldGhvZCA9IGxvZ2dlciQ0IHx8IGxvZ1RvQ29uc29sZTtcbiAgICBjb25zdCB0YWdzID0gKHdpdGhUYWdzIHx8IFtdKS5qb2luKCc6Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gKGxvZ0xldmVsLCBtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChsb2dMZXZlbHNbbG9nTGV2ZWxdID49IGxvZ0xldmVsc1tsZXZlbF0pIHtcbiAgICAgICAgICAgIGxvZ2dlck1ldGhvZChsb2dMZXZlbCwgYFske3RhZ3N9XTogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZ2V0UHJlZmVycmVkQ29kZWNzID0gKGtpbmQsIHByZWZlcnJlZENvZGVjLCBjb2RlY1RvUmVtb3ZlKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnY29kZWNzJ10pO1xuICAgIGlmICghKCdnZXRDYXBhYmlsaXRpZXMnIGluIFJUQ1J0cFNlbmRlcikpIHtcbiAgICAgICAgbG9nZ2VyPy4oJ3dhcm4nLCAnUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FwID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgICBpZiAoIWNhcClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoZWQgPSBbXTtcbiAgICBjb25zdCBwYXJ0aWFsTWF0Y2hlZCA9IFtdO1xuICAgIGNvbnN0IHVubWF0Y2hlZCA9IFtdO1xuICAgIGNhcC5jb2RlY3MuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjb25zdCBjb2RlYyA9IGMubWltZVR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG9nZ2VyPy4oJ2RlYnVnJywgYEZvdW5kIHN1cHBvcnRlZCBjb2RlYzogJHtjb2RlY31gKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlQ29kZWMgPSBjb2RlY1RvUmVtb3ZlICYmIGNvZGVjID09PSBgJHtraW5kfS8ke2NvZGVjVG9SZW1vdmUudG9Mb3dlckNhc2UoKX1gO1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQ29kZWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1hdGNoZXNDb2RlYyA9IGNvZGVjID09PSBgJHtraW5kfS8ke3ByZWZlcnJlZENvZGVjLnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgaWYgKCFtYXRjaGVzQ29kZWMpIHtcbiAgICAgICAgICAgIHVubWF0Y2hlZC5wdXNoKGMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBoMjY0IGNvZGVjcyB0aGF0IGhhdmUgc2RwRm10cExpbmUgYXZhaWxhYmxlLCB1c2Ugb25seSBpZiB0aGVcbiAgICAgICAgLy8gcHJvZmlsZS1sZXZlbC1pZCBpcyA0MmUwMWYgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAoY29kZWMgPT09ICdoMjY0Jykge1xuICAgICAgICAgICAgaWYgKGMuc2RwRm10cExpbmUgJiYgYy5zZHBGbXRwTGluZS5pbmNsdWRlcygncHJvZmlsZS1sZXZlbC1pZD00MmUwMWYnKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxNYXRjaGVkLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlZC5wdXNoKGMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5tYXRjaGVkLCAuLi5wYXJ0aWFsTWF0Y2hlZCwgLi4udW5tYXRjaGVkXTtcbiAgICBsb2dnZXI/LignaW5mbycsIGBQcmVmZmVyZWQgY29kZWNzOiBgLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZ2V0R2VuZXJpY1NkcCA9IGFzeW5jIChkaXJlY3Rpb24pID0+IHtcbiAgICBjb25zdCB0ZW1wUGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oKTtcbiAgICB0ZW1wUGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywgeyBkaXJlY3Rpb24gfSk7XG4gICAgdGVtcFBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycsIHsgZGlyZWN0aW9uIH0pO1xuICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGVtcFBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgbGV0IHNkcCA9IG9mZmVyLnNkcCA/PyAnJztcbiAgICB0ZW1wUGMuZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICB0LnN0b3AoKTtcbiAgICB9KTtcbiAgICB0ZW1wUGMuY2xvc2UoKTtcbiAgICByZXR1cm4gc2RwO1xufTtcblxuY29uc3Qgc2Z1RXZlbnRLaW5kcyA9IHtcbiAgICBzdWJzY3JpYmVyT2ZmZXI6IHVuZGVmaW5lZCxcbiAgICBwdWJsaXNoZXJBbnN3ZXI6IHVuZGVmaW5lZCxcbiAgICBjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQ6IHVuZGVmaW5lZCxcbiAgICBhdWRpb0xldmVsQ2hhbmdlZDogdW5kZWZpbmVkLFxuICAgIGljZVRyaWNrbGU6IHVuZGVmaW5lZCxcbiAgICBjaGFuZ2VQdWJsaXNoUXVhbGl0eTogdW5kZWZpbmVkLFxuICAgIHBhcnRpY2lwYW50Sm9pbmVkOiB1bmRlZmluZWQsXG4gICAgcGFydGljaXBhbnRMZWZ0OiB1bmRlZmluZWQsXG4gICAgZG9taW5hbnRTcGVha2VyQ2hhbmdlZDogdW5kZWZpbmVkLFxuICAgIGpvaW5SZXNwb25zZTogdW5kZWZpbmVkLFxuICAgIGhlYWx0aENoZWNrUmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICB0cmFja1B1Ymxpc2hlZDogdW5kZWZpbmVkLFxuICAgIHRyYWNrVW5wdWJsaXNoZWQ6IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgIGNhbGxHcmFudHNVcGRhdGVkOiB1bmRlZmluZWQsXG4gICAgZ29Bd2F5OiB1bmRlZmluZWQsXG4gICAgaWNlUmVzdGFydDogdW5kZWZpbmVkLFxuICAgIHBpbnNVcGRhdGVkOiB1bmRlZmluZWQsXG59O1xuY29uc3QgaXNTZnVFdmVudCA9IChldmVudE5hbWUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNmdUV2ZW50S2luZHMsIGV2ZW50TmFtZSk7XG59O1xuY2xhc3MgRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKFsnRGlzcGF0Y2hlciddKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IHt9O1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50S2luZCA9IG1lc3NhZ2UuZXZlbnRQYXlsb2FkLm9uZW9mS2luZDtcbiAgICAgICAgICAgIGlmICghZXZlbnRLaW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlLmV2ZW50UGF5bG9hZFtldmVudEtpbmRdO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYERpc3BhdGNoaW5nICR7ZXZlbnRLaW5kfWAsIHBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5zdWJzY3JpYmVyc1tldmVudEtpbmRdO1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnTGlzdGVuZXIgZmFpbGVkIHdpdGggZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24gPSAoZXZlbnROYW1lLCBmbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKChfYSA9IHRoaXMuc3Vic2NyaWJlcnMpW2V2ZW50TmFtZV0gPz8gKF9hW2V2ZW50TmFtZV0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2ZmID0gKGV2ZW50TmFtZSwgZm4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnNbZXZlbnROYW1lXSA9ICh0aGlzLnN1YnNjcmliZXJzW2V2ZW50TmFtZV0gfHwgW10pLmZpbHRlcigoZikgPT4gZiAhPT0gZm4pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9mZkFsbCA9IChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBidWZmZXIgZm9yIElDRSBDYW5kaWRhdGVzLiBVc2VkIGZvciBJQ0UgVHJpY2tsZTpcbiAqIC0gaHR0cHM6Ly9ibG9nZ2Vlay5tZS93ZWJydGNnbG9zc2FyeS90cmlja2xlLWljZS9cbiAqL1xuY2xhc3MgSWNlVHJpY2tsZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlckNhbmRpZGF0ZXMgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB0aGlzLnB1Ymxpc2hlckNhbmRpZGF0ZXMgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ3NmdS1jbGllbnQnXSk7XG4gICAgICAgIHRoaXMucHVzaCA9IChpY2VUcmlja2xlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaWNlVHJpY2tsZS5wZWVyVHlwZSA9PT0gUGVlclR5cGUuU1VCU0NSSUJFUikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlckNhbmRpZGF0ZXMubmV4dChpY2VUcmlja2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGljZVRyaWNrbGUucGVlclR5cGUgPT09IFBlZXJUeXBlLlBVQkxJU0hFUl9VTlNQRUNJRklFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyQ2FuZGlkYXRlcy5uZXh0KGljZVRyaWNrbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgSUNFVHJpY2tsZSwgVW5rbm93biBwZWVyIHR5cGVgLCBpY2VUcmlja2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICBpZiAoIWNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50KSB7XG4gICAgICAgIC8vIHJlYWN0LW5hdGl2ZS13ZWJydGMgZG9lc24ndCBpbmNsdWRlIHVzZXJuYW1lRnJhZ21lbnQgaW4gdGhlIGNhbmRpZGF0ZVxuICAgICAgICBjb25zdCBzcGxpdHRlZENhbmRpZGF0ZSA9IGNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoJyAnKTtcbiAgICAgICAgY29uc3QgdWZyYWdJbmRleCA9IHNwbGl0dGVkQ2FuZGlkYXRlLmZpbmRJbmRleCgocykgPT4gcyA9PT0gJ3VmcmFnJykgKyAxO1xuICAgICAgICBjb25zdCB1c2VybmFtZUZyYWdtZW50ID0gc3BsaXR0ZWRDYW5kaWRhdGVbdWZyYWdJbmRleF07XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IC4uLmNhbmRpZGF0ZSwgdXNlcm5hbWVGcmFnbWVudCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjYW5kaWRhdGUudG9KU09OKCkpO1xuICAgIH1cbn1cblxubGV0IHNka0luZm87XG5sZXQgb3NJbmZvO1xubGV0IGRldmljZUluZm87XG5jb25zdCBzZXRTZGtJbmZvID0gKGluZm8pID0+IHtcbiAgICBzZGtJbmZvID0gaW5mbztcbn07XG5jb25zdCBnZXRTZGtJbmZvID0gKCkgPT4ge1xuICAgIHJldHVybiBzZGtJbmZvO1xufTtcbmNvbnN0IHNldE9TSW5mbyA9IChpbmZvKSA9PiB7XG4gICAgb3NJbmZvID0gaW5mbztcbn07XG5jb25zdCBnZXRPU0luZm8gPSAoKSA9PiB7XG4gICAgcmV0dXJuIG9zSW5mbztcbn07XG5jb25zdCBzZXREZXZpY2VJbmZvID0gKGluZm8pID0+IHtcbiAgICBkZXZpY2VJbmZvID0gaW5mbztcbn07XG5jb25zdCBnZXREZXZpY2VJbmZvID0gKCkgPT4ge1xuICAgIHJldHVybiBkZXZpY2VJbmZvO1xufTtcbmNvbnN0IGdldENsaWVudERldGFpbHMgPSAoKSA9PiB7XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAvLyBTaW5jZSBSTiBkb2Vzbid0IHN1cHBvcnQgd2ViLCBzaGFyaW5nIGJyb3dzZXIgaW5mbyBpcyBub3QgcmVxdWlyZWRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNkazogZ2V0U2RrSW5mbygpLFxuICAgICAgICAgICAgb3M6IGdldE9TSW5mbygpLFxuICAgICAgICAgICAgZGV2aWNlOiBnZXREZXZpY2VJbmZvKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5ldyBVQVBhcnNlcihuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBjb25zdCB7IGJyb3dzZXIsIG9zLCBkZXZpY2UsIGNwdSB9ID0gdXNlckFnZW50LmdldFJlc3VsdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNkazogZ2V0U2RrSW5mbygpLFxuICAgICAgICBicm93c2VyOiB7XG4gICAgICAgICAgICBuYW1lOiBicm93c2VyLm5hbWUgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIHZlcnNpb246IGJyb3dzZXIudmVyc2lvbiB8fCAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgb3M6IHtcbiAgICAgICAgICAgIG5hbWU6IG9zLm5hbWUgfHwgJycsXG4gICAgICAgICAgICB2ZXJzaW9uOiBvcy52ZXJzaW9uIHx8ICcnLFxuICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOiBjcHUuYXJjaGl0ZWN0dXJlIHx8ICcnLFxuICAgICAgICB9LFxuICAgICAgICBkZXZpY2U6IHtcbiAgICAgICAgICAgIG5hbWU6IGAke2RldmljZS52ZW5kb3IgfHwgJyd9ICR7ZGV2aWNlLm1vZGVsIHx8ICcnfSAke2RldmljZS50eXBlIHx8ICcnfWAsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnJyxcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgREVGQVVMVF9CSVRSQVRFID0gMTI1MDAwMDtcbmNvbnN0IGRlZmF1bHRUYXJnZXRSZXNvbHV0aW9uID0ge1xuICAgIGJpdHJhdGU6IERFRkFVTFRfQklUUkFURSxcbiAgICB3aWR0aDogMTI4MCxcbiAgICBoZWlnaHQ6IDcyMCxcbn07XG4vKipcbiAqIERldGVybWluZXMgdGhlIG1vc3Qgb3B0aW1hbCB2aWRlbyBsYXllcnMgZm9yIHNpbXVsY2FzdGluZ1xuICogZm9yIHRoZSBnaXZlbiB0cmFjay5cbiAqXG4gKiBAcGFyYW0gdmlkZW9UcmFjayB0aGUgdmlkZW8gdHJhY2sgdG8gZmluZCBvcHRpbWFsIGxheWVycyBmb3IuXG4gKiBAcGFyYW0gdGFyZ2V0UmVzb2x1dGlvbiB0aGUgZXhwZWN0ZWQgdGFyZ2V0IHJlc29sdXRpb24uXG4gKi9cbmNvbnN0IGZpbmRPcHRpbWFsVmlkZW9MYXllcnMgPSAodmlkZW9UcmFjaywgdGFyZ2V0UmVzb2x1dGlvbiA9IGRlZmF1bHRUYXJnZXRSZXNvbHV0aW9uKSA9PiB7XG4gICAgY29uc3Qgb3B0aW1hbFZpZGVvTGF5ZXJzID0gW107XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgY29uc3QgeyB3aWR0aDogdyA9IDAsIGhlaWdodDogaCA9IDAgfSA9IHNldHRpbmdzO1xuICAgIGNvbnN0IGlzUk5Jb3MgPSBpc1JlYWN0TmF0aXZlKCkgJiYgZ2V0T1NJbmZvKCk/Lm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lvcyc7XG4gICAgY29uc3QgbWF4Qml0cmF0ZSA9IGdldENvbXB1dGVkTWF4Qml0cmF0ZSh0YXJnZXRSZXNvbHV0aW9uLCB3LCBoKTtcbiAgICBsZXQgZG93bnNjYWxlRmFjdG9yID0gMTtcbiAgICBbJ2YnLCAnaCcsICdxJ10uZm9yRWFjaCgocmlkKSA9PiB7XG4gICAgICAgIC8vIFJldmVyc2luZyB0aGUgb3JkZXIgW2YsIGgsIHFdIHRvIFtxLCBoLCBmXSBhcyBDaHJvbWUgdXNlcyBlbmNvZGluZyBpbmRleFxuICAgICAgICAvLyB3aGVuIGRlY2lkaW5nIHdoaWNoIGxheWVyIHRvIGRpc2FibGUgd2hlbiBDUFUgb3IgYmFuZHdpZHRoIGlzIGNvbnN0cmFpbmVkLlxuICAgICAgICAvLyBFbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsIHJlc29sdXRpb24gb3JkZXIuXG4gICAgICAgIG9wdGltYWxWaWRlb0xheWVycy51bnNoaWZ0KHtcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHJpZCxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHcgLyBkb3duc2NhbGVGYWN0b3IpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGggLyBkb3duc2NhbGVGYWN0b3IpLFxuICAgICAgICAgICAgbWF4Qml0cmF0ZTogTWF0aC5yb3VuZChtYXhCaXRyYXRlIC8gZG93bnNjYWxlRmFjdG9yKSxcbiAgICAgICAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogZG93bnNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgLy8gU2ltdWxjYXN0IG9uIGlPUyBSZWFjdC1OYXRpdmUgcmVxdWlyZXMgYWxsIGVuY29kaW5ncyB0byBzaGFyZSB0aGUgc2FtZSBmcmFtZXJhdGVcbiAgICAgICAgICAgIG1heEZyYW1lcmF0ZToge1xuICAgICAgICAgICAgICAgIGY6IDMwLFxuICAgICAgICAgICAgICAgIGg6IGlzUk5Jb3MgPyAzMCA6IDI1LFxuICAgICAgICAgICAgICAgIHE6IGlzUk5Jb3MgPyAzMCA6IDIwLFxuICAgICAgICAgICAgfVtyaWRdLFxuICAgICAgICB9KTtcbiAgICAgICAgZG93bnNjYWxlRmFjdG9yICo9IDI7XG4gICAgfSk7XG4gICAgLy8gZm9yIHNpbXBsaWNpdHksIHdlIHN0YXJ0IHdpdGggYWxsIGxheWVycyBlbmFibGVkLCB0aGVuIHRoaXMgZnVuY3Rpb25cbiAgICAvLyB3aWxsIGNsZWFyL3JlYXNzaWduIHRoZSBsYXllcnMgdGhhdCBhcmUgbm90IG5lZWRlZFxuICAgIHJldHVybiB3aXRoU2ltdWxjYXN0Q29uc3RyYWludHMoc2V0dGluZ3MsIG9wdGltYWxWaWRlb0xheWVycyk7XG59O1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWF4aW11bSBiaXRyYXRlIGZvciBhIGdpdmVuIHJlc29sdXRpb24uXG4gKiBJZiB0aGUgY3VycmVudCByZXNvbHV0aW9uIGlzIGxvd2VyIHRoYW4gdGhlIHRhcmdldCByZXNvbHV0aW9uLFxuICogd2Ugd2FudCB0byBwcm9wb3J0aW9uYWxseSByZWR1Y2UgdGhlIHRhcmdldCBiaXRyYXRlLlxuICogSWYgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBpcyBoaWdoZXIgdGhhbiB0aGUgdGFyZ2V0IHJlc29sdXRpb24sXG4gKiB3ZSB3YW50IHRvIHVzZSB0aGUgdGFyZ2V0IGJpdHJhdGUuXG4gKlxuICogQHBhcmFtIHRhcmdldFJlc29sdXRpb24gdGhlIHRhcmdldCByZXNvbHV0aW9uLlxuICogQHBhcmFtIGN1cnJlbnRXaWR0aCB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgdHJhY2suXG4gKiBAcGFyYW0gY3VycmVudEhlaWdodCB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIHRyYWNrLlxuICovXG5jb25zdCBnZXRDb21wdXRlZE1heEJpdHJhdGUgPSAodGFyZ2V0UmVzb2x1dGlvbiwgY3VycmVudFdpZHRoLCBjdXJyZW50SGVpZ2h0KSA9PiB7XG4gICAgLy8gaWYgdGhlIGN1cnJlbnQgcmVzb2x1dGlvbiBpcyBsb3dlciB0aGFuIHRoZSB0YXJnZXQgcmVzb2x1dGlvbixcbiAgICAvLyB3ZSB3YW50IHRvIHByb3BvcnRpb25hbGx5IHJlZHVjZSB0aGUgdGFyZ2V0IGJpdHJhdGVcbiAgICBjb25zdCB7IHdpZHRoOiB0YXJnZXRXaWR0aCwgaGVpZ2h0OiB0YXJnZXRIZWlnaHQgfSA9IHRhcmdldFJlc29sdXRpb247XG4gICAgaWYgKGN1cnJlbnRXaWR0aCA8IHRhcmdldFdpZHRoIHx8IGN1cnJlbnRIZWlnaHQgPCB0YXJnZXRIZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBpeGVscyA9IGN1cnJlbnRXaWR0aCAqIGN1cnJlbnRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHRhcmdldFBpeGVscyA9IHRhcmdldFdpZHRoICogdGFyZ2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCByZWR1Y3Rpb25GYWN0b3IgPSBjdXJyZW50UGl4ZWxzIC8gdGFyZ2V0UGl4ZWxzO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0YXJnZXRSZXNvbHV0aW9uLmJpdHJhdGUgKiByZWR1Y3Rpb25GYWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0UmVzb2x1dGlvbi5iaXRyYXRlO1xufTtcbi8qKlxuICogQnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgc2ltdWxjYXN0IGNvbnN0cmFpbnRzIGZvciBkaWZmZXJlbnQgdmlkZW8gcmVzb2x1dGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGUgcHJvdmlkZWQgbGlzdCBvZiB2aWRlbyBsYXllcnMgYWNjb3JkaW5nIHRvIHRoZVxuICogY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBzaW11bGNhc3QgY29uc3RyYWludHMgaW4gdGhlIENocm9taXVtIGJhc2VkIGJyb3dzZXJzLlxuICpcbiAqIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9leHRlcm5hbC93ZWJydGMvKy9yZWZzL2hlYWRzL21haW4vbWVkaWEvZW5naW5lL3NpbXVsY2FzdC5jYyM5MFxuICovXG5jb25zdCB3aXRoU2ltdWxjYXN0Q29uc3RyYWludHMgPSAoc2V0dGluZ3MsIG9wdGltYWxWaWRlb0xheWVycykgPT4ge1xuICAgIGxldCBsYXllcnM7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHNldHRpbmdzLndpZHRoIHx8IDAsIHNldHRpbmdzLmhlaWdodCB8fCAwKTtcbiAgICBpZiAoc2l6ZSA8PSAzMjApIHtcbiAgICAgICAgLy8gcHJvdmlkZSBvbmx5IG9uZSBsYXllciAzMjB4MjQwIChxKSwgdGhlIG9uZSB3aXRoIHRoZSBoaWdoZXN0IHF1YWxpdHlcbiAgICAgICAgbGF5ZXJzID0gb3B0aW1hbFZpZGVvTGF5ZXJzLmZpbHRlcigobGF5ZXIpID0+IGxheWVyLnJpZCA9PT0gJ2YnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2l6ZSA8PSA2NDApIHtcbiAgICAgICAgLy8gcHJvdmlkZSB0d28gbGF5ZXJzLCAxNjB4MTIwIChxKSBhbmQgNjQweDQ4MCAoaClcbiAgICAgICAgbGF5ZXJzID0gb3B0aW1hbFZpZGVvTGF5ZXJzLmZpbHRlcigobGF5ZXIpID0+IGxheWVyLnJpZCAhPT0gJ2gnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByb3ZpZGUgdGhyZWUgbGF5ZXJzIGZvciBzaXplcyA+IDY0MHg0ODBcbiAgICAgICAgbGF5ZXJzID0gb3B0aW1hbFZpZGVvTGF5ZXJzO1xuICAgIH1cbiAgICBjb25zdCByaWRNYXBwaW5nID0gWydxJywgJ2gnLCAnZiddO1xuICAgIHJldHVybiBsYXllcnMubWFwKChsYXllciwgaW5kZXgpID0+ICh7XG4gICAgICAgIC4uLmxheWVyLFxuICAgICAgICByaWQ6IHJpZE1hcHBpbmdbaW5kZXhdLCAvLyByZWFzc2lnbiByaWRcbiAgICB9KSk7XG59O1xuY29uc3QgZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzID0gKHZpZGVvVHJhY2ssIHByZWZlcmVuY2VzKSA9PiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgcmlkOiAncScsXG4gICAgICAgICAgICB3aWR0aDogc2V0dGluZ3Mud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogc2V0dGluZ3MuaGVpZ2h0IHx8IDAsXG4gICAgICAgICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IDEsXG4gICAgICAgICAgICBtYXhCaXRyYXRlOiBwcmVmZXJlbmNlcz8ubWF4Qml0cmF0ZSA/PyAzMDAwMDAwLFxuICAgICAgICAgICAgbWF4RnJhbWVyYXRlOiBwcmVmZXJlbmNlcz8ubWF4RnJhbWVyYXRlID8/IDMwLFxuICAgICAgICB9LFxuICAgIF07XG59O1xuXG5jb25zdCB0cmFja1R5cGVUb1BhcnRpY2lwYW50U3RyZWFtS2V5ID0gKHRyYWNrVHlwZSkgPT4ge1xuICAgIHN3aXRjaCAodHJhY2tUeXBlKSB7XG4gICAgICAgIGNhc2UgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRTpcbiAgICAgICAgICAgIHJldHVybiAnc2NyZWVuU2hhcmVTdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU86XG4gICAgICAgICAgICByZXR1cm4gJ3NjcmVlblNoYXJlQXVkaW9TdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcbiAgICAgICAgICAgIHJldHVybiAndmlkZW9TdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcbiAgICAgICAgICAgIHJldHVybiAnYXVkaW9TdHJlYW0nO1xuICAgICAgICBjYXNlIFRyYWNrVHlwZS5VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhY2sgdHlwZSBpcyB1bnNwZWNpZmllZCcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrID0gdHJhY2tUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRyYWNrIHR5cGU6ICR7ZXhoYXVzdGl2ZVRyYWNrVHlwZUNoZWNrfWApO1xuICAgIH1cbn07XG5jb25zdCBtdXRlVHlwZVRvVHJhY2tUeXBlID0gKG11dGVUeXBlKSA9PiB7XG4gICAgc3dpdGNoIChtdXRlVHlwZSkge1xuICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLkFVRElPO1xuICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlZJREVPO1xuICAgICAgICBjYXNlICdzY3JlZW5zaGFyZSc6XG4gICAgICAgICAgICByZXR1cm4gVHJhY2tUeXBlLlNDUkVFTl9TSEFSRTtcbiAgICAgICAgY2FzZSAnc2NyZWVuc2hhcmVfYXVkaW8nOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU87XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlTXV0ZVR5cGVDaGVjayA9IG11dGVUeXBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG11dGUgdHlwZTogJHtleGhhdXN0aXZlTXV0ZVR5cGVDaGVja31gKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgdXBkYXRlIGlzIGEgZnVuY3Rpb24gcGF0Y2guXG4gKlxuICogQHBhcmFtIHVwZGF0ZSB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb25QYXRjaCA9ICh1cGRhdGUpID0+IHR5cGVvZiB1cGRhdGUgPT09ICdmdW5jdGlvbic7XG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICogbm90IGVtaXR0ZWQgYSB2YWx1ZSB5ZXQuXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAqL1xuY29uc3QgZ2V0Q3VycmVudFZhbHVlID0gKG9ic2VydmFibGUkKSA9PiB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBlcnIgPSB1bmRlZmluZWQ7XG4gICAgY29tYmluZUxhdGVzdChbb2JzZXJ2YWJsZSRdKVxuICAgICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKFt2XSkgPT4ge1xuICAgICAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKGUpID0+IHtcbiAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgIH0sXG4gICAgfSlcbiAgICAgICAgLnVuc3Vic2NyaWJlKCk7XG4gICAgaWYgKGVycilcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBTdWJqZWN0LlxuICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gKiBAcGFyYW0gdXBkYXRlIHRoZSB1cGRhdGUgdG8gYXBwbHkgdG8gdGhlIHN1YmplY3QuXG4gKiBAcmV0dXJuIHRoZSB1cGRhdGVkIHZhbHVlLlxuICovXG5jb25zdCBzZXRDdXJyZW50VmFsdWUgPSAoc3ViamVjdCwgdXBkYXRlKSA9PiB7XG4gICAgY29uc3QgbmV4dCA9IGlzRnVuY3Rpb25QYXRjaCh1cGRhdGUpXG4gICAgICAgID8gdXBkYXRlKGdldEN1cnJlbnRWYWx1ZShzdWJqZWN0KSlcbiAgICAgICAgOiB1cGRhdGU7XG4gICAgc3ViamVjdC5uZXh0KG5leHQpO1xuICAgIHJldHVybiBuZXh0O1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIHN1YnNjcmlwdGlvbiBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVuc3Vic2NyaWJlLlxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlIHRoZSBvYnNlcnZhYmxlIHRvIHN1YnNjcmliZSB0by5cbiAqIEBwYXJhbSBoYW5kbGVyIHRoZSBoYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgb2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICovXG5jb25zdCBjcmVhdGVTdWJzY3JpcHRpb24gPSAob2JzZXJ2YWJsZSwgaGFuZGxlcikgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG59O1xuXG52YXIgcnhVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY3JlYXRlU3Vic2NyaXB0aW9uOiBjcmVhdGVTdWJzY3JpcHRpb24sXG4gICAgZ2V0Q3VycmVudFZhbHVlOiBnZXRDdXJyZW50VmFsdWUsXG4gICAgc2V0Q3VycmVudFZhbHVlOiBzZXRDdXJyZW50VmFsdWVcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29tYmluZWQge0BsaW5rIENvbXBhcmF0b3I8VD59IHdoaWNoIHNvcnRzIGl0ZW1zIGJ5IHRoZSBnaXZlbiBjb21wYXJhdG9ycy5cbiAqIFRoZSBjb21wYXJhdG9ycyBhcmUgYXBwbGllZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZ2l2ZW4gKGxlZnQgLT4gcmlnaHQpLlxuICpcbiAqIEBwYXJhbSBjb21wYXJhdG9ycyB0aGUgY29tcGFyYXRvcnMgdG8gdXNlIGZvciBzb3J0aW5nLlxuICogQHJldHVybnMgYSBjb21iaW5lZCB7QGxpbmsgQ29tcGFyYXRvcjxUPn0uXG4gKi9cbmNvbnN0IGNvbWJpbmVDb21wYXJhdG9ycyA9ICguLi5jb21wYXJhdG9ycykgPT4ge1xuICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBhcmF0b3Igb2YgY29tcGFyYXRvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYSwgYik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29tcGFyYXRvciB3aGljaCBzb3J0cyBpdGVtcyBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBieVZhbHVlID0gKGEsIGIpID0+IGEgPCBiID8gLSAxIDogYSA+IGIgPyAxIDogMDtcbiAqIGNvbnN0IGJ5VmFsdWVEZXNjID0gZGVzY2VuZGluZyhieVZhbHVlKTtcbiAqXG4gKiBAcGFyYW0gY29tcGFyYXRvciB0aGUgY29tcGFyYXRvciB0byB3cmFwLlxuICovXG5jb25zdCBkZXNjZW5kaW5nID0gKGNvbXBhcmF0b3IpID0+IHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGNvbXBhcmF0b3IoYiwgYSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbXBhcmF0b3Igd2hpY2ggY29uZGl0aW9uYWxseSBhcHBsaWVzIHRoZSBnaXZlbiBjb21wYXJhdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzaG91bGRTb3J0QnlWYWx1ZSA9IChhLCBiKSA9PiBhICUgMiA9PT0gMDsgLy8gcmV0dXJuIGZhbHNlIHRvIHR1cm4gaXQgb2ZmXG4gKiBjb25zdCBieVZhbHVlID0gKGEsIGIpID0+IGEgPCBiID8gLSAxIDogYSA+IGIgPyAxIDogMDtcbiAqIGNvbnN0IGNvbXBhcmF0b3IgPSBjb25kaXRpb25hbChzaG91bGRTb3J0QnlWYWx1ZSkoYnlWYWx1ZSk7XG4gKlxuICogQHBhcmFtIHByZWRpY2F0ZSB0aGUgcHJlZGljYXRlIHRvIHVzZSBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0byBhcHBseSB0aGUgY29tcGFyYXRvci5cbiAqL1xuY29uc3QgY29uZGl0aW9uYWwgPSAocHJlZGljYXRlKSA9PiB7XG4gICAgcmV0dXJuIChjb21wYXJhdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUoYSwgYikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiKTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbi8qKlxuICogQSBuby1vcCBjb21wYXJhdG9yIHdoaWNoIGFsd2F5cyByZXR1cm5zIDAuXG4gKi9cbmNvbnN0IG5vb3BDb21wYXJhdG9yID0gKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiAwO1xufTtcblxuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgdGhlIGRvbWluYW50IHNwZWFrZXIgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IGRvbWluYW50U3BlYWtlciA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEuaXNEb21pbmFudFNwZWFrZXIgJiYgIWIuaXNEb21pbmFudFNwZWFrZXIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWEuaXNEb21pbmFudFNwZWFrZXIgJiYgYi5pc0RvbWluYW50U3BlYWtlcilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgc3BlYWtpbmcgb3Igbm90LlxuICpcbiAqIEBwYXJhbSBhIHRoZSBmaXJzdCBwYXJ0aWNpcGFudC5cbiAqIEBwYXJhbSBiIHRoZSBzZWNvbmQgcGFydGljaXBhbnQuXG4gKi9cbmNvbnN0IHNwZWFraW5nID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5pc1NwZWFraW5nICYmICFiLmlzU3BlYWtpbmcpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWEuaXNTcGVha2luZyAmJiBiLmlzU3BlYWtpbmcpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSBzY3JlZW4gc2hhcmluZyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3Qgc2NyZWVuU2hhcmluZyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGhhc1NjcmVlblNoYXJlKGEpICYmICFoYXNTY3JlZW5TaGFyZShiKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmICghaGFzU2NyZWVuU2hhcmUoYSkgJiYgaGFzU2NyZWVuU2hhcmUoYikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHdoaWNoIHNvcnRzIHBhcnRpY2lwYW50cyBieSB2aWRlbyBzdGF0dXMuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3QgcHVibGlzaGluZ1ZpZGVvID0gKGEsIGIpID0+IHtcbiAgICBpZiAoaGFzVmlkZW8oYSkgJiYgIWhhc1ZpZGVvKGIpKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFoYXNWaWRlbyhhKSAmJiBoYXNWaWRlbyhiKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3Igd2hpY2ggc29ydHMgcGFydGljaXBhbnRzIGJ5IGF1ZGlvIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5jb25zdCBwdWJsaXNoaW5nQXVkaW8gPSAoYSwgYikgPT4ge1xuICAgIGlmIChoYXNBdWRpbyhhKSAmJiAhaGFzQXVkaW8oYikpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWhhc0F1ZGlvKGEpICYmIGhhc0F1ZGlvKGIpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBwcmlvcml0aXplcyBwYXJ0aWNpcGFudHMgd2hvIGFyZSBwaW5uZWQuXG4gKlxuICogQHBhcmFtIGEgdGhlIGZpcnN0IHBhcnRpY2lwYW50LlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBwYXJ0aWNpcGFudC5cbiAqL1xuY29uc3QgcGlubmVkID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5waW4gJiYgYi5waW4pIHtcbiAgICAgICAgaWYgKCFhLnBpbi5pc0xvY2FsUGluICYmIGIucGluLmlzTG9jYWxQaW4pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhLnBpbi5pc0xvY2FsUGluICYmICFiLnBpbi5pc0xvY2FsUGluKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhLnBpbi5waW5uZWRBdCA+IGIucGluLnBpbm5lZEF0KVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5waW4ucGlubmVkQXQgPCBiLnBpbi5waW5uZWRBdClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYS5waW4gJiYgIWIucGluKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKCFhLnBpbiAmJiBiLnBpbilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3IgY3JlYXRvciB3aGljaCB3aWxsIHNldCB1cCBhIGNvbXBhcmF0b3Igd2hpY2ggcHJpb3JpdGl6ZXNcbiAqIHBhcnRpY2lwYW50cyB3aG8gaGF2ZSBhIHNwZWNpZmljIHJlYWN0aW9uLlxuICpcbiAqIEBwYXJhbSB0eXBlIHRoZSByZWFjdGlvbiB0eXBlLlxuICovXG5jb25zdCByZWFjdGlvblR5cGUgPSAodHlwZSkgPT4ge1xuICAgIHJldHVybiAoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5yZWFjdGlvbj8udHlwZSA9PT0gdHlwZSAmJiBiLnJlYWN0aW9uPy50eXBlICE9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYS5yZWFjdGlvbj8udHlwZSAhPT0gdHlwZSAmJiBiLnJlYWN0aW9uPy50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG59O1xuLyoqXG4gKiBBIGNvbXBhcmF0b3IgY3JlYXRvciB3aGljaCB3aWxsIHNldCB1cCBhIGNvbXBhcmF0b3Igd2hpY2ggcHJpb3JpdGl6ZXNcbiAqIHBhcnRpY2lwYW50cyB3aG8gaGF2ZSBhIHNwZWNpZmljIHJvbGUuXG4gKlxuICogQHBhcmFtIHJvbGVzIHRoZSByb2xlcyB0byBwcmlvcml0aXplLlxuICovXG5jb25zdCByb2xlID0gKC4uLnJvbGVzKSA9PiAoYSwgYikgPT4ge1xuICAgIGlmIChoYXNBbnlSb2xlKGEsIHJvbGVzKSAmJiAhaGFzQW55Um9sZShiLCByb2xlcykpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoIWhhc0FueVJvbGUoYSwgcm9sZXMpICYmIGhhc0FueVJvbGUoYiwgcm9sZXMpKVxuICAgICAgICByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbn07XG4vKipcbiAqIEEgY29tcGFyYXRvciB3aGljaCBzb3J0cyBwYXJ0aWNpcGFudHMgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3QgcGFydGljaXBhbnQuXG4gKiBAcGFyYW0gYiB0aGUgc2Vjb25kIHBhcnRpY2lwYW50LlxuICovXG5jb25zdCBuYW1lID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5uYW1lIDwgYi5uYW1lKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEubmFtZSA+IGIubmFtZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG59O1xuY29uc3QgaGFzQW55Um9sZSA9IChwLCByb2xlcykgPT4gKHAucm9sZXMgfHwgW10pLnNvbWUoKHIpID0+IHJvbGVzLmluY2x1ZGVzKHIpKTtcbmNvbnN0IGhhc1NjcmVlblNoYXJlID0gKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpO1xuY29uc3QgaGFzVmlkZW8gPSAocCkgPT4gcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlZJREVPKTtcbmNvbnN0IGhhc0F1ZGlvID0gKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5BVURJTyk7XG5cbi8vIGEgY29tcGFyYXRvciBkZWNvcmF0b3Igd2hpY2ggYXBwbGllcyB0aGUgZGVjb3JhdGVkIGNvbXBhcmF0b3Igb25seSBpZiB0aGVcbi8vIHBhcnRpY2lwYW50IGlzIGludmlzaWJsZS5cbi8vIFRoaXMgZW5zdXJlcyBzdGFibGUgc29ydGluZyB3aGVuIGFsbCBwYXJ0aWNpcGFudHMgYXJlIHZpc2libGUuXG5jb25zdCBpZkludmlzaWJsZUJ5ID0gY29uZGl0aW9uYWwoKGEsIGIpID0+IGEudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBiLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFKTtcbi8qKlxuICogQSBjb21wYXJhdG9yIHRoYXQgYXBwbGllcyB0aGUgZGVjb3JhdGVkIGNvbXBhcmF0b3Igd2hlbiBhIHBhcnRpY2lwYW50IGlzXG4gKiBlaXRoZXIgaW52aXNpYmxlIG9yIGl0cyB2aXNpYmlsaXR5IHN0YXRlIGlzbid0IGtub3duLlxuICogRm9yIHZpc2libGUgcGFydGljaXBhbnRzLCBpdCBlbnN1cmVzIHN0YWJsZSBzb3J0aW5nLlxuICovXG5jb25zdCBpZkludmlzaWJsZU9yVW5rbm93bkJ5ID0gY29uZGl0aW9uYWwoKGEsIGIpID0+IGEudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBhLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTiB8fFxuICAgIGIudmlld3BvcnRWaXNpYmlsaXR5U3RhdGU/LnZpZGVvVHJhY2sgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUgfHxcbiAgICBiLnZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy52aWRlb1RyYWNrID09PSBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHNvcnRpbmcgcHJlc2V0LlxuICovXG5jb25zdCBkZWZhdWx0U29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhwaW5uZWQsIHNjcmVlblNoYXJpbmcsIGlmSW52aXNpYmxlQnkoY29tYmluZUNvbXBhcmF0b3JzKGRvbWluYW50U3BlYWtlciwgc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSk7XG4vKipcbiAqIFRoZSBzb3J0aW5nIHByZXNldCBmb3Igc3BlYWtlciBsYXlvdXQuXG4gKi9cbmNvbnN0IHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0ID0gY29tYmluZUNvbXBhcmF0b3JzKHBpbm5lZCwgc2NyZWVuU2hhcmluZywgZG9taW5hbnRTcGVha2VyLCBpZkludmlzaWJsZUJ5KGNvbWJpbmVDb21wYXJhdG9ycyhzcGVha2luZywgcmVhY3Rpb25UeXBlKCdyYWlzZWQtaGFuZCcpLCBwdWJsaXNoaW5nVmlkZW8sIHB1Ymxpc2hpbmdBdWRpbykpKTtcbi8qKlxuICogVGhlIHNvcnRpbmcgcHJlc2V0IGZvciBsYXlvdXRzIHRoYXQgZG9uJ3QgcmVuZGVyIGFsbCBwYXJ0aWNpcGFudHMgYnV0XG4gKiBpbnN0ZWFkLCByZW5kZXIgdGhlbSBpbiBwYWdlcy5cbiAqL1xuY29uc3QgcGFnaW5hdGVkTGF5b3V0U29ydFByZXNldCA9IGNvbWJpbmVDb21wYXJhdG9ycyhwaW5uZWQsIGlmSW52aXNpYmxlT3JVbmtub3duQnkoY29tYmluZUNvbXBhcmF0b3JzKGRvbWluYW50U3BlYWtlciwgc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSk7XG4vKipcbiAqIFRoZSBzb3J0aW5nIHByZXNldCBmb3IgbGl2ZXN0cmVhbXMgYW5kIGF1ZGlvIHJvb21zLlxuICovXG5jb25zdCBsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0ID0gY29tYmluZUNvbXBhcmF0b3JzKGlmSW52aXNpYmxlQnkoY29tYmluZUNvbXBhcmF0b3JzKGRvbWluYW50U3BlYWtlciwgc3BlYWtpbmcsIHJlYWN0aW9uVHlwZSgncmFpc2VkLWhhbmQnKSwgcHVibGlzaGluZ1ZpZGVvLCBwdWJsaXNoaW5nQXVkaW8pKSwgcm9sZSgnYWRtaW4nLCAnaG9zdCcsICdzcGVha2VyJykpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gKi9cbnZhciBDYWxsaW5nU3RhdGU7XG4oZnVuY3Rpb24gKENhbGxpbmdTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIGFuIHVua25vd24gc3RhdGUuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIGFuIGlkbGUgc3RhdGUuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiSURMRVwiXSA9IFwiaWRsZVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGlzIGluIHRoZSBwcm9jZXNzIG9mIHJpbmdpbmcuXG4gICAgICogKFVzZXIgaGFzbid0IGFjY2VwdGVkIG5vciByZWplY3RlZCB0aGUgY2FsbCB5ZXQuKVxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlJJTkdJTkdcIl0gPSBcInJpbmdpbmdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiBqb2luaW5nLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIkpPSU5JTkdcIl0gPSBcImpvaW5pbmdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIkpPSU5FRFwiXSA9IFwiam9pbmVkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaGFzIGJlZW4gbGVmdC5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJMRUZUXCJdID0gXCJsZWZ0XCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgcmVjb25uZWN0aW5nLlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlJFQ09OTkVDVElOR1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGwgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgbWlncmF0aW5nIGZyb20gb25lIG5vZGUgdG8gYW5vdGhlci5cbiAgICAgKi9cbiAgICBDYWxsaW5nU3RhdGVbXCJNSUdSQVRJTkdcIl0gPSBcIm1pZ3JhdGluZ1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIGhhcyBmYWlsZWQgdG8gcmVjb25uZWN0LlxuICAgICAqL1xuICAgIENhbGxpbmdTdGF0ZVtcIlJFQ09OTkVDVElOR19GQUlMRURcIl0gPSBcInJlY29ubmVjdGluZy1mYWlsZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbCBpcyBpbiBvZmZsaW5lIG1vZGUuXG4gICAgICovXG4gICAgQ2FsbGluZ1N0YXRlW1wiT0ZGTElORVwiXSA9IFwib2ZmbGluZVwiO1xufSkoQ2FsbGluZ1N0YXRlIHx8IChDYWxsaW5nU3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqIEByZWFjdCBZb3UgZG9uJ3QgaGF2ZSB0byB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgYXMgd2UgYXJlIGV4cG9zaW5nIHRoZSBzdGF0ZSB0aHJvdWdoIEhvb2tzLlxuICovXG5jbGFzcyBDYWxsU3RhdGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENhbGxTdGF0ZSBjbGFzcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJhY2tzdGFnZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRydWUpO1xuICAgICAgICB0aGlzLmJsb2NrZWRVc2VySWRzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG5ldyBEYXRlKCkpO1xuICAgICAgICB0aGlzLmVuZGVkQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnN0YXJ0c0F0U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy51cGRhdGVkQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChuZXcgRGF0ZSgpKTtcbiAgICAgICAgdGhpcy5jcmVhdGVkQnlTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmN1c3RvbVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICAgICAgdGhpcy5lZ3Jlc3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmluZ3Jlc3NTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnJlY29yZGluZ1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMudHJhbnNjcmliaW5nU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICB0aGlzLmVuZGVkQnlTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnRodW1ibmFpbHNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLm1lbWJlcnNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdChbXSk7XG4gICAgICAgIHRoaXMub3duQ2FwYWJpbGl0aWVzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICB0aGlzLmNhbGxpbmdTdGF0ZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KENhbGxpbmdTdGF0ZS5VTktOT1dOKTtcbiAgICAgICAgdGhpcy5zdGFydGVkQXRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLnBhcnRpY2lwYW50Q291bnRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCgwKTtcbiAgICAgICAgdGhpcy5hbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50U3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoMCk7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICB0aGlzLmNhbGxTdGF0c1JlcG9ydFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29tcGFyYXRvcnMgdGhhdCBhcmUgdXNlZCB0byBzb3J0IHRoZSBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRQYXJ0aWNpcGFudHNCeSA9IGRlZmF1bHRTb3J0UHJlc2V0O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbGlzdCBvZiBjcml0ZXJpYSB0aGF0IGFyZSB1c2VkIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICogVG8gZGlzYWJsZSBzb3J0aW5nLCB5b3UgY2FuIHBhc3MgYG5vb3BDb21wYXJhdG9yKClgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY29tcGFyYXRvciB0aGUgY29tcGFyYXRvciB0byB1c2UgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRTb3J0UGFydGljaXBhbnRzQnkgPSAoY29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb3J0UGFydGljaXBhbnRzQnkgPSBjb21wYXJhdG9yO1xuICAgICAgICAgICAgLy8gdHJpZ2dlciByZS1zb3J0aW5nIG9mIHBhcnRpY2lwYW50c1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5wYXJ0aWNpcGFudHNTdWJqZWN0LCAocHMpID0+IHBzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgICAgICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIFN1YmplY3QuXG4gICAgICAgICAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICAgICAgICAgKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZSB0aGUgdXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBzdWJqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUgPSBzZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q291bnQgPSAoY291bnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnBhcnRpY2lwYW50Q291bnRTdWJqZWN0LCBjb3VudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB0aW1lIHRoZSBjYWxsIHNlc3Npb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBzdGFydGVkQXQgdGhlIHRpbWUgdGhlIGNhbGwgc2Vzc2lvbiBhY3R1YWxseSBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRTdGFydGVkQXQgPSAoc3RhcnRlZEF0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zdGFydGVkQXRTdWJqZWN0LCBzdGFydGVkQXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIGFub255bW91cyBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGFub255bW91cyBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQgPSAoY291bnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0LCBjb3VudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcnRpY2lwYW50cyB0aGUgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFBhcnRpY2lwYW50cyA9IChwYXJ0aWNpcGFudHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnBhcnRpY2lwYW50c1N1YmplY3QsIHBhcnRpY2lwYW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjYWxsaW5nIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHN0YXRlIHRoZSBuZXcgY2FsbGluZyBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q2FsbGluZ1N0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsaW5nU3RhdGVTdWJqZWN0LCBzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBjYWxsIHN0YXRzIHJlcG9ydC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSByZXBvcnQgdGhlIHJlcG9ydCB0byBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENhbGxTdGF0c1JlcG9ydCA9IChyZXBvcnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNhbGxTdGF0c1JlcG9ydFN1YmplY3QsIHJlcG9ydCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBtZW1iZXJzIG9mIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gbWVtYmVycyB0aGUgbWVtYmVycyB0byBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldE1lbWJlcnMgPSAobWVtYmVycykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzU3ViamVjdCwgbWVtYmVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBvd24gY2FwYWJpbGl0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIGNhcGFiaWxpdGllcyB0aGUgY2FwYWJpbGl0aWVzIHRvIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0T3duQ2FwYWJpbGl0aWVzID0gKGNhcGFiaWxpdGllcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMub3duQ2FwYWJpbGl0aWVzU3ViamVjdCwgY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgdHJ5IHRvIGZpbmQgdGhlIHBhcnRpY2lwYW50IHdpdGggdGhlIGdpdmVuIHNlc3Npb25JZCBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uSWQgb2YgdGhlIHBhcnRpY2lwYW50IHRvIGZpbmQuXG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBwYXJ0aWNpcGFudCB3aXRoIHRoZSBnaXZlbiBzZXNzaW9uSWQgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQgPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGxvb2t1cCB0YWJsZSBvZiBwYXJ0aWNpcGFudHMgaW5kZXhlZCBieSB0aGVpciBzZXNzaW9uIElELlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRQYXJ0aWNpcGFudExvb2t1cEJ5U2Vzc2lvbklkID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydGljaXBhbnRzLnJlZHVjZSgobG9va3VwVGFibGUsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGVbcGFydGljaXBhbnQuc2Vzc2lvbklkXSA9IHBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgYSBwYXJ0aWNpcGFudCBpbiB0aGUgY3VycmVudCBjYWxsIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIGBzZXNzaW9uSWRgLlxuICAgICAgICAgKiBJZiB0aGUgcGFydGljaXBhbnQgY2FuJ3QgYmUgZm91bmQsIHRoaXMgb3BlcmF0aW9uIGlzIG5vLW9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBJRCBvZiB0aGUgcGFydGljaXBhbnQgdG8gdXBkYXRlLlxuICAgICAgICAgKiBAcGFyYW0gcGF0Y2ggdGhlIHBhdGNoIHRvIGFwcGx5IHRvIHRoZSBwYXJ0aWNpcGFudC5cbiAgICAgICAgICogQHJldHVybnMgdGhlIHVwZGF0ZWQgcGFydGljaXBhbnQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHBhcnRpY2lwYW50IGNvdWxkbid0IGJlIGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVQYXJ0aWNpcGFudCA9IChzZXNzaW9uSWQsIHBhdGNoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQoc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBQYXJ0aWNpcGFudCB3aXRoIHNlc3Npb25JZCAke3Nlc3Npb25JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhlUGF0Y2ggPSB0eXBlb2YgcGF0Y2ggPT09ICdmdW5jdGlvbicgPyBwYXRjaChwYXJ0aWNpcGFudCkgOiBwYXRjaDtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQYXJ0aWNpcGFudCA9IHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBPTDogdGhpcyBpcyBub3QgYSBkZWVwIG1lcmdlLCB3ZSBtaWdodCB3YW50IHRvIHJldmlzaXQgdGhpc1xuICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgIC4uLnRoZVBhdGNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMubWFwKChwKSA9PiBwLnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkID8gdXBkYXRlZFBhcnRpY2lwYW50IDogcCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhIHBhcnRpY2lwYW50IGluIHRoZSBjdXJyZW50IGNhbGwgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gYHNlc3Npb25JZGAuXG4gICAgICAgICAqIElmIGEgcGFydGljaXBhbnQgd2l0aCBtYXRjaGluZyBgc2Vzc2lvbklkYCBjYW4ndCBiZSBmb3VuZCwgdGhlIHByb3ZpZGVkXG4gICAgICAgICAqIGBwYXJ0aWNpcGFudGAgaXMgYWRkZWQgdG8gdGhlIGxpc3Qgb2YgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIElEIG9mIHRoZSBwYXJ0aWNpcGFudCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSBwYXJ0aWNpcGFudCB0aGUgcGFydGljaXBhbnQgdG8gdXBkYXRlIG9yIGFkZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlT3JBZGRQYXJ0aWNpcGFudCA9IChzZXNzaW9uSWQsIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQoc2Vzc2lvbklkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50cyxcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwLnNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyBhbGwgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwgd2hvc2Ugc2Vzc2lvbiBJRCBpcyBpbiB0aGUgZ2l2ZW4gYHNlc3Npb25JZHNgLlxuICAgICAgICAgKiBJZiBubyBwYXRjaGVzIGFyZSBwcm92aWRlZCwgdGhpcyBvcGVyYXRpb24gaXMgbm8tb3AuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGF0Y2ggdGhlIHBhdGNoIHRvIGFwcGx5IHRvIHRoZSBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqIEByZXR1cm5zIGFsbCBwYXJ0aWNpcGFudHMsIHdpdGggYWxsIHBhdGNoIGFwcGxpZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpY2lwYW50cyA9IChwYXRjaCkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhdGNoKS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0UGFydGljaXBhbnRzKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVQYXRjaCA9IHBhdGNoW3Auc2Vzc2lvbklkXTtcbiAgICAgICAgICAgICAgICBpZiAodGhlUGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGVQYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjYWxsIHN0YXRlIHdpdGggdGhlIGRhdGEgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IHRoZSB2aWRlbyBldmVudCB0aGF0IG91ciBiYWNrZW5kIHNlbnQgdXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21FdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5ldmVudEhhbmRsZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBwYXJ0aWNpcGFudCBwaW5uZWQgc3RhdGUgd2l0aCBzZXJ2ZXIgc2lkZSBwaW5uaW5nIGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwaW5zIHRoZSBsYXRlc3QgcGlucyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFNlcnZlclNpZGVQaW5zID0gKHBpbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBpbnNMb29rdXAgPSBwaW5zLnJlZHVjZSgobG9va3VwLCBwaW4pID0+IHtcbiAgICAgICAgICAgICAgICBsb29rdXBbcGluLnNlc3Npb25JZF0gPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb29rdXA7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLm1hcCgocGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTaWRlUGlubmVkQXQgPSBwaW5zTG9va3VwW3BhcnRpY2lwYW50LnNlc3Npb25JZF07XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50IGlzIG5ld2x5IHBpbm5lZFxuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJTaWRlUGlubmVkQXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGluOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFBpbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGlubmVkQXQ6IHNlcnZlclNpZGVQaW5uZWRBdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJ0aWNpcGFudCBpcyBubyBsb25nZXIgcGlubmVkIHNlcnZlciBzaWRlXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCB0aGUgcGluXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpY2lwYW50LnBpbiAmJiAhcGFydGljaXBhbnQucGluLmlzTG9jYWxQaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGluOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vIGNoYW5nZXMgdG8gYmUgYXBwbGllZFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIGNhbGwgc3RhdGUgd2l0aCB0aGUgZGF0YSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY2FsbCB0aGUgY2FsbCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UgPSAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5iYWNrc3RhZ2VTdWJqZWN0LCBjYWxsLmJhY2tzdGFnZSk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmJsb2NrZWRVc2VySWRzU3ViamVjdCwgY2FsbC5ibG9ja2VkX3VzZXJfaWRzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuY3JlYXRlZEF0U3ViamVjdCwgbmV3IERhdGUoY2FsbC5jcmVhdGVkX2F0KSk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnVwZGF0ZWRBdFN1YmplY3QsIG5ldyBEYXRlKGNhbGwudXBkYXRlZF9hdCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zdGFydHNBdFN1YmplY3QsIGNhbGwuc3RhcnRzX2F0ID8gbmV3IERhdGUoY2FsbC5zdGFydHNfYXQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZW5kZWRBdFN1YmplY3QsIGNhbGwuZW5kZWRfYXQgPyBuZXcgRGF0ZShjYWxsLmVuZGVkX2F0KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmNyZWF0ZWRCeVN1YmplY3QsIGNhbGwuY3JlYXRlZF9ieSk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmN1c3RvbVN1YmplY3QsIGNhbGwuY3VzdG9tKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgY2FsbC5lZ3Jlc3MpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5pbmdyZXNzU3ViamVjdCwgY2FsbC5pbmdyZXNzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMucmVjb3JkaW5nU3ViamVjdCwgY2FsbC5yZWNvcmRpbmcpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uU3ViamVjdCwgY2FsbC5zZXNzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2V0dGluZ3NTdWJqZWN0LCBjYWxsLnNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMudHJhbnNjcmliaW5nU3ViamVjdCwgY2FsbC50cmFuc2NyaWJpbmcpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy50aHVtYm5haWxzU3ViamVjdCwgY2FsbC50aHVtYm5haWxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tTWVtYmVyUmVtb3ZlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZW1iZXJzU3ViamVjdCwgKG1lbWJlcnMpID0+IG1lbWJlcnMuZmlsdGVyKChtKSA9PiBldmVudC5tZW1iZXJzLmluZGV4T2YobS51c2VyX2lkKSA9PT0gLTEpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tTWVtYmVyQWRkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVyc1N1YmplY3QsIChtZW1iZXJzKSA9PiBbXG4gICAgICAgICAgICAgICAgLi4ubWVtYmVycyxcbiAgICAgICAgICAgICAgICAuLi5ldmVudC5tZW1iZXJzLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0b3BwZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmVncmVzc1N1YmplY3QsIChlZ3Jlc3MpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZWdyZXNzLFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdGluZ0ZhaWxlZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuZWdyZXNzU3ViamVjdCwgKGVncmVzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5lZ3Jlc3MsXG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGcm9tSExTQnJvYWRjYXN0U3RhcnRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3NTdWJqZWN0LCAoZWdyZXNzKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmVncmVzcyxcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Rpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgaGxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmVncmVzcy5obHMsXG4gICAgICAgICAgICAgICAgICAgIHBsYXlsaXN0X3VybDogZXZlbnQuaGxzX3BsYXlsaXN0X3VybCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRMZWZ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNlc3Npb25TdWJqZWN0LCAoc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBSZWNlaXZlZCBjYWxsLnNlc3Npb25fcGFydGljaXBhbnRfbGVmdCBldmVudCBidXQgbm8gc2Vzc2lvbiBpcyBhdmFpbGFibGUuYCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJ0aWNpcGFudHMsIHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlIH0gPSBzZXNzaW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlciwgdXNlcl9zZXNzaW9uX2lkIH0gPSBldmVudC5wYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5zZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudHM6IHBhcnRpY2lwYW50cy5maWx0ZXIoKHApID0+IHAudXNlcl9zZXNzaW9uX2lkICE9PSB1c2VyX3Nlc3Npb25faWQpLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdXNlci5yb2xlXTogTWF0aC5tYXgoMCwgKHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlW3VzZXIucm9sZV0gfHwgMCkgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRnJvbVNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uU3ViamVjdCwgKHNlc3Npb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCBgUmVjZWl2ZWQgY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2pvaW5lZCBldmVudCBidXQgbm8gc2Vzc2lvbiBpcyBhdmFpbGFibGUuYCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXJ0aWNpcGFudHMsIHBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlIH0gPSBzZXNzaW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlciwgdXNlcl9zZXNzaW9uX2lkIH0gPSBldmVudC5wYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICAvLyBJdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgYmFja2VuZCBkZWxpdmVycyB0aGUgc2FtZSBwYXJ0aWNpcGFudCBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgICAgICAgICAvLyBPbmNlIHdpdGggdGhlIGNhbGwuc2Vzc2lvbl9zdGFydGVkIGV2ZW50IGFuZCBvbmNlIGFnYWluIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2pvaW5lZCBldmVudC4gSW4gdGhpcyBjYXNlLFxuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCB1cGRhdGUgdGhlIGV4aXN0aW5nIHBhcnRpY2lwYW50IGFuZCBwcmV2ZW50IGR1cGxpY2F0aW5nIGl0LlxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRJbnNlcnRQYXJ0aWNpcGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBhcnRpY2lwYW50cyA9IHBhcnRpY2lwYW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAudXNlcl9zZXNzaW9uX2lkID09PSB1c2VyX3Nlc3Npb25faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEluc2VydFBhcnRpY2lwYW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQucGFydGljaXBhbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEluc2VydFBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBuZXcgYXJyYXksIHdlIGNhbiBzYWZlbHkgcHVzaCB0aGUgbmV3IHBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRQYXJ0aWNpcGFudHMucHVzaChldmVudC5wYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSB1cGRhdGluZyBhbiBleGlzdGluZyBwYXJ0aWNpcGFudCwgd2UgZG9uJ3Qgd2FudCB0byBpbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnRfYnlfcm9sZSBjb3VudC5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBzaG91bGRJbnNlcnRQYXJ0aWNpcGFudCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50czogdXBkYXRlZFBhcnRpY2lwYW50cyxcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50c19jb3VudF9ieV9yb2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3VzZXIucm9sZV06IChwYXJ0aWNpcGFudHNfY291bnRfYnlfcm9sZVt1c2VyLnJvbGVdIHx8IDApICsgaW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVNZW1iZXJzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm1lbWJlcnNTdWJqZWN0LCAobWVtYmVycykgPT4gbWVtYmVycy5tYXAoKG1lbWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lbWJlclVwZGF0ZSA9IGV2ZW50Lm1lbWJlcnMuZmluZCgobSkgPT4gbS51c2VyX2lkID09PSBtZW1iZXIudXNlcl9pZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlclVwZGF0ZSA/IG1lbWJlclVwZGF0ZSA6IG1lbWJlcjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJ0aWNpcGFudFJlYWN0aW9uID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXIsIGN1c3RvbSwgdHlwZSwgZW1vamlfY29kZSB9ID0gZXZlbnQucmVhY3Rpb247XG4gICAgICAgICAgICB0aGlzLnNldFBhcnRpY2lwYW50cygocGFydGljaXBhbnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcmVhY3Rpb24gaXMgbm90IGZvciB0aGlzIHBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnVzZXJJZCAhPT0gdXNlci5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcnRpY2lwYW50IHdpdGggdGhlIG5ldyByZWFjdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbW9qaV9jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bmJsb2NrVXNlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QsIChjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5maWx0ZXIoKGlkKSA9PiBpZCAhPT0gZXZlbnQudXNlci5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibG9ja1VzZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuYmxvY2tlZFVzZXJJZHNTdWJqZWN0LCAoY3VycmVudCkgPT4gW1xuICAgICAgICAgICAgICAgIC4uLihjdXJyZW50IHx8IFtdKSxcbiAgICAgICAgICAgICAgICBldmVudC51c2VyLmlkLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlT3duQ2FwYWJpbGl0aWVzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudXNlci5pZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50Py51c2VySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLm93bkNhcGFiaWxpdGllc1N1YmplY3QsIGV2ZW50Lm93bl9jYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ0NhbGxTdGF0ZSddKTtcbiAgICAgICAgdGhpcy5wYXJ0aWNpcGFudHMkID0gdGhpcy5wYXJ0aWNpcGFudHNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnBpcGUoXG4gICAgICAgIC8vIG1haW50YWluIHN0YWJsZS1zb3J0IGJ5IG11dGF0aW5nIHRoZSBwYXJ0aWNpcGFudHMgc3RvcmVkXG4gICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBzdWJqZWN0XG4gICAgICAgIG1hcCQxKChwcykgPT4gcHMuc29ydCh0aGlzLnNvcnRQYXJ0aWNpcGFudHNCeSkpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50JCA9IHRoaXMucGFydGljaXBhbnRzJC5waXBlKG1hcCQxKChwYXJ0aWNpcGFudHMpID0+IHBhcnRpY2lwYW50cy5maW5kKChwKSA9PiBwLmlzTG9jYWxQYXJ0aWNpcGFudCkpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMkID0gdGhpcy5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbHRlcigocCkgPT4gIXAuaXNMb2NhbFBhcnRpY2lwYW50KSksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLnBpbm5lZFBhcnRpY2lwYW50cyQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmlsdGVyKChwKSA9PiAhIXAucGluKSksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLmRvbWluYW50U3BlYWtlciQgPSB0aGlzLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC5pc0RvbWluYW50U3BlYWtlcikpLCBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5oYXNPbmdvaW5nU2NyZWVuU2hhcmUkID0gdGhpcy5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLnNvbWUoKHApID0+IHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUpKSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWRBdCQgPSB0aGlzLnN0YXJ0ZWRBdFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMucGFydGljaXBhbnRDb3VudCQgPSB0aGlzLnBhcnRpY2lwYW50Q291bnRTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnQkID1cbiAgICAgICAgICAgIHRoaXMuYW5vbnltb3VzUGFydGljaXBhbnRDb3VudFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuY2FsbFN0YXRzUmVwb3J0JCA9IHRoaXMuY2FsbFN0YXRzUmVwb3J0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzJCA9IHRoaXMubWVtYmVyc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMub3duQ2FwYWJpbGl0aWVzJCA9IHRoaXMub3duQ2FwYWJpbGl0aWVzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jYWxsaW5nU3RhdGUkID0gdGhpcy5jYWxsaW5nU3RhdGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmJhY2tzdGFnZSQgPSB0aGlzLmJhY2tzdGFnZVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuYmxvY2tlZFVzZXJJZHMkID0gdGhpcy5ibG9ja2VkVXNlcklkc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0JCA9IHRoaXMuY3JlYXRlZEF0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5lbmRlZEF0JCA9IHRoaXMuZW5kZWRBdFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuc3RhcnRzQXQkID0gdGhpcy5zdGFydHNBdFN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlZEF0JCA9IHRoaXMudXBkYXRlZEF0U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVkQnkkID0gdGhpcy5jcmVhdGVkQnlTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmN1c3RvbSQgPSB0aGlzLmN1c3RvbVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuZWdyZXNzJCA9IHRoaXMuZWdyZXNzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5pbmdyZXNzJCA9IHRoaXMuaW5ncmVzc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nJCA9IHRoaXMucmVjb3JkaW5nU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uJCA9IHRoaXMuc2Vzc2lvblN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MkID0gdGhpcy5zZXR0aW5nc1N1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMudHJhbnNjcmliaW5nJCA9IHRoaXMudHJhbnNjcmliaW5nU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5lbmRlZEJ5JCA9IHRoaXMuZW5kZWRCeVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMudGh1bWJuYWlscyQgPSB0aGlzLnRodW1ibmFpbHNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIG5vdCB1cGRhdGluZyB0aGUgY2FsbCBzdGF0ZTpcbiAgICAgICAgICAgICdjYWxsLnBlcm1pc3Npb25fcmVxdWVzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjYWxsLnJlY29yZGluZ19mYWlsZWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC5yZWNvcmRpbmdfcmVhZHknOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2FsbC51c2VyX211dGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nvbm5lY3Rpb24uZXJyb3InOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY29ubmVjdGlvbi5vayc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdoZWFsdGguY2hlY2snOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdXN0b206IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIGV2ZW50cyB0aGF0IHVwZGF0ZSBjYWxsIHN0YXRlOlxuICAgICAgICAgICAgJ2NhbGwuYWNjZXB0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5ibG9ja2VkX3VzZXInOiB0aGlzLmJsb2NrVXNlcixcbiAgICAgICAgICAgICdjYWxsLmNyZWF0ZWQnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5lbmRlZCc6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5lbmRlZEJ5U3ViamVjdCwgZS51c2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnY2FsbC5obHNfYnJvYWRjYXN0aW5nX2ZhaWxlZCc6IHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdGluZ0ZhaWxlZCxcbiAgICAgICAgICAgICdjYWxsLmhsc19icm9hZGNhc3Rpbmdfc3RhcnRlZCc6IHRoaXMudXBkYXRlRnJvbUhMU0Jyb2FkY2FzdFN0YXJ0ZWQsXG4gICAgICAgICAgICAnY2FsbC5obHNfYnJvYWRjYXN0aW5nX3N0b3BwZWQnOiB0aGlzLnVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdG9wcGVkLFxuICAgICAgICAgICAgJ2NhbGwubGl2ZV9zdGFydGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwubWVtYmVyX2FkZGVkJzogdGhpcy51cGRhdGVGcm9tTWVtYmVyQWRkZWQsXG4gICAgICAgICAgICAnY2FsbC5tZW1iZXJfcmVtb3ZlZCc6IHRoaXMudXBkYXRlRnJvbU1lbWJlclJlbW92ZWQsXG4gICAgICAgICAgICAnY2FsbC5tZW1iZXJfdXBkYXRlZF9wZXJtaXNzaW9uJzogdGhpcy51cGRhdGVNZW1iZXJzLFxuICAgICAgICAgICAgJ2NhbGwubWVtYmVyX3VwZGF0ZWQnOiB0aGlzLnVwZGF0ZU1lbWJlcnMsXG4gICAgICAgICAgICAnY2FsbC5ub3RpZmljYXRpb24nOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWVtYmVycyhlLm1lbWJlcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWQnOiB0aGlzLnVwZGF0ZU93bkNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICdjYWxsLnJlYWN0aW9uX25ldyc6IHRoaXMudXBkYXRlUGFydGljaXBhbnRSZWFjdGlvbixcbiAgICAgICAgICAgICdjYWxsLnJlY29yZGluZ19zdGFydGVkJzogKCkgPT4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmdTdWJqZWN0LCB0cnVlKSxcbiAgICAgICAgICAgICdjYWxsLnJlY29yZGluZ19zdG9wcGVkJzogKCkgPT4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmdTdWJqZWN0LCBmYWxzZSksXG4gICAgICAgICAgICAnY2FsbC5yZWplY3RlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgICAgICdjYWxsLnJpbmcnOiAoZSkgPT4gdGhpcy51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGUuY2FsbCksXG4gICAgICAgICAgICAnY2FsbC5zZXNzaW9uX2VuZGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwuc2Vzc2lvbl9wYXJ0aWNpcGFudF9qb2luZWQnOiB0aGlzLnVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRKb2luZWQsXG4gICAgICAgICAgICAnY2FsbC5zZXNzaW9uX3BhcnRpY2lwYW50X2xlZnQnOiB0aGlzLnVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRMZWZ0LFxuICAgICAgICAgICAgJ2NhbGwuc2Vzc2lvbl9zdGFydGVkJzogKGUpID0+IHRoaXMudXBkYXRlRnJvbUNhbGxSZXNwb25zZShlLmNhbGwpLFxuICAgICAgICAgICAgJ2NhbGwudW5ibG9ja2VkX3VzZXInOiB0aGlzLnVuYmxvY2tVc2VyLFxuICAgICAgICAgICAgJ2NhbGwudXBkYXRlZCc6IChlKSA9PiB0aGlzLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UoZS5jYWxsKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlci1zaWRlIGNvdW50ZWQgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBjb25uZWN0ZWQgdG8gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKiBUaGlzIG51bWJlciBpbmNsdWRlcyB0aGUgYW5vbnltb3VzIHBhcnRpY2lwYW50cyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGdldCBwYXJ0aWNpcGFudENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5wYXJ0aWNpcGFudENvdW50JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIHRoZSBjYWxsIHNlc3Npb24gYWN0dWFsbHkgc3RhcnRlZC5cbiAgICAgKiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgdGhlIGNhbGwgZHVyYXRpb24uXG4gICAgICovXG4gICAgZ2V0IHN0YXJ0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhcnRlZEF0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXItc2lkZSBjb3VudGVkIG51bWJlciBvZiBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGNvbm5lY3RlZCB0byB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqIFRoaXMgbnVtYmVyIGluY2x1ZGVzIHRoZSBhbm9ueW1vdXMgcGFydGljaXBhbnRzIGFzIHdlbGwuXG4gICAgICovXG4gICAgZ2V0IGFub255bW91c1BhcnRpY2lwYW50Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmFub255bW91c1BhcnRpY2lwYW50Q291bnQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgcGFydGljaXBhbnRzIGluIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IHBhcnRpY2lwYW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMucGFydGljaXBhbnRzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBwYXJ0aWNpcGFudCBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqL1xuICAgIGdldCBsb2NhbFBhcnRpY2lwYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5sb2NhbFBhcnRpY2lwYW50JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBsaXN0IG9mIHJlbW90ZSBwYXJ0aWNpcGFudHMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcmVtb3RlUGFydGljaXBhbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGRvbWluYW50IHNwZWFrZXIgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgZG9taW5hbnRTcGVha2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kb21pbmFudFNwZWFrZXIkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3Qgb2YgcGlubmVkIHBhcnRpY2lwYW50cyBpbiB0aGUgY3VycmVudCBjYWxsLlxuICAgICAqL1xuICAgIGdldCBwaW5uZWRQYXJ0aWNpcGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnBpbm5lZFBhcnRpY2lwYW50cyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWxsIGlmIHRoZXJlIGlzIGFuIG9uZ29pbmcgc2NyZWVuIHNoYXJlIGluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgaGFzT25nb2luZ1NjcmVlblNoYXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5oYXNPbmdvaW5nU2NyZWVuU2hhcmUkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGNhbGxpbmdTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbGluZ1N0YXRlJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjYWxsIHN0YXRzIHJlcG9ydC5cbiAgICAgKi9cbiAgICBnZXQgY2FsbFN0YXRzUmVwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsU3RhdHNSZXBvcnQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1lbWJlcnMgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgbWVtYmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMubWVtYmVycyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBjdXJyZW50IHVzZXIgZm9yIHRoZSBjdXJyZW50IGNhbGwuXG4gICAgICovXG4gICAgZ2V0IG93bkNhcGFiaWxpdGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMub3duQ2FwYWJpbGl0aWVzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrc3RhZ2Ugc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IGJhY2tzdGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYmFja3N0YWdlJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgbGlzdCBvZiBibG9ja2VkIHVzZXIgSURzLlxuICAgICAqL1xuICAgIGdldCBibG9ja2VkVXNlcklkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYmxvY2tlZFVzZXJJZHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgZ2V0IGNyZWF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY3JlYXRlZEF0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdGltZSB3aGVuIHRoaXMgY2FsbCBoYXMgYmVlbiBlbmRlZC5cbiAgICAgKi9cbiAgICBnZXQgZW5kZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZW5kZWRBdCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRpbWUgd2hlbiB0aGlzIGNhbGwgaGFzIGJlZW4gc2NoZWR1bGVkIHRvIHN0YXJ0LlxuICAgICAqL1xuICAgIGdldCBzdGFydHNBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhcnRzQXQkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0aW1lIHdoZW4gdGhpcyBjYWxsIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICovXG4gICAgZ2V0IHVwZGF0ZWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMudXBkYXRlZEF0JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgdXNlciB3aG8gY3JlYXRlZCB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZ2V0IGNyZWF0ZWRCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY3JlYXRlZEJ5JCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgY3VzdG9tIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBjdXN0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLmN1c3RvbSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIGVncmVzcyBkYXRhIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgZWdyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5lZ3Jlc3MkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSBpbmdyZXNzIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBpbmdyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5pbmdyZXNzJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgcmVjb3JkaW5nIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcmVjb3JkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5yZWNvcmRpbmckKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSBzZXNzaW9uIGRhdGEgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZXNzaW9uJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcHJvdmlkZSB0aGUgc2V0dGluZ3Mgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCBzZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2V0dGluZ3MkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBwcm92aWRlIHRoZSB0cmFuc2NyaWJpbmcgc3RhdGUgb2YgdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGdldCB0cmFuc2NyaWJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnRyYW5zY3JpYmluZyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHVzZXIgd2hvIGVuZGVkIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgZW5kZWRCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZW5kZWRCeSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIHByb3ZpZGUgdGhlIHRodW1ibmFpbHMgb2YgdGhpcyBjYWxsLCBpZiBlbmFibGVkIGluIHRoZSBjYWxsIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGdldCB0aHVtYm5haWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy50aHVtYm5haWxzJCk7XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdG9yZSBrZWVwaW5nIGRhdGEgb2YgYSBzdWNjZXNzZnVsbHkgY29ubmVjdGVkIHVzZXIgb3ZlciBXUyB0byB0aGUgY29vcmRpbmF0b3Igc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0ZWRVc2VyU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiB7QGxpbmsgQ2FsbH0gb2JqZWN0cyBjcmVhdGVkL3RyYWNrZWQgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhbiBvYnNlcnZhYmxlLCBvciB1bmRlZmluZWQgaWYgdGhlIG9ic2VydmFibGUgaGFzXG4gICAgICAgICAqIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSQgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvdmlkZWQgU3ViamVjdC5cbiAgICAgICAgICogQW4gYHVwZGF0ZWAgY2FuIGVpdGhlciBiZSBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzXG4gICAgICAgICAqIHRoZSBjdXJyZW50IHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGUgdGhlIHVwZGF0ZSB0byBhcHBseSB0byB0aGUgc3ViamVjdC5cbiAgICAgICAgICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlID0gc2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHVzZXIgdGhlIHVzZXIgdG8gc2V0IGFzIGNvbm5lY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q29ubmVjdGVkVXNlciA9ICh1c2VyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jb25uZWN0ZWRVc2VyU3ViamVjdCwgdXNlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICogQHBhcmFtIGNhbGxzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENhbGxzID0gKGNhbGxzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5jYWxsc1N1YmplY3QsIGNhbGxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYSB7QGxpbmsgQ2FsbH0gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gYWRkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWdpc3RlckNhbGwgPSAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxzLmZpbmQoKGMpID0+IGMuY2lkID09PSBjYWxsLmNpZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENhbGxzKChjYWxscykgPT4gWy4uLmNhbGxzLCBjYWxsXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEge0BsaW5rIENhbGx9IG9iamVjdCBmcm9tIHRoZSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gcmVtb3ZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJDYWxsID0gKGNhbGwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldENhbGxzKChjYWxscykgPT4gY2FsbHMuZmlsdGVyKChjKSA9PiBjICE9PSBjYWxsKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kcyBhIHtAbGluayBDYWxsfSBvYmplY3QgaW4gdGhlIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiBjYWxsIHRvIGZpbmQuXG4gICAgICAgICAqIEBwYXJhbSBpZCB0aGUgaWQgb2YgdGhlIGNhbGwgdG8gZmluZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZENhbGwgPSAodHlwZSwgaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxzLmZpbmQoKGMpID0+IGMudHlwZSA9PT0gdHlwZSAmJiBjLmlkID09PSBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGVkVXNlclN1YmplY3Quc3Vic2NyaWJlKGFzeW5jICh1c2VyKSA9PiB7XG4gICAgICAgICAgICAvLyBsZWF2ZSBhbGwgY2FsbHMgd2hlbiB0aGUgdXNlciBkaXNjb25uZWN0cy5cbiAgICAgICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2NsaWVudC1zdGF0ZSddKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy5jYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcignaW5mbycsIGBVc2VyIGRpc2Nvbm5lY3RlZCwgbGVhdmluZyBjYWxsOiAke2NhbGwuY2lkfWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGBFcnJvciBsZWF2aW5nIGNhbGw6ICR7Y2FsbC5jaWR9YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlci5cbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGVkVXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY29ubmVjdGVkVXNlclN1YmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGxpc3Qgb2Yge0BsaW5rIENhbGx9IG9iamVjdHMgY3JlYXRlZC90cmFja2VkIGJ5IHRoaXMgY2xpZW50LlxuICAgICAqL1xuICAgIGdldCBjYWxscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuY2FsbHNTdWJqZWN0KTtcbiAgICB9XG59XG4vKipcbiAqIEEgcmVhY3RpdmUgc3RvcmUgdGhhdCBleHBvc2VzIHN0YXRlIHZhcmlhYmxlcyBpbiBhIHJlYWN0aXZlIG1hbm5lci5cbiAqIFlvdSBjYW4gc3Vic2NyaWJlIHRvIGNoYW5nZXMgb2YgdGhlIGRpZmZlcmVudCBzdGF0ZSB2YXJpYWJsZXMuXG4gKiBUaGlzIGNlbnRyYWwgc3RvcmUgY29udGFpbnMgYWxsIHRoZSBzdGF0ZSB2YXJpYWJsZXMgcmVsYXRlZCB0byBbYFN0cmVhbVZpZGVvQ2xpZW50YF0oLi9TdHJlYW1WaWRlQ2xpZW50Lm1kKSBhbmQgW2BDYWxsYF0oLi9DYWxsLm1kKS5cbiAqL1xuY2xhc3MgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRoZSBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdGF0ZSB2YXJpYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUgdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mLlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvLyBjb252ZXJ0IGFuZCBleHBvc2Ugc3ViamVjdHMgYXMgb2JzZXJ2YWJsZXNcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRVc2VyJCA9IHN0b3JlLmNvbm5lY3RlZFVzZXJTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLmNhbGxzJCA9IHN0b3JlLmNhbGxzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdXNlciBjb25uZWN0ZWQgb3ZlciBXUyB0byB0aGUgYmFja2VuZC5cbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGVkVXNlcigpIHtcbiAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRWYWx1ZSh0aGlzLmNvbm5lY3RlZFVzZXIkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHtAbGluayBDYWxsfSBvYmplY3RzIGNyZWF0ZWQvdHJhY2tlZCBieSB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXQgY2FsbHMoKSB7XG4gICAgICAgIHJldHVybiBnZXRDdXJyZW50VmFsdWUodGhpcy5jYWxscyQpO1xuICAgIH1cbn1cblxuY29uc3QgZ2V0UnRwTWFwID0gKGxpbmUpID0+IHtcbiAgICAvLyBFeGFtcGxlOiBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgY29uc3QgcnRwUmVnZXggPSAvXmE9cnRwbWFwOihcXGQqKSAoW1xcd1xcLS5dKikoPzpcXHMqXFwvKFxcZCopKD86XFxzKlxcLyhcXFMqKSk/KT8vO1xuICAgIC8vIFRoZSBmaXJzdCBjYXB0dXJlZCBncm91cCBpcyB0aGUgcGF5bG9hZCB0eXBlIG51bWJlciwgdGhlIHNlY29uZCBjYXB0dXJlZCBncm91cCBpcyB0aGUgZW5jb2RpbmcgbmFtZSwgdGhlIHRoaXJkIGNhcHR1cmVkIGdyb3VwIGlzIHRoZSBjbG9jayByYXRlLCBhbmQgdGhlIGZvdXJ0aCBjYXB0dXJlZCBncm91cCBpcyBhbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzLlxuICAgIGNvbnN0IHJ0cE1hdGNoID0gcnRwUmVnZXguZXhlYyhsaW5lKTtcbiAgICBpZiAocnRwTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiBydHBNYXRjaFswXSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJ0cE1hdGNoWzFdLFxuICAgICAgICAgICAgY29kZWM6IHJ0cE1hdGNoWzJdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBnZXRGbXRwID0gKGxpbmUpID0+IHtcbiAgICAvLyBFeGFtcGxlOiBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgIGNvbnN0IGZtdHBSZWdleCA9IC9eYT1mbXRwOihcXGQqKSAoLiopLztcbiAgICBjb25zdCBmbXRwTWF0Y2ggPSBmbXRwUmVnZXguZXhlYyhsaW5lKTtcbiAgICAvLyBUaGUgZmlyc3QgY2FwdHVyZWQgZ3JvdXAgaXMgdGhlIHBheWxvYWQgdHlwZSBudW1iZXIsIHRoZSBzZWNvbmQgY2FwdHVyZWQgZ3JvdXAgaXMgYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVycy5cbiAgICBpZiAoZm10cE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnaW5hbDogZm10cE1hdGNoWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogZm10cE1hdGNoWzFdLFxuICAgICAgICAgICAgY29uZmlnOiBmbXRwTWF0Y2hbMl0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogZ2V0cyB0aGUgbWVkaWEgc2VjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBtZWRpYSB0eXBlLlxuICogVGhlIG1lZGlhIHNlY3Rpb24gY29udGFpbnMgdGhlIG1lZGlhIHR5cGUsIHBvcnQsIGNvZGVjLCBhbmQgcGF5bG9hZCB0eXBlLlxuICogRXhhbXBsZTogbT12aWRlbyA5IFVEUC9UTFMvUlRQL1NBVlBGIDEwMCAxMDEgOTYgOTcgMzUgMzYgMTAyIDEyNSAxMjdcbiAqL1xuY29uc3QgZ2V0TWVkaWEgPSAobGluZSwgbWVkaWFUeXBlKSA9PiB7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAobT0ke21lZGlhVHlwZX0gXFxcXGQrIFtcXFxcdy9dKykgKFtcXFxcZFxcXFxzXSspYCk7XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKGxpbmUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ2luYWw6IG1hdGNoWzBdLFxuICAgICAgICAgICAgbWVkaWFXaXRoUG9ydHM6IG1hdGNoWzFdLFxuICAgICAgICAgICAgY29kZWNPcmRlcjogbWF0Y2hbMl0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGdldE1lZGlhU2VjdGlvbiA9IChzZHAsIG1lZGlhVHlwZSkgPT4ge1xuICAgIGxldCBtZWRpYTtcbiAgICBjb25zdCBydHBNYXAgPSBbXTtcbiAgICBjb25zdCBmbXRwID0gW107XG4gICAgbGV0IGlzVGhlUmVxdWlyZWRNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRMaW5lID0gL14oW2Etel0pPSguKikvLnRlc3QobGluZSk7XG4gICAgICAgIGlmICghaXNWYWxpZExpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qXG4gICAgICAgICAgTk9URTogYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM4ODY2LnBkZlxuICAgICAgICAgIEVhY2ggbWVkaWEgZGVzY3JpcHRpb24gc3RhcnRzIHdpdGggYW4gXCJtPVwiIGxpbmUgYW5kIGNvbnRpbnVlcyB0byB0aGUgbmV4dCBtZWRpYSBkZXNjcmlwdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB3aG9sZSBzZXNzaW9uIGRlc2NyaXB0aW9uLCB3aGljaGV2ZXIgY29tZXMgZmlyc3RcbiAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdHlwZSA9IGxpbmVbMF07XG4gICAgICAgIGlmICh0eXBlID09PSAnbScpIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZWRpYSA9IGdldE1lZGlhKGxpbmUsIG1lZGlhVHlwZSk7XG4gICAgICAgICAgICBpc1RoZVJlcXVpcmVkTWVkaWFTZWN0aW9uID0gISFfbWVkaWE7XG4gICAgICAgICAgICBpZiAoX21lZGlhKSB7XG4gICAgICAgICAgICAgICAgbWVkaWEgPSBfbWVkaWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUaGVSZXF1aXJlZE1lZGlhU2VjdGlvbiAmJiB0eXBlID09PSAnYScpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0cE1hcExpbmUgPSBnZXRSdHBNYXAobGluZSk7XG4gICAgICAgICAgICBjb25zdCBmbXRwTGluZSA9IGdldEZtdHAobGluZSk7XG4gICAgICAgICAgICBpZiAocnRwTWFwTGluZSkge1xuICAgICAgICAgICAgICAgIHJ0cE1hcC5wdXNoKHJ0cE1hcExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm10cExpbmUpIHtcbiAgICAgICAgICAgICAgICBmbXRwLnB1c2goZm10cExpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYSxcbiAgICAgICAgICAgIHJ0cE1hcCxcbiAgICAgICAgICAgIGZtdHAsXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogR2V0cyB0aGUgZm10cCBsaW5lIGNvcnJlc3BvbmRpbmcgdG8gb3B1c1xuICovXG5jb25zdCBnZXRPcHVzRm10cCA9IChzZHApID0+IHtcbiAgICBjb25zdCBzZWN0aW9uID0gZ2V0TWVkaWFTZWN0aW9uKHNkcCwgJ2F1ZGlvJyk7XG4gICAgY29uc3QgcnRwTWFwID0gc2VjdGlvbj8ucnRwTWFwLmZpbmQoKHIpID0+IHIuY29kZWMudG9Mb3dlckNhc2UoKSA9PT0gJ29wdXMnKTtcbiAgICBjb25zdCBjb2RlY0lkID0gcnRwTWFwPy5wYXlsb2FkO1xuICAgIGlmIChjb2RlY0lkKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uPy5mbXRwLmZpbmQoKGYpID0+IGYucGF5bG9hZCA9PT0gY29kZWNJZCk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBTRFAgd2l0aCBEVFggZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAqL1xuY29uc3QgdG9nZ2xlRHR4ID0gKHNkcCwgZW5hYmxlKSA9PiB7XG4gICAgY29uc3Qgb3B1c0ZtdHAgPSBnZXRPcHVzRm10cChzZHApO1xuICAgIGlmIChvcHVzRm10cCkge1xuICAgICAgICBjb25zdCBtYXRjaER0eCA9IC91c2VkdHg9KFxcZCkvLmV4ZWMob3B1c0ZtdHAuY29uZmlnKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWREdHhDb25maWcgPSBgdXNlZHR4PSR7ZW5hYmxlID8gJzEnIDogJzAnfWA7XG4gICAgICAgIGlmIChtYXRjaER0eCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Rm10cCA9IG9wdXNGbXRwLm9yaWdpbmFsLnJlcGxhY2UoL3VzZWR0eD0oXFxkKS8sIHJlcXVpcmVkRHR4Q29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBzZHAucmVwbGFjZShvcHVzRm10cC5vcmlnaW5hbCwgbmV3Rm10cCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdGbXRwID0gYCR7b3B1c0ZtdHAub3JpZ2luYWx9OyR7cmVxdWlyZWREdHhDb25maWd9YDtcbiAgICAgICAgICAgIHJldHVybiBzZHAucmVwbGFjZShvcHVzRm10cC5vcmlnaW5hbCwgbmV3Rm10cCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNkcDtcbn07XG4vKipcbiAqIEVuYWJsZXMgaGlnaC1xdWFsaXR5IGF1ZGlvIHRocm91Z2ggU0RQIG11bmdpbmcgZm9yIHRoZSBnaXZlbiB0cmFja01pZC5cbiAqXG4gKiBAcGFyYW0gc2RwIHRoZSBTRFAgdG8gbXVuZ2UuXG4gKiBAcGFyYW0gdHJhY2tNaWQgdGhlIHRyYWNrTWlkLlxuICogQHBhcmFtIG1heEJpdHJhdGUgdGhlIG1heCBiaXRyYXRlIHRvIHNldC5cbiAqL1xuY29uc3QgZW5hYmxlSGlnaFF1YWxpdHlBdWRpbyA9IChzZHAsIHRyYWNrTWlkLCBtYXhCaXRyYXRlID0gNTEwMDAwKSA9PiB7XG4gICAgbWF4Qml0cmF0ZSA9IE1hdGgubWF4KE1hdGgubWluKG1heEJpdHJhdGUsIDUxMDAwMCksIDk2MDAwKTtcbiAgICBjb25zdCBwYXJzZWRTZHAgPSBTRFAucGFyc2Uoc2RwKTtcbiAgICBjb25zdCBhdWRpb01lZGlhID0gcGFyc2VkU2RwLm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2F1ZGlvJyAmJiBTdHJpbmcobS5taWQpID09PSB0cmFja01pZCk7XG4gICAgaWYgKCFhdWRpb01lZGlhKVxuICAgICAgICByZXR1cm4gc2RwO1xuICAgIGNvbnN0IG9wdXNSdHAgPSBhdWRpb01lZGlhLnJ0cC5maW5kKChyKSA9PiByLmNvZGVjID09PSAnb3B1cycpO1xuICAgIGlmICghb3B1c1J0cClcbiAgICAgICAgcmV0dXJuIHNkcDtcbiAgICBjb25zdCBvcHVzRm10cCA9IGF1ZGlvTWVkaWEuZm10cC5maW5kKChmKSA9PiBmLnBheWxvYWQgPT09IG9wdXNSdHAucGF5bG9hZCk7XG4gICAgaWYgKCFvcHVzRm10cClcbiAgICAgICAgcmV0dXJuIHNkcDtcbiAgICAvLyBlbmFibGUgc3RlcmVvLCBpZiBub3QgYWxyZWFkeSBlbmFibGVkXG4gICAgaWYgKG9wdXNGbXRwLmNvbmZpZy5tYXRjaCgvc3RlcmVvPShcXGQpLykpIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gb3B1c0ZtdHAuY29uZmlnLnJlcGxhY2UoL3N0ZXJlbz0oXFxkKS8sICdzdGVyZW89MScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gYCR7b3B1c0ZtdHAuY29uZmlnfTtzdGVyZW89MWA7XG4gICAgfVxuICAgIC8vIHNldCBtYXhhdmVyYWdlYml0cmF0ZSwgdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAgaWYgKG9wdXNGbXRwLmNvbmZpZy5tYXRjaCgvbWF4YXZlcmFnZWJpdHJhdGU9KFxcZCopLykpIHtcbiAgICAgICAgb3B1c0ZtdHAuY29uZmlnID0gb3B1c0ZtdHAuY29uZmlnLnJlcGxhY2UoL21heGF2ZXJhZ2ViaXRyYXRlPShcXGQqKS8sIGBtYXhhdmVyYWdlYml0cmF0ZT0ke21heEJpdHJhdGV9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHVzRm10cC5jb25maWcgPSBgJHtvcHVzRm10cC5jb25maWd9O21heGF2ZXJhZ2ViaXRyYXRlPSR7bWF4Qml0cmF0ZX1gO1xuICAgIH1cbiAgICByZXR1cm4gU0RQLndyaXRlKHBhcnNlZFNkcCk7XG59O1xuXG5jb25zdCBsb2dnZXIkMyA9IGdldExvZ2dlcihbJ1B1Ymxpc2hlciddKTtcbi8qKlxuICogVGhlIGBQdWJsaXNoZXJgIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nL3VucHVibGlzaGluZyBtZWRpYSBzdHJlYW1zIHRvL2Zyb20gdGhlIFNGVVxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFB1Ymxpc2hlciB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnBjLmdldENvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgUHVibGlzaGVyYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgY2FsbCBzdGF0ZSB0byB1c2UuXG4gICAgICogQHBhcmFtIGRpc3BhdGNoZXIgdGhlIGRpc3BhdGNoZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBpc0R0eEVuYWJsZWQgd2hldGhlciBEVFggaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0gaXNSZWRFbmFibGVkIHdoZXRoZXIgUkVEIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIGljZVJlc3RhcnREZWxheSB0aGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc3RhcnRpbmcgSUNFIG9uY2UgY29ubmVjdGlvbiBnb2VzIHRvIGBkaXNjb25uZWN0ZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY29ubmVjdGlvbkNvbmZpZywgc2Z1Q2xpZW50LCBkaXNwYXRjaGVyLCBzdGF0ZSwgaXNEdHhFbmFibGVkLCBpc1JlZEVuYWJsZWQsIGljZVJlc3RhcnREZWxheSA9IDI1MDAsIH0pIHtcbiAgICAgICAgdGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5ID0ge1xuICAgICAgICAgICAgW1RyYWNrVHlwZS5BVURJT106IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVklERU9dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5VTlNQRUNJRklFRF06IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG1haW50YWluaW5nIHRoZSBvcmRlciBob3cgdHJhbnNjZWl2ZXJzIHdlcmUgYWRkZWQgdG8gdGhlIHBlZXIgY29ubmVjdGlvbi5cbiAgICAgICAgICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBzb21lIGJyb3dzZXJzIChGaXJlZm94KSBkb24ndCByZWxpYWJseSByZXBvcnRcbiAgICAgICAgICogdHJhY2tJZCBhbmQgYG1pZGAgcGFyYW1ldGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNjZWl2ZXJJbml0T3JkZXIgPSBbXTtcbiAgICAgICAgdGhpcy50cmFja0tpbmRNYXBwaW5nID0ge1xuICAgICAgICAgICAgW1RyYWNrVHlwZS5BVURJT106ICdhdWRpbycsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlZJREVPXTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFXTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPXTogJ2F1ZGlvJyxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVU5TUEVDSUZJRURdOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhY2tMYXllcnNDYWNoZSA9IHtcbiAgICAgICAgICAgIFtUcmFja1R5cGUuQVVESU9dOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlZJREVPXTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgW1RyYWNrVHlwZS5TQ1JFRU5fU0hBUkVdOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJT106IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIFtUcmFja1R5cGUuVU5TUEVDSUZJRURdOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24gPSAoY29ubmVjdGlvbkNvbmZpZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCB0aGlzLm9uSWNlQ2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ25lZ290aWF0aW9ubmVlZGVkJywgdGhpcy5vbk5lZ290aWF0aW9uTmVlZGVkKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZWVycm9yJywgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignc2lnbmFsaW5nc3RhdGVjaGFuZ2UnLCB0aGlzLm9uU2lnbmFsaW5nU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHBjO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBwdWJsaXNoZXIgUGVlckNvbm5lY3Rpb24gYW5kIGNsZWFucyB1cCB0aGUgcmVzb3VyY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9ICh7IHN0b3BUcmFja3MgPSB0cnVlIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BUcmFja3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BQdWJsaXNoaW5nKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5KS5mb3JFYWNoKCh0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnRyYWNrTGF5ZXJzQ2FjaGUpLmZvckVhY2goKHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2tMYXllcnNDYWNoZVt0cmFja1R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWNlUmVzdGFydFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZU9uSWNlUmVzdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5wYy5yZW1vdmVFdmVudExpc3RlbmVyKCduZWdvdGlhdGlvbm5lZWRlZCcsIHRoaXMub25OZWdvdGlhdGlvbk5lZWRlZCk7XG4gICAgICAgICAgICB0aGlzLnBjLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdHJhY2sgb2YgdGhlIGdpdmVuIG1lZGlhIHN0cmVhbS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc2VjdXRpdmUgY2FsbHMgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIHRoZSBzdHJlYW0uXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbWVkaWFTdHJlYW0gdGhlIG1lZGlhIHN0cmVhbSB0byBwdWJsaXNoLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2sgdGhlIHRyYWNrIHRvIHB1Ymxpc2guXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIHRyYWNrIHR5cGUgdG8gcHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIG9wdHMgdGhlIG9wdGlvbmFsIHB1Ymxpc2ggb3B0aW9ucyB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnB1Ymxpc2hTdHJlYW0gPSBhc3luYyAobWVkaWFTdHJlYW0sIHRyYWNrLCB0cmFja1R5cGUsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHB1Ymxpc2ggYSB0cmFjayB0aGF0IGhhcyBlbmRlZCBhbHJlYWR5LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYW5zY2VpdmVyID0gdGhpcy5wY1xuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0ID09PSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSAmJlxuICAgICAgICAgICAgICAgIHQuc2VuZGVyLnRyYWNrICYmXG4gICAgICAgICAgICAgICAgdC5zZW5kZXIudHJhY2s/LmtpbmQgPT09IHRoaXMudHJhY2tLaW5kTWFwcGluZ1t0cmFja1R5cGVdKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gZXZlbnQgaGFuZGxlciB3aGljaCBsaXN0ZW5zIGZvciB0aGUgJ2VuZGVkJyBldmVudCBvbiB0aGUgdHJhY2suXG4gICAgICAgICAgICAgKiBPbmNlIHRoZSB0cmFjayBoYXMgZW5kZWQsIGl0IHdpbGwgbm90aWZ5IHRoZSBTRlUgYW5kIHVwZGF0ZSB0aGUgc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVRyYWNrRW5kZWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2luZm8nLCBgVHJhY2sgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gaGFzIGVuZGVkLCBub3RpZnlpbmcgdGhlIFNGVWApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkKG1lZGlhU3RyZWFtLCB0cmFja1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGNsZWFuLXVwLCB0aGlzIGV2ZW50IGxpc3RlbmVyIG5lZWRzIHRvIHJ1biBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRSZXNvbHV0aW9uID0gc2V0dGluZ3M/LnZpZGVvLnRhcmdldF9yZXNvbHV0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZGVvRW5jb2RpbmdzID0gdHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU9cbiAgICAgICAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFZpZGVvTGF5ZXJzKHRyYWNrLCB0YXJnZXRSZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlNDUkVFTl9TSEFSRVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFNjcmVlblNoYXJpbmdMYXllcnModHJhY2ssIG9wdHMuc2NyZWVuU2hhcmVTZXR0aW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBwcmVmZXJyZWRDb2RlYyA9IG9wdHMucHJlZmVycmVkQ29kZWM7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVmZXJyZWRDb2RlYyAmJiB0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvc05hbWUgPSBnZXRPU0luZm8oKT8ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9zTmFtZSA9PT0gJ2lwYWRvcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpcGFkcyBpdCB3YXMgbm90aWNlZCB0aGF0IGlmIHZwOCBjb2RlYyBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgYnl0ZXMgc2VudCBpcyAwIGluIHRoZSBvdXRib3VuZC1ydHBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBhcmUgZm9yY2luZyBoMjY0IGNvZGVjIGZvciBpcGFkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZENvZGVjID0gJ0gyNjQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3NOYW1lID09PSAnYW5kcm9pZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWRDb2RlYyA9ICdWUDgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjUHJlZmVyZW5jZXMgPSB0aGlzLmdldENvZGVjUHJlZmVyZW5jZXModHJhY2tUeXBlLCBwcmVmZXJyZWRDb2RlYyk7XG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuIGZvciAnZW5kZWQnIGV2ZW50IG9uIHRoZSB0cmFjayBhcyBpdCBtaWdodCBiZSBlbmRlZCBhYnJ1cHRseVxuICAgICAgICAgICAgICAgIC8vIGJ5IGFuIGV4dGVybmFsIGZhY3RvciBhcyBwZXJtaXNzaW9uIHJldm9rZXMsIGRldmljZSBkaXNjb25uZWN0ZWQsIGV0Yy5cbiAgICAgICAgICAgICAgICAvLyBrZWVwIGluIG1pbmQgdGhhdCBgdHJhY2suc3RvcCgpYCBkb2Vzbid0IHRyaWdnZXIgdGhpcyBldmVudC5cbiAgICAgICAgICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgICAgICAgICAgIGlmICghdHJhY2suZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5JyxcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtczogdHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8gfHwgdHJhY2tUeXBlID09PSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFttZWRpYVN0cmVhbV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiB2aWRlb0VuY29kaW5ncyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgQWRkZWQgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gdHJhbnNjZWl2ZXJgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVySW5pdE9yZGVyLnB1c2godHJhY2tUeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXSA9IHRyYW5zY2VpdmVyO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaE9wdGlvbnNQZXJUcmFja1R5cGUuc2V0KHRyYWNrVHlwZSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKCdzZXRDb2RlY1ByZWZlcmVuY2VzJyBpbiB0cmFuc2NlaXZlciAmJiBjb2RlY1ByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdpbmZvJywgYFNldHRpbmcgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gY29kZWMgcHJlZmVyZW5jZXNgLCBjb2RlY1ByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2V0Q29kZWNQcmVmZXJlbmNlcyhjb2RlY1ByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1RyYWNrID0gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrO1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN0b3AgdGhlIHRyYWNrIGlmIHdlIGFyZSByZS1wdWJsaXNoaW5nIHRoZSBzYW1lIHRyYWNrXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVHJhY2sgJiYgcHJldmlvdXNUcmFjayAhPT0gdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNUcmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBoYW5kbGVUcmFja0VuZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFjay5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5VHJhY2tNdXRlU3RhdGVDaGFuZ2VkKG1lZGlhU3RyZWFtLCB0cmFja1R5cGUsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIHRyYWNrIHR5cGUgdG8gdGhlIFNGVSwgaWYgaXQgaXMgY3VycmVudGx5IGJlaW5nIHB1Ymxpc2hlZC5cbiAgICAgICAgICogVW5kZXJseWluZyB0cmFjayB3aWxsIGJlIHN0b3BwZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgcHVibGlzaGVyLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIHVucHVibGlzaC5cbiAgICAgICAgICogQHBhcmFtIHN0b3BUcmFjayBzcGVjaWZpZXMgd2hldGhlciB0cmFjayBzaG91bGQgYmUgc3RvcHBlZCBvciBqdXN0IGRpc2FibGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVucHVibGlzaFN0cmVhbSA9IGFzeW5jICh0cmFja1R5cGUsIHN0b3BUcmFjaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLnBjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQgPT09IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVt0cmFja1R5cGVdICYmIHQuc2VuZGVyLnRyYWNrKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlciAmJlxuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJlxuICAgICAgICAgICAgICAgIChzdG9wVHJhY2tcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnXG4gICAgICAgICAgICAgICAgICAgIDogdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmVuYWJsZWQpKSB7XG4gICAgICAgICAgICAgICAgc3RvcFRyYWNrXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLnN0b3AoKVxuICAgICAgICAgICAgICAgICAgICA6ICh0cmFuc2NlaXZlci5zZW5kZXIudHJhY2suZW5hYmxlZCA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIG5vdGlmeSBTRlUgaWYgdW5wdWJsaXNoaW5nIGluIHJlc3BvbnNlIHRvIHJlbW90ZSBzb2Z0IG11dGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5sb2NhbFBhcnRpY2lwYW50Py5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXModHJhY2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZCh1bmRlZmluZWQsIHRyYWNrVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB0cmFjayB0eXBlIGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQgdG8gdGhlIFNGVS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdHJhY2sgdHlwZSB0byBjaGVjay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNQdWJsaXNoaW5nID0gKHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUgPSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbdHJhY2tUeXBlXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlckZvclRyYWNrVHlwZSAmJiB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0cmFuc2NlaXZlckZvclRyYWNrVHlwZS5zZW5kZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuICghIXNlbmRlci50cmFjayAmJlxuICAgICAgICAgICAgICAgICAgICBzZW5kZXIudHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2xpdmUnICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlci50cmFjay5lbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSBpcyBjdXJyZW50bHkgbGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIGNoZWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0xpdmUgPSAodHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2NlaXZlckZvclRyYWNrVHlwZSA9IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVt0cmFja1R5cGVdO1xuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlICYmIHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlLnNlbmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHRyYW5zY2VpdmVyRm9yVHJhY2tUeXBlLnNlbmRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFzZW5kZXIudHJhY2sgJiYgc2VuZGVyLnRyYWNrLnJlYWR5U3RhdGUgPT09ICdsaXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlUcmFja011dGVTdGF0ZUNoYW5nZWQgPSBhc3luYyAobWVkaWFTdHJlYW0sIHRyYWNrVHlwZSwgaXNNdXRlZCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQudXBkYXRlTXV0ZVN0YXRlKHRyYWNrVHlwZSwgaXNNdXRlZCk7XG4gICAgICAgICAgICBjb25zdCBhdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtID0gdHJhY2tUeXBlVG9QYXJ0aWNpcGFudFN0cmVhbUtleSh0cmFja1R5cGUpO1xuICAgICAgICAgICAgaWYgKGlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHRoaXMuc2Z1Q2xpZW50LnNlc3Npb25JZCwgKHApID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogcC5wdWJsaXNoZWRUcmFja3MuZmlsdGVyKCh0KSA9PiB0ICE9PSB0cmFja1R5cGUpLFxuICAgICAgICAgICAgICAgICAgICBbYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbV06IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHRoaXMuc2Z1Q2xpZW50LnNlc3Npb25JZCwgKHApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXModHJhY2tUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcC5wdWJsaXNoZWRUcmFja3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFsuLi5wLnB1Ymxpc2hlZFRyYWNrcywgdHJhY2tUeXBlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdWRpb09yVmlkZW9PclNjcmVlblNoYXJlU3RyZWFtXTogbWVkaWFTdHJlYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wcyBwdWJsaXNoaW5nIGFsbCB0cmFja3MgYW5kIHN0b3AgYWxsIHRyYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcFB1Ymxpc2hpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnU3RvcHBpbmcgcHVibGlzaGluZyBhbGwgdHJhY2tzJyk7XG4gICAgICAgICAgICB0aGlzLnBjLmdldFNlbmRlcnMoKS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgcy50cmFjaz8uc3RvcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBjLnJlbW92ZVRyYWNrKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZGVvUHVibGlzaFF1YWxpdHkgPSBhc3luYyAoZW5hYmxlZExheWVycykgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDMoJ2luZm8nLCAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgcmVxdWVzdGVkIGxheWVycyBieSBTRlU6JywgZW5hYmxlZExheWVycyk7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1NlbmRlciA9IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVtUcmFja1R5cGUuVklERU9dPy5zZW5kZXI7XG4gICAgICAgICAgICBpZiAoIXZpZGVvU2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCAnVXBkYXRlIHB1Ymxpc2ggcXVhbGl0eSwgbm8gdmlkZW8gc2VuZGVyIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHZpZGVvU2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCd3YXJuJywgJ1VwZGF0ZSBwdWJsaXNoIHF1YWxpdHksIE5vIHN1aXRhYmxlIHZpZGVvIGVuY29kaW5nIHF1YWxpdHkgZm91bmQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGVuYWJsZWRSaWRzID0gZW5hYmxlZExheWVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGx5KSA9PiBseS5hY3RpdmUpXG4gICAgICAgICAgICAgICAgLm1hcCgobHkpID0+IGx5Lm5hbWUpO1xuICAgICAgICAgICAgcGFyYW1zLmVuY29kaW5ncy5mb3JFYWNoKChlbmMpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmbGlwICdhY3RpdmUnIGZsYWcgb25seSB3aGVuIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEVuYWJsZSA9IGVuYWJsZWRSaWRzLmluY2x1ZGVzKGVuYy5yaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFbmFibGUgIT09IGVuYy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jLmFjdGl2ZSA9IHNob3VsZEVuYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRFbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheWVyID0gZW5hYmxlZExheWVycy5maW5kKCh2bHMpID0+IHZscy5uYW1lID09PSBlbmMucmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXllci5zY2FsZVJlc29sdXRpb25Eb3duQnkgPj0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLnNjYWxlUmVzb2x1dGlvbkRvd25CeSAhPT0gZW5jLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsICdbZHluYXNjYWxlXTogc2V0dGluZyBzY2FsZVJlc29sdXRpb25Eb3duQnkgZnJvbSBzZXJ2ZXInLCAnbGF5ZXInLCBsYXllci5uYW1lLCAnc2NhbGUtcmVzb2x1dGlvbi1kb3duLWJ5JywgbGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmMuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gbGF5ZXIuc2NhbGVSZXNvbHV0aW9uRG93bkJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLm1heEJpdHJhdGUgPiAwICYmIGxheWVyLm1heEJpdHJhdGUgIT09IGVuYy5tYXhCaXRyYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ1tkeW5hc2NhbGVdIHNldHRpbmcgbWF4LWJpdHJhdGUgZnJvbSB0aGUgc2VydmVyJywgJ2xheWVyJywgbGF5ZXIubmFtZSwgJ21heC1iaXRyYXRlJywgbGF5ZXIubWF4Qml0cmF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jLm1heEJpdHJhdGUgPSBsYXllci5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLm1heEZyYW1lcmF0ZSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllci5tYXhGcmFtZXJhdGUgIT09IGVuYy5tYXhGcmFtZXJhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnW2R5bmFzY2FsZV06IHNldHRpbmcgbWF4RnJhbWVyYXRlIGZyb20gc2VydmVyJywgJ2xheWVyJywgbGF5ZXIubmFtZSwgJ21heC1mcmFtZXJhdGUnLCBsYXllci5tYXhGcmFtZXJhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuYy5tYXhGcmFtZXJhdGUgPSBsYXllci5tYXhGcmFtZXJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUxheWVycyA9IHBhcmFtcy5lbmNvZGluZ3MuZmlsdGVyKChlKSA9PiBlLmFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHZpZGVvU2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnaW5mbycsIGBVcGRhdGUgcHVibGlzaCBxdWFsaXR5LCBlbmFibGVkIHJpZHM6IGAsIGFjdGl2ZUxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnaW5mbycsIGBVcGRhdGUgcHVibGlzaCBxdWFsaXR5LCBubyBjaGFuZ2U6IGAsIGFjdGl2ZUxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cygpYCBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHNlbGVjdG9yXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFN0YXRzID0gKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYy5nZXRTdGF0cyhzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q29kZWNQcmVmZXJlbmNlcyA9ICh0cmFja1R5cGUsIHByZWZlcnJlZENvZGVjKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJlZmVycmVkQ29kZWNzKCd2aWRlbycsIHByZWZlcnJlZENvZGVjIHx8ICd2cDgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5BVURJTykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRBdWRpb0NvZGVjID0gdGhpcy5pc1JlZEVuYWJsZWQgPyAncmVkJyA6ICdvcHVzJztcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlY1RvUmVtb3ZlID0gIXRoaXMuaXNSZWRFbmFibGVkID8gJ3JlZCcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByZWZlcnJlZENvZGVjcygnYXVkaW8nLCBwcmVmZXJyZWRDb2RlYyA/PyBkZWZhdWx0QXVkaW9Db2RlYywgY29kZWNUb1JlbW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JY2VDYW5kaWRhdGUgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjYW5kaWRhdGUgfSA9IGU7XG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsICdudWxsIGljZSBjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlKHtcbiAgICAgICAgICAgICAgICBpY2VDYW5kaWRhdGU6IGdldEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpLFxuICAgICAgICAgICAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5QVUJMSVNIRVJfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2Z1Q2xpZW50ID0gKHNmdUNsaWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIG1pZ3JhdGlvbiBvZiB0aGlzIHB1Ymxpc2hlciBpbnN0YW5jZSB0byBhIG5ldyBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluaXRpYXRlcyBhIG5ldyBgaWNlUmVzdGFydGAgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlIHdpdGggdGhlIG5ldyBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZnVDbGllbnQgdGhlIG5ldyBTRlUgY2xpZW50IHRvIG1pZ3JhdGUgdG8uXG4gICAgICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBuZXcgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWlncmF0ZVRvID0gYXN5bmMgKHNmdUNsaWVudCwgY29ubmVjdGlvbkNvbmZpZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgICAgICB0aGlzLnBjLnNldENvbmZpZ3VyYXRpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IGNvbm5lY3Rpb25Db25maWc7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZXN0YXJ0SWNlID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlc3RhcnRJY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWdvdGlhdGUgb25seSBpZiB0aGVyZSBhcmUgdHJhY2tzIHRvIHB1Ymxpc2hcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5lZ290aWF0ZSh7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN0YXJ0cyB0aGUgSUNFIGNvbm5lY3Rpb24gYW5kIHJlbmVnb3RpYXRlcyB3aXRoIHRoZSBTRlUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc3RhcnRJY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnUmVzdGFydGluZyBJQ0UgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsaW5nU3RhdGUgPSB0aGlzLnBjLnNpZ25hbGluZ1N0YXRlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJY2VSZXN0YXJ0aW5nIHx8IHNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCAnSUNFIHJlc3RhcnQgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubmVnb3RpYXRlKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk5lZ290aWF0aW9uTmVlZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYXRlcyBhIG5ldyBvZmZlci9hbnN3ZXIgZXhjaGFuZ2Ugd2l0aCB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTRlUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25hbCBvZmZlciBvcHRpb25zIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmVnb3RpYXRlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gb3B0aW9ucz8uaWNlUmVzdGFydCA/PyBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5wYy5jcmVhdGVPZmZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGxldCBzZHAgPSB0aGlzLm11bmdlQ29kZWNzKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBpZiAoc2RwICYmIHRoaXMuaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLnRyYW5zY2VpdmVyUmVnaXN0cnlbVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJT107XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyICYmIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaWQgPSB0cmFuc2NlaXZlci5taWQgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdE1pZChzZHAsIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjaywgVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyk7XG4gICAgICAgICAgICAgICAgICAgIHNkcCA9IGVuYWJsZUhpZ2hRdWFsaXR5QXVkaW8oc2RwLCBtaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCB0aGUgbXVuZ2VkIFNEUCBiYWNrIHRvIHRoZSBvZmZlclxuICAgICAgICAgICAgb2ZmZXIuc2RwID0gc2RwO1xuICAgICAgICAgICAgY29uc3QgdHJhY2tJbmZvcyA9IHRoaXMuZ2V0Q3VycmVudFRyYWNrSW5mb3Mob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGlmICh0cmFja0luZm9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaW5pdGlhdGUgbmVnb3RpYXRpb24gd2l0aG91dCBhbm5vdW5jaW5nIGFueSB0cmFja3NgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLnNmdUNsaWVudC5zZXRQdWJsaXNoZXIoe1xuICAgICAgICAgICAgICAgIHNkcDogb2ZmZXIuc2RwIHx8ICcnLFxuICAgICAgICAgICAgICAgIHRyYWNrczogdHJhY2tJbmZvcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Fuc3dlcicsXG4gICAgICAgICAgICAgICAgICAgIHNkcDogcmVzcG9uc2Uuc2RwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZXJyb3InLCBgc2V0UmVtb3RlRGVzY3JpcHRpb24gZXJyb3JgLCB7XG4gICAgICAgICAgICAgICAgICAgIHNkcDogcmVzcG9uc2Uuc2RwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNJY2VSZXN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNmdUNsaWVudC5pY2VUcmlja2xlQnVmZmVyLnB1Ymxpc2hlckNhbmRpZGF0ZXMuc3Vic2NyaWJlKGFzeW5jIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY2VDYW5kaWRhdGUgPSBKU09OLnBhcnNlKGNhbmRpZGF0ZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnd2FybicsIGBJQ0UgY2FuZGlkYXRlIGVycm9yYCwgW2UsIGNhbmRpZGF0ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm11bmdlQ29kZWNzID0gKHNkcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNkcCkge1xuICAgICAgICAgICAgICAgIHNkcCA9IHRvZ2dsZUR0eChzZHAsIHRoaXMuaXNEdHhFbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZHA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXh0cmFjdE1pZCA9IChzZHAsIHRyYWNrLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGlmICghc2RwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCAnTm8gU0RQIGZvdW5kLiBSZXR1cm5pbmcgZW1wdHkgbWlkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYE5vICdtaWQnIGZvdW5kIGZvciB0cmFjay4gVHJ5aW5nIHRvIGZpbmQgaXQgZnJvbSB0aGUgT2ZmZXIgU0RQYCk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZHAgPSBTRFAucGFyc2Uoc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhID0gcGFyc2VkU2RwLm1lZGlhLmZpbmQoKG0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG0udHlwZSA9PT0gdHJhY2sua2luZCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBgbXNpZGAgaXMgbm90IHByZXNlbnQsIHdlIGFzc3VtZSB0aGF0IHRoZSB0cmFjayBpcyB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgIChtLm1zaWQ/LmluY2x1ZGVzKHRyYWNrLmlkKSA/PyB0cnVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVkaWE/Lm1pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgTm8gbWlkIGZvdW5kIGluIFNEUCBmb3IgdHJhY2sgdHlwZSAke3RyYWNrLmtpbmR9IGFuZCBpZCAke3RyYWNrLmlkfS4gQXR0ZW1wdGluZyB0byBmaW5kIGEgaGV1cmlzdGljIG1pZGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhldXJpc3RpY01pZCA9IHRoaXMudHJhbnNjZWl2ZXJJbml0T3JkZXIuaW5kZXhPZih0cmFja1R5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChoZXVyaXN0aWNNaWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaGV1cmlzdGljTWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgJ05vIGhldXJpc3RpYyBtaWQgZm91bmQuIFJldHVybmluZyBlbXB0eSBtaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKG1lZGlhLm1pZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFRyYWNrSW5mb3MgPSAoc2RwKSA9PiB7XG4gICAgICAgICAgICBzZHAgPSBzZHAgfHwgdGhpcy5wYy5sb2NhbERlc2NyaXB0aW9uPy5zZHA7XG4gICAgICAgICAgICBjb25zdCB7IHNldHRpbmdzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHNldHRpbmdzPy52aWRlby50YXJnZXRfcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigodCkgPT4gdC5kaXJlY3Rpb24gPT09ICdzZW5kb25seScgJiYgdC5zZW5kZXIudHJhY2spXG4gICAgICAgICAgICAgICAgLm1hcCgodHJhbnNjZWl2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja1R5cGUgPSBOdW1iZXIoT2JqZWN0LmtleXModGhpcy50cmFuc2NlaXZlclJlZ2lzdHJ5KS5maW5kKChrZXkpID0+IHRoaXMudHJhbnNjZWl2ZXJSZWdpc3RyeVtrZXldID09PSB0cmFuc2NlaXZlcikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrO1xuICAgICAgICAgICAgICAgIGxldCBvcHRpbWFsTGF5ZXJzO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVibGlzaE9wdHMgPSB0aGlzLnB1Ymxpc2hPcHRpb25zUGVyVHJhY2tUeXBlLmdldCh0cmFja1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpbWFsTGF5ZXJzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaW5kT3B0aW1hbFZpZGVvTGF5ZXJzKHRyYWNrLCB0YXJnZXRSZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJhY2tUeXBlID09PSBUcmFja1R5cGUuU0NSRUVOX1NIQVJFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmluZE9wdGltYWxTY3JlZW5TaGFyaW5nTGF5ZXJzKHRyYWNrLCBwdWJsaXNoT3B0cz8uc2NyZWVuU2hhcmVTZXR0aW5ncylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFja0xheWVyc0NhY2hlW3RyYWNrVHlwZV0gPSBvcHRpbWFsTGF5ZXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVwb3J0IHRoZSBsYXN0IGtub3duIG9wdGltYWwgbGF5ZXJzIGZvciBlbmRlZCB0cmFja3NcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1hbExheWVycyA9IHRoaXMudHJhY2tMYXllcnNDYWNoZVt0cmFja1R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgVHJhY2sgJHtUcmFja1R5cGVbdHJhY2tUeXBlXX0gaXMgZW5kZWQuIEFubm91bmNpbmcgbGFzdCBrbm93biBvcHRpbWFsIGxheWVyc2AsIG9wdGltYWxMYXllcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcnMgPSBvcHRpbWFsTGF5ZXJzLm1hcCgob3B0aW1hbExheWVyKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICByaWQ6IG9wdGltYWxMYXllci5yaWQgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIGJpdHJhdGU6IG9wdGltYWxMYXllci5tYXhCaXRyYXRlIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGZwczogb3B0aW1hbExheWVyLm1heEZyYW1lcmF0ZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiB0aGlzLnJpZFRvVmlkZW9RdWFsaXR5KG9wdGltYWxMYXllci5yaWQgfHwgJycpLFxuICAgICAgICAgICAgICAgICAgICB2aWRlb0RpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG9wdGltYWxMYXllci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW1hbExheWVyLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdWRpb1RyYWNrID0gW1xuICAgICAgICAgICAgICAgICAgICBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgICAgICAgICAgICAgIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyh0cmFja1R5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU3RlcmVvID0gaXNBdWRpb1RyYWNrICYmIHRyYWNrU2V0dGluZ3MuY2hhbm5lbENvdW50ID09PSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLmlkLFxuICAgICAgICAgICAgICAgICAgICBsYXllcnM6IGxheWVycyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICBtaWQ6IHRyYW5zY2VpdmVyLm1pZCA/PyB0aGlzLmV4dHJhY3RNaWQoc2RwLCB0cmFjaywgdHJhY2tUeXBlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcmVvOiBpc1N0ZXJlbyxcbiAgICAgICAgICAgICAgICAgICAgZHR4OiBpc0F1ZGlvVHJhY2sgJiYgdGhpcy5pc0R0eEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlZDogaXNBdWRpb1RyYWNrICYmIHRoaXMuaXNSZWRFbmFibGVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZUVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGUgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQgJiZcbiAgICAgICAgICAgICAgICBgJHtlLmVycm9yQ29kZX06ICR7ZS5lcnJvclRleHR9YDtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0xldmVsID0gdGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnID8gJ2RlYnVnJyA6ICdlcnJvcic7XG4gICAgICAgICAgICBsb2dnZXIkMyhsb2dMZXZlbCwgYElDRSBDYW5kaWRhdGUgZXJyb3JgLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGxvZ2dlciQzKCdkZWJ1ZycsIGBJQ0UgQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvYCwgc3RhdGUpO1xuICAgICAgICAgICAgY29uc3QgaGFzTmV0d29ya0Nvbm5lY3Rpb24gPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLk9GRkxJTkU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCBgQXR0ZW1wdGluZyB0byByZXN0YXJ0IElDRWApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQzKCdlcnJvcicsIGBJQ0UgcmVzdGFydCBlcnJvcmAsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmIGhhc05ldHdvcmtDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpbiBgZGlzY29ubmVjdGVkYCBzdGF0ZSwgdGhlIGJyb3dzZXIgbWF5IHJlY292ZXIgYXV0b21hdGljYWxseSxcbiAgICAgICAgICAgICAgICAvLyBoZW5jZSwgd2UgZGVsYXkgdGhlIElDRSByZXN0YXJ0XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ3dhcm4nLCBgU2NoZWR1bGluZyBJQ0UgcmVzdGFydCBpbiAke3RoaXMuaWNlUmVzdGFydERlbGF5fSBtcy5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmljZVJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzdGF0ZSBpcyBzdGlsbCBgZGlzY29ubmVjdGVkYCBvciBgZmFpbGVkYFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY29ubmVjdGlvbiBtYXkgaGF2ZSByZWNvdmVyZWQgKG9yIGZhaWxlZCkgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0SWNlKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMygnZXJyb3InLCBgSUNFIHJlc3RhcnQgZXJyb3JgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDMoJ2RlYnVnJywgYFNjaGVkdWxlZCBJQ0UgcmVzdGFydDogY29ubmVjdGlvbiByZWNvdmVyZWQsIGNhbmNlbGVkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5pY2VSZXN0YXJ0RGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlR2F0aGVyaW5nU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgSUNFIEdhdGhlcmluZyBTdGF0ZWAsIHRoaXMucGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2lnbmFsaW5nU3RhdGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMygnZGVidWcnLCBgU2lnbmFsaW5nIHN0YXRlIGNoYW5nZWRgLCB0aGlzLnBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yaWRUb1ZpZGVvUXVhbGl0eSA9IChyaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByaWQgPT09ICdxJ1xuICAgICAgICAgICAgICAgID8gVmlkZW9RdWFsaXR5LkxPV19VTlNQRUNJRklFRFxuICAgICAgICAgICAgICAgIDogcmlkID09PSAnaCdcbiAgICAgICAgICAgICAgICAgICAgPyBWaWRlb1F1YWxpdHkuTUlEXG4gICAgICAgICAgICAgICAgICAgIDogVmlkZW9RdWFsaXR5LkhJR0g7IC8vIGRlZmF1bHQgdG8gSElHSFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBjID0gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5pc0R0eEVuYWJsZWQgPSBpc0R0eEVuYWJsZWQ7XG4gICAgICAgIHRoaXMuaXNSZWRFbmFibGVkID0gaXNSZWRFbmFibGVkO1xuICAgICAgICB0aGlzLmljZVJlc3RhcnREZWxheSA9IGljZVJlc3RhcnREZWxheTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZU9uSWNlUmVzdGFydCA9IGRpc3BhdGNoZXIub24oJ2ljZVJlc3RhcnQnLCBhc3luYyAoaWNlUmVzdGFydCkgPT4ge1xuICAgICAgICAgICAgaWYgKGljZVJlc3RhcnQucGVlclR5cGUgIT09IFBlZXJUeXBlLlBVQkxJU0hFUl9VTlNQRUNJRklFRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRJY2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBsb2dnZXIkMiA9IGdldExvZ2dlcihbJ1N1YnNjcmliZXInXSk7XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIGBSVENQZWVyQ29ubmVjdGlvbmAgdGhhdCBoYW5kbGVzIHRoZSBpbmNvbWluZ1xuICogbWVkaWEgc3RyZWFtcyBmcm9tIHRoZSBTRlUuXG4gKi9cbmNsYXNzIFN1YnNjcmliZXIge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGNvbm5lY3Rpb25Db25maWd1cmF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYy5nZXRDb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgYFN1YnNjcmliZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNmdUNsaWVudCB0aGUgU0ZVIGNsaWVudCB0byB1c2UuXG4gICAgICogQHBhcmFtIGRpc3BhdGNoZXIgdGhlIGRpc3BhdGNoZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBzdGF0ZSB0aGUgc3RhdGUgb2YgdGhlIGNhbGwuXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWcgdGhlIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAgICogQHBhcmFtIGljZVJlc3RhcnREZWxheSB0aGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc3RhcnRpbmcgSUNFIHdoZW4gY29ubmVjdGlvbiBnb2VzIHRvIGBkaXNjb25uZWN0ZWRgIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgc2Z1Q2xpZW50LCBkaXNwYXRjaGVyLCBzdGF0ZSwgY29ubmVjdGlvbkNvbmZpZywgaWNlUmVzdGFydERlbGF5ID0gMjUwMCwgfSkge1xuICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBgUlRDUGVlckNvbm5lY3Rpb25gIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnIHRoZSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbiA9IChjb25uZWN0aW9uQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Db25maWd1cmF0aW9uID0gY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIHRoaXMub25JY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLmhhbmRsZU9uVHJhY2spO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlZXJyb3InLCB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IpO1xuICAgICAgICAgICAgcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScsIHRoaXMub25JY2VHYXRoZXJpbmdTdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gcGM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIGBSVENQZWVyQ29ubmVjdGlvbmAgYW5kIHVuc3Vic2NyaWJlcyBmcm9tIHRoZSBkaXNwYXRjaGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmljZVJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlck9uU3Vic2NyaWJlck9mZmVyKCk7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJPbkljZVJlc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMucGMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgYFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKClgIG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0gc2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0U3RhdHMgPSAoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIFNGVSBjbGllbnQgdG8gdXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBTRlUgY2xpZW50IHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0U2Z1Q2xpZW50ID0gKHNmdUNsaWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZnVDbGllbnQgPSBzZnVDbGllbnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaWdyYXRlcyB0aGUgc3Vic2NyaWJlciB0byBhIG5ldyBTRlUgY2xpZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Z1Q2xpZW50IHRoZSBuZXcgU0ZVIGNsaWVudCB0byBtaWdyYXRlIHRvLlxuICAgICAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZyB0aGUgbmV3IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbiB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pZ3JhdGVUbyA9IChzZnVDbGllbnQsIGNvbm5lY3Rpb25Db25maWcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2Z1Q2xpZW50KHNmdUNsaWVudCk7XG4gICAgICAgICAgICAvLyB3aGVuIG1pZ3JhdGluZywgd2Ugd2FudCB0byBrZWVwIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyIG9wZW5cbiAgICAgICAgICAgIC8vIHVudGlsIHRoZSBuZXcgb25lIGlzIGNvbm5lY3RlZFxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQQyA9IHRoaXMucGM7XG4gICAgICAgICAgICAvLyB3ZSBrZWVwIGEgcmVjb3JkIG9mIHByZXZpb3VzbHkgYXZhaWxhYmxlIHZpZGVvIHRyYWNrc1xuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gbW9uaXRvciB3aGVuIHRoZXkgYmVjb21lIGF2YWlsYWJsZSBvbiB0aGUgbmV3XG4gICAgICAgICAgICAvLyBzdWJzY3JpYmVyIGFuZCBjbG9zZSB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICAgICAgY29uc3QgdHJhY2tJZHNUb01pZ3JhdGUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBwcmV2aW91c1BDLmdldFJlY2VpdmVycygpLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoci50cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSWRzVG9NaWdyYXRlLmFkZChyLnRyYWNrLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB1cCBhIG5ldyBzdWJzY3JpYmVyIHBlZXIgY29ubmVjdGlvbiwgY29uZmlndXJlZCB0byBjb25uZWN0XG4gICAgICAgICAgICAvLyB0byB0aGUgbmV3IFNGVSBub2RlXG4gICAgICAgICAgICBjb25zdCBwYyA9IHRoaXMuY3JlYXRlUGVlckNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBsZXQgbWlncmF0aW9uVGltZW91dElkO1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cE1pZ3JhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1BDLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1pZ3JhdGlvblRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2hlbiBtaWdyYXRpbmcsIHdlIHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgdmlkZW8gdHJhY2tzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBtaWdyYXRpbmcgdG8gdGhlIG5ldyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgLy8gT25jZSBhbGwgb2YgdGhlbSBhcmUgYXZhaWxhYmxlLCB3ZSBjYW4gY2xvc2UgdGhlIHByZXZpb3VzIHN1YnNjcmliZXIuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVUcmFja01pZ3JhdGlvbiA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgYFtNaWdyYXRpb25dOiBNaWdyYXRlZCB0cmFjazogJHtlLnRyYWNrLmlkfSwgJHtlLnRyYWNrLmtpbmR9YCk7XG4gICAgICAgICAgICAgICAgdHJhY2tJZHNUb01pZ3JhdGUuZGVsZXRlKGUudHJhY2suaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0lkc1RvTWlncmF0ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsIGBbTWlncmF0aW9uXTogTWlncmF0aW9uIGNvbXBsZXRlYCk7XG4gICAgICAgICAgICAgICAgICAgIHBjLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgaGFuZGxlVHJhY2tNaWdyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwTWlncmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gbWlncmF0aW5nLCB3ZSB3YW50IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNvbm5lY3Rpb24gc3RhdGVcbiAgICAgICAgICAgIC8vIG9mIHRoZSBuZXcgc3Vic2NyaWJlci5cbiAgICAgICAgICAgIC8vIE9uY2UgaXQgaXMgY29ubmVjdGVkLCB3ZSBnaXZlIGl0IGEgMi1zZWNvbmQgZ3JhY2UgcGVyaW9kIHRvIHJlY2VpdmVcbiAgICAgICAgICAgIC8vIGFsbCB0aGUgdmlkZW8gdHJhY2tzIHRoYXQgYXJlIG1pZ3JhdGluZyBmcm9tIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgLy8gQWZ0ZXIgdGhpcyB0aHJlc2hvbGQsIHdlIGFicnVwdGx5IGNsb3NlIHRoZSBwcmV2aW91cyBzdWJzY3JpYmVyLlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYy5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCBoYW5kbGVUcmFja01pZ3JhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwTWlncmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICAgICAgICBwYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIGhhbmRsZVRyYWNrTWlncmF0aW9uKTtcbiAgICAgICAgICAgIHBjLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBQZWVyQ29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICAgICAgICAgdGhpcy5wYyA9IHBjO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdGFydHMgdGhlIElDRSBjb25uZWN0aW9uIGFuZCByZW5lZ290aWF0ZXMgd2l0aCB0aGUgU0ZVLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXN0YXJ0SWNlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgJ1Jlc3RhcnRpbmcgSUNFIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1yZW1vdGUtb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgJ0lDRSByZXN0YXJ0IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0lzSWNlUmVzdGFydGluZyA9IHRoaXMuaXNJY2VSZXN0YXJ0aW5nO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuaWNlUmVzdGFydCh7XG4gICAgICAgICAgICAgICAgICAgIHBlZXJUeXBlOiBQZWVyVHlwZS5TVUJTQ1JJQkVSLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBzdGF0ZSwgYXMgb3VyIGludGVudCBmb3IgcmVzdGFydGluZyBJQ0UgZmFpbGVkXG4gICAgICAgICAgICAgICAgdGhpcy5pc0ljZVJlc3RhcnRpbmcgPSBwcmV2aW91c0lzSWNlUmVzdGFydGluZztcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU9uVHJhY2sgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3ByaW1hcnlTdHJlYW1dID0gZS5zdHJlYW1zO1xuICAgICAgICAgICAgLy8gZXhhbXBsZTogYGUzZjZhYWY4LWIwM2QtNDkxMS1iZTM2LTgzZjQ3ZDM3YTc2YTpUUkFDS19UWVBFX1ZJREVPYFxuICAgICAgICAgICAgY29uc3QgW3RyYWNrSWQsIHRyYWNrVHlwZV0gPSBwcmltYXJ5U3RyZWFtLmlkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudFRvVXBkYXRlID0gdGhpcy5zdGF0ZS5wYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC50cmFja0xvb2t1cFByZWZpeCA9PT0gdHJhY2tJZCk7XG4gICAgICAgICAgICBsb2dnZXIkMignZGVidWcnLCBgW29uVHJhY2tdOiBHb3QgcmVtb3RlICR7dHJhY2tUeXBlfSB0cmFjayBmb3IgdXNlcklkOiAke3BhcnRpY2lwYW50VG9VcGRhdGU/LnVzZXJJZH1gLCBlLnRyYWNrLmlkLCBlLnRyYWNrKTtcbiAgICAgICAgICAgIGlmICghcGFydGljaXBhbnRUb1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdlcnJvcicsIGBbb25UcmFja106IFJlY2VpdmVkIHRyYWNrIGZvciB1bmtub3duIHBhcnRpY2lwYW50OiAke3RyYWNrSWR9YCwgZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS50cmFjay5hZGRFdmVudExpc3RlbmVyKCdtdXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdpbmZvJywgYFtvblRyYWNrXTogVHJhY2sgbXV0ZWQ6ICR7cGFydGljaXBhbnRUb1VwZGF0ZS51c2VySWR9ICR7dHJhY2tUeXBlfToke3RyYWNrSWR9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUudHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdpbmZvJywgYFtvblRyYWNrXTogVHJhY2sgdW5tdXRlZDogJHtwYXJ0aWNpcGFudFRvVXBkYXRlLnVzZXJJZH0gJHt0cmFja1R5cGV9OiR7dHJhY2tJZH1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS50cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignaW5mbycsIGBbb25UcmFja106IFRyYWNrIGVuZGVkOiAke3BhcnRpY2lwYW50VG9VcGRhdGUudXNlcklkfSAke3RyYWNrVHlwZX06JHt0cmFja0lkfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1LaW5kUHJvcCA9IHtcbiAgICAgICAgICAgICAgICBUUkFDS19UWVBFX0FVRElPOiAnYXVkaW9TdHJlYW0nLFxuICAgICAgICAgICAgICAgIFRSQUNLX1RZUEVfVklERU86ICd2aWRlb1N0cmVhbScsXG4gICAgICAgICAgICAgICAgVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkU6ICdzY3JlZW5TaGFyZVN0cmVhbScsXG4gICAgICAgICAgICAgICAgVFJBQ0tfVFlQRV9TQ1JFRU5fU0hBUkVfQVVESU86ICdzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtJyxcbiAgICAgICAgICAgIH1bdHJhY2tUeXBlXTtcbiAgICAgICAgICAgIGlmICghc3RyZWFtS2luZFByb3ApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMignZXJyb3InLCBgVW5rbm93biB0cmFjayB0eXBlOiAke3RyYWNrVHlwZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1N0cmVhbSA9IHBhcnRpY2lwYW50VG9VcGRhdGVbc3RyZWFtS2luZFByb3BdO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2luZm8nLCBgW29uVHJhY2tdOiBDbGVhbmluZyB1cCBwcmV2aW91cyByZW1vdGUgJHtlLnRyYWNrLmtpbmR9IHRyYWNrcyBmb3IgdXNlcklkOiAke3BhcnRpY2lwYW50VG9VcGRhdGUudXNlcklkfWApO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3RyZWFtLnJlbW92ZVRyYWNrKHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChwYXJ0aWNpcGFudFRvVXBkYXRlLnNlc3Npb25JZCwge1xuICAgICAgICAgICAgICAgIFtzdHJlYW1LaW5kUHJvcF06IHByaW1hcnlTdHJlYW0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUNhbmRpZGF0ZSA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbmRpZGF0ZSB9ID0gZTtcbiAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgJ251bGwgaWNlIGNhbmRpZGF0ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Z1Q2xpZW50LmljZVRyaWNrbGUoe1xuICAgICAgICAgICAgICAgIGljZUNhbmRpZGF0ZTogZ2V0SWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSksXG4gICAgICAgICAgICAgICAgcGVlclR5cGU6IFBlZXJUeXBlLlNVQlNDUklCRVIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUgPSBhc3luYyAoc3Vic2NyaWJlck9mZmVyKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIkMignaW5mbycsIGBSZWNlaXZlZCBzdWJzY3JpYmVyT2ZmZXJgLCBzdWJzY3JpYmVyT2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29mZmVyJyxcbiAgICAgICAgICAgICAgICBzZHA6IHN1YnNjcmliZXJPZmZlci5zZHAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50LmljZVRyaWNrbGVCdWZmZXIuc3Vic2NyaWJlckNhbmRpZGF0ZXMuc3Vic2NyaWJlKGFzeW5jIChjYW5kaWRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpY2VDYW5kaWRhdGUgPSBKU09OLnBhcnNlKGNhbmRpZGF0ZS5pY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMignd2FybicsIGBJQ0UgY2FuZGlkYXRlIGVycm9yYCwgW2UsIGNhbmRpZGF0ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZnVDbGllbnQuc2VuZEFuc3dlcih7XG4gICAgICAgICAgICAgICAgcGVlclR5cGU6IFBlZXJUeXBlLlNVQlNDUklCRVIsXG4gICAgICAgICAgICAgICAgc2RwOiBhbnN3ZXIuc2RwIHx8ICcnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmlzSWNlUmVzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIGxvZ2dlciQyKCdkZWJ1ZycsIGBJQ0UgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkYCwgc3RhdGUpO1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZyB3aGVuIElDRSBpcyByZXN0YXJ0aW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ljZVJlc3RhcnRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaGFzTmV0d29ya0Nvbm5lY3Rpb24gPSB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLk9GRkxJTkU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ3dhcm4nLCBgQXR0ZW1wdGluZyB0byByZXN0YXJ0IElDRWApO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlciQyKCdlcnJvcicsIGBJQ0UgcmVzdGFydCBmYWlsZWRgLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBoYXNOZXR3b3JrQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gaW4gYGRpc2Nvbm5lY3RlZGAgc3RhdGUsIHRoZSBicm93c2VyIG1heSByZWNvdmVyIGF1dG9tYXRpY2FsbHksXG4gICAgICAgICAgICAgICAgLy8gaGVuY2UsIHdlIGRlbGF5IHRoZSBJQ0UgcmVzdGFydFxuICAgICAgICAgICAgICAgIGxvZ2dlciQyKCd3YXJuJywgYFNjaGVkdWxpbmcgSUNFIHJlc3RhcnQgaW4gJHt0aGlzLmljZVJlc3RhcnREZWxheX0gbXMuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pY2VSZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgc3RhdGUgaXMgc3RpbGwgYGRpc2Nvbm5lY3RlZGAgb3IgYGZhaWxlZGBcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbm5lY3Rpb24gbWF5IGhhdmUgcmVjb3ZlcmVkIChvciBmYWlsZWQpIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdGFydEljZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyJDIoJ2Vycm9yJywgYElDRSByZXN0YXJ0IGZhaWxlZGAsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIkMignZGVidWcnLCBgU2NoZWR1bGVkIElDRSByZXN0YXJ0OiBjb25uZWN0aW9uIHJlY292ZXJlZCwgY2FuY2VsZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyJDIoJ2RlYnVnJywgYElDRSBnYXRoZXJpbmcgc3RhdGUgY2hhbmdlZGAsIHRoaXMucGMuaWNlR2F0aGVyaW5nU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZSBpbnN0YW5jZW9mIFJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCAmJlxuICAgICAgICAgICAgICAgIGAke2UuZXJyb3JDb2RlfTogJHtlLmVycm9yVGV4dH1gO1xuICAgICAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgPyAnZGVidWcnIDogJ2Vycm9yJztcbiAgICAgICAgICAgIGxvZ2dlciQyKGxvZ0xldmVsLCBgSUNFIENhbmRpZGF0ZSBlcnJvcmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gc2Z1Q2xpZW50O1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuaWNlUmVzdGFydERlbGF5ID0gaWNlUmVzdGFydERlbGF5O1xuICAgICAgICB0aGlzLnBjID0gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyT25TdWJzY3JpYmVyT2ZmZXIgPSBkaXNwYXRjaGVyLm9uKCdzdWJzY3JpYmVyT2ZmZXInLCBhc3luYyAoc3Vic2NyaWJlck9mZmVyKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5lZ290aWF0ZShzdWJzY3JpYmVyT2ZmZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVyT25JY2VSZXN0YXJ0ID0gZGlzcGF0Y2hlci5vbignaWNlUmVzdGFydCcsIGFzeW5jIChpY2VSZXN0YXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWNlUmVzdGFydC5wZWVyVHlwZSAhPT0gUGVlclR5cGUuU1VCU0NSSUJFUilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRJY2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsID0gKG9wdHMpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydzZnUtY2xpZW50J10pO1xuICAgIGNvbnN0IHsgZW5kcG9pbnQsIG9uTWVzc2FnZSB9ID0gb3B0cztcbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoZW5kcG9pbnQpO1xuICAgIHdzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInOyAvLyBkbyB3ZSBuZWVkIHRoaXM/XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2Vycm9yJywgJ1NpZ25hbGluZyBXUyBjaGFubmVsIGVycm9yJywgZSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoZSkgPT4ge1xuICAgICAgICBsb2dnZXIoJ2luZm8nLCAnU2lnbmFsaW5nIFdTIGNoYW5uZWwgaXMgY2xvc2VkJywgZSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIChlKSA9PiB7XG4gICAgICAgIGxvZ2dlcignaW5mbycsICdTaWduYWxpbmcgV1MgY2hhbm5lbCBpcyBvcGVuJywgZSk7XG4gICAgfSk7XG4gICAgd3MuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgICA/IFNmdUV2ZW50LmZyb21CaW5hcnkobmV3IFVpbnQ4QXJyYXkoZS5kYXRhKSlcbiAgICAgICAgICAgICAgICA6IFNmdUV2ZW50LmZyb21Kc29uU3RyaW5nKGUuZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIoJ2Vycm9yJywgJ0ZhaWxlZCB0byBkZWNvZGUgYSBtZXNzYWdlLiBDaGVjayB3aGV0aGVyIHRoZSBQcm90byBtb2RlbHMgbWF0Y2guJywgeyBldmVudDogZSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3cztcbn07XG5cbmNvbnN0IHNsZWVwID0gKG0pID0+IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIG0pKTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmXG4gICAgICAgIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKTtcbn1cbi8qKlxuICogQSBtYXAgb2Yga25vd24gZXJyb3IgY29kZXMuXG4gKi9cbmNvbnN0IEtub3duQ29kZXMgPSB7XG4gICAgVE9LRU5fRVhQSVJFRDogNDAsXG4gICAgV1NfQ0xPU0VEX1NVQ0NFU1M6IDEwMDAsXG4gICAgV1NfQ0xPU0VEX0FCUlVQVExZOiAxMDA2LFxuICAgIFdTX1BPTElDWV9WSU9MQVRJT046IDEwMDgsXG59O1xuLyoqXG4gKiByZXRyeUludGVydmFsIC0gQSByZXRyeSBpbnRlcnZhbCB3aGljaCBpbmNyZWFzZXMgYWNjIHRvIG51bWJlciBvZiBmYWlsdXJlc1xuICpcbiAqIEByZXR1cm4ge251bWJlcn0gRHVyYXRpb24gdG8gd2FpdCBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZnVuY3Rpb24gcmV0cnlJbnRlcnZhbChudW1iZXJPZkZhaWx1cmVzKSB7XG4gICAgLy8gdHJ5IHRvIHJlY29ubmVjdCBpbiAwLjI1LTUgc2Vjb25kcyAocmFuZG9tIHRvIHNwcmVhZCBvdXQgdGhlIGxvYWQgZnJvbSBmYWlsdXJlcylcbiAgICBjb25zdCBtYXggPSBNYXRoLm1pbig1MDAgKyBudW1iZXJPZkZhaWx1cmVzICogMjAwMCwgNTAwMCk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oTWF0aC5tYXgoMjUwLCAobnVtYmVyT2ZGYWlsdXJlcyAtIDEpICogMjAwMCksIDUwMDApO1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbik7XG59XG5mdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVVVUlEdjQoKTtcbn1cbmZ1bmN0aW9uIGhleChieXRlcykge1xuICAgIGxldCBzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzICs9IGJ5dGVzW2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUR2NCgpIHtcbiAgICBjb25zdCBieXRlcyA9IGdldFJhbmRvbUJ5dGVzKDE2KTtcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDsgLy8gdmVyc2lvblxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHhiZikgfCAweDgwOyAvLyB2YXJpYW50XG4gICAgcmV0dXJuIChoZXgoYnl0ZXMuc3ViYXJyYXkoMCwgNCkpICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgaGV4KGJ5dGVzLnN1YmFycmF5KDQsIDYpKSArXG4gICAgICAgICctJyArXG4gICAgICAgIGhleChieXRlcy5zdWJhcnJheSg2LCA4KSkgK1xuICAgICAgICAnLScgK1xuICAgICAgICBoZXgoYnl0ZXMuc3ViYXJyYXkoOCwgMTApKSArXG4gICAgICAgICctJyArXG4gICAgICAgIGhleChieXRlcy5zdWJhcnJheSgxMCwgMTYpKSk7XG59XG5mdW5jdGlvbiBnZXRSYW5kb21WYWx1ZXNXaXRoTWF0aFJhbmRvbShieXRlcykge1xuICAgIGNvbnN0IG1heCA9IE1hdGgucG93KDIsICg4ICogYnl0ZXMuYnl0ZUxlbmd0aCkgLyBieXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBNYXRoLnJhbmRvbSgpICogbWF4O1xuICAgIH1cbn1cbmNvbnN0IGdldFJhbmRvbVZhbHVlcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8/LmdldFJhbmRvbVZhbHVlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzV2l0aE1hdGhSYW5kb207XG4gICAgfVxufSkoKTtcbmZ1bmN0aW9uIGdldFJhbmRvbUJ5dGVzKGxlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRFcnJvclRvSnNvbihlcnIpIHtcbiAgICBjb25zdCBqc29uT2JqID0ge307XG4gICAgaWYgKCFlcnIpXG4gICAgICAgIHJldHVybiBqc29uT2JqO1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBqc29uT2JqW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVyciwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcjogJ2ZhaWxlZCB0byBzZXJpYWxpemUgdGhlIGVycm9yJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25PYmo7XG59XG4vKipcbiAqIGlzT25saW5lIHNhZmVseSByZXR1cm4gdGhlIG5hdmlnYXRvci5vbmxpbmUgdmFsdWUgZm9yIGJyb3dzZXIgZW52XG4gKiBpZiBuYXZpZ2F0b3IgaXMgbm90IGluIGdsb2JhbCBvYmplY3QsIGl0IGFsd2F5cyByZXR1cm4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc09ubGluZShsb2dnZXIpIHtcbiAgICBjb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG5hdmlnYXRvclxuICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3JcbiAgICAgICAgICAgID8gd2luZG93Lm5hdmlnYXRvclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuYXYpIHtcbiAgICAgICAgbG9nZ2VyKCd3YXJuJywgJ2lzT25saW5lIGZhaWxlZCB0byBhY2Nlc3Mgd2luZG93Lm5hdmlnYXRvciBhbmQgYXNzdW1lIGJyb3dzZXIgaXMgb25saW5lJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSTiBuYXZpZ2F0b3IgaGFzIHVuZGVmaW5lZCBmb3Igb25MaW5lXG4gICAgaWYgKHR5cGVvZiBuYXYub25MaW5lICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBuYXYub25MaW5lO1xufVxuLyoqXG4gKiBsaXN0ZW5Gb3JDb25uZWN0aW9uQ2hhbmdlcyAtIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgZmlyZWQgb24gYnJvd3NlciBnb2luZyBvbmxpbmUgb3Igb2ZmbGluZVxuICovXG5mdW5jdGlvbiBhZGRDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMoY2IpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBjYik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBjYik7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKGNiKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgY2IpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgY2IpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgY2xpZW50IHVzZWQgZm9yIGV4Y2hhbmdpbmcgaW5mb3JtYXRpb24gd2l0aCB0aGUgU0ZVLlxuICovXG5jbGFzcyBTdHJlYW1TZnVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU0ZVIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBldmVudCBkaXNwYXRjaGVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gc2Z1U2VydmVyIHRoZSBTRlUgc2VydmVyIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIHRva2VuIHRoZSBKV1QgdG9rZW4gdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBgc2Vzc2lvbklkYCBvZiB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBwYXJ0aWNpcGFudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGRpc3BhdGNoZXIsIHNmdVNlcnZlciwgdG9rZW4sIHNlc3Npb25JZCwgfSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBidWZmZXIgZm9yIElDRSBDYW5kaWRhdGVzIHRoYXQgYXJlIHJlY2VpdmVkIGJlZm9yZVxuICAgICAgICAgKiB0aGUgUGVlckNvbm5lY3Rpb25zIGFyZSByZWFkeSB0byBoYW5kbGUgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWNlVHJpY2tsZUJ1ZmZlciA9IG5ldyBJY2VUcmlja2xlQnVmZmVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IG1pZ3JhdGluZyBhd2F5XG4gICAgICAgICAqIGZyb20gdGhpcyBTRlUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzTWlncmF0aW5nQXdheSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGUgY2xpZW50IGNvbm5lY3Rpb24gaXMgYnJva2VuIGZvciB0aGUgY3VycmVudFxuICAgICAgICAgKiBjbGllbnQgYW5kIHRoYXQgYSBmYXN0LXJlY29ubmVjdCB3aXRoIGEgbmV3IGNsaWVudCBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0Zhc3RSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxJbk1zID0gMTAgKiAxMDAwO1xuICAgICAgICB0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zID0gdGhpcy5waW5nSW50ZXJ2YWxJbk1zICsgNSAqIDEwMDA7XG4gICAgICAgIHRoaXMuY2xvc2UgPSAoY29kZSA9IFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSwgcmVhc29uID0gJ2pzLWNsaWVudDogcmVxdWVzdGVkIHNpZ25hbCBjb25uZWN0aW9uIGNsb3NlJykgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ0Nsb3NpbmcgU0ZVIFdTIGNvbm5lY3Rpb24nLCBjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsV3MucmVhZHlTdGF0ZSAhPT0gdGhpcy5zaWduYWxXcy5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25hbFdzLmNsb3NlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlSWNlVHJpY2tsZSgpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMgPSBhc3luYyAoc3Vic2NyaXB0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy51cGRhdGVTdWJzY3JpcHRpb25zKHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIHRyYWNrczogc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgICAgIH0pLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0UHVibGlzaGVyID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGUoKCkgPT4gdGhpcy5ycGMuc2V0UHVibGlzaGVyKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRBbnN3ZXIgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy5zZW5kQW5zd2VyKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmljZVRyaWNrbGUgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy5pY2VUcmlja2xlKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmljZVJlc3RhcnQgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5YWJsZSgoKSA9PiB0aGlzLnJwYy5pY2VSZXN0YXJ0KHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICB9KSwgdGhpcy5sb2dnZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZU11dGVTdGF0ZSA9IGFzeW5jICh0cmFja1R5cGUsIG11dGVkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVNdXRlU3RhdGVzKHtcbiAgICAgICAgICAgICAgICBtdXRlU3RhdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVNdXRlU3RhdGVzID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeWFibGUoKCkgPT4gdGhpcy5ycGMudXBkYXRlTXV0ZVN0YXRlcyh7XG4gICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgICAgICAgfSksIHRoaXMubG9nZ2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5qb2luID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGpvaW5SZXF1ZXN0ID0gSm9pblJlcXVlc3QuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudG9rZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoU2Z1UmVxdWVzdC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgIG9uZW9mS2luZDogJ2pvaW5SZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgam9pblJlcXVlc3QsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZW5kID0gYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25hbFJlYWR5LnRoZW4oKHNpZ25hbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzaWduYWwucmVhZHlTdGF0ZSAhPT0gc2lnbmFsLk9QRU4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgU2VuZGluZyBtZXNzYWdlIHRvOiAke3RoaXMuZWRnZU5hbWV9YCwgU2Z1UmVxdWVzdC50b0pzb24obWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIHNpZ25hbC5zZW5kKFNmdVJlcXVlc3QudG9CaW5hcnkobWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMua2VlcEFsaXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBBbGl2ZUludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3RyYWNlJywgJ1NlbmRpbmcgaGVhbHRoQ2hlY2tSZXF1ZXN0IHRvIFNGVScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBTZnVSZXF1ZXN0LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RQYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVvZktpbmQ6ICdoZWFsdGhDaGVja1JlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhbHRoQ2hlY2tSZXF1ZXN0OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQobWVzc2FnZSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ0Vycm9yIHNlbmRpbmcgaGVhbHRoQ2hlY2tSZXF1ZXN0IHRvIFNGVScsIGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5waW5nSW50ZXJ2YWxJbk1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3Rpb25DaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdE1lc3NhZ2VUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdE1lc3NhZ2UgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMubGFzdE1lc3NhZ2VUaW1lc3RhbXAuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdE1lc3NhZ2UgPiB0aGlzLnVuaGVhbHRoeVRpbWVvdXRJbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKFN0cmVhbVNmdUNsaWVudC5FUlJPUl9DT05ORUNUSU9OX1VOSEVBTFRIWSwgYFNGVSBjb25uZWN0aW9uIHVuaGVhbHRoeS4gRGlkbid0IHJlY2VpdmUgYW55IG1lc3NhZ2UgZm9yICR7dGhpcy51bmhlYWx0aHlUaW1lb3V0SW5Nc31tc2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy51bmhlYWx0aHlUaW1lb3V0SW5Ncyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkIHx8IGdlbmVyYXRlVVVJRHY0KCk7XG4gICAgICAgIHRoaXMuc2Z1U2VydmVyID0gc2Z1U2VydmVyO1xuICAgICAgICB0aGlzLmVkZ2VOYW1lID0gc2Z1U2VydmVyLmVkZ2VfbmFtZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ3NmdS1jbGllbnQnXSk7XG4gICAgICAgIGNvbnN0IGxvZ0ludGVyY2VwdG9yID0ge1xuICAgICAgICAgICAgaW50ZXJjZXB0VW5hcnk6IChuZXh0LCBtZXRob2QsIGlucHV0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3RyYWNlJywgYENhbGxpbmcgU0ZVIFJQQyBtZXRob2QgJHttZXRob2QubmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KG1ldGhvZCwgaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ycGMgPSBjcmVhdGVTaWduYWxDbGllbnQoe1xuICAgICAgICAgICAgYmFzZVVybDogc2Z1U2VydmVyLnVybCxcbiAgICAgICAgICAgIGludGVyY2VwdG9yczogW1xuICAgICAgICAgICAgICAgIHdpdGhIZWFkZXJzKHtcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbG9nSW50ZXJjZXB0b3IsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlIElDRVRyaWNrbGUga2luZCBvZiBldmVudHMuXG4gICAgICAgIC8vIFRoZXNlIGV2ZW50cyBtaWdodCBiZSB0cmlnZ2VyZWQgYnkgdGhlIFNGVSBiZWZvcmUgdGhlIGluaXRpYWwgUlRDXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuIEluIHRoYXQgY2FzZSwgdGhvc2UgZXZlbnRzIChJQ0UgY2FuZGlkYXRlcylcbiAgICAgICAgLy8gbmVlZCB0byBiZSBidWZmZXJlZCBhbmQgbGF0ZXIgYWRkZWQgdG8gdGhlIGFwcHJvcHJpYXRlIFBlZXJDb25uZWN0aW9uXG4gICAgICAgIC8vIG9uY2UgdGhlIHJlbW90ZURlc2NyaXB0aW9uIGlzIGtub3duIGFuZCBzZXQuXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJY2VUcmlja2xlID0gZGlzcGF0Y2hlci5vbignaWNlVHJpY2tsZScsIChpY2VUcmlja2xlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmljZVRyaWNrbGVCdWZmZXIucHVzaChpY2VUcmlja2xlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmFsV3MgPSBjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsKHtcbiAgICAgICAgICAgIGVuZHBvaW50OiBzZnVTZXJ2ZXIud3NfZW5kcG9pbnQsXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3Rpb25DaGVjaygpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuZGlzcGF0Y2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaWduYWxSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbk9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWxXcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBBbGl2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5zaWduYWxXcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zaWduYWxXcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbm9ybWFsIGNsb3N1cmUgY29kZS4gVXNlZCBmb3IgY29udHJvbGxlZCBzaHV0ZG93bnMuXG4gKi9cblN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSA9IDEwMDA7XG4vKipcbiAqIFRoZSBlcnJvciBjb2RlIHVzZWQgd2hlbiB0aGUgU0ZVIGNvbm5lY3Rpb24gaXMgdW5oZWFsdGh5LlxuICogVXN1YWxseSwgdGhpcyBtZWFucyB0aGF0IG5vIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQgZnJvbSB0aGUgU0ZVIGZvclxuICogYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lIChgY29ubmVjdGlvbkNoZWNrVGltZW91dGApLlxuICovXG5TdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9VTkhFQUxUSFkgPSA0MDAxO1xuLyoqXG4gKiBUaGUgZXJyb3IgY29kZSB1c2VkIHdoZW4gdGhlIFNGVSBjb25uZWN0aW9uIGlzIGJyb2tlbi5cbiAqIFVzdWFsbHksIHRoaXMgbWVhbnMgdGhhdCB0aGUgV1MgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQgdW5leHBlY3RlZGx5LlxuICogVGhpcyBlcnJvciBjb2RlIGlzIHVzZWQgdG8gYW5ub3VuY2UgYSBmYXN0LXJlY29ubmVjdC5cbiAqL1xuU3RyZWFtU2Z1Q2xpZW50LkVSUk9SX0NPTk5FQ1RJT05fQlJPS0VOID0gNDAwMjsgLy8gdXNlZCBpbiBmYXN0LXJlY29ubmVjdHNcbmNvbnN0IE1BWF9SRVRSSUVTID0gNTtcbi8qKlxuICogQ3JlYXRlcyBhIGNsb3N1cmUgd2hpY2ggd3JhcHMgdGhlIGdpdmVuIFJQQyBjYWxsIGFuZCByZXRyaWVzIGludm9raW5nXG4gKiB0aGUgUlBDIHVudGlsIGl0IHN1Y2NlZWRzIG9yIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIGlzIHJlYWNoZWQuXG4gKlxuICogQmV0d2VlbiBlYWNoIHJldHJ5LCB0aGVyZSB3b3VsZCBiZSBhIHJhbmRvbSBkZWxheSBpbiBvcmRlciB0byBhdm9pZFxuICogcmVxdWVzdCBidXJzdHMgdG93YXJkcyB0aGUgU0ZVLlxuICpcbiAqIEBwYXJhbSBycGMgdGhlIGNsb3N1cmUgYXJvdW5kIHRoZSBSUEMgY2FsbCB0byBleGVjdXRlLlxuICogQHBhcmFtIGxvZ2dlciBhIGxvZ2dlciBpbnN0YW5jZSB0byB1c2UuXG4gKiBAcGFyYW0gPEk+IHRoZSB0eXBlIG9mIHRoZSByZXF1ZXN0IG9iamVjdC5cbiAqIEBwYXJhbSA8Tz4gdGhlIHR5cGUgb2YgdGhlIHJlc3BvbnNlIG9iamVjdC5cbiAqL1xuY29uc3QgcmV0cnlhYmxlID0gYXN5bmMgKHJwYywgbG9nZ2VyKSA9PiB7XG4gICAgbGV0IHJldHJ5QXR0ZW1wdCA9IDA7XG4gICAgbGV0IHJwY0NhbGxSZXN1bHQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBkb24ndCBkZWxheSB0aGUgZmlyc3QgaW52b2NhdGlvblxuICAgICAgICBpZiAocmV0cnlBdHRlbXB0ID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbChyZXRyeUF0dGVtcHQpKTtcbiAgICAgICAgfVxuICAgICAgICBycGNDYWxsUmVzdWx0ID0gYXdhaXQgcnBjKCk7XG4gICAgICAgIGxvZ2dlcigndHJhY2UnLCBgU0ZVIFJQQyByZXNwb25zZSByZWNlaXZlZCBmb3IgJHtycGNDYWxsUmVzdWx0Lm1ldGhvZC5uYW1lfWAsIHJwY0NhbGxSZXN1bHQpO1xuICAgICAgICAvLyBpZiB0aGUgUlBDIGNhbGwgZmFpbGVkLCBsb2cgdGhlIGVycm9yIGFuZCByZXRyeVxuICAgICAgICBpZiAocnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyKCdlcnJvcicsIGBTRlUgUlBDIEVycm9yICgke3JwY0NhbGxSZXN1bHQubWV0aG9kLm5hbWV9KTpgLCBycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXRyeUF0dGVtcHQrKztcbiAgICB9IHdoaWxlIChycGNDYWxsUmVzdWx0LnJlc3BvbnNlLmVycm9yPy5zaG91bGRSZXRyeSAmJlxuICAgICAgICByZXRyeUF0dGVtcHQgPCBNQVhfUkVUUklFUyk7XG4gICAgaWYgKHJwY0NhbGxSZXN1bHQucmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgcnBjQ2FsbFJlc3VsdC5yZXNwb25zZS5lcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJwY0NhbGxSZXN1bHQ7XG59O1xuXG4vKipcbiAqIEV2ZW50IGhhbmRsZXIgdGhhdCB3YXRjaGVkIHRoZSBkZWxpdmVyeSBvZiBgY2FsbC5hY2NlcHRlZGAuXG4gKiBPbmNlIHRoZSBldmVudCBpcyByZWNlaXZlZCwgdGhlIGNhbGwgaXMgam9pbmVkLlxuICovXG5jb25zdCB3YXRjaENhbGxBY2NlcHRlZCA9IChjYWxsKSA9PiB7XG4gICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIG9uQ2FsbEFjY2VwdGVkKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZGlzY2FyZCB0aGUgZXZlbnQgaWYgaXQncyBmcm9tIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgICAgaWYgKGV2ZW50LnVzZXIuaWQgPT09IGNhbGwuY3VycmVudFVzZXJJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gY2FsbDtcbiAgICAgICAgaWYgKGV2ZW50LmNhbGwuY3JlYXRlZF9ieS5pZCA9PT0gY2FsbC5jdXJyZW50VXNlcklkICYmXG4gICAgICAgICAgICBzdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWxsLmpvaW4oKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBFdmVudCBoYW5kbGVyIHRoYXQgd2F0Y2hlcyBkZWxpdmVyeSBvZiBgY2FsbC5yZWplY3RlZGAgV2Vic29ja2V0IGV2ZW50LlxuICogT25jZSB0aGUgZXZlbnQgaXMgcmVjZWl2ZWQsIHRoZSBjYWxsIGlzIGxlZnQuXG4gKi9cbmNvbnN0IHdhdGNoQ2FsbFJlamVjdGVkID0gKGNhbGwpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gb25DYWxsUmVqZWN0ZWQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBkaXNjYXJkIHRoZSBldmVudCBpZiBpdCdzIGZyb20gdGhlIGN1cnJlbnQgdXNlclxuICAgICAgICBpZiAoZXZlbnQudXNlci5pZCA9PT0gY2FsbC5jdXJyZW50VXNlcklkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGNhbGw6IGV2ZW50Q2FsbCB9ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbjogY2FsbFNlc3Npb24gfSA9IGV2ZW50Q2FsbDtcbiAgICAgICAgaWYgKCFjYWxsU2Vzc2lvbikge1xuICAgICAgICAgICAgY2FsbC5sb2dnZXIoJ3dhcm4nLCAnTm8gY2FsbCBzZXNzaW9uIHByb3ZpZGVkLiBJZ25vcmluZyBjYWxsLnJlamVjdGVkIGV2ZW50LicsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWplY3RlZEJ5ID0gY2FsbFNlc3Npb24ucmVqZWN0ZWRfYnk7XG4gICAgICAgIGNvbnN0IHsgbWVtYmVycywgY2FsbGluZ1N0YXRlIH0gPSBjYWxsLnN0YXRlO1xuICAgICAgICBpZiAoY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuUklOR0lORykge1xuICAgICAgICAgICAgY2FsbC5sb2dnZXIoJ2luZm8nLCAnQ2FsbCBpcyBub3QgaW4gcmluZ2luZyBtb2RlIChpdCBpcyBlaXRoZXIgYWNjZXB0ZWQgb3IgcmVqZWN0ZWQgYWxyZWFkeSkuIElnbm9yaW5nIGNhbGwucmVqZWN0ZWQgZXZlbnQuJywgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsLmlzQ3JlYXRlZEJ5TWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZXJ5b25lRWxzZVJlamVjdGVkID0gbWVtYmVyc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG0pID0+IG0udXNlcl9pZCAhPT0gY2FsbC5jdXJyZW50VXNlcklkKVxuICAgICAgICAgICAgICAgIC5ldmVyeSgobSkgPT4gcmVqZWN0ZWRCeVttLnVzZXJfaWRdKTtcbiAgICAgICAgICAgIGlmIChldmVyeW9uZUVsc2VSZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIGNhbGwubG9nZ2VyKCdpbmZvJywgJ2V2ZXJ5b25lIHJlamVjdGVkLCBsZWF2aW5nIHRoZSBjYWxsJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5sZWF2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlamVjdGVkQnlbZXZlbnRDYWxsLmNyZWF0ZWRfYnkuaWRdKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5sb2dnZXIoJ2luZm8nLCAnY2FsbCBjcmVhdG9yIHJlamVjdGVkLCBsZWF2aW5nIGNhbGwnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8qKlxuICogRXZlbnQgaGFuZGxlciB0aGF0IHdhdGNoZXMgdGhlIGRlbGl2ZXJ5IG9mIGBjYWxsLmVuZGVkYCBXZWJzb2NrZXQgZXZlbnQuXG4gKi9cbmNvbnN0IHdhdGNoQ2FsbEVuZGVkID0gKGNhbGwpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gb25DYWxsRW5kZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGluZ1N0YXRlIH0gPSBjYWxsLnN0YXRlO1xuICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUklOR0lORyB8fFxuICAgICAgICAgICAgY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEIHx8XG4gICAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lOSU5HKSB7XG4gICAgICAgICAgICBhd2FpdCBjYWxsLmxlYXZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBFdmVudCBoYW5kbGVyIHRoYXQgd2F0Y2hlcyBmb3IgYGNhbGxHcmFudHNVcGRhdGVkYCBldmVudHMuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjYWxsIHN0YXRlIHRvIHVwZGF0ZS5cbiAqL1xuY29uc3Qgd2F0Y2hDYWxsR3JhbnRzVXBkYXRlZCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvbkNhbGxHcmFudHNVcGRhdGVkKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudEdyYW50cyB9ID0gZXZlbnQ7XG4gICAgICAgIGlmIChjdXJyZW50R3JhbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhblB1Ymxpc2hBdWRpbywgY2FuUHVibGlzaFZpZGVvLCBjYW5TY3JlZW5zaGFyZSB9ID0gY3VycmVudEdyYW50cztcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPXTogY2FuUHVibGlzaEF1ZGlvLFxuICAgICAgICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfVklERU9dOiBjYW5QdWJsaXNoVmlkZW8sXG4gICAgICAgICAgICAgICAgW093bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkVdOiBjYW5TY3JlZW5zaGFyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2FwYWJpbGl0aWVzID0gc3RhdGUub3duQ2FwYWJpbGl0aWVzLmZpbHRlcigoY2FwYWJpbGl0eSkgPT4gdXBkYXRlW2NhcGFiaWxpdHldICE9PSBmYWxzZSk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh1cGRhdGUpLmZvckVhY2goKFtjYXBhYmlsaXR5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgIW5leHRDYXBhYmlsaXRpZXMuaW5jbHVkZXMoY2FwYWJpbGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENhcGFiaWxpdGllcy5wdXNoKGNhcGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKG5leHRDYXBhYmlsaXRpZXMpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNvbnN0IGxvZ2dlciQxID0gZ2V0TG9nZ2VyKFsnZXZlbnRzJ10pO1xuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYGNoYW5nZVB1Ymxpc2hRdWFsaXR5YCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hDaGFuZ2VQdWJsaXNoUXVhbGl0eSA9IChkaXNwYXRjaGVyLCBjYWxsKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2NoYW5nZVB1Ymxpc2hRdWFsaXR5JywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyB2aWRlb1NlbmRlcnMgfSA9IGU7XG4gICAgICAgIHZpZGVvU2VuZGVycy5mb3JFYWNoKCh2aWRlb1NlbmRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBsYXllcnMgfSA9IHZpZGVvU2VuZGVyO1xuICAgICAgICAgICAgY2FsbC51cGRhdGVQdWJsaXNoUXVhbGl0eShsYXllcnMuZmlsdGVyKChsKSA9PiBsLmFjdGl2ZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCB3YXRjaENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IChkaXNwYXRjaGVyLCBzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQnLCAoZSkgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcyB9ID0gZTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50cyhjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZXMucmVkdWNlKChwYXRjaGVzLCB1cGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbklkLCBjb25uZWN0aW9uUXVhbGl0eSB9ID0gdXBkYXRlO1xuICAgICAgICAgICAgcGF0Y2hlc1tzZXNzaW9uSWRdID0ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25RdWFsaXR5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgICAgICB9LCB7fSkpO1xuICAgIH0pO1xufTtcbi8qKlxuICogVXBkYXRlcyB0aGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyBpbiB0aGUgY2FsbCBieSBwZWVraW5nIGF0IHRoZVxuICogaGVhbHRoIGNoZWNrIGV2ZW50cyB0aGF0IG91ciBTRlUgc2VuZHMuXG4gKi9cbmNvbnN0IHdhdGNoUGFydGljaXBhbnRDb3VudENoYW5nZWQgPSAoZGlzcGF0Y2hlciwgc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignaGVhbHRoQ2hlY2tSZXNwb25zZScsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFydGljaXBhbnRDb3VudCB9ID0gZTtcbiAgICAgICAgaWYgKHBhcnRpY2lwYW50Q291bnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldFBhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudC50b3RhbCk7XG4gICAgICAgICAgICBzdGF0ZS5zZXRBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50KHBhcnRpY2lwYW50Q291bnQuYW5vbnltb3VzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHdhdGNoTGl2ZUVuZGVkID0gKGRpc3BhdGNoZXIsIGNhbGwpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5lcnJvciAmJiBlLmVycm9yLmNvZGUgIT09IEVycm9yQ29kZS5MSVZFX0VOREVEKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNhbGwucGVybWlzc2lvbnNDb250ZXh0Lmhhc1Blcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5KT0lOX0JBQ0tTVEFHRSkpIHtcbiAgICAgICAgICAgIGNhbGwubGVhdmUoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDEoJ2Vycm9yJywgJ0ZhaWxlZCB0byBsZWF2ZSBjYWxsIGFmdGVyIGxpdmUgZW5kZWQnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vKipcbiAqIFdhdGNoZXMgYW5kIGxvZ3MgdGhlIGVycm9ycyByZXBvcnRlZCBieSB0aGUgY3VycmVudGx5IGNvbm5lY3RlZCBTRlUuXG4gKi9cbmNvbnN0IHdhdGNoU2Z1RXJyb3JSZXBvcnRzID0gKGRpc3BhdGNoZXIpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci5vbignZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICBpZiAoIWUuZXJyb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGU7XG4gICAgICAgIGxvZ2dlciQxKCdlcnJvcicsICdTRlUgcmVwb3J0ZWQgZXJyb3InLCB7XG4gICAgICAgICAgICBjb2RlOiBFcnJvckNvZGVbZXJyb3IuY29kZV0sXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgc2hvdWxkUmV0cnk6IGVycm9yLnNob3VsZFJldHJ5LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFdhdGNoZXMgZm9yIGBwaW5zVXBkYXRlZGAgZXZlbnRzIGFuZCB1cGRhdGVzIHRoZSBwaW5uZWQgc3RhdGUgb2YgcGFydGljaXBhbnRzXG4gKiBpbiB0aGUgY2FsbC5cbiAqL1xuY29uc3Qgd2F0Y2hQaW5zVXBkYXRlZCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvblBpbnNVcGRhdGVkKGUpIHtcbiAgICAgICAgY29uc3QgeyBwaW5zIH0gPSBlO1xuICAgICAgICBzdGF0ZS5zZXRTZXJ2ZXJTaWRlUGlucyhwaW5zKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRoYXQgaGFuZGxlcyBzb2Z0IG11dGVzLlxuICpcbiAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsLlxuICovXG5jb25zdCBoYW5kbGVSZW1vdGVTb2Z0TXV0ZSA9IChjYWxsKSA9PiB7XG4gICAgcmV0dXJuIGNhbGwub24oJ3RyYWNrVW5wdWJsaXNoZWQnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBjYXVzZSwgdHlwZSwgc2Vzc2lvbklkIH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgeyBsb2NhbFBhcnRpY2lwYW50IH0gPSBjYWxsLnN0YXRlO1xuICAgICAgICBpZiAoY2F1c2UgPT09IFRyYWNrVW5wdWJsaXNoUmVhc29uLk1PREVSQVRJT04gJiZcbiAgICAgICAgICAgIHNlc3Npb25JZCA9PT0gbG9jYWxQYXJ0aWNpcGFudD8uc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXIgPSBjYWxsLmxvZ2dlcjtcbiAgICAgICAgICAgIGxvZ2dlcignaW5mbycsIGBMb2NhbCBwYXJ0aWNpcGFudCdzICR7VHJhY2tUeXBlW3R5cGVdfSB0cmFjayBpcyBtdXRlZCByZW1vdGVseWApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIoJ3dhcm4nLCAnVW5zdXBwb3J0ZWQgdHJhY2sgdHlwZSB0byBzb2Z0IG11dGUnLCBUcmFja1R5cGVbdHlwZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FsbC5wdWJsaXNoZXI/LmlzUHVibGlzaGluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLnN0b3BQdWJsaXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcignZXJyb3InLCAnRmFpbGVkIHRvIHN0b3AgcHVibGlzaGluZycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHBhcnRpY2lwYW50Sm9pbmVkYCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hQYXJ0aWNpcGFudEpvaW5lZCA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBvblBhcnRpY2lwYW50Sm9pbmVkKGUpIHtcbiAgICAgICAgY29uc3QgeyBwYXJ0aWNpcGFudCB9ID0gZTtcbiAgICAgICAgaWYgKCFwYXJ0aWNpcGFudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gYHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnRgIGFjdHMgYXMgYSBzYWZlZ3VhcmQgYWdhaW5zdFxuICAgICAgICAvLyBwb3RlbnRpYWwgZHVwbGljYXRlIGV2ZW50cyBmcm9tIHRoZSBTRlUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFsdGhvdWdoIHRoZSBTRlUgc2hvdWxkIG5vdCBzZW5kIGR1cGxpY2F0ZSBldmVudHMsIHdlIGhhdmUgc2VlblxuICAgICAgICAvLyBzb21lIHJhY2UgY29uZGl0aW9ucyBpbiB0aGUgcGFzdCBkdXJpbmcgdGhlIGBqb2luLWZsb3dgIHdoZXJlXG4gICAgICAgIC8vIHRoZSBTRlUgd291bGQgc2VuZCBwYXJ0aWNpcGFudCBpbmZvIGFzIHBhcnQgb2YgdGhlIGBqb2luYFxuICAgICAgICAvLyByZXNwb25zZSBhbmQgdGhlbiBmb2xsb3cgdXAgd2l0aCBhIGBwYXJ0aWNpcGFudEpvaW5lZGAgZXZlbnQgZm9yXG4gICAgICAgIC8vIGFscmVhZHkgYW5ub3VuY2VkIHBhcnRpY2lwYW50cy5cbiAgICAgICAgc3RhdGUudXBkYXRlT3JBZGRQYXJ0aWNpcGFudChwYXJ0aWNpcGFudC5zZXNzaW9uSWQsIE9iamVjdC5hc3NpZ24ocGFydGljaXBhbnQsIHtcbiAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVUcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgfTtcbn07XG4vKipcbiAqIEFuIGV2ZW50IHJlc3BvbmRlciB3aGljaCBoYW5kbGVzIHRoZSBgcGFydGljaXBhbnRMZWZ0YCBldmVudC5cbiAqL1xuY29uc3Qgd2F0Y2hQYXJ0aWNpcGFudExlZnQgPSAoc3RhdGUpID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25QYXJ0aWNpcGFudExlZnQoZSkge1xuICAgICAgICBjb25zdCB7IHBhcnRpY2lwYW50IH0gPSBlO1xuICAgICAgICBpZiAoIXBhcnRpY2lwYW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGF0ZS5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbHRlcigocCkgPT4gcC5zZXNzaW9uSWQgIT09IHBhcnRpY2lwYW50LnNlc3Npb25JZCkpO1xuICAgIH07XG59O1xuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHRyYWNrUHVibGlzaGVkYCBldmVudC5cbiAqIFRoZSBTRlUgd2lsbCBzZW5kIHRoaXMgZXZlbnQgd2hlbiBhIHBhcnRpY2lwYW50IHB1Ymxpc2hlcyBhIHRyYWNrLlxuICovXG5jb25zdCB3YXRjaFRyYWNrUHVibGlzaGVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uVHJhY2tQdWJsaXNoZWQoZSkge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNlc3Npb25JZCwgcGFydGljaXBhbnQgfSA9IGU7XG4gICAgICAgIC8vIEFuIG9wdGltaXphdGlvbiBmb3IgbGFyZ2UgY2FsbHMuXG4gICAgICAgIC8vIEFmdGVyIGEgY2VydGFpbiB0aHJlc2hvbGQsIHRoZSBTRlUgd291bGQgc3RvcCBlbWl0dGluZyBgcGFydGljaXBhbnRKb2luZWRgXG4gICAgICAgIC8vIGV2ZW50cywgYW5kIGluc3RlYWQsIGl0IHdvdWxkIG9ubHkgcHJvdmlkZSB0aGUgcGFydGljaXBhbnQncyBpbmZvcm1hdGlvblxuICAgICAgICAvLyBvbmNlIHRoZXkgc3RhcnQgcHVibGlzaGluZyBhIHRyYWNrLlxuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnVwZGF0ZU9yQWRkUGFydGljaXBhbnQoc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIChwKSA9PiAoe1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrczogWy4uLnAucHVibGlzaGVkVHJhY2tzLCB0eXBlXS5maWx0ZXIodW5pcXVlKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBBbiBldmVudCByZXNwb25kZXIgd2hpY2ggaGFuZGxlcyB0aGUgYHRyYWNrVW5wdWJsaXNoZWRgIGV2ZW50LlxuICogVGhlIFNGVSB3aWxsIHNlbmQgdGhpcyBldmVudCB3aGVuIGEgcGFydGljaXBhbnQgdW5wdWJsaXNoZXMgYSB0cmFjay5cbiAqL1xuY29uc3Qgd2F0Y2hUcmFja1VucHVibGlzaGVkID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uVHJhY2tVbnB1Ymxpc2hlZChlKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgc2Vzc2lvbklkLCBwYXJ0aWNpcGFudCB9ID0gZTtcbiAgICAgICAgLy8gQW4gb3B0aW1pemF0aW9uIGZvciBsYXJnZSBjYWxscy4gU2VlIGB3YXRjaFRyYWNrUHVibGlzaGVkYC5cbiAgICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICBzdGF0ZS51cGRhdGVPckFkZFBhcnRpY2lwYW50KHNlc3Npb25JZCwgcGFydGljaXBhbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCAocCkgPT4gKHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoZWRUcmFja3M6IHAucHVibGlzaGVkVHJhY2tzLmZpbHRlcigodCkgPT4gdCAhPT0gdHlwZSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IHVuaXF1ZSA9ICh2LCBpLCBhcnIpID0+IGFyci5pbmRleE9mKHYpID09PSBpO1xuXG4vKipcbiAqIFdhdGNoZXMgZm9yIGBkb21pbmFudFNwZWFrZXJDaGFuZ2VkYCBldmVudHMuXG4gKi9cbmNvbnN0IHdhdGNoRG9taW5hbnRTcGVha2VyQ2hhbmdlZCA9IChkaXNwYXRjaGVyLCBzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBkaXNwYXRjaGVyLm9uKCdkb21pbmFudFNwZWFrZXJDaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZXNzaW9uSWQgfSA9IGU7XG4gICAgICAgIGlmIChzZXNzaW9uSWQgPT09IHN0YXRlLmRvbWluYW50U3BlYWtlcj8uc2Vzc2lvbklkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGF0ZS5zZXRQYXJ0aWNpcGFudHMoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLm1hcCgocGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgIC8vIG1hcmsgdGhlIG5ldyBkb21pbmFudCBzcGVha2VyXG4gICAgICAgICAgICBpZiAocGFydGljaXBhbnQuc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICAgICAgaXNEb21pbmFudFNwZWFrZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVubWFyayB0aGUgb2xkIGRvbWluYW50IHNwZWFrZXJcbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5pc0RvbWluYW50U3BlYWtlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnRpY2lwYW50LFxuICAgICAgICAgICAgICAgICAgICBpc0RvbWluYW50U3BlYWtlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWNpcGFudDsgLy8gbm8gY2hhbmdlXG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFdhdGNoZXMgZm9yIGBhdWRpb0xldmVsQ2hhbmdlZGAgZXZlbnRzLlxuICovXG5jb25zdCB3YXRjaEF1ZGlvTGV2ZWxDaGFuZ2VkID0gKGRpc3BhdGNoZXIsIHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIub24oJ2F1ZGlvTGV2ZWxDaGFuZ2VkJywgKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBhdWRpb0xldmVscyB9ID0gZTtcbiAgICAgICAgc3RhdGUudXBkYXRlUGFydGljaXBhbnRzKGF1ZGlvTGV2ZWxzLnJlZHVjZSgocGF0Y2hlcywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcGF0Y2hlc1tjdXJyZW50LnNlc3Npb25JZF0gPSB7XG4gICAgICAgICAgICAgICAgYXVkaW9MZXZlbDogY3VycmVudC5sZXZlbCxcbiAgICAgICAgICAgICAgICBpc1NwZWFraW5nOiBjdXJyZW50LmlzU3BlYWtpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVycyBmb3IgYSBjYWxsIGR1cmluZyBpdHMgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSBjYWxsIHRoZSBjYWxsIHRvIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzIGZvci5cbiAqIEBwYXJhbSBzdGF0ZSB0aGUgY2FsbCBzdGF0ZS5cbiAqIEBwYXJhbSBkaXNwYXRjaGVyIHRoZSBkaXNwYXRjaGVyLlxuICovXG5jb25zdCByZWdpc3RlckV2ZW50SGFuZGxlcnMgPSAoY2FsbCwgc3RhdGUsIGRpc3BhdGNoZXIpID0+IHtcbiAgICBjb25zdCBldmVudEhhbmRsZXJzID0gW1xuICAgICAgICBjYWxsLm9uKCdjYWxsLmVuZGVkJywgd2F0Y2hDYWxsRW5kZWQoY2FsbCkpLFxuICAgICAgICB3YXRjaExpdmVFbmRlZChkaXNwYXRjaGVyLCBjYWxsKSxcbiAgICAgICAgd2F0Y2hTZnVFcnJvclJlcG9ydHMoZGlzcGF0Y2hlciksXG4gICAgICAgIHdhdGNoQ2hhbmdlUHVibGlzaFF1YWxpdHkoZGlzcGF0Y2hlciwgY2FsbCksXG4gICAgICAgIHdhdGNoQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgd2F0Y2hQYXJ0aWNpcGFudENvdW50Q2hhbmdlZChkaXNwYXRjaGVyLCBzdGF0ZSksXG4gICAgICAgIGNhbGwub24oJ3BhcnRpY2lwYW50Sm9pbmVkJywgd2F0Y2hQYXJ0aWNpcGFudEpvaW5lZChzdGF0ZSkpLFxuICAgICAgICBjYWxsLm9uKCdwYXJ0aWNpcGFudExlZnQnLCB3YXRjaFBhcnRpY2lwYW50TGVmdChzdGF0ZSkpLFxuICAgICAgICBjYWxsLm9uKCd0cmFja1B1Ymxpc2hlZCcsIHdhdGNoVHJhY2tQdWJsaXNoZWQoc3RhdGUpKSxcbiAgICAgICAgY2FsbC5vbigndHJhY2tVbnB1Ymxpc2hlZCcsIHdhdGNoVHJhY2tVbnB1Ymxpc2hlZChzdGF0ZSkpLFxuICAgICAgICB3YXRjaEF1ZGlvTGV2ZWxDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgd2F0Y2hEb21pbmFudFNwZWFrZXJDaGFuZ2VkKGRpc3BhdGNoZXIsIHN0YXRlKSxcbiAgICAgICAgY2FsbC5vbignY2FsbEdyYW50c1VwZGF0ZWQnLCB3YXRjaENhbGxHcmFudHNVcGRhdGVkKHN0YXRlKSksXG4gICAgICAgIGNhbGwub24oJ3BpbnNVcGRhdGVkJywgd2F0Y2hQaW5zVXBkYXRlZChzdGF0ZSkpLFxuICAgICAgICBoYW5kbGVSZW1vdGVTb2Z0TXV0ZShjYWxsKSxcbiAgICBdO1xuICAgIGlmIChjYWxsLnJpbmdpbmcpIHtcbiAgICAgICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBvbmx5IHJlbGV2YW50IHdoZW4gdGhlIGNhbGwgaXMgcmluZ2luZ1xuICAgICAgICBldmVudEhhbmRsZXJzLnB1c2gocmVnaXN0ZXJSaW5naW5nQ2FsbEV2ZW50SGFuZGxlcnMoY2FsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goKHVuc3Vic2NyaWJlKSA9PiB1bnN1YnNjcmliZSgpKTtcbiAgICB9O1xufTtcbi8qKlxuICogUmVnaXN0ZXJzIGV2ZW50IGhhbmRsZXJzIGZvciBhIGNhbGwgdGhhdCBpcyBvZiByaW5naW5nIHR5cGUuXG4gKlxuICogQHBhcmFtIGNhbGwgdGhlIGNhbGwgdG8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnMgZm9yLlxuICovXG5jb25zdCByZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyA9IChjYWxsKSA9PiB7XG4gICAgY29uc3QgY29vcmRpbmF0b3JSaW5nRXZlbnRzID0ge1xuICAgICAgICAnY2FsbC5hY2NlcHRlZCc6IHdhdGNoQ2FsbEFjY2VwdGVkKGNhbGwpLFxuICAgICAgICAnY2FsbC5yZWplY3RlZCc6IHdhdGNoQ2FsbFJlamVjdGVkKGNhbGwpLFxuICAgIH07XG4gICAgY29uc3QgZXZlbnRIYW5kbGVycyA9IE9iamVjdC5rZXlzKGNvb3JkaW5hdG9yUmluZ0V2ZW50cykubWFwKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIGNhbGwub24oZXZlbnROYW1lLCBjb29yZGluYXRvclJpbmdFdmVudHNbZXZlbnROYW1lXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5mb3JFYWNoKCh1bnN1YnNjcmliZSkgPT4gdW5zdWJzY3JpYmUoKSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29sbGVjdHMgYWxsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBqb2luIGEgY2FsbCwgdGFsa3MgdG8gdGhlIGNvb3JkaW5hdG9yXG4gKiBhbmQgcmV0dXJucyB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHRvIGpvaW4gdGhlIGNhbGwuXG4gKlxuICogQHBhcmFtIGh0dHBDbGllbnQgdGhlIGh0dHAgY2xpZW50IHRvIHVzZS5cbiAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBjYWxsLlxuICogQHBhcmFtIGlkIHRoZSBpZCBvZiB0aGUgY2FsbC5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgY2FsbC5cbiAqL1xuY29uc3Qgam9pbiA9IGFzeW5jIChodHRwQ2xpZW50LCB0eXBlLCBpZCwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IGpvaW5DYWxsUmVzcG9uc2UgPSBhd2FpdCBkb0pvaW4oaHR0cENsaWVudCwgdHlwZSwgaWQsIGRhdGEpO1xuICAgIGNvbnN0IHsgY2FsbCwgY3JlZGVudGlhbHMsIG1lbWJlcnMsIG93bl9jYXBhYmlsaXRpZXMgfSA9IGpvaW5DYWxsUmVzcG9uc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZzogdG9SdGNDb25maWd1cmF0aW9uKGNyZWRlbnRpYWxzLmljZV9zZXJ2ZXJzKSxcbiAgICAgICAgc2Z1U2VydmVyOiBjcmVkZW50aWFscy5zZXJ2ZXIsXG4gICAgICAgIHRva2VuOiBjcmVkZW50aWFscy50b2tlbixcbiAgICAgICAgbWV0YWRhdGE6IGNhbGwsXG4gICAgICAgIG1lbWJlcnMsXG4gICAgICAgIG93bkNhcGFiaWxpdGllczogb3duX2NhcGFiaWxpdGllcyxcbiAgICB9O1xufTtcbmNvbnN0IGRvSm9pbiA9IGFzeW5jIChodHRwQ2xpZW50LCB0eXBlLCBpZCwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gYXdhaXQgaHR0cENsaWVudC5nZXRMb2NhdGlvbkhpbnQoKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBsb2NhdGlvbixcbiAgICB9O1xuICAgIHJldHVybiBodHRwQ2xpZW50LnBvc3QoYC9jYWxsLyR7dHlwZX0vJHtpZH0vam9pbmAsIHJlcXVlc3QpO1xufTtcbmNvbnN0IHRvUnRjQ29uZmlndXJhdGlvbiA9IChjb25maWcpID0+IHtcbiAgICBpZiAoIWNvbmZpZyB8fCBjb25maWcubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJ0Y0NvbmZpZyA9IHtcbiAgICAgICAgaWNlU2VydmVyczogY29uZmlnLm1hcCgoaWNlKSA9PiAoe1xuICAgICAgICAgICAgdXJsczogaWNlLnVybHMsXG4gICAgICAgICAgICB1c2VybmFtZTogaWNlLnVzZXJuYW1lLFxuICAgICAgICAgICAgY3JlZGVudGlhbDogaWNlLnBhc3N3b3JkLFxuICAgICAgICB9KSksXG4gICAgfTtcbiAgICByZXR1cm4gcnRjQ29uZmlnO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN0YXRzUmVwb3J0ZXIgaW5zdGFuY2UgdGhhdCBjb2xsZWN0cyBtZXRyaWNzIGFib3V0IHRoZSBvbmdvaW5nIGNhbGwgYW5kIHJlcG9ydHMgdGhlbSB0byB0aGUgc3RhdGUgc3RvcmVcbiAqL1xuY29uc3QgY3JlYXRlU3RhdHNSZXBvcnRlciA9ICh7IHN1YnNjcmliZXIsIHB1Ymxpc2hlciwgc3RhdGUsIHBvbGxpbmdJbnRlcnZhbEluTXMgPSAyMDAwLCB9KSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKFsnc3RhdHMnXSk7XG4gICAgY29uc3QgZ2V0UmF3U3RhdHNGb3JUcmFjayA9IGFzeW5jIChraW5kLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICBpZiAoa2luZCA9PT0gJ3N1YnNjcmliZXInICYmIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmdldFN0YXRzKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChraW5kID09PSAncHVibGlzaGVyJyAmJiBwdWJsaXNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwdWJsaXNoZXIuZ2V0U3RhdHMoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyKCd3YXJuJywgYENhbid0IHJldHJpZXZlIFJUQyBzdGF0cyBmb3IgJHtraW5kfWApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0U3RhdHNGb3JTdHJlYW0gPSBhc3luYyAoa2luZCwgbWVkaWFTdHJlYW0pID0+IHtcbiAgICAgICAgY29uc3QgcGMgPSBraW5kID09PSAnc3Vic2NyaWJlcicgPyBzdWJzY3JpYmVyIDogcHVibGlzaGVyO1xuICAgICAgICBjb25zdCBzdGF0c0ZvclN0cmVhbSA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0cmFjayBvZiBtZWRpYVN0cmVhbS5nZXRUcmFja3MoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgcGMuZ2V0U3RhdHModHJhY2spO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB0cmFuc2Zvcm0ocmVwb3J0LCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRyYWNrS2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0c0ZvclN0cmVhbS5wdXNoKHN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHNGb3JTdHJlYW07XG4gICAgfTtcbiAgICBjb25zdCBzdGFydFJlcG9ydGluZ1N0YXRzRm9yID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICBzZXNzaW9uSWRzVG9UcmFjay5hZGQoc2Vzc2lvbklkKTtcbiAgICAgICAgdm9pZCBydW4oKTtcbiAgICB9O1xuICAgIGNvbnN0IHN0b3BSZXBvcnRpbmdTdGF0c0ZvciA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgc2Vzc2lvbklkc1RvVHJhY2suZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgICAgIHZvaWQgcnVuKCk7XG4gICAgfTtcbiAgICBjb25zdCBzZXNzaW9uSWRzVG9UcmFjayA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBzdGF0cyByZXBvcnRpbmcgbG9vcC5cbiAgICAgKi9cbiAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50U3RhdHMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkcyA9IG5ldyBTZXQoc2Vzc2lvbklkc1RvVHJhY2spO1xuICAgICAgICBpZiAoc2Vzc2lvbklkcy5zaXplID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGFydGljaXBhbnQgb2Ygc3RhdGUucGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uSWRzLmhhcyhwYXJ0aWNpcGFudC5zZXNzaW9uSWQpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gcGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgICAgID8gJ3B1Ymxpc2hlcidcbiAgICAgICAgICAgICAgICAgICAgOiAnc3Vic2NyaWJlcic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwYXJ0aWNpcGFudC52aWRlb1N0cmVhbT8uZ2V0VmlkZW9UcmFja3MoKSB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4ocGFydGljaXBhbnQuYXVkaW9TdHJlYW0/LmdldEF1ZGlvVHJhY2tzKCkgfHwgW10pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhbnRTdGF0c1twYXJ0aWNpcGFudC5zZXNzaW9uSWRdID0gYXdhaXQgZ2V0U3RhdHNGb3JTdHJlYW0oa2luZCwgbWVyZ2VkU3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFN0cmVhbS5yZW1vdmVUcmFjayh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcignZXJyb3InLCBgRmFpbGVkIHRvIGNvbGxlY3Qgc3RhdHMgZm9yICR7a2luZH0gaWYgJHtwYXJ0aWNpcGFudC51c2VySWR9YCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzdWJzY3JpYmVyU3RhdHMsIHB1Ymxpc2hlclN0YXRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHN1YnNjcmliZXJcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdHMoKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXBvcnQpID0+IHRyYW5zZm9ybShyZXBvcnQsIHtcbiAgICAgICAgICAgICAgICBraW5kOiAnc3Vic2NyaWJlcicsXG4gICAgICAgICAgICAgICAgdHJhY2tLaW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oYWdncmVnYXRlKSxcbiAgICAgICAgICAgIHB1Ymxpc2hlclxuICAgICAgICAgICAgICAgIC5nZXRTdGF0cygpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcG9ydCkgPT4gdHJhbnNmb3JtKHJlcG9ydCwge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdwdWJsaXNoZXInLFxuICAgICAgICAgICAgICAgIHRyYWNrS2luZDogJ3ZpZGVvJyxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC50aGVuKGFnZ3JlZ2F0ZSksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBbc3Vic2NyaWJlclJhd1N0YXRzLCBwdWJsaXNoZXJSYXdTdGF0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBnZXRSYXdTdGF0c0ZvclRyYWNrKCdzdWJzY3JpYmVyJyksXG4gICAgICAgICAgICBnZXRSYXdTdGF0c0ZvclRyYWNrKCdwdWJsaXNoZXInKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHN0YXRlLnNldENhbGxTdGF0c1JlcG9ydCh7XG4gICAgICAgICAgICBkYXRhY2VudGVyOiBwdWJsaXNoZXIuc2Z1Q2xpZW50LmVkZ2VOYW1lLFxuICAgICAgICAgICAgcHVibGlzaGVyU3RhdHMsXG4gICAgICAgICAgICBzdWJzY3JpYmVyU3RhdHMsXG4gICAgICAgICAgICBzdWJzY3JpYmVyUmF3U3RhdHMsXG4gICAgICAgICAgICBwdWJsaXNoZXJSYXdTdGF0cyxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50czogcGFydGljaXBhbnRTdGF0cyxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGlmIChwb2xsaW5nSW50ZXJ2YWxJbk1zID4gMCkge1xuICAgICAgICBjb25zdCBsb29wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgcnVuKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIoJ2RlYnVnJywgJ0ZhaWxlZCB0byBjb2xsZWN0IHN0YXRzJywgZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQobG9vcCwgcG9sbGluZ0ludGVydmFsSW5Ncyk7XG4gICAgICAgIH07XG4gICAgICAgIHZvaWQgbG9vcCgpO1xuICAgIH1cbiAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0UmF3U3RhdHNGb3JUcmFjayxcbiAgICAgICAgZ2V0U3RhdHNGb3JTdHJlYW0sXG4gICAgICAgIHN0YXJ0UmVwb3J0aW5nU3RhdHNGb3IsXG4gICAgICAgIHN0b3BSZXBvcnRpbmdTdGF0c0ZvcixcbiAgICAgICAgc3RvcCxcbiAgICB9O1xufTtcbi8qKlxuICogVHJhbnNmb3JtcyByYXcgUlRDIHN0YXRzIGludG8gYSBzbGltbWVyIGFuZCB1bmlmb3JtIGFjcm9zcyBicm93c2VycyBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHJlcG9ydCB0aGUgcmVwb3J0IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSBvcHRzIHRoZSB0cmFuc2Zvcm0gb3B0aW9ucy5cbiAqL1xuY29uc3QgdHJhbnNmb3JtID0gKHJlcG9ydCwgb3B0cykgPT4ge1xuICAgIGNvbnN0IHsgdHJhY2tLaW5kLCBraW5kIH0gPSBvcHRzO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGtpbmQgPT09ICdzdWJzY3JpYmVyJyA/ICdpbmJvdW5kLXJ0cCcgOiAnb3V0Ym91bmQtcnRwJztcbiAgICBjb25zdCBzdGF0cyA9IGZsYXR0ZW4kMShyZXBvcnQpO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBzdGF0c1xuICAgICAgICAuZmlsdGVyKChzdGF0KSA9PiBzdGF0LnR5cGUgPT09IGRpcmVjdGlvbiAmJlxuICAgICAgICBzdGF0LmtpbmQgPT09IHRyYWNrS2luZClcbiAgICAgICAgLm1hcCgoc3RhdCkgPT4ge1xuICAgICAgICBjb25zdCBydGNTdHJlYW1TdGF0cyA9IHN0YXQ7XG4gICAgICAgIGNvbnN0IGNvZGVjID0gc3RhdHMuZmluZCgocykgPT4gcy50eXBlID09PSAnY29kZWMnICYmIHMuaWQgPT09IHJ0Y1N0cmVhbVN0YXRzLmNvZGVjSWQpOyAvLyBGSVhNRSBPTDogaW5jb3JyZWN0IHR5cGUhXG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHN0YXRzLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gJ3RyYW5zcG9ydCcgJiYgcy5pZCA9PT0gcnRjU3RyZWFtU3RhdHMudHJhbnNwb3J0SWQpO1xuICAgICAgICBsZXQgcm91bmRUcmlwVGltZTtcbiAgICAgICAgaWYgKHRyYW5zcG9ydCAmJiB0cmFuc3BvcnQuZHRsc1N0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlUGFpciA9IHN0YXRzLmZpbmQoKHMpID0+IHMudHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJyAmJlxuICAgICAgICAgICAgICAgIHMuaWQgPT09IHRyYW5zcG9ydC5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCk7XG4gICAgICAgICAgICByb3VuZFRyaXBUaW1lID0gY2FuZGlkYXRlUGFpcj8uY3VycmVudFJvdW5kVHJpcFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzU2VudDogcnRjU3RyZWFtU3RhdHMuYnl0ZXNTZW50LFxuICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogcnRjU3RyZWFtU3RhdHMuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGNvZGVjOiBjb2RlYz8ubWltZVR5cGUsXG4gICAgICAgICAgICBjdXJyZW50Um91bmRUcmlwVGltZTogcm91bmRUcmlwVGltZSxcbiAgICAgICAgICAgIGZyYW1lSGVpZ2h0OiBydGNTdHJlYW1TdGF0cy5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHJ0Y1N0cmVhbVN0YXRzLmZyYW1lc1BlclNlY29uZCxcbiAgICAgICAgICAgIGppdHRlcjogcnRjU3RyZWFtU3RhdHMuaml0dGVyLFxuICAgICAgICAgICAga2luZDogcnRjU3RyZWFtU3RhdHMua2luZCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGF2YWlsYWJsZSBpbiBDaHJvbWUgb25seSwgVFMgZG9lc24ndCByZWNvZ25pemUgdGhpc1xuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb246IHJ0Y1N0cmVhbVN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uLFxuICAgICAgICAgICAgcmlkOiBydGNTdHJlYW1TdGF0cy5yaWQsXG4gICAgICAgICAgICBzc3JjOiBydGNTdHJlYW1TdGF0cy5zc3JjLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhd1N0YXRzOiByZXBvcnQsXG4gICAgICAgIHN0cmVhbXMsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9O1xufTtcbi8qKlxuICogQWdncmVnYXRlcyBnZW5lcmljIHN0YXRzLlxuICpcbiAqIEBwYXJhbSBzdGF0cyB0aGUgc3RhdHMgdG8gYWdncmVnYXRlLlxuICovXG5jb25zdCBhZ2dyZWdhdGUgPSAoc3RhdHMpID0+IHtcbiAgICBjb25zdCBhZ2dyZWdhdGVkU3RhdHMgPSB7XG4gICAgICAgIHJhd1JlcG9ydDogc3RhdHMsXG4gICAgICAgIHRvdGFsQnl0ZXNTZW50OiAwLFxuICAgICAgICB0b3RhbEJ5dGVzUmVjZWl2ZWQ6IDAsXG4gICAgICAgIGF2ZXJhZ2VKaXR0ZXJJbk1zOiAwLFxuICAgICAgICBhdmVyYWdlUm91bmRUcmlwVGltZUluTXM6IDAsXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uczogJ25vbmUnLFxuICAgICAgICBoaWdoZXN0RnJhbWVXaWR0aDogMCxcbiAgICAgICAgaGlnaGVzdEZyYW1lSGVpZ2h0OiAwLFxuICAgICAgICBoaWdoZXN0RnJhbWVzUGVyU2Vjb25kOiAwLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfTtcbiAgICBsZXQgbWF4QXJlYSA9IC0xO1xuICAgIGNvbnN0IGFyZWEgPSAodywgaCkgPT4gdyAqIGg7XG4gICAgY29uc3QgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN0cmVhbXMgPSBzdGF0cy5zdHJlYW1zO1xuICAgIGNvbnN0IHJlcG9ydCA9IHN0cmVhbXMucmVkdWNlKChhY2MsIHN0cmVhbSkgPT4ge1xuICAgICAgICBhY2MudG90YWxCeXRlc1NlbnQgKz0gc3RyZWFtLmJ5dGVzU2VudCB8fCAwO1xuICAgICAgICBhY2MudG90YWxCeXRlc1JlY2VpdmVkICs9IHN0cmVhbS5ieXRlc1JlY2VpdmVkIHx8IDA7XG4gICAgICAgIGFjYy5hdmVyYWdlSml0dGVySW5NcyArPSBzdHJlYW0uaml0dGVyIHx8IDA7XG4gICAgICAgIGFjYy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgKz0gc3RyZWFtLmN1cnJlbnRSb3VuZFRyaXBUaW1lIHx8IDA7XG4gICAgICAgIC8vIG5haXZlIGNhbGN1bGF0aW9uIG9mIHRoZSBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3Qgc3RyZWFtQXJlYSA9IGFyZWEoc3RyZWFtLmZyYW1lV2lkdGggfHwgMCwgc3RyZWFtLmZyYW1lSGVpZ2h0IHx8IDApO1xuICAgICAgICBpZiAoc3RyZWFtQXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgICAgIGFjYy5oaWdoZXN0RnJhbWVXaWR0aCA9IHN0cmVhbS5mcmFtZVdpZHRoIHx8IDA7XG4gICAgICAgICAgICBhY2MuaGlnaGVzdEZyYW1lSGVpZ2h0ID0gc3RyZWFtLmZyYW1lSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICBhY2MuaGlnaGVzdEZyYW1lc1BlclNlY29uZCA9IHN0cmVhbS5mcmFtZXNQZXJTZWNvbmQgfHwgMDtcbiAgICAgICAgICAgIG1heEFyZWEgPSBzdHJlYW1BcmVhO1xuICAgICAgICB9XG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucy5hZGQoc3RyZWFtLnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uIHx8ICcnKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBhZ2dyZWdhdGVkU3RhdHMpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVwb3J0LmF2ZXJhZ2VKaXR0ZXJJbk1zID0gTWF0aC5yb3VuZCgocmVwb3J0LmF2ZXJhZ2VKaXR0ZXJJbk1zIC8gc3RyZWFtcy5sZW5ndGgpICogMTAwMCk7XG4gICAgICAgIHJlcG9ydC5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgPSBNYXRoLnJvdW5kKChyZXBvcnQuYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zIC8gc3RyZWFtcy5sZW5ndGgpICogMTAwMCk7XG4gICAgfVxuICAgIGNvbnN0IHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uID0gW1xuICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlYXNvbnMuaGFzKCdjcHUnKSAmJiAnY3B1JyxcbiAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb25zLmhhcygnYmFuZHdpZHRoJykgJiYgJ2JhbmR3aWR0aCcsXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29ucy5oYXMoJ290aGVyJykgJiYgJ290aGVyJyxcbiAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgaWYgKHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uKSB7XG4gICAgICAgIHJlcG9ydC5xdWFsaXR5TGltaXRhdGlvblJlYXNvbnMgPSBxdWFsaXR5TGltaXRhdGlvblJlYXNvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG4vKipcbiAqIEZsYXR0ZW4gdGhlIHN0YXRzIHJlcG9ydCBpbnRvIGFuIGFycmF5IG9mIHN0YXRzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHJlcG9ydCB0aGUgcmVwb3J0IHRvIGZsYXR0ZW4uXG4gKi9cbmNvbnN0IGZsYXR0ZW4kMSA9IChyZXBvcnQpID0+IHtcbiAgICBjb25zdCBzdGF0cyA9IFtdO1xuICAgIHJlcG9ydC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHN0YXRzLnB1c2gocyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRzO1xufTtcblxuY29uc3QgREVGQVVMVF9USFJFU0hPTEQgPSAwLjM1O1xuY2xhc3MgVmlld3BvcnRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICAvLyBpbiBSZWFjdCBjaGlsZHJlbiByZW5kZXIgYmVmb3JlIHZpZXdwb3J0IGlzIHNldCwgYWRkXG4gICAgICAgIC8vIHRoZW0gdG8gdGhlIHF1ZXVlIGFuZCBvYnNlcnZlIHRoZW0gb25jZSB0aGUgb2JzZXJ2ZXIgaXMgcmVhZHlcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnF1ZXVlU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHNldCBzY3JvbGxhYmxlIHZpZXdwb3J0IGFzIHJvb3QgZm9yIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciwgcmV0dXJuc1xuICAgICAgICAgKiBjbGVhbnVwIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgdXBvbiBkaXNwb3Npbmcgb2YgdGhlIERPTSBlbGVtZW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWV3cG9ydEVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMgVW5vYnNlcnZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0ID0gKHZpZXdwb3J0RWxlbWVudCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50SGFuZGxlck1hcC5jbGVhcigpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyPy4oZW50cnkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHZpZXdwb3J0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogb3B0aW9ucz8udGhyZXNob2xkID8/IERFRkFVTFRfVEhSRVNIT0xELFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWV1ZVNldC5zaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVNldC5mb3JFYWNoKChbcXVldWVFbGVtZW50LCBxdWV1ZUhhbmRsZXJdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGVsZW1lbnQgd2hpY2ggcmVxdWVzdGVkIG9ic2VydmF0aW9uIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgb2YgYSB2aWV3cG9ydCBlbGVtZW50LCBza2lwIGlmIGlzbid0XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld3BvcnRFbGVtZW50LmNvbnRhaW5zKHF1ZXVlRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShxdWV1ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLnNldChxdWV1ZUVsZW1lbnQsIHF1ZXVlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVNldC5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gc2V0IGVsZW1lbnQgdG8gb2JzZXJ2ZSBhbmQgaGFuZGxlciB0byBiZSB0cmlnZ2VyZWQgd2hlbmV2ZXIgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgICogZGV0ZWN0cyBhIHBvc3NpYmxlIGNoYW5nZSBpbiBlbGVtZW50J3MgdmlzaWJpbGl0eSB3aXRoaW4gc3BlY2lmaWVkIHZpZXdwb3J0LCByZXR1cm5zXG4gICAgICAgICAqIGNsZWFudXAgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB1cG9uIGRpc3Bvc2luZyBvZiB0aGUgRE9NIGVsZW1lbnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIGhhbmRsZXJcbiAgICAgICAgICogQHJldHVybnMgVW5vYnNlcnZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9ic2VydmUgPSAoZWxlbWVudCwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVldWVJdGVtID0gW2VsZW1lbnQsIGhhbmRsZXJdO1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRIYW5kbGVyTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyPy51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVNldC5kZWxldGUocXVldWVJdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50SGFuZGxlck1hcC5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgICAgICAgICBpZiAoIXRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlU2V0LmFkZChxdWV1ZUl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIucm9vdC5jb250YWlucyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEhhbmRsZXJNYXAuc2V0KGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIFNhZmFyaS5cbiAqL1xuY29uc3QgaXNTYWZhcmkgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJyk7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIGlzIEZpcmVmb3guXG4gKi9cbmNvbnN0IGlzRmlyZWZveCA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudD8uaW5jbHVkZXMoJ0ZpcmVmb3gnKTtcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgR29vZ2xlIENocm9tZS5cbiAqL1xuY29uc3QgaXNDaHJvbWUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ/LmluY2x1ZGVzKCdDaHJvbWUnKTtcbn07XG5cbnZhciBicm93c2VycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgaXNDaHJvbWU6IGlzQ2hyb21lLFxuICAgIGlzRmlyZWZveDogaXNGaXJlZm94LFxuICAgIGlzU2FmYXJpOiBpc1NhZmFyaVxufSk7XG5cbmNvbnN0IERFRkFVTFRfVklFV1BPUlRfVklTSUJJTElUWV9TVEFURSA9IHtcbiAgICB2aWRlb1RyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICBzY3JlZW5TaGFyZVRyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbn07XG4vKipcbiAqIEEgbWFuYWdlciBjbGFzcyB0aGF0IGhhbmRsZXMgZHluYXNjYWxlIHJlbGF0ZWQgdGFza3MgbGlrZTpcbiAqXG4gKiAtIGJpbmRpbmcgdmlkZW8gZWxlbWVudHMgdG8gc2Vzc2lvbiBpZHNcbiAqIC0gYmluZGluZyBhdWRpbyBlbGVtZW50cyB0byBzZXNzaW9uIGlkc1xuICogLSB0cmFja2luZyBlbGVtZW50IHZpc2liaWxpdHlcbiAqIC0gdXBkYXRpbmcgc3Vic2NyaXB0aW9ucyBiYXNlZCBvbiB2aWV3cG9ydCB2aXNpYmlsaXR5XG4gKiAtIHVwZGF0aW5nIHN1YnNjcmlwdGlvbnMgYmFzZWQgb24gdmlkZW8gZWxlbWVudCBkaW1lbnNpb25zXG4gKiAtIHVwZGF0aW5nIHN1YnNjcmlwdGlvbnMgYmFzZWQgb24gcHVibGlzaGVkIHRyYWNrc1xuICovXG5jbGFzcyBEeW5hc2NhbGVNYW5hZ2VyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IER5bmFzY2FsZU1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbCB0aGUgY2FsbCB0byBtYW5hZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FsbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZpZXdwb3J0IHRyYWNrZXIgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdwb3J0VHJhY2tlciA9IG5ldyBWaWV3cG9ydFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydEeW5hc2NhbGVNYW5hZ2VyJ10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBiZWdpbiB0cmFja2luZyB0aGUgZ2l2ZW4gZWxlbWVudCBmb3IgdmlzaWJpbGl0eSBjaGFuZ2VzIHdpdGhpbiB0aGVcbiAgICAgICAgICogY29uZmlndXJlZCB2aWV3cG9ydCBlbGVtZW50IChgY2FsbC5zZXRWaWV3cG9ydGApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byB0cmFjay5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiB2aWRlby5cbiAgICAgICAgICogQHJldHVybnMgVW50cmFjay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50VmlzaWJpbGl0eSA9IChlbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xlYW51cCA9IHRoaXMudmlld3BvcnRUcmFja2VyLm9ic2VydmUoZWxlbWVudCwgKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwgKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmlzaWJpbGl0eVN0YXRlID0gcGFydGljaXBhbnQudmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfVklFV1BPUlRfVklTSUJJTElUWV9TVEFURTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2JzZXJ2ZXIgdHJpZ2dlcnMgd2hlbiB0aGUgZWxlbWVudCBpcyBcIm1vdmVkXCIgdG8gYmUgYSBmdWxsc2NyZWVuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBpdCBWSVNJQkxFIGlmIHRoYXQgaGFwcGVucyB0byBwcmV2ZW50IGZ1bGxzY3JlZW4gd2l0aCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCA9PT0gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBWaXNpYmlsaXR5U3RhdGUuVklTSUJMRVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByZXZpb3VzVmlzaWJpbGl0eVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0cmFja1R5cGVdOiBpc1Zpc2libGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCB2aXNpYmlsaXR5IHN0YXRlIHRvIFVOS05PV04gdXBvbiBjbGVhbnVwXG4gICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgbGF5b3V0cyB0aGF0IGFyZSBub3QgYWN0aXZlbHkgb2JzZXJ2ZWRcbiAgICAgICAgICAgICAgICAvLyBjYW4gc3RpbGwgZnVuY3Rpb24gbm9ybWFsbHkgKHJ1bnRpbWUgbGF5b3V0IHN3aXRjaGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwuc3RhdGUudXBkYXRlUGFydGljaXBhbnQoc2Vzc2lvbklkLCAocGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWaXNpYmlsaXR5U3RhdGUgPSBwYXJ0aWNpcGFudC52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9WSUVXUE9SVF9WSVNJQklMSVRZX1NUQVRFO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByZXZpb3VzVmlzaWJpbGl0eVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0cmFja1R5cGVdOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdmlld3BvcnQgZWxlbWVudCB0byB0cmFjayBib3VuZCB2aWRlbyBlbGVtZW50cyBmb3IgdmlzaWJpbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIHZpZXdwb3J0IGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0ID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0VHJhY2tlci5zZXRWaWV3cG9ydChlbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIGEgRE9NIDx2aWRlbz4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGUgdmlkZW8gZWxlbWVudCB3aWxsIHBsYXlcbiAgICAgICAgICogdGhlIGNvcnJlY3QgdmlkZW8gc3RyZWFtIGZvciB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVW5kZXIgdGhlIGhvb2QsIGl0IHdvdWxkIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgdmlkZW8gZWxlbWVudCBkaW1lbnNpb25zXG4gICAgICAgICAqIGFuZCB1cGRhdGUgdGhlIHN1YnNjcmlwdGlvbiBhY2NvcmRpbmdseSBpbiBvcmRlciB0byBvcHRpbWl6ZSB0aGUgYmFuZHdpZHRoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIFwidmlld3BvcnRcIiBpcyBjb25maWd1cmVkLCB0aGUgdmlkZW8gZWxlbWVudCB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogdHJhY2tlZCBmb3IgdmlzaWJpbGl0eSBhbmQgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnQgdGhlIHZpZGVvIGVsZW1lbnQgdG8gYmluZCB0by5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiB2aWRlby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZFZpZGVvRWxlbWVudCA9ICh2aWRlb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3VuZFBhcnRpY2lwYW50ID0gdGhpcy5jYWxsLnN0YXRlLmZpbmRQYXJ0aWNpcGFudEJ5U2Vzc2lvbklkKHNlc3Npb25JZCk7XG4gICAgICAgICAgICBpZiAoIWJvdW5kUGFydGljaXBhbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMgPSAoZGVib3VuY2VUeXBlLCBkaW1lbnNpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9uICYmIChkaW1lbnNpb24ud2lkdGggPT09IDAgfHwgZGltZW5zaW9uLmhlaWdodCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDB4MCBkaW1lbnNpb25zLiB0aGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdmlkZW8gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdmlzaWJsZSAoZS5nLiwgaGFzIGRpc3BsYXk6IG5vbmUpLlxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0cmVhdCB0aGlzIGFzIFwidW5zdWJzY3JpcHRpb25cIiBhcyB3ZSBkb24ndCB3YW50IHRvIGtlZXBcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3VtaW5nIGJhbmR3aWR0aCBmb3IgYSB2aWRlbyB0aGF0IGlzIG5vdCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBJZ25vcmluZyAweDAgZGltZW5zaW9uYCwgYm91bmRQYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsLnVwZGF0ZVN1YnNjcmlwdGlvbnNQYXJ0aWFsKHRyYWNrVHlwZSwgeyBbc2Vzc2lvbklkXTogeyBkaW1lbnNpb24gfSB9LCBkZWJvdW5jZVR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50JCA9IHRoaXMuY2FsbC5zdGF0ZS5wYXJ0aWNpcGFudHMkLnBpcGUobWFwJDEoKHBhcnRpY2lwYW50cykgPT4gcGFydGljaXBhbnRzLmZpbmQoKHBhcnRpY2lwYW50KSA9PiBwYXJ0aWNpcGFudC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkpLCB0YWtlV2hpbGUoKHBhcnRpY2lwYW50KSA9PiAhIXBhcnRpY2lwYW50KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgc2hhcmVSZXBsYXkoeyBidWZmZXJTaXplOiAxLCByZWZDb3VudDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNpbmNlIHRoZSB2aWRlbyBlbGVtZW50cyBhcmUgbm93IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgRE9NIChSZWFjdCBTREspIHVwb25cbiAgICAgICAgICAgICAqIHZpc2liaWxpdHkgY2hhbmdlLCB0aGlzIHN1YnNjcmlwdGlvbiBpcyBub3QgaW4gdXNlIGFuIHN0YXlzIGhlcmUgb25seSBmb3IgdGhlXG4gICAgICAgICAgICAgKiBwbGFpbiBKUyBpbnRlZ3JhdGlvbnMgd2hlcmUgaW50ZWdyYXRvcnMgbWlnaHQgY2hvb3NlIG5vdCB0byByZW1vdmUgdGhlIHZpZGVvXG4gICAgICAgICAgICAgKiBlbGVtZW50cyBmcm9tIHRoZSBET00uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIGtlZXAgY29weSBmb3IgcmVzaXplIG9ic2VydmVyIGhhbmRsZXJcbiAgICAgICAgICAgIGxldCB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlU3Vic2NyaXB0aW9uID0gYm91bmRQYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHBhcnRpY2lwYW50JFxuICAgICAgICAgICAgICAgICAgICAucGlwZShtYXAkMSgocCkgPT4gcC52aWV3cG9ydFZpc2liaWxpdHlTdGF0ZT8uW3RyYWNrVHlwZV0pLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChuZXh0Vmlld3BvcnRWaXNpYmlsaXR5U3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpbml0aWFsIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRWaWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA/PyBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Vmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPz8gVmlzaWJpbGl0eVN0YXRlLlVOS05PV047XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Vmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPT09IFZpc2liaWxpdHlTdGF0ZS5JTlZJU0lCTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0VHJhY2tXaXRoRGltZW5zaW9ucyhEZWJvdW5jZVR5cGUuTUVESVVNLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5NRURJVU0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB2aWRlb0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZGVvRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGxhc3REaW1lbnNpb25zO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBib3VuZFBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudERpbWVuc2lvbnMgPSBgJHt2aWRlb0VsZW1lbnQuY2xpZW50V2lkdGh9LCR7dmlkZW9FbGVtZW50LmNsaWVudEhlaWdodH1gO1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGluaXRpYWwgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3REaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RGltZW5zaW9ucyA9IGN1cnJlbnREaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RGltZW5zaW9ucyA9PT0gY3VycmVudERpbWVuc2lvbnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlID09PSBWaXNpYmlsaXR5U3RhdGUuSU5WSVNJQkxFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLlNMT1csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB2aWRlb0VsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZGVvRWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0RGltZW5zaW9ucyA9IGN1cnJlbnREaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/Lm9ic2VydmUodmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgcmVuZGVycyBhbmQgZ2V0cyBib3VuZCAtIHRyYWNrIHN1YnNjcmlwdGlvbiBnZXRzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgZmlyc3Qgb3RoZXIgb25lcyBnZXQgc2tpcHBlZCBvbiBpbml0aWFsIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHB1Ymxpc2hlZFRyYWNrc1N1YnNjcmlwdGlvbiA9IGJvdW5kUGFydGljaXBhbnQuaXNMb2NhbFBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBwYXJ0aWNpcGFudCRcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ3B1Ymxpc2hlZFRyYWNrcycpLCBtYXAkMSgocCkgPT4gcC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXModHJhY2tUeXBlID09PSAndmlkZW9UcmFjaydcbiAgICAgICAgICAgICAgICAgICAgPyBUcmFja1R5cGUuVklERU9cbiAgICAgICAgICAgICAgICAgICAgOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFKSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKGlzUHVibGlzaGluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQdWJsaXNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGFydGljaXBhbnQganVzdCBzdGFydGVkIHRvIHB1Ymxpc2ggYSB0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRyYWNrV2l0aERpbWVuc2lvbnMoRGVib3VuY2VUeXBlLkZBU1QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlkZW9FbGVtZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdmlkZW9FbGVtZW50LmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50IGp1c3Qgc3RvcHBlZCBwdWJsaXNoaW5nIGEgdHJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5GQVNULCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgbWFya2luZyB0aGUgZWxlbWVudCBhcyBtdXRlZCB3aWxsIGFsbG93IGF1dG9wbGF5IHRvIHdvcmtcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgcHJpb3IgdXNlciBpbnRlcmFjdGlvbjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL01lZGlhL0F1dG9wbGF5X2d1aWRlXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtU3Vic2NyaXB0aW9uID0gcGFydGljaXBhbnQkXG4gICAgICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbEtleUNoYW5nZWQodHJhY2tUeXBlID09PSAndmlkZW9UcmFjaycgPyAndmlkZW9TdHJlYW0nIDogJ3NjcmVlblNoYXJlU3RyZWFtJykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snID8gcC52aWRlb1N0cmVhbSA6IHAuc2NyZWVuU2hhcmVTdHJlYW07XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPT09IHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzb3VyY2UgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNTYWZhcmkoKSB8fCBpc0ZpcmVmb3goKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzb3VyY2UgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5wbGF5KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBGYWlsZWQgdG8gcGxheSBzdHJlYW1gLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWRkIGV4dHJhIGRlbGF5IHVudGlsIHdlIGF0dGVtcHQgdG8gZm9yY2UtcGxheVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhcnRpY2lwYW50J3MgbWVkaWEgc3RyZWFtIGluIEZpcmVmb3ggYW5kIFNhZmFyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZXkgc2VlbSB0byBoYXZlIHNvbWUgdGltaW5nIGlzc3Vlc1xuICAgICAgICAgICAgICAgICAgICB9LCAyNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zKERlYm91bmNlVHlwZS5GQVNULCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hlZFRyYWNrc1N1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBzdHJlYW1TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRzIGEgRE9NIDxhdWRpbz4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGUgYXVkaW8gZWxlbWVudCB3aWxsXG4gICAgICAgICAqIHBsYXkgdGhlIGNvcnJlY3QgYXVkaW8gc3RyZWFtIGZvciB0aGUgZ2l2ZW4gc2Vzc2lvbiBpZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGF1ZGlvRWxlbWVudCB0aGUgYXVkaW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIGF1ZGlvLlxuICAgICAgICAgKiBAcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCB3aWxsIHVuYmluZCB0aGUgYXVkaW8gZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZEF1ZGlvRWxlbWVudCA9IChhdWRpb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuY2FsbC5zdGF0ZS5maW5kUGFydGljaXBhbnRCeVNlc3Npb25JZChzZXNzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNpcGFudCB8fCBwYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcGFydGljaXBhbnQkID0gdGhpcy5jYWxsLnN0YXRlLnBhcnRpY2lwYW50cyQucGlwZShtYXAkMSgocGFydGljaXBhbnRzKSA9PiBwYXJ0aWNpcGFudHMuZmluZCgocCkgPT4gcC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkpLCB0YWtlV2hpbGUoKHApID0+ICEhcCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlTWVkaWFTdHJlYW1TdWJzY3JpcHRpb24gPSBwYXJ0aWNpcGFudCRcbiAgICAgICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCh0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZUF1ZGlvVHJhY2snXG4gICAgICAgICAgICAgICAgPyAnc2NyZWVuU2hhcmVBdWRpb1N0cmVhbSdcbiAgICAgICAgICAgICAgICA6ICdhdWRpb1N0cmVhbScpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSB0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZUF1ZGlvVHJhY2snXG4gICAgICAgICAgICAgICAgICAgID8gcC5zY3JlZW5TaGFyZUF1ZGlvU3RyZWFtXG4gICAgICAgICAgICAgICAgICAgIDogcC5hdWRpb1N0cmVhbTtcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9FbGVtZW50LnNyY09iamVjdCA9PT0gc291cmNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudC5zcmNPYmplY3QgPSBzb3VyY2UgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudC5zcmNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvRWxlbWVudC5wbGF5KCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGBGYWlsZWQgdG8gcGxheSBzdHJlYW1gLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXVkaW8gb3V0cHV0IGRldmljZSBzaGFsbCBiZSBzZXQgYWZ0ZXIgdGhlIGF1ZGlvIGVsZW1lbnQgaXMgcGxheWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHRoZSBicm93c2VyIHdpbGwgbm90IHBpY2sgaXQgdXAsIGFuZCB3aWxsIGFsd2F5c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxheSBhdWRpbyB0aHJvdWdoIHRoZSBzeXN0ZW0ncyBkZWZhdWx0IGRldmljZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZERldmljZSB9ID0gdGhpcy5jYWxsLnNwZWFrZXIuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWREZXZpY2UgJiYgJ3NldFNpbmtJZCcgaW4gYXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgbGliXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnNldFNpbmtJZChzZWxlY3RlZERldmljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2lua0lkU3Vic2NyaXB0aW9uID0gISgnc2V0U2lua0lkJyBpbiBhdWRpb0VsZW1lbnQpXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNhbGwuc3BlYWtlci5zdGF0ZS5zZWxlY3RlZERldmljZSQuc3Vic2NyaWJlKChkZXZpY2VJZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igc2V0U2lua0lkIGlzIG5vdCB5ZXQgaW4gdGhlIGxpYlxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9FbGVtZW50LnNldFNpbmtJZChkZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZvbHVtZVN1YnNjcmlwdGlvbiA9IHRoaXMuY2FsbC5zcGVha2VyLnN0YXRlLnZvbHVtZSQuc3Vic2NyaWJlKCh2b2x1bWUpID0+IHtcbiAgICAgICAgICAgICAgICBhdWRpb0VsZW1lbnQudm9sdW1lID0gdm9sdW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdWRpb0VsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBzaW5rSWRTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdm9sdW1lU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlTWVkaWFTdHJlYW1TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0b3JlcyB0aGUgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50IHVzZXIgYW5kIGV4cG9zZXNcbiAqIGEgZmV3IGhlbHBlciBtZXRob2RzIHdoaWNoIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBwZXJtaXNzaW9ucy5cbiAqXG4gKiBUaGlzIGlzIGFuIGludGVybmFsIGNsYXNzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aFxuICogYSB7QGxpbmsgQ2FsbH0gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBlcm1pc3Npb25zQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGVybWlzc2lvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnMgdGhlIHBlcm1pc3Npb25zIHRvIHNldC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0UGVybWlzc2lvbnMgPSAocGVybWlzc2lvbnMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucyB8fCBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHNldHRpbmdzIGZvciB0aGUgYm91bmQgY2FsbC5cbiAgICAgICAgICogQHBhcmFtIHNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldENhbGxTZXR0aW5ncyA9IChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHVzZXIgaGFzIGEgc3BlY2lmaWMgcGVybWlzc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb24gdGhlIHBlcm1pc3Npb24gdG8gY2hlY2sgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNQZXJtaXNzaW9uID0gKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zLmluY2x1ZGVzKHBlcm1pc3Npb24pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHVzZXIgY2FuIHJlcXVlc3QgYSBzcGVjaWZpYyBwZXJtaXNzaW9uXG4gICAgICAgICAqIHdpdGhpbiB0aGUgY2FsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb24gdGhlIHBlcm1pc3Npb24gdG8gY2hlY2sgZm9yLlxuICAgICAgICAgKiBAcGFyYW0gc2V0dGluZ3MgdGhlIGNhbGwgc2V0dGluZ3MgdG8gY2hlY2sgYWdhaW5zdCAob3B0aW9uYWwpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5SZXF1ZXN0ID0gKHBlcm1pc3Npb24sIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB7IGF1ZGlvLCB2aWRlbywgc2NyZWVuc2hhcmluZyB9ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICBzd2l0Y2ggKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0VORF9BVURJTzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvLmFjY2Vzc19yZXF1ZXN0X2VuYWJsZWQ7XG4gICAgICAgICAgICAgICAgY2FzZSBPd25DYXBhYmlsaXR5LlNFTkRfVklERU86XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby5hY2Nlc3NfcmVxdWVzdF9lbmFibGVkO1xuICAgICAgICAgICAgICAgIGNhc2UgT3duQ2FwYWJpbGl0eS5TQ1JFRU5TSEFSRTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmVlbnNoYXJpbmcuYWNjZXNzX3JlcXVlc3RfZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjYWxsIHR5cGUuXG4gKi9cbmNsYXNzIENhbGxUeXBlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENhbGxUeXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGNhbGwgdHlwZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIGNhbGwgdHlwZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb25zID0ge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGRlZmF1bHRTb3J0UHJlc2V0LFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG59XG4vKipcbiAqIEEgcmVnaXN0cnkgb2Yge0BsaW5rIENhbGxUeXBlfXMuXG4gKiBZb3UgY2FuIHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIGNhbGwgdHlwZXMuXG4gKi9cbmNsYXNzIENhbGxUeXBlc1JlZ2lzdHJ5IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENhbGxUeXBlc1JlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxUeXBlcyB0aGUgaW5pdGlhbCBjYWxsIHR5cGVzIHRvIHJlZ2lzdGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbGxUeXBlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXJzIGEgbmV3IGNhbGwgdHlwZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGxUeXBlIHRoZSBjYWxsIHR5cGUgdG8gcmVnaXN0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZ2lzdGVyID0gKGNhbGxUeXBlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUeXBlc1tjYWxsVHlwZS5uYW1lXSA9IGNhbGxUeXBlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlcnMgYSBjYWxsIHR5cGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBjYWxsIHR5cGUgdG8gdW5yZWdpc3Rlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5yZWdpc3RlciA9IChuYW1lKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWxsVHlwZXNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGEgY2FsbCB0eXBlIGJ5IG5hbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBjYWxsIHR5cGUgdG8gZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXQgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxUeXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIobmV3IENhbGxUeXBlKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxUeXBlc1tuYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYWxsVHlwZXMgPSBjYWxsVHlwZXMucmVkdWNlKChhY2MsIGNhbGxUeXBlKSA9PiB7XG4gICAgICAgICAgICBhY2NbY2FsbFR5cGUubmFtZV0gPSBjYWxsVHlwZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGNhbGwgdHlwZXMgcmVnaXN0cnkuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGluc3RhbmNlIHRvIGR5bmFtaWNhbGx5IHJlZ2lzdGVyIGFuZCB1bnJlZ2lzdGVyIGNhbGwgdHlwZXMuXG4gKi9cbmNvbnN0IENhbGxUeXBlcyA9IG5ldyBDYWxsVHlwZXNSZWdpc3RyeShbXG4gICAgbmV3IENhbGxUeXBlKCdkZWZhdWx0Jywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGRlZmF1bHRTb3J0UHJlc2V0LFxuICAgIH0pLFxuICAgIG5ldyBDYWxsVHlwZSgnZGV2ZWxvcG1lbnQnLCB7XG4gICAgICAgIHNvcnRQYXJ0aWNpcGFudHNCeTogZGVmYXVsdFNvcnRQcmVzZXQsXG4gICAgfSksXG4gICAgbmV3IENhbGxUeXBlKCdsaXZlc3RyZWFtJywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQsXG4gICAgfSksXG4gICAgbmV3IENhbGxUeXBlKCdhdWRpb19yb29tJywge1xuICAgICAgICBzb3J0UGFydGljaXBhbnRzQnk6IGxpdmVzdHJlYW1PckF1ZGlvUm9vbVNvcnRQcmVzZXQsXG4gICAgfSksXG5dKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgZGV2aWNlc1xuICogdGhhdCBtZWV0IHRoZSBnaXZlbiBjb25zdHJhaW50cy5cbiAqXG4gKiBAcGFyYW0gY29uc3RyYWludHMgdGhlIGNvbnN0cmFpbnRzIHRvIHVzZSB3aGVuIHJlcXVlc3RpbmcgdGhlIGRldmljZXMuXG4gKiBAcGFyYW0ga2luZCB0aGUga2luZCBvZiBkZXZpY2VzIHRvIGVudW1lcmF0ZS5cbiAqL1xuY29uc3QgZ2V0RGV2aWNlcyA9IChjb25zdHJhaW50cywga2luZCkgPT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICBjb25zdCBlbnVtZXJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgLy8gc29tZSBicm93c2VycyByZXBvcnQgZW1wdHkgZGV2aWNlIGxhYmVscyAoRmlyZWZveCkuXG4gICAgICAgICAgICAvLyBpbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gcmVxdWVzdCBwZXJtaXNzaW9ucyAodmlhIGdldFVzZXJNZWRpYSlcbiAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gZ2V0IHRoZSBkZXZpY2UgbGFiZWxzXG4gICAgICAgICAgICBjb25zdCBuZWVkc0dldFVzZXJNZWRpYSA9IGRldmljZXMuc29tZSgoZGV2aWNlKSA9PiBkZXZpY2Uua2luZCA9PT0ga2luZCAmJiBkZXZpY2UubGFiZWwgPT09ICcnKTtcbiAgICAgICAgICAgIGlmIChuZWVkc0dldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgICAgIGxldCBtZWRpYVN0cmVhbTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhU3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZU9mTWVkaWFTdHJlYW0obWVkaWFTdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VzO1xuICAgICAgICB9O1xuICAgICAgICBlbnVtZXJhdGUoKVxuICAgICAgICAgICAgLnRoZW4oKGRldmljZXMpID0+IHtcbiAgICAgICAgICAgIC8vIG5vdGlmeSBzdWJzY3JpYmVycyBhbmQgY29tcGxldGVcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChkZXZpY2VzKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcihbJ2RldmljZXMnXSk7XG4gICAgICAgICAgICBsb2dnZXIoJ2Vycm9yJywgJ0ZhaWxlZCB0byBlbnVtZXJhdGUgZGV2aWNlcycsIGVycm9yKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFtUZWxscyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBvdXRwdXQgY2hhbmdlIG9uICdhdWRpbycgZWxlbWVudHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCkuXG4gKlxuICogICovXG5jb25zdCBjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcbiAgICByZXR1cm4gJ3NldFNpbmtJZCcgaW4gZWxlbWVudDtcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIHVzZWQgdG8gcmVxdWVzdCBhdWRpbyBkZXZpY2VzLlxuICovXG5jb25zdCBhdWRpb0RldmljZUNvbnN0cmFpbnRzID0ge1xuICAgIGF1ZGlvOiB7XG4gICAgICAgIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbiAgICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICB9LFxufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgY29uc3RyYWludHMgdXNlZCB0byByZXF1ZXN0IHZpZGVvIGRldmljZXMuXG4gKi9cbmNvbnN0IHZpZGVvRGV2aWNlQ29uc3RyYWludHMgPSB7XG4gICAgdmlkZW86IHtcbiAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgIGhlaWdodDogNzIwLFxuICAgIH0sXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbWVtb2l6ZWQgb2JzZXJ2YWJsZSBpbnN0YW5jZVxuICogdGhhdCB3aWxsIGJlIGNyZWF0ZWQgb25seSBvbmNlIGFuZCBzaGFyZWQgYmV0d2VlbiBhbGwgY2FsbGVycy5cbiAqXG4gKiBAcGFyYW0gY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIE9ic2VydmFibGUuXG4gKi9cbmNvbnN0IG1lbW9pemVkT2JzZXJ2YWJsZSA9IChjcmVhdGUpID0+IHtcbiAgICBsZXQgbWVtb2l6ZWQ7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFtZW1vaXplZClcbiAgICAgICAgICAgIG1lbW9pemVkID0gY3JlYXRlKCk7XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xufTtcbmNvbnN0IGdldERldmljZUNoYW5nZU9ic2VydmVyID0gbWVtb2l6ZWRPYnNlcnZhYmxlKCgpID0+IHtcbiAgICAvLyBBdWRpbyBhbmQgdmlkZW8gZGV2aWNlcyBhcmUgcmVxdWVzdGVkIGluIHR3byBzZXBhcmF0ZSByZXF1ZXN0cy5cbiAgICAvLyBUaGF0IHdheSwgdXNlcnMgd2lsbCBiZSBwcmVzZW50ZWQgd2l0aCB0d28gc2VwYXJhdGUgcHJvbXB0c1xuICAgIC8vIC0+IHRoZXkgY2FuIGdpdmUgYWNjZXNzIHRvIGp1c3QgY2FtZXJhLCBvciBqdXN0IG1pY3JvcGhvbmVcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgLy8gJ2FkZEV2ZW50TGlzdGVuZXInIGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgTmF0aXZlXG4gICAgICAgIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBub3RpZnkgPSAoKSA9PiBzdWJzY3JpYmVyLm5leHQoKTtcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICB9O1xuICAgIH0pLnBpcGUoZGVib3VuY2VUaW1lKDUwMCksIGNvbmNhdE1hcCgoKSA9PiBmcm9tKG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpKSksIHNoYXJlUmVwbGF5KDEpKTtcbn0pO1xuY29uc3QgZ2V0QXVkaW9EZXZpY2VzT2JzZXJ2ZXIgPSBtZW1vaXplZE9ic2VydmFibGUoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZShnZXREZXZpY2VzKGF1ZGlvRGV2aWNlQ29uc3RyYWludHMsICdhdWRpb2lucHV0JyksIGdldERldmljZUNoYW5nZU9ic2VydmVyKCkpLnBpcGUoc2hhcmVSZXBsYXkoMSkpO1xufSk7XG5jb25zdCBnZXRBdWRpb091dHB1dERldmljZXNPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlKGdldERldmljZXMoYXVkaW9EZXZpY2VDb25zdHJhaW50cywgJ2F1ZGlvb3V0cHV0JyksIGdldERldmljZUNoYW5nZU9ic2VydmVyKCkpLnBpcGUoc2hhcmVSZXBsYXkoMSkpO1xufSk7XG5jb25zdCBnZXRWaWRlb0RldmljZXNPYnNlcnZlciA9IG1lbW9pemVkT2JzZXJ2YWJsZSgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlKGdldERldmljZXModmlkZW9EZXZpY2VDb25zdHJhaW50cywgJ3ZpZGVvaW5wdXQnKSwgZ2V0RGV2aWNlQ2hhbmdlT2JzZXJ2ZXIoKSkucGlwZShzaGFyZVJlcGxheSgxKSk7XG59KTtcbi8qKlxuICogUHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHVzZSBhdWRpbyBkZXZpY2VzIChpZiBub3QgYWxyZWFkeSBncmFudGVkKSBhbmQgbGlzdHMgdGhlIGF2YWlsYWJsZSAnYXVkaW9pbnB1dCcgZGV2aWNlcywgaWYgZGV2aWNlcyBhcmUgYWRkZWQvcmVtb3ZlZCB0aGUgbGlzdCBpcyB1cGRhdGVkLlxuICovXG5jb25zdCBnZXRBdWRpb0RldmljZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldEF1ZGlvRGV2aWNlc09ic2VydmVyKCkucGlwZShtYXAkMSgodmFsdWVzKSA9PiB2YWx1ZXMuZmlsdGVyKChkKSA9PiBkLmtpbmQgPT09ICdhdWRpb2lucHV0JykpKTtcbn07XG4vKipcbiAqIFByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgdmlkZW8gZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZCkgYW5kIGxpc3RzIHRoZSBhdmFpbGFibGUgJ3ZpZGVvaW5wdXQnIGRldmljZXMsIGlmIGRldmljZXMgYXJlIGFkZGVkL3JlbW92ZWQgdGhlIGxpc3QgaXMgdXBkYXRlZC5cbiAqL1xuY29uc3QgZ2V0VmlkZW9EZXZpY2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBnZXRWaWRlb0RldmljZXNPYnNlcnZlcigpLnBpcGUobWFwJDEoKHZhbHVlcykgPT4gdmFsdWVzLmZpbHRlcigoZCkgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpKSk7XG59O1xuLyoqXG4gKiBQcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGF1ZGlvIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpIGFuZCBsaXN0cyB0aGUgYXZhaWxhYmxlICdhdWRpb291dHB1dCcgZGV2aWNlcywgaWYgZGV2aWNlcyBhcmUgYWRkZWQvcmVtb3ZlZCB0aGUgbGlzdCBpcyB1cGRhdGVkLiBTZWxlY3RpbmcgJ2F1ZGlvb3V0cHV0JyBkZXZpY2Ugb25seSBtYWtlcyBzZW5zZSBpZiBbdGhlIGJyb3dzZXIgaGFzIHN1cHBvcnQgZm9yIGNoYW5naW5nIGF1ZGlvIG91dHB1dCBvbiAnYXVkaW8nIGVsZW1lbnRzXSgjY2hlY2tpZmF1ZGlvb3V0cHV0Y2hhbmdlc3VwcG9ydGVkKVxuICovXG5jb25zdCBnZXRBdWRpb091dHB1dERldmljZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldEF1ZGlvT3V0cHV0RGV2aWNlc09ic2VydmVyKCkucGlwZShtYXAkMSgodmFsdWVzKSA9PiB2YWx1ZXMuZmlsdGVyKChkKSA9PiBkLmtpbmQgPT09ICdhdWRpb291dHB1dCcpKSk7XG59O1xuY29uc3QgZ2V0U3RyZWFtID0gYXN5bmMgKGNvbnN0cmFpbnRzKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKSgnZXJyb3InLCBgRmFpbGVkIGdldCB1c2VyIG1lZGlhYCwge1xuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludHMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgYW4gYXVkaW8gbWVkaWEgc3RyZWFtIHRoYXQgZnVsZmlsbHMgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICogSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBvbmVzLlxuICpcbiAqIEBhbmd1bGFyIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBbYERldmljZU1hbmFnZXJTZXJ2aWNlYF0oLi9EZXZpY2VNYW5hZ2VyU2VydmljZS5tZCkgZm9yIGEgaGlnaGVyIGxldmVsIEFQSSwgdXNlIHRoaXMgbG93LWxldmVsIG1ldGhvZCBvbmx5IGlmIHRoZSBgRGV2aWNlTWFuYWdlclNlcnZpY2VgIGRvZXNuJ3Qgc3VpdCB5b3VyIHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSB0cmFja0NvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyB0aGUgbmV3IGBNZWRpYVN0cmVhbWAgZnVsZmlsbGluZyB0aGUgZ2l2ZW4gY29uc3RyYWludHMuXG4gKi9cbmNvbnN0IGdldEF1ZGlvU3RyZWFtID0gYXN5bmMgKHRyYWNrQ29uc3RyYWludHMpID0+IHtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgIC4uLmF1ZGlvRGV2aWNlQ29uc3RyYWludHMuYXVkaW8sXG4gICAgICAgICAgICAuLi50cmFja0NvbnN0cmFpbnRzLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGdldFN0cmVhbShjb25zdHJhaW50cyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgdmlkZW8gbWVkaWEgc3RyZWFtIHRoYXQgZnVsZmlsbHMgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICogSWYgbm8gY29uc3RyYWludHMgYXJlIHByb3ZpZGVkLCBpdCB1c2VzIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBvbmVzLlxuICpcbiAqIEBhbmd1bGFyIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBbYERldmljZU1hbmFnZXJTZXJ2aWNlYF0oLi9EZXZpY2VNYW5hZ2VyU2VydmljZS5tZCkgZm9yIGEgaGlnaGVyIGxldmVsIEFQSSwgdXNlIHRoaXMgbG93LWxldmVsIG1ldGhvZCBvbmx5IGlmIHRoZSBgRGV2aWNlTWFuYWdlclNlcnZpY2VgIGRvZXNuJ3Qgc3VpdCB5b3VyIHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSB0cmFja0NvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byB1c2Ugd2hlbiByZXF1ZXN0aW5nIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyBhIG5ldyBgTWVkaWFTdHJlYW1gIGZ1bGZpbGxpbmcgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLlxuICovXG5jb25zdCBnZXRWaWRlb1N0cmVhbSA9IGFzeW5jICh0cmFja0NvbnN0cmFpbnRzKSA9PiB7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAuLi52aWRlb0RldmljZUNvbnN0cmFpbnRzLnZpZGVvLFxuICAgICAgICAgICAgLi4udHJhY2tDb25zdHJhaW50cyxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRTdHJlYW0oY29uc3RyYWludHMpO1xufTtcbi8qKlxuICogUHJvbXB0cyB0aGUgdXNlciBmb3IgYSBwZXJtaXNzaW9uIHRvIHNoYXJlIGEgc2NyZWVuLlxuICogSWYgdGhlIHVzZXIgZ3JhbnRzIHRoZSBwZXJtaXNzaW9uLCBhIHNjcmVlbiBzaGFyaW5nIHN0cmVhbSBpcyByZXR1cm5lZC4gVGhyb3dzIG90aGVyd2lzZS5cbiAqXG4gKiBUaGUgY2FsbGVycyBvZiB0aGlzIEFQSSBhcmUgcmVzcG9uc2libGUgdG8gaGFuZGxlIHRoZSBwb3NzaWJsZSBlcnJvcnMuXG4gKlxuICogQGFuZ3VsYXIgSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIFtgRGV2aWNlTWFuYWdlclNlcnZpY2VgXSguL0RldmljZU1hbmFnZXJTZXJ2aWNlLm1kKSBmb3IgYSBoaWdoZXIgbGV2ZWwgQVBJLCB1c2UgdGhpcyBsb3ctbGV2ZWwgbWV0aG9kIG9ubHkgaWYgdGhlIGBEZXZpY2VNYW5hZ2VyU2VydmljZWAgZG9lc24ndCBzdWl0IHlvdXIgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIGFueSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgW2BnZXREaXNwbGF5TWVkaWFgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldERpc3BsYXlNZWRpYSkgQVBJLlxuICovXG5jb25zdCBnZXRTY3JlZW5TaGFyZVN0cmVhbSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKHtcbiAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWRlYWw6IDIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlY2hvQ2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvR2FpbkNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5vaXNlU3VwcHJlc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBub3QgcHJlc2VudCBpbiB0eXBlcyB5ZXRcbiAgICAgICAgICAgIHN5c3RlbUF1ZGlvOiAnaW5jbHVkZScsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2V0TG9nZ2VyKFsnZGV2aWNlcyddKSgnZXJyb3InLCAnRmFpbGVkIHRvIGdldCBzY3JlZW4gc2hhcmUgc3RyZWFtJywgZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufTtcbmNvbnN0IGRldmljZUlkcyQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICE9PSAndW5kZWZpbmVkJ1xuICAgID8gbWVtb2l6ZWRPYnNlcnZhYmxlKCgpID0+IG1lcmdlKGZyb20obmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkpLCBnZXREZXZpY2VDaGFuZ2VPYnNlcnZlcigpKS5waXBlKHNoYXJlUmVwbGF5KDEpKSkoKVxuICAgIDogdW5kZWZpbmVkO1xuLyoqXG4gKiBEZWFjdGl2YXRlcyBNZWRpYVN0cmVhbSAoc3RvcHMgYW5kIHJlbW92ZXMgdHJhY2tzKSB0byBiZSBsYXRlciBnYXJiYWdlIGNvbGxlY3RlZFxuICpcbiAqIEBwYXJhbSBzdHJlYW0gTWVkaWFTdHJlYW1cbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuY29uc3QgZGlzcG9zZU9mTWVkaWFTdHJlYW0gPSAoc3RyZWFtKSA9PiB7XG4gICAgaWYgKCFzdHJlYW0uYWN0aXZlKVxuICAgICAgICByZXR1cm47XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICB9KTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlbGVhc2UoKSBpcyBwcmVzZW50IGluIHJlYWN0LW5hdGl2ZS13ZWJydGMgYW5kIG11c3QgYmUgY2FsbGVkIHRvIGRpc3Bvc2UgdGhlIHN0cmVhbVxuICAgIGlmICh0eXBlb2Ygc3RyZWFtLnJlbGVhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBzdHJlYW0ucmVsZWFzZSgpO1xuICAgIH1cbn07XG5cbmNsYXNzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBzdGF0ZSwgdHJhY2tUeXBlKSB7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFja1R5cGUgPSB0cmFja1R5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpZiB0cnVlLCBzdG9wcyB0aGUgbWVkaWEgc3RyZWFtIHdoZW4gY2FsbCBpcyBsZWZ0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BPbkxlYXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzKSA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbYCR7VHJhY2tUeXBlW3RyYWNrVHlwZV0udG9Mb3dlckNhc2UoKX0gbWFuYWdlcmBdKTtcbiAgICAgICAgaWYgKGRldmljZUlkcyQgJiZcbiAgICAgICAgICAgICFpc1JlYWN0TmF0aXZlKCkgJiZcbiAgICAgICAgICAgICh0aGlzLnRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPIHx8IHRoaXMudHJhY2tUeXBlID09PSBUcmFja1R5cGUuVklERU8pKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZE9yUmVwbGFjZWREZXZpY2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGF2YWlsYWJsZSBhdWRpby92aWRlbyBkZXZpY2VzXG4gICAgICpcbiAgICAgKiBOb3RlOiBJdCBwcm9tcHRzIHRoZSB1c2VyIGZvciBhIHBlcm1pc3Npb24gdG8gdXNlIGRldmljZXMgKGlmIG5vdCBhbHJlYWR5IGdyYW50ZWQpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgd2lsbCBiZSB1cGRhdGVkIGlmIGEgZGV2aWNlIGlzIGNvbm5lY3RlZCBvciBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgc3RyZWFtLlxuICAgICAqL1xuICAgIGFzeW5jIGVuYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZW5hYmxlUHJvbWlzZSA9IHRoaXMudW5tdXRlU3RyZWFtKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmVuYWJsZVByb21pc2U7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldFN0YXR1cygnZW5hYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgb3IgcGF1c2VzIHRoZSBzdHJlYW0gYmFzZWQgb24gc3RhdGUuZGlzYWJsZU1vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVN0b3A9ZmFsc2VdIHdoZW4gdHJ1ZSwgc3RvcHMgdGhlIHRyYWNrcyByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZS5kaXNhYmxlTW9kZVxuICAgICAqL1xuICAgIGFzeW5jIGRpc2FibGUoZm9yY2VTdG9wID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wcmV2U3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG4gICAgICAgIGlmICghZm9yY2VTdG9wICYmIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzdG9wVHJhY2tzID0gZm9yY2VTdG9wIHx8IHRoaXMuc3RhdGUuZGlzYWJsZU1vZGUgPT09ICdzdG9wLXRyYWNrcyc7XG4gICAgICAgIHRoaXMuZGlzYWJsZVByb21pc2UgPSB0aGlzLm11dGVTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTdGF0dXMoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHN0YXR1cyB3YXMgcHJldmlvdXNseSBlbmFibGVkLCBpdCB3aWxsIHJlLWVuYWJsZSB0aGUgZGV2aWNlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucHJldlN0YXR1cyA9PT0gJ2VuYWJsZWQnICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY3VycmVudCBkZXZpY2Ugc3RhdHVzIGlzIGRpc2FibGVkLCBpdCB3aWxsIGVuYWJsZSB0aGUgZGV2aWNlLFxuICAgICAqIGVsc2UgaXQgd2lsbCBkaXNhYmxlIGl0LlxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgc2V0IHRoZSBkZWZhdWx0IGNvbnN0cmFpbnRzIGZvciB0aGUgZGV2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnN0cmFpbnRzIHRoZSBjb25zdHJhaW50cyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0RGVmYXVsdENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGVmYXVsdENvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIGRldmljZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBkZXZpY2UgaWQgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdChkZXZpY2VJZCkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldmljZUlkID09PSB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXREZXZpY2UoZGV2aWNlSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgIH1cbiAgICBhc3luYyBhcHBseVNldHRpbmdzVG9TdHJlYW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm11dGVTdHJlYW0oKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudW5tdXRlU3RyZWFtKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHJhY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5tZWRpYVN0cmVhbT8uZ2V0VHJhY2tzKCkgPz8gW107XG4gICAgfVxuICAgIGFzeW5jIG11dGVTdHJlYW0oc3RvcFRyYWNrcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLm1lZGlhU3RyZWFtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgJHtzdG9wVHJhY2tzID8gJ1N0b3BwaW5nJyA6ICdEaXNhYmxpbmcnfSBzdHJlYW1gKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5KT0lORUQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RvcFB1Ymxpc2hTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRlTG9jYWxTdHJlYW0oc3RvcFRyYWNrcyk7XG4gICAgICAgIGNvbnN0IGFsbEVuZGVkID0gdGhpcy5nZXRUcmFja3MoKS5ldmVyeSgodCkgPT4gdC5yZWFkeVN0YXRlID09PSAnZW5kZWQnKTtcbiAgICAgICAgaWYgKGFsbEVuZGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVsZWFzZSgpIGlzIHByZXNlbnQgaW4gcmVhY3QtbmF0aXZlLXdlYnJ0Y1xuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtLnJlbGVhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbGxlZCB0byBkaXNwb3NlIHRoZSBzdHJlYW0gaW4gUk5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1lZGlhU3RyZWFtLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0TWVkaWFTdHJlYW0odW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtdXRlVHJhY2tzKCkge1xuICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJhY2suZW5hYmxlZClcbiAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bm11dGVUcmFja3MoKSB7XG4gICAgICAgIHRoaXMuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhY2suZW5hYmxlZClcbiAgICAgICAgICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BUcmFja3MoKSB7XG4gICAgICAgIHRoaXMuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFjay5yZWFkeVN0YXRlID09PSAnbGl2ZScpXG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXV0ZUxvY2FsU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLm1lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3BUcmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRyYWNrcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tdXRlVHJhY2tzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdW5tdXRlU3RyZWFtKCkge1xuICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCAnU3RhcnRpbmcgc3RyZWFtJyk7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1lZGlhU3RyZWFtICYmXG4gICAgICAgICAgICB0aGlzLmdldFRyYWNrcygpLmV2ZXJ5KCh0KSA9PiB0LnJlYWR5U3RhdGUgPT09ICdsaXZlJykpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuc3RhdGUubWVkaWFTdHJlYW07XG4gICAgICAgICAgICB0aGlzLnVubXV0ZVRyYWNrcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdENvbnN0cmFpbnRzID0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29uc3RyYWludHM7XG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0Q29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RyZWFtID0gYXdhaXQgdGhpcy5nZXRTdHJlYW0oY29uc3RyYWludHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbGwuc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTkVEKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tZWRpYVN0cmVhbSAhPT0gc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lZGlhU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgICAgICB0aGlzLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5hYmxlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNhYmxlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RyYWNrU3RvcHBlZER1ZVRvVHJhY2tFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtZWRpYURldmljZUtpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLkFVRElPKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2F1ZGlvaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyYWNrVHlwZSA9PT0gVHJhY2tUeXBlLlZJREVPKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaGFuZGxlRGlzY29ubmVjdGVkT3JSZXBsYWNlZERldmljZXMoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICAgICAgZGV2aWNlSWRzJC5waXBlKHBhaXJ3aXNlKCkpLFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3RlZERldmljZSQsXG4gICAgICAgIF0pLnN1YnNjcmliZShhc3luYyAoW1twcmV2RGV2aWNlcywgY3VycmVudERldmljZXNdLCBkZXZpY2VJZF0pID0+IHtcbiAgICAgICAgICAgIGlmICghZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc2FibGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlzRGV2aWNlRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaXNEZXZpY2VSZXBsYWNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERldmljZSA9IHRoaXMuZmluZERldmljZUluTGlzdChjdXJyZW50RGV2aWNlcywgZGV2aWNlSWQpO1xuICAgICAgICAgICAgY29uc3QgcHJldkRldmljZSA9IHRoaXMuZmluZERldmljZUluTGlzdChwcmV2RGV2aWNlcywgZGV2aWNlSWQpO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGV2aWNlICYmIHByZXZEZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBpc0RldmljZURpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RGV2aWNlICYmXG4gICAgICAgICAgICAgICAgcHJldkRldmljZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZGV2aWNlSWQgPT09IHByZXZEZXZpY2UuZGV2aWNlSWQgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLmdyb3VwSWQgIT09IHByZXZEZXZpY2UuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIGlzRGV2aWNlUmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGV2aWNlRGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RldmljZVJlcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzID09PSAnZGlzYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUcmFja1N0b3BwZWREdWVUb1RyYWNrRW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcGx5U2V0dGluZ3NUb1N0cmVhbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBmaW5kRGV2aWNlSW5MaXN0KGRldmljZXMsIGRldmljZUlkKSB7XG4gICAgICAgIHJldHVybiBkZXZpY2VzLmZpbmQoKGQpID0+IGQuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIGQua2luZCA9PT0gdGhpcy5tZWRpYURldmljZUtpbmQpO1xuICAgIH1cbn1cblxuY2xhc3MgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBuZXcgSW5wdXRNZWRpYURldmljZU1hbmFnZXJTdGF0ZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXNhYmxlTW9kZSB0aGUgZGlzYWJsZSBtb2RlIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbk5hbWUgdGhlIHBlcm1pc3Npb24gbmFtZSB0byB1c2UgZm9yIHF1ZXJ5aW5nLlxuICAgICAqIGB1bmRlZmluZWRgIG1lYW5zIG5vIHBlcm1pc3Npb24gaXMgcmVxdWlyZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGlzYWJsZU1vZGUgPSAnc3RvcC10cmFja3MnLCBwZXJtaXNzaW9uTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVNb2RlID0gZGlzYWJsZU1vZGU7XG4gICAgICAgIHRoaXMucGVybWlzc2lvbk5hbWUgPSBwZXJtaXNzaW9uTmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QodW5kZWZpbmVkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudCBtZWRpYSBzdHJlYW0sIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBkZXZpY2UgaXMgY3VycmVudGx5IGRpc2FibGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbSQgPSB0aGlzLm1lZGlhU3RyZWFtU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRldmljZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZERldmljZSQgPSB0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgZGV2aWNlIHN0YXR1c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMkID0gdGhpcy5zdGF0dXNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzJCA9IHRoaXMuZGVmYXVsdENvbnN0cmFpbnRzU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9ic2VydmFibGUgdGhhdCB3aWxsIGVtaXQgYHRydWVgIGlmIGJyb3dzZXIvc3lzdGVtIHBlcm1pc3Npb25cbiAgICAgICAgICogaXMgZ3JhbnRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0Jyb3dzZXJQZXJtaXNzaW9uJCA9IG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3RpZnlHcmFudGVkID0gKCkgPT4gc3Vic2NyaWJlci5uZXh0KHRydWUpO1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnNBUElBdmFpbGFibGUgPSAhIW5hdmlnYXRvcj8ucGVybWlzc2lvbnM/LnF1ZXJ5O1xuICAgICAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSB8fCAhdGhpcy5wZXJtaXNzaW9uTmFtZSB8fCAhcGVybWlzc2lvbnNBUElBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICBnZXRMb2dnZXIoWydkZXZpY2VzJ10pKCd3YXJuJywgYFBlcm1pc3Npb25zIGNhbid0IGJlIHF1ZXJpZWQuIEFzc3VtaW5nIGdyYW50ZWQuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdGlmeUdyYW50ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwZXJtaXNzaW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBub3RpZnkgPSAoKSA9PiBzdWJzY3JpYmVyLm5leHQoXG4gICAgICAgICAgICAvLyBJbiBTYWZhcmksIHRoZSBgY2hhbmdlYCBldmVudCBkb2Vzbid0IHJlbGlhYmx5IGVtaXQgYW5kIGhlbmNlLFxuICAgICAgICAgICAgLy8gcGVybWlzc2lvblN0YXRlIHN0YXlzIGluICdwcm9tcHQnIHN0YXRlIGZvcmV2ZXIuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNoZWNraW5nIGlmIGEgcGVybWlzc2lvbiBpcyBncmFudGVkLCB3ZSBjaGVjayBpZiBpdCBpc24ndCBkZW5pZWRcbiAgICAgICAgICAgIGlzU2FmYXJpKClcbiAgICAgICAgICAgICAgICA/IHBlcm1pc3Npb25TdGF0ZS5zdGF0ZSAhPT0gJ2RlbmllZCdcbiAgICAgICAgICAgICAgICA6IHBlcm1pc3Npb25TdGF0ZS5zdGF0ZSA9PT0gJ2dyYW50ZWQnKTtcbiAgICAgICAgICAgIG5hdmlnYXRvci5wZXJtaXNzaW9uc1xuICAgICAgICAgICAgICAgIC5xdWVyeSh7IG5hbWU6IHRoaXMucGVybWlzc2lvbk5hbWUgfSlcbiAgICAgICAgICAgICAgICAudGhlbigocGVybWlzc2lvblN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25TdGF0ZSA9IHBlcm1pc3Npb25TdGF0dXM7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvblN0YXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG5vdGlmeSk7XG4gICAgICAgICAgICAgICAgbm90aWZ5KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gcGVybWlzc2lvbiBkb2Vzbid0IGV4aXN0IG9yIGNhbid0IGJlIHF1ZXJpZWQgLT4gYXNzdW1lIGl0J3MgZ3JhbnRlZFxuICAgICAgICAgICAgICAgIC8vIGFuIGV4YW1wbGUgd291bGQgYmUgRmlyZWZveCxcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBuZWl0aGVyIGNhbWVyYSBtaWNyb3Bob25lIHBlcm1pc3Npb24gY2FuIGJlIHF1ZXJpZWRcbiAgICAgICAgICAgICAgICBub3RpZnlHcmFudGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvblN0YXRlPy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBub3RpZnkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkucGlwZShzaGFyZVJlcGxheSgxKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIGFuIG9ic2VydmFibGUsIG9yIHVuZGVmaW5lZCBpZiB0aGUgb2JzZXJ2YWJsZSBoYXNcbiAgICAgICAgICogbm90IGVtaXR0ZWQgYSB2YWx1ZSB5ZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYnNlcnZhYmxlJCB0aGUgb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHZhbHVlIGZyb20uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBTdWJqZWN0LlxuICAgICAgICAgKiBBbiBgdXBkYXRlYCBjYW4gZWl0aGVyIGJlIGEgbmV3IHZhbHVlIG9yIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXNcbiAgICAgICAgICogdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byB1cGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB1cGRhdGUgdGhlIHVwZGF0ZSB0byBhcHBseSB0byB0aGUgc3ViamVjdC5cbiAgICAgICAgICogQHJldHVybiB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlID0gc2V0Q3VycmVudFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGV2aWNlIHN0YXR1c1xuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnN0YXR1cyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRldmljZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZERldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbWVkaWEgc3RyZWFtLCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgZGV2aWNlIGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBnZXQgbWVkaWFTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLm1lZGlhU3RyZWFtJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc3RhdHVzU3ViamVjdCwgc3RhdHVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHN0cmVhbSB0aGUgc3RyZWFtIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRNZWRpYVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5tZWRpYVN0cmVhbVN1YmplY3QsIHN0cmVhbSk7XG4gICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGV2aWNlKHRoaXMuZ2V0RGV2aWNlSWRGcm9tU3RyZWFtKHN0cmVhbSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgZGV2aWNlIGlkIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXREZXZpY2UoZGV2aWNlSWQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QsIGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdENvbnN0cmFpbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5kZWZhdWx0Q29uc3RyYWludHMkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBjb25zdHJhaW50cyBmb3IgdGhlIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyB0aGUgY29uc3RyYWludHMgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLmRlZmF1bHRDb25zdHJhaW50c1N1YmplY3QsIGNvbnN0cmFpbnRzKTtcbiAgICB9XG59XG5cbmNsYXNzIENhbWVyYU1hbmFnZXJTdGF0ZSBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignc3RvcC10cmFja3MnLCBcbiAgICAgICAgLy8gYGNhbWVyYWAgaXMgbm90IGluIHRoZSBXM0Mgc3RhbmRhcmQgeWV0LFxuICAgICAgICAvLyBidXQgaXQncyBzdXBwb3J0ZWQgYnkgQ2hyb21lIGFuZCBTYWZhcmkuXG4gICAgICAgICdjYW1lcmEnKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25TdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiQgPSB0aGlzLmRpcmVjdGlvblN1YmplY3RcbiAgICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmZXJyZWQgY2FtZXJhIGRpcmVjdGlvblxuICAgICAqIGZyb250IC0gbWVhbnMgdGhlIGNhbWVyYSBmYWNpbmcgdGhlIHVzZXJcbiAgICAgKiBiYWNrIC0gbWVhbnMgdGhlIGNhbWVyYSBmYWNpbmcgdGhlIGVudmlyb25tZW50XG4gICAgICovXG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuZGlyZWN0aW9uJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNldERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5kaXJlY3Rpb25TdWJqZWN0LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXRNZWRpYVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgc3VwZXIuc2V0TWVkaWFTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgLy8gUk4gZ2V0U2V0dGluZ3MoKSBkb2Vzbid0IHJldHVybiBmYWNpbmdNb2RlLCBzbyB3ZSBkb24ndCB2ZXJpZnkgY2FtZXJhIGRpcmVjdGlvblxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gaXNSZWFjdE5hdGl2ZSgpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRpcmVjdGlvblxuICAgICAgICAgICAgICAgIDogc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF0/LmdldFNldHRpbmdzKCkuZmFjaW5nTW9kZSA9PT0gJ2Vudmlyb25tZW50J1xuICAgICAgICAgICAgICAgICAgICA/ICdiYWNrJ1xuICAgICAgICAgICAgICAgICAgICA6ICdmcm9udCc7XG4gICAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERldmljZUlkRnJvbVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdPy5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FtZXJhTWFuYWdlciBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG5ldyBDYW1lcmFNYW5hZ2VyU3RhdGUoKSwgVHJhY2tUeXBlLlZJREVPKTtcbiAgICAgICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgd2lkdGg6IDEyODAsXG4gICAgICAgICAgICBoZWlnaHQ6IDcyMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBjYW1lcmEgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjYW1lcmEgdG8gc2VsZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgLy8gUHJvdmlkaW5nIGJvdGggZGV2aWNlIGlkIGFuZCBkaXJlY3Rpb24gZG9lc24ndCB3b3JrLCBzbyB3ZSBkZXNlbGVjdCB0aGUgZGV2aWNlXG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGV2aWNlKHVuZGVmaW5lZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBwbHlTZXR0aW5nc1RvU3RyZWFtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsaXBzIHRoZSBjYW1lcmEgZGlyZWN0aW9uOiBpZiBpdCdzIGZyb250IGl0IHdpbGwgY2hhbmdlIHRvIGJhY2ssIGlmIGl0J3MgYmFjaywgaXQgd2lsbCBjaGFuZ2UgdG8gZnJvbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpZiB0aGVyZSBpcyBubyBhdmFpbGFibGUgY2FtZXJhIHdpdGggdGhlIGRlc2lyZWQgZGlyZWN0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBhc3luYyBmbGlwKCkge1xuICAgICAgICBjb25zdCBuZXdEaXJlY3Rpb24gPSB0aGlzLnN0YXRlLmRpcmVjdGlvbiA9PT0gJ2Zyb250JyA/ICdiYWNrJyA6ICdmcm9udCc7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VsZWN0RGlyZWN0aW9uKG5ld0RpcmVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIHNlbGVjdFRhcmdldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbi53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVByb21pc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5lbmFibGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gY291bGRuJ3QgZW5hYmxlIGRldmljZSwgdGFyZ2V0IHJlc29sdXRpb24gd2lsbCBiZSBhcHBsaWVkIHRoZSBuZXh0IHRpbWUgdXNlciBhdHRlbXB0cyB0byBzdGFydCB0aGUgZGV2aWNlXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnY291bGQgbm90IGFwcGx5IHRhcmdldCByZXNvbHV0aW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc3RhdGVcbiAgICAgICAgICAgICAgICAubWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXVxuICAgICAgICAgICAgICAgID8uZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCAhPT0gdGhpcy50YXJnZXRSZXNvbHV0aW9uLndpZHRoIHx8XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICE9PSB0aGlzLnRhcmdldFJlc29sdXRpb24uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHBseVNldHRpbmdzVG9TdHJlYW0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgJHt3aWR0aH14JHtoZWlnaHR9IHRhcmdldCByZXNvbHV0aW9uIGFwcGxpZWQgdG8gbWVkaWEgc3RyZWFtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJlZmVycmVkIGNvZGVjIGZvciBlbmNvZGluZyB0aGUgdmlkZW8uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWwgaW50ZXJuYWwgdXNlIG9ubHksIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLlxuICAgICAqIEBwYXJhbSBjb2RlYyB0aGUgY29kZWMgdG8gdXNlIGZvciBlbmNvZGluZyB0aGUgdmlkZW8uXG4gICAgICovXG4gICAgc2V0UHJlZmVycmVkQ29kZWMoY29kZWMpIHtcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRDb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBnZXREZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gZ2V0VmlkZW9EZXZpY2VzKCk7XG4gICAgfVxuICAgIGdldFN0cmVhbShjb25zdHJhaW50cykge1xuICAgICAgICBjb25zdHJhaW50cy53aWR0aCA9IHRoaXMudGFyZ2V0UmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgY29uc3RyYWludHMuaGVpZ2h0ID0gdGhpcy50YXJnZXRSZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc2V0IGJvdGggZGV2aWNlIGlkIGFuZCBmYWNpbmcgbW9kZVxuICAgICAgICAvLyBEZXZpY2UgaWQgaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICBpZiAoIWNvbnN0cmFpbnRzLmRldmljZUlkICYmIHRoaXMuc3RhdGUuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50cy5mYWNpbmdNb2RlID1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpcmVjdGlvbiA9PT0gJ2Zyb250JyA/ICd1c2VyJyA6ICdlbnZpcm9ubWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFZpZGVvU3RyZWFtKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgcHVibGlzaFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5wdWJsaXNoVmlkZW9TdHJlYW0oc3RyZWFtLCB7XG4gICAgICAgICAgICBwcmVmZXJyZWRDb2RlYzogdGhpcy5wcmVmZXJyZWRDb2RlYyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuVklERU8sIHN0b3BUcmFja3MpO1xuICAgIH1cbn1cblxuY2xhc3MgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSBleHRlbmRzIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignZGlzYWJsZS10cmFja3MnLCBcbiAgICAgICAgLy8gYG1pY3JvcGhvbmVgIGlzIG5vdCBpbiB0aGUgVzNDIHN0YW5kYXJkIHlldCxcbiAgICAgICAgLy8gYnV0IGl0J3Mgc3VwcG9ydGVkIGJ5IENocm9tZSBhbmQgU2FmYXJpLlxuICAgICAgICAnbWljcm9waG9uZScpO1xuICAgICAgICB0aGlzLnNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5zcGVha2luZ1doaWxlTXV0ZWQkID0gdGhpcy5zcGVha2luZ1doaWxlTXV0ZWRTdWJqZWN0XG4gICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIHVzZXIncyBtaWNyb3Bob25lIGlzIG11dGVkIGJ1dCB0aGV5J2FyZSBzcGVha2luZy5cbiAgICAgKlxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBSZWFjdCBOYXRpdmUgU0RLLlxuICAgICAqL1xuICAgIGdldCBzcGVha2luZ1doaWxlTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnNwZWFraW5nV2hpbGVNdXRlZCQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXRTcGVha2luZ1doaWxlTXV0ZWQoaXNTcGVha2luZykge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRWYWx1ZSh0aGlzLnNwZWFraW5nV2hpbGVNdXRlZFN1YmplY3QsIGlzU3BlYWtpbmcpO1xuICAgIH1cbiAgICBnZXREZXZpY2VJZEZyb21TdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXT8uZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZDtcbiAgICB9XG59XG5cbmNvbnN0IERFVEVDVElPTl9GUkVRVUVOQ1lfSU5fTVMgPSA1MDA7XG5jb25zdCBBVURJT19MRVZFTF9USFJFU0hPTEQkMSA9IDE1MDtcbmNvbnN0IEZGVF9TSVpFID0gMTI4O1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvdW5kIGRldGVjdG9yLlxuICpcbiAqIEBwYXJhbSBhdWRpb1N0cmVhbSB0aGUgYXVkaW8gc3RyZWFtIHRvIG9ic2VydmUuIERlcGVuZGluZyBvbiB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiwgdGhpcyBzdHJlYW0gbWlnaHQgYmUgZGVzdHJveWVkIHdoZW4gdGhlIHNvdW5kIGRldGVjdG9yIGlzIHN0b3BwZWQuXG4gKiBAcGFyYW0gb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHNvdW5kIHN0YXRlIGNoYW5nZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyBjdXN0b20gb3B0aW9ucyBmb3IgdGhlIHNvdW5kIGRldGVjdG9yLlxuICogQHJldHVybnMgYSBjbGVhbi11cCBmdW5jdGlvbiB3aGljaCBvbmNlIGludm9rZWQgc3RvcHMgdGhlIHNvdW5kIGRldGVjdG9yLlxuICovXG5jb25zdCBjcmVhdGVTb3VuZERldGVjdG9yID0gKGF1ZGlvU3RyZWFtLCBvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgZGV0ZWN0aW9uRnJlcXVlbmN5SW5NcyA9IERFVEVDVElPTl9GUkVRVUVOQ1lfSU5fTVMsIGF1ZGlvTGV2ZWxUaHJlc2hvbGQgPSBBVURJT19MRVZFTF9USFJFU0hPTEQkMSwgZmZ0U2l6ZSA9IEZGVF9TSVpFLCBkZXN0cm95U3RyZWFtT25TdG9wID0gdHJ1ZSwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemU7XG4gICAgY29uc3QgbWljcm9waG9uZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShhdWRpb1N0cmVhbSk7XG4gICAgbWljcm9waG9uZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuICAgICAgICBhbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShkYXRhKTtcbiAgICAgICAgY29uc3QgaXNTb3VuZERldGVjdGVkID0gZGF0YS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgPj0gYXVkaW9MZXZlbFRocmVzaG9sZCk7XG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VkRGF0YVZhbHVlID0gZGF0YS5yZWR1Y2UoKHB2LCBjdikgPT4gcHYgKyBjdiwgMCkgLyBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGF2ZXJhZ2VkRGF0YVZhbHVlID4gYXVkaW9MZXZlbFRocmVzaG9sZFxuICAgICAgICAgICAgPyAxMDBcbiAgICAgICAgICAgIDogTWF0aC5yb3VuZCgoYXZlcmFnZWREYXRhVmFsdWUgLyBhdWRpb0xldmVsVGhyZXNob2xkKSAqIDEwMCk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHRyYWNrIGlzIGRpc2FibGVkLCBpdCB0YWtlcyB0aW1lIGZvciB0aGUgYnVmZmVyIHRvIGVtcHR5XG4gICAgICAgIC8vIFRoaXMgY2hlY2sgd2lsbCBlbnN1cmUgdGhhdCB3ZSBkb24ndCBzZW5kIGFueXRoaW5nIGlmIHRoZSB0cmFjayBpcyBkaXNhYmxlZFxuICAgICAgICBpZiAoYXVkaW9TdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXT8uZW5hYmxlZCkge1xuICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHsgaXNTb3VuZERldGVjdGVkLCBhdWRpb0xldmVsOiBwZXJjZW50YWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25Tb3VuZERldGVjdGVkU3RhdGVDaGFuZ2VkKHsgaXNTb3VuZERldGVjdGVkOiBmYWxzZSwgYXVkaW9MZXZlbDogMCB9KTtcbiAgICAgICAgfVxuICAgIH0sIGRldGVjdGlvbkZyZXF1ZW5jeUluTXMpO1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICAvLyBjbGVhbi11cCB0aGUgQXVkaW9Db250ZXh0IGVsZW1lbnRzXG4gICAgICAgIG1pY3JvcGhvbmUuZGlzY29ubmVjdCgpO1xuICAgICAgICBhbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGF3YWl0IGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgICAgICAvLyBzdG9wIHRoZSBzdHJlYW1cbiAgICAgICAgaWYgKGRlc3Ryb3lTdHJlYW1PblN0b3ApIHtcbiAgICAgICAgICAgIGF1ZGlvU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIGF1ZGlvU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogRmxhdHRlbiB0aGUgc3RhdHMgcmVwb3J0IGludG8gYW4gYXJyYXkgb2Ygc3RhdHMgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gcmVwb3J0IHRoZSByZXBvcnQgdG8gZmxhdHRlbi5cbiAqL1xuY29uc3QgZmxhdHRlbiA9IChyZXBvcnQpID0+IHtcbiAgICBjb25zdCBzdGF0cyA9IFtdO1xuICAgIHJlcG9ydC5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgIHN0YXRzLnB1c2gocyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRzO1xufTtcbmNvbnN0IEFVRElPX0xFVkVMX1RIUkVTSE9MRCA9IDAuMjtcbmNsYXNzIFJOU3BlZWNoRGV0ZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBjMSA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7fSk7XG4gICAgICAgIHRoaXMucGMyID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBzcGVlY2ggZGV0ZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9TdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGMxLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYzIuYWRkSWNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYzIuYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBjMS5hZGRJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdWRpb1N0cmVhbVxuICAgICAgICAgICAgICAgIC5nZXRUcmFja3MoKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh0cmFjaykgPT4gdGhpcy5wYzEuYWRkVHJhY2sodHJhY2ssIGF1ZGlvU3RyZWFtKSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMucGMxLmNyZWF0ZU9mZmVyKHt9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMyLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGMxLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wYzIuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBjMS5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYzIuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSBhdWRpb1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBtdXRlIHRoZSBhdWRpbyB0cmFjayBmb3IgdGhpcyB0ZW1wb3Jhcnkgc3RyZWFtLCBvciBlbHNlIHlvdSB3aWxsIGhlYXIgeW91cnNlbGYgdHdpY2Ugd2hpbGUgaW4gdGhlIGNhbGwuXG4gICAgICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKCh0cmFjaykgPT4gKHRyYWNrLmVuYWJsZWQgPSBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29ubmVjdGluZyBhbmQgbmVnb3RpYXRpbmcgYmV0d2VlbiBQZWVyQ29ubmVjdGlvbnM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBzcGVlY2ggZGV0ZWN0aW9uIGFuZCByZWxlYXNlcyBhbGwgYWxsb2NhdGVkIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnBjMS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBjMi5jbG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0aGF0IGRldGVjdHMgdGhlIGF1ZGlvIGxldmVscyBhbmQgcmV0dXJucyB0aGUgc3RhdHVzLlxuICAgICAqL1xuICAgIG9uU3BlYWtpbmdEZXRlY3RlZFN0YXRlQ2hhbmdlKG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IChhd2FpdCB0aGlzLnBjMS5nZXRTdGF0cygpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IGZsYXR0ZW4oc3RhdHMpO1xuICAgICAgICAgICAgLy8gQXVkaW8gbGV2ZWxzIGFyZSBwcmVzZW50IGluc2lkZSBzdGF0cyBvZiB0eXBlIGBtZWRpYS1zb3VyY2VgIGFuZCBvZiBraW5kIGBhdWRpb2BcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvTWVkaWFTb3VyY2VTdGF0cyA9IHJlcG9ydC5maW5kKChzdGF0KSA9PiBzdGF0LnR5cGUgPT09ICdtZWRpYS1zb3VyY2UnICYmXG4gICAgICAgICAgICAgICAgc3RhdC5raW5kID09PSAnYXVkaW8nKTtcbiAgICAgICAgICAgIGlmIChhdWRpb01lZGlhU291cmNlU3RhdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1ZGlvTGV2ZWwgfSA9IGF1ZGlvTWVkaWFTb3VyY2VTdGF0cztcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW9MZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9MZXZlbCA+PSBBVURJT19MRVZFTF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTb3VuZERldGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU291bmREZXRlY3RlZFN0YXRlQ2hhbmdlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTb3VuZERldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0xldmVsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgTWljcm9waG9uZU1hbmFnZXIgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCkge1xuICAgICAgICBzdXBlcihjYWxsLCBuZXcgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSgpLCBUcmFja1R5cGUuQVVESU8pO1xuICAgICAgICBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICAgIHRoaXMuY2FsbC5zdGF0ZS5jYWxsaW5nU3RhdGUkLFxuICAgICAgICAgICAgdGhpcy5jYWxsLnN0YXRlLm93bkNhcGFiaWxpdGllcyQsXG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGVkRGV2aWNlJCxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdHVzJCxcbiAgICAgICAgXSkuc3Vic2NyaWJlKGFzeW5jIChbY2FsbGluZ1N0YXRlLCBvd25DYXBhYmlsaXRpZXMsIGRldmljZUlkLCBzdGF0dXNdKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlICE9PSBDYWxsaW5nU3RhdGUuSk9JTkVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkxFRlQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdG9wU3BlYWtpbmdXaGlsZU11dGVkRGV0ZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvd25DYXBhYmlsaXRpZXMuaW5jbHVkZXMoT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbihkZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldERldmljZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdWRpb0RldmljZXMoKTtcbiAgICB9XG4gICAgZ2V0U3RyZWFtKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBnZXRBdWRpb1N0cmVhbShjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHB1Ymxpc2hTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwucHVibGlzaEF1ZGlvU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxuICAgIHN0b3BQdWJsaXNoU3RyZWFtKHN0b3BUcmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuQVVESU8sIHN0b3BUcmFja3MpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbihkZXZpY2VJZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKTtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgICAgdGhpcy5yblNwZWVjaERldGVjdG9yID0gbmV3IFJOU3BlZWNoRGV0ZWN0b3IoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucm5TcGVlY2hEZXRlY3Rvci5zdGFydCgpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLnJuU3BlZWNoRGV0ZWN0b3I/Lm9uU3BlYWtpbmdEZXRlY3RlZFN0YXRlQ2hhbmdlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0U3BlYWtpbmdXaGlsZU11dGVkKGV2ZW50LmlzU291bmREZXRlY3RlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc291bmREZXRlY3RvckNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJuU3BlZWNoRGV0ZWN0b3I/LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJuU3BlZWNoRGV0ZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBzdGFydCBhIG5ldyBzdHJlYW0gdGhhdCdzIG5vdCBjb25uZWN0ZWQgdG8gcHVibGlzaGVyXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLmdldFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc291bmREZXRlY3RvckNsZWFudXAgPSBjcmVhdGVTb3VuZERldGVjdG9yKHN0cmVhbSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTcGVha2luZ1doaWxlTXV0ZWQoZXZlbnQuaXNTb3VuZERldGVjdGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VuZERldGVjdG9yQ2xlYW51cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U3BlYWtpbmdXaGlsZU11dGVkKGZhbHNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc291bmREZXRlY3RvckNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc291bmREZXRlY3RvckNsZWFudXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNjcmVlblNoYXJlU3RhdGUgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlclN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWRTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIGF1ZGlvIHN0YXR1cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXVkaW9FbmFibGVkJCA9IHRoaXMuYXVkaW9FbmFibGVkU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzJCA9IHRoaXMuc2V0dGluZ3NTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERldmljZUlkRnJvbVN0cmVhbSA9IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt0cmFja10gPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2s/LmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBhdWRpbyBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0IGF1ZGlvRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuYXVkaW9FbmFibGVkJCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgYXVkaW8gc3RhdHVzLlxuICAgICAqL1xuICAgIHNldEF1ZGlvRW5hYmxlZChpc0VuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5hdWRpb0VuYWJsZWRTdWJqZWN0LCBpc0VuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICovXG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VmFsdWUodGhpcy5zZXR0aW5ncyQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgc2NyZWVuIHNoYXJlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIHRoZSBzY3JlZW4gc2hhcmUgc2V0dGluZ3MgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFZhbHVlKHRoaXMuc2V0dGluZ3NTdWJqZWN0LCBzZXR0aW5ncyk7XG4gICAgfVxufVxuXG5jbGFzcyBTY3JlZW5TaGFyZU1hbmFnZXIgZXh0ZW5kcyBJbnB1dE1lZGlhRGV2aWNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCkge1xuICAgICAgICBzdXBlcihjYWxsLCBuZXcgU2NyZWVuU2hhcmVTdGF0ZSgpLCBUcmFja1R5cGUuU0NSRUVOX1NIQVJFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBlbmFibGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9wdGlvbnMgb24gc3VwcG9ydGVkIHBsYXRmb3Jtcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IGZvciBvbmdvaW5nIHNjcmVlbiBzaGFyZSwgYXVkaW8gd29uJ3QgYmUgZW5hYmxlZCB1bnRpbCB5b3VcbiAgICAgKiByZS1wdWJsaXNoIHRoZSBzY3JlZW4gc2hhcmUgc3RyZWFtLlxuICAgICAqL1xuICAgIGVuYWJsZVNjcmVlblNoYXJlQXVkaW8oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0QXVkaW9FbmFibGVkKHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIGRpc2FibGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9wdGlvbnMgb24gc3VwcG9ydGVkIHBsYXRmb3Jtcy5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNhYmxlU2NyZWVuU2hhcmVBdWRpbygpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRBdWRpb0VuYWJsZWQoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jYWxsLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbGwuc3RvcFB1Ymxpc2goVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzY3JlZW4gc2hhcmUgc2V0dGluZ3MuXG4gICAgICovXG4gICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHNjcmVlbiBzaGFyZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyB0aGUgc2V0dGluZ3MgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH1cbiAgICBnZXREZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gb2YoW10pOyAvLyB0aGVyZSBhcmUgbm8gZGV2aWNlcyB0byBiZSBsaXN0ZWQgZm9yIFNjcmVlbiBTaGFyZVxuICAgIH1cbiAgICBnZXRTdHJlYW0oY29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmF1ZGlvRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U2NyZWVuU2hhcmVTdHJlYW0oY29uc3RyYWludHMpO1xuICAgIH1cbiAgICBwdWJsaXNoU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLnB1Ymxpc2hTY3JlZW5TaGFyZVN0cmVhbShzdHJlYW0sIHtcbiAgICAgICAgICAgIHNjcmVlblNoYXJlU2V0dGluZ3M6IHRoaXMuc3RhdGUuc2V0dGluZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdG9wUHVibGlzaFN0cmVhbShzdG9wVHJhY2tzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbC5zdG9wUHVibGlzaChUcmFja1R5cGUuU0NSRUVOX1NIQVJFLCBzdG9wVHJhY2tzKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsLnN0b3BQdWJsaXNoKFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sIHN0b3BUcmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYHNlbGVjdGAgbWV0aG9kIHRvIHRocm93IGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRldmljZUlkIGlnbm9yZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2VsZWN0KGRldmljZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBpbiBmb3IgU2NyZWVuIFNoYXJlJyk7XG4gICAgfVxufVxuXG5jbGFzcyBTcGVha2VyU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGV2aWNlU3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3QoJycpO1xuICAgICAgICB0aGlzLnZvbHVtZVN1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogW1RlbGxzIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGF1ZGlvIG91dHB1dCBjaGFuZ2Ugb24gJ2F1ZGlvJyBlbGVtZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvc2V0U2lua0lkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNEZXZpY2VTZWxlY3Rpb25TdXBwb3J0ZWQgPSBjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW4gb2JzZXJ2YWJsZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBvYnNlcnZhYmxlIGhhc1xuICAgICAgICAgKiBub3QgZW1pdHRlZCBhIHZhbHVlIHlldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9ic2VydmFibGUkIHRoZSBvYnNlcnZhYmxlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHByb3ZpZGVkIFN1YmplY3QuXG4gICAgICAgICAqIEFuIGB1cGRhdGVgIGNhbiBlaXRoZXIgYmUgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB3aGljaCB0YWtlc1xuICAgICAgICAgKiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZSB0aGUgdXBkYXRlIHRvIGFwcGx5IHRvIHRoZSBzdWJqZWN0LlxuICAgICAgICAgKiBAcmV0dXJuIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUgPSBzZXRDdXJyZW50VmFsdWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREZXZpY2UkID0gdGhpcy5zZWxlY3RlZERldmljZVN1YmplY3RcbiAgICAgICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgICAgIHRoaXMudm9sdW1lJCA9IHRoaXMudm9sdW1lU3ViamVjdFxuICAgICAgICAgICAgLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkZXZpY2VcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZERldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFZhbHVlKHRoaXMuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCB2b2x1bWVcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZVxuICAgICAqL1xuICAgIGdldCB2b2x1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRWYWx1ZSh0aGlzLnZvbHVtZSQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gZGV2aWNlSWRcbiAgICAgKi9cbiAgICBzZXREZXZpY2UoZGV2aWNlSWQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy5zZWxlY3RlZERldmljZVN1YmplY3QsIGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICogQHBhcmFtIHZvbHVtZVxuICAgICAqL1xuICAgIHNldFZvbHVtZSh2b2x1bWUpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50VmFsdWUodGhpcy52b2x1bWVTdWJqZWN0LCB2b2x1bWUpO1xuICAgIH1cbn1cblxuY2xhc3MgU3BlYWtlck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFNwZWFrZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdWJzY3JpcHRpb25zID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHMpID0+IHMudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZXZpY2VJZHMkICYmICFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKGNvbWJpbmVMYXRlc3QoW2RldmljZUlkcyQsIHRoaXMuc3RhdGUuc2VsZWN0ZWREZXZpY2UkXSkuc3Vic2NyaWJlKChbZGV2aWNlcywgZGV2aWNlSWRdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IGRldmljZXMuZmluZCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQgJiYgZC5raW5kID09PSAnYXVkaW9vdXRwdXQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRldmljZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBhdmFpbGFibGUgYXVkaW8gb3V0cHV0IGRldmljZXNcbiAgICAgKlxuICAgICAqIE5vdGU6IEl0IHByb21wdHMgdGhlIHVzZXIgZm9yIGEgcGVybWlzc2lvbiB0byB1c2UgZGV2aWNlcyAoaWYgbm90IGFscmVhZHkgZ3JhbnRlZClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgaWYgYSBkZXZpY2UgaXMgY29ubmVjdGVkIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAqL1xuICAgIGxpc3REZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QXVkaW9PdXRwdXREZXZpY2VzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBkZXZpY2VcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGV2aWNlSWQgZW1wdHkgc3RyaW5nIG1lYW5zIHRoZSBzeXN0ZW0gZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdChkZXZpY2VJZCkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0RGV2aWNlKGRldmljZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB2b2x1bWUgb2YgdGhlIGF1ZGlvIGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHZvbHVtZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgaW4gUmVhY3QgTmF0aXZlXG4gICAgICovXG4gICAgc2V0Vm9sdW1lKHZvbHVtZSkge1xuICAgICAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZmVhdHVyZSBpcyBub3Qgc3VwcG9ydGVkIGluIFJlYWN0IE5hdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2b2x1bWUgJiYgKHZvbHVtZSA8IDAgfHwgdm9sdW1lID4gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVm9sdW1lIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgYENhbGxgLlxuICovXG5jbGFzcyBDYWxsIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBDYWxsYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IERvbid0IGNhbGwgdGhlIGNvbnN0cnVjdG9yIGRpcmVjdGx5LCBpbnN0ZWFkXG4gICAgICogVXNlIHRoZSBbYFN0cmVhbVZpZGVvQ2xpZW50LmNhbGxgXSguL1N0cmVhbVZpZGVvQ2xpZW50Lm1kLyNjYWxsKVxuICAgICAqIG1ldGhvZCB0byBjb25zdHJ1Y3QgYSBgQ2FsbGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyB0eXBlLCBpZCwgc3RyZWFtQ2xpZW50LCBtZW1iZXJzLCBvd25DYXBhYmlsaXRpZXMsIHNvcnRQYXJ0aWNpcGFudHNCeSwgY2xpZW50U3RvcmUsIHJpbmdpbmcgPSBmYWxzZSwgd2F0Y2hpbmcgPSBmYWxzZSwgfSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRlIG9mIHRoaXMgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgQ2FsbFN0YXRlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgRHluYXNjYWxlTWFuYWdlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHluYXNjYWxlTWFuYWdlciA9IG5ldyBEeW5hc2NhbGVNYW5hZ2VyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcm1pc3Npb25zIGNvbnRleHQgb2YgdGhpcyBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQgPSBuZXcgUGVybWlzc2lvbnNDb250ZXh0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXZlbnQgZGlzcGF0Y2hlciBpbnN0YW5jZSBkZWRpY2F0ZWQgdG8gdGhpcyBDYWxsIGluc3RhbmNlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoKTtcbiAgICAgICAgdGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7IHR5cGU6IERlYm91bmNlVHlwZS5NRURJVU0sIGRhdGE6IFtdIH0pO1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cyA9IDEwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IGhvb2tzL2Z1bmN0aW9ucyB0byBpbnZva2Ugd2hlbiB0aGUgY2FsbCBpcyBsZWZ0LlxuICAgICAgICAgKiBBIHR5cGljYWwgdXNlIGNhc2UgaXMgdG8gY2xlYW4gdXAgc29tZSBnbG9iYWwgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgY2FuIHN1YnNjcmliZSB0byBXZWJTb2NrZXQgZXZlbnRzIHByb3ZpZGVkIGJ5IHRoZSBBUEkuIFRvIHJlbW92ZSBhIHN1YnNjcmlwdGlvbiwgY2FsbCB0aGUgYG9mZmAgbWV0aG9kLlxuICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHN1YnNjcmliaW5nIHRvIFdlYlNvY2tldCBldmVudHMgaXMgYW4gYWR2YW5jZWQgdXNlLWNhc2UuXG4gICAgICAgICAqIEZvciBtb3N0IHVzZS1jYXNlcywgaXQgc2hvdWxkIGJlIGVub3VnaCB0byB3YXRjaCBmb3Igc3RhdGUgY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIGZuIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IChldmVudE5hbWUsIGZuKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTZnVFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9mZkhhbmRsZXIgPSB0aGlzLnN0cmVhbUNsaWVudC5vbihldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBlO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jYWxsX2NpZCAmJiBldmVudC5jYWxsX2NpZCA9PT0gdGhpcy5jaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8ga2VlcCB0aGUgJ29mZicgcmVmZXJlbmNlIHJldHVybmVkIGJ5IHRoZSBzdHJlYW0gY2xpZW50XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMuc2V0KGZuLCBvZmZIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHN1YnNjcmlwdGlvbiBmb3IgV2ViU29ja2V0IGV2ZW50cyB0aGF0IHdlcmUgY3JlYXRlZCBieSB0aGUgYG9uYCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgdGhlIGV2ZW50IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBmbiB0aGUgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmID0gKGV2ZW50TmFtZSwgZm4pID0+IHtcbiAgICAgICAgICAgIGlmIChpc1NmdUV2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaGVyLm9mZihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIHN0cmVhbSBjbGllbnQgZXZlbnQgYnkgdXNpbmcgdGhlICdvZmYnIHJlZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZE9mZkhhbmRsZXIgPSB0aGlzLnN0cmVhbUNsaWVudEV2ZW50SGFuZGxlcnMuZ2V0KGZuKTtcbiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkT2ZmSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRPZmZIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWF2ZSB0aGUgY2FsbCBhbmQgc3RvcCB0aGUgbWVkaWEgc3RyZWFtcyB0aGF0IHdlcmUgcHVibGlzaGVkIGJ5IHRoZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWF2ZSA9IGFzeW5jICh7IHJlamVjdCA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsbGluZ1N0YXRlID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGU7XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuTEVGVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxlYXZlIGNhbGwgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGxlZnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSk9JTklORykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0Q2FsbEpvaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmluZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIEknbSB0aGUgb25lIHdobyBzdGFydGVkIHRoZSBjYWxsLCBzbyBJIHNob3VsZCBjYW5jZWwgaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzT3RoZXJQYXJ0aWNpcGFudHMgPSB0aGlzLnN0YXRlLnJlbW90ZVBhcnRpY2lwYW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ3JlYXRlZEJ5TWUgJiYgIWhhc090aGVyUGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpZ25hbHMgb3RoZXIgdXNlcnMgdGhhdCBJIGhhdmUgY2FuY2VsbGVkIG15IGNhbGwgdG8gdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWZvcmUgdGhleSBhY2NlcHRlZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVqZWN0ICYmIGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJJTkdJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbmFscyBvdGhlciB1c2VycyB0aGF0IEkgaGF2ZSByZWplY3RlZCB0aGUgaW5jb21pbmcgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRzUmVwb3J0ZXI/LnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcj8uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaGVyPy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNmdUNsaWVudD8uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2Z1Q2xpZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLm9mZkFsbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLkxFRlQpO1xuICAgICAgICAgICAgLy8gQ2FsbCBhbGwgbGVhdmUgY2FsbCBob29rcywgZS5nLiB0byBjbGVhbiB1cCBnbG9iYWwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuZm9yRWFjaCgoaG9vaykgPT4gaG9vaygpKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50U3RvcmUudW5yZWdpc3RlckNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5yZW1vdmVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmUucmVtb3ZlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zY3JlZW5TaGFyZS5yZW1vdmVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLnNwZWFrZXIucmVtb3ZlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcE9uTGVhdmVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnN0b3BPbkxlYXZlKSB7XG4gICAgICAgICAgICAgICAgc3RvcE9uTGVhdmVQcm9taXNlcy5wdXNoKHRoaXMuY2FtZXJhLmRpc2FibGUodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5zdG9wT25MZWF2ZSkge1xuICAgICAgICAgICAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLm1pY3JvcGhvbmUuZGlzYWJsZSh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JlZW5TaGFyZS5zdG9wT25MZWF2ZSkge1xuICAgICAgICAgICAgICAgIHN0b3BPbkxlYXZlUHJvbWlzZXMucHVzaCh0aGlzLnNjcmVlblNoYXJlLmRpc2FibGUodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RvcE9uTGVhdmVQcm9taXNlcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMucmluZyBpZiBzZXQgdG8gdHJ1ZSwgYSBgY2FsbC5yaW5nYCBldmVudCB3aWxsIGJlIHNlbnQgdG8gdGhlIGNhbGwgbWVtYmVycy5cbiAgICAgICAgICogQHBhcmFtIHBhcmFtcy5ub3RpZnkgaWYgc2V0IHRvIHRydWUsIGEgYGNhbGwubm90aWZpY2F0aW9uYCBldmVudCB3aWxsIGJlIHNlbnQgdG8gdGhlIGNhbGwgbWVtYmVycy5cbiAgICAgICAgICogQHBhcmFtIHBhcmFtcy5tZW1iZXJzX2xpbWl0IHRoZSB0b3RhbCBudW1iZXIgb2YgbWVtYmVycyB0byByZXR1cm4gYXMgcGFydCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQuZ2V0KHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAocGFyYW1zPy5yaW5nICYmICF0aGlzLnJpbmdpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpbmdpbmdTdWJqZWN0Lm5leHQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZUZyb21DYWxsUmVzcG9uc2UocmVzcG9uc2UuY2FsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMocmVzcG9uc2UubWVtYmVycyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldE93bkNhcGFiaWxpdGllcyhyZXNwb25zZS5vd25fY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNsaWVudC5faGFzQ29ubmVjdGlvbklEKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudFN0b3JlLnJlZ2lzdGVyQ2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwbHlEZXZpY2VDb25maWcoKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRzIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsbCBhbmQgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSB0byBjcmVhdGUgdGhlIGNhbGwgd2l0aC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGE/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmluZ2luZ1N1YmplY3QubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShyZXNwb25zZS5jYWxsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0TWVtYmVycyhyZXNwb25zZS5tZW1iZXJzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0T3duQ2FwYWJpbGl0aWVzKHJlc3BvbnNlLm93bl9jYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtQ2xpZW50Ll9oYXNDb25uZWN0aW9uSUQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50U3RvcmUucmVnaXN0ZXJDYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBseURldmljZUNvbmZpZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNhbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgdG8gY3JlYXRlIHRoZSBjYWxsIHdpdGguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckNyZWF0ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2hvcnRjdXQgZm9yIHtAbGluayBDYWxsLmdldH0gd2l0aCBgcmluZ2AgcGFyYW1ldGVyIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICAqIFdpbGwgc2VuZCBhIGBjYWxsLnJpbmdgIGV2ZW50IHRvIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoeyByaW5nOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaG9ydGN1dCBmb3Ige0BsaW5rIENhbGwuZ2V0fSB3aXRoIGBub3RpZnlgIHBhcmFtZXRlciBzZXQgdG8gYHRydWVgLlxuICAgICAgICAgKiBXaWxsIHNlbmQgYSBgY2FsbC5ub3RpZmljYXRpb25gIGV2ZW50IHRvIHRoZSBjYWxsIG1lbWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGlmeSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldCh7IG5vdGlmeTogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBpbmNvbWluZyBjYWxsIGFzIGFjY2VwdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBvbmx5IGZvciBcInJpbmdpbmdcIiBjYWxsIGZsb3dzLlxuICAgICAgICAgKiB7QGxpbmsgQ2FsbC5qb2lufSBpbnZva2VzIHRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSB3aGVuIGpvaW5pbmcgYSBjYWxsLlxuICAgICAgICAgKiBVbmxlc3MgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjdXN0b20gXCJyaW5naW5nXCIgZmxvdywgeW91IHNob3VsZCBub3QgdXNlIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2NlcHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9hY2NlcHRgKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBpbmNvbWluZyBjYWxsIGFzIHJlamVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBvbmx5IGZvciBcInJpbmdpbmdcIiBjYWxsIGZsb3dzLlxuICAgICAgICAgKiB7QGxpbmsgQ2FsbC5sZWF2ZX0gaW52b2tlcyB0aGlzIG1ldGhvZCBhdXRvbWF0aWNhbGx5IGZvciB5b3Ugd2hlbiB5b3UgbGVhdmUgb3IgcmVqZWN0IHRoaXMgY2FsbC5cbiAgICAgICAgICogVW5sZXNzIHlvdSBhcmUgaW1wbGVtZW50aW5nIGEgY3VzdG9tIFwicmluZ2luZ1wiIGZsb3csIHlvdSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVqZWN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vcmVqZWN0YCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIHN0YXJ0IHRvIHdhdGNoIGZvciBjYWxsIHJlbGF0ZWQgV2ViU29ja2V0IGV2ZW50cyBhbmQgaW5pdGlhdGUgYSBjYWxsIHNlc3Npb24gd2l0aCB0aGUgc2VydmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb25jZSB0aGUgY2FsbCBqb2luLWZsb3cgaGFzIGZpbmlzaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5qb2luID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxpbmdTdGF0ZSA9IHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlO1xuICAgICAgICAgICAgaWYgKFtDYWxsaW5nU3RhdGUuSk9JTkVELCBDYWxsaW5nU3RhdGUuSk9JTklOR10uaW5jbHVkZXMoY2FsbGluZ1N0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ0pvaW4gbWV0aG9kIGNhbGxlZCB0d2ljZSwgeW91IHNob3VsZCBvbmx5IGNhbGwgdGhpcyBvbmNlJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIFN0YXRlOiBBbHJlYWR5IGpvaW5lZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIFN0YXRlOiBDYW5ub3Qgam9pbiBhbHJlYWR5IGxlZnQgY2FsbC4gQ3JlYXRlIGEgbmV3IENhbGwgaW5zdGFuY2UgdG8gam9pbiBhIGNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc01pZ3JhdGluZyA9IGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLk1JR1JBVElORztcbiAgICAgICAgICAgIGNvbnN0IGlzUmVjb25uZWN0aW5nID0gY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLkpPSU5JTkcpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ1N0YXJ0aW5nIGpvaW4gZmxvdycpO1xuICAgICAgICAgICAgaWYgKGRhdGE/LnJpbmcgJiYgIXRoaXMucmluZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMucmluZ2luZ1N1YmplY3QubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJpbmdpbmcgJiYgIXRoaXMuaXNDcmVhdGVkQnlNZSkge1xuICAgICAgICAgICAgICAgIC8vIHNpZ25hbHMgb3RoZXIgdXNlcnMgdGhhdCBJIGhhdmUgYWNjZXB0ZWQgdGhlIGluY29taW5nIGNhbGwuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hY2NlcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzZnVTZXJ2ZXI7XG4gICAgICAgICAgICBsZXQgc2Z1VG9rZW47XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbkNvbmZpZztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Z1Q2xpZW50Py5pc0Zhc3RSZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHByZXZpb3VzIFNGVSBjb25maWd1cmF0aW9uIGFuZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZyA9IHRoaXMucHVibGlzaGVyPy5jb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2Z1U2VydmVyID0gdGhpcy5zZnVDbGllbnQuc2Z1U2VydmVyO1xuICAgICAgICAgICAgICAgICAgICBzZnVUb2tlbiA9IHRoaXMuc2Z1Q2xpZW50LnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZnVsbCBqb2luIGZsb3cgLSBsZXQgdGhlIENvb3JkaW5hdG9yIHBpY2sgYSBuZXcgU0ZVIGZvciB1c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsID0gYXdhaXQgam9pbih0aGlzLnN0cmVhbUNsaWVudCwgdGhpcy50eXBlLCB0aGlzLmlkLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwubWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldE1lbWJlcnMoY2FsbC5tZW1iZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMoY2FsbC5vd25DYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnID0gY2FsbC5jb25uZWN0aW9uQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBzZnVTZXJ2ZXIgPSBjYWxsLnNmdVNlcnZlcjtcbiAgICAgICAgICAgICAgICAgICAgc2Z1VG9rZW4gPSBjYWxsLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHJlYW1DbGllbnQuX2hhc0Nvbm5lY3Rpb25JRCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudFN0b3JlLnJlZ2lzdGVyQ2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBwcmV2aW91cyBjYWxsIHN0YXRlIGlmIHRoZSBqb2luLWZsb3cgZmFpbHNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShjYWxsaW5nU3RhdGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTZnVDbGllbnQgPSB0aGlzLnNmdUNsaWVudDtcbiAgICAgICAgICAgIGNvbnN0IHNmdUNsaWVudCA9ICh0aGlzLnNmdUNsaWVudCA9IG5ldyBTdHJlYW1TZnVDbGllbnQoe1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXI6IHRoaXMuZGlzcGF0Y2hlcixcbiAgICAgICAgICAgICAgICBzZnVTZXJ2ZXIsXG4gICAgICAgICAgICAgICAgdG9rZW46IHNmdVRva2VuLFxuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcHJldmlvdXNTZnVDbGllbnQ/LnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjbG9zdXJlIHdoaWNoIGhpZGVzIGF3YXkgdGhlIHJlLWNvbm5lY3Rpb24gbG9naWMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlY29ubmVjdCA9IGFzeW5jIChzdHJhdGVneSA9ICdmdWxsJykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IENhbGxpbmdTdGF0ZS5NSUdSQVRJTkcgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID09PSBDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgcGFyYWxsZWwgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKHN0cmF0ZWd5ID09PSAnbWlncmF0ZSdcbiAgICAgICAgICAgICAgICAgICAgPyBDYWxsaW5nU3RhdGUuTUlHUkFUSU5HXG4gICAgICAgICAgICAgICAgICAgIDogQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElORyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYFtNaWdyYXRpb25dOiBtaWdyYXRpbmcgY2FsbCAke3RoaXMuY2lkfSBhd2F5IGZyb20gJHtzZnVTZXJ2ZXIuZWRnZV9uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNNaWdyYXRpbmdBd2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBbUmVqb2luXTogJHtzdHJhdGVneX0gcmVqb2luIGNhbGwgJHt0aGlzLmNpZH0gKCR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30pLi4uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRha2UgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBcImxvY2FsIHBhcnRpY2lwYW50XCIgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyB3ZSdsbCBuZWVkIGl0IGZvciByZXN0b3JpbmcgdGhlIHByZXZpb3VzIHB1Ymxpc2hpbmcgc3RhdGUgbGF0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFBhcnRpY2lwYW50ID0gdGhpcy5zdGF0ZS5sb2NhbFBhcnRpY2lwYW50O1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ2Zhc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5jbG9zZShTdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9CUk9LRU4sICdqcy1jbGllbnQ6IGF0dGVtcHRpbmcgZmFzdCByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdmdWxsJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBtaWdyYXRpb24gb3IgcmVjb3Zlcnkgc2NlbmFyaW9zLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvIGFuIFNGVSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGZ1bGwtcmVjb25uZWN0LCB3ZSBuZWVkIHRvIGRpc3Bvc2UgYWxsIFBlZXIgQ29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyPy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyPy5jbG9zZSh7IHN0b3BUcmFja3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0c1JlcG9ydGVyPy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHNSZXBvcnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgY3VycmVudCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNmdUNsaWVudC5jbG9zZShTdHJlYW1TZnVDbGllbnQuTk9STUFMX0NMT1NVUkUsICdqcy1jbGllbnQ6IGF0dGVtcHRpbmcgZnVsbCByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5qb2luKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScgJiYgeyBtaWdyYXRpbmdfZnJvbTogc2Z1U2VydmVyLmVkZ2VfbmFtZSB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBwcmV2aW91cyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWd5ID09PSAnbWlncmF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LmNsb3NlKFN0cmVhbVNmdUNsaWVudC5OT1JNQUxfQ0xPU1VSRSwgJ2pzLWNsaWVudDogYXR0ZW1wdGluZyBtaWdyYXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCBgW1Jlam9pbl06IEF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBzdWNjZXNzZnVsIWApO1xuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBiZSByZXB1Ymxpc2hpbmcgdGhlIHN0cmVhbXMgaWYgd2UncmUgbWlncmF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIHVuZGVybHlpbmcgcGVlciBjb25uZWN0aW9uIHdpbGwgdGFrZSBjYXJlIG9mIGl0IGFzIHBhcnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgaWNlLXJlc3RhcnQgcHJvY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFBhcnRpY2lwYW50ICYmIHN0cmF0ZWd5ID09PSAnZnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhdWRpb1N0cmVhbSwgdmlkZW9TdHJlYW0sIHNjcmVlblNoYXJlU3RyZWFtLCBzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtLCB9ID0gbG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjcmVlblNoYXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NyZWVuU2hhcmVTdHJlYW0gfHwgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hhcmUgPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlU3RyZWFtPy5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hhcmU/LmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVBdWRpb1N0cmVhbT8uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmVlblNoYXJlPy5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHByZXZpb3VzIHB1Ymxpc2hpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1ZGlvU3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoQXVkaW9TdHJlYW0oYXVkaW9TdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9TdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaFZpZGVvU3RyZWFtKHZpZGVvU3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkQ29kZWM6IHRoaXMuY2FtZXJhLnByZWZlcnJlZENvZGVjLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcmVlblNoYXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoU2NyZWVuU2hhcmVTdHJlYW0oc2NyZWVuU2hhcmUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBbUmVqb2luXTogU3RhdGUgcmVzdG9yZWQuIEF0dGVtcHQ6ICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmVjb25uZWN0IGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgdW5leHBlY3RlZGx5LiBleGFtcGxlOlxuICAgICAgICAgICAgLy8gLSBTRlUgY3Jhc2ggb3IgcmVzdGFydFxuICAgICAgICAgICAgLy8gLSBuZXR3b3JrIGNoYW5nZVxuICAgICAgICAgICAgc2Z1Q2xpZW50LnNpZ25hbFJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgdGhlIFwiZ29Bd2F5XCIgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCB1bnJlZ2lzdGVyR29Bd2F5ID0gdGhpcy5kaXNwYXRjaGVyLm9uKCdnb0F3YXknLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWFzb24gfSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBbTWlncmF0aW9uXTogR29pbmcgYXdheSBmcm9tIFNGVS4uLiBSZWFzb246ICR7R29Bd2F5UmVhc29uW3JlYXNvbl19YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdCgnbWlncmF0ZScpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYFtNaWdyYXRpb25dOiBGYWlsZWQgdG8gbWlncmF0ZSB0byBhbm90aGVyIFNGVS5gLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZnVDbGllbnQuc2lnbmFsV3MuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bnJlZ2lzdGVyIHRoZSBcImdvQXdheVwiIGhhbmRsZXIsIGFzIHdlIHdvbid0IG5lZWQgaXQgYW55bW9yZSBmb3IgdGhpcyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdXBjb21pbmcgcmUtam9pbiB3aWxsIHJlZ2lzdGVyIGEgbmV3IGhhbmRsZXIgYW55d2F5XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJHb0F3YXkoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIG9uIHB1cnBvc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gU3RyZWFtU2Z1Q2xpZW50Lk5PUk1BTF9DTE9TVVJFKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVjYXVzZSBvZiBhIHBvbGljeSB2aW9sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiwgdGhlIHVzZXIgaGFzIGJlZW4gYmxvY2tlZCBieSBhbiBhZG1pbiBvciBtb2RlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gS25vd25Db2Rlcy5XU19QT0xJQ1lfVklPTEFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBTRlUgaXMgYmVpbmcgc2h1dCBkb3duLCBpdCBzZW5kcyBhIGdvQXdheSBtZXNzYWdlLlxuICAgICAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBtaWdyYXRlIHRvIGFub3RoZXIgU0ZVLCB3ZSBtaWdodCBoYXZlIHRoZSBXUyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBvbGQgU0ZVIGNsb3NlZCBhYnJ1cHRseS4gSW4gdGhpcyBjYXNlLCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlY29ubmVjdCB0byB0aGUgb2xkIFNGVSwgYnV0IHJhdGhlciB0byB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNNaWdyYXRpbmdBd2F5ID0gZS5jb2RlID09PSBLbm93bkNvZGVzLldTX0NMT1NFRF9BQlJVUFRMWSAmJiBzZnVDbGllbnQuaXNNaWdyYXRpbmdBd2F5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Zhc3RSZWNvbm5lY3RpbmcgPSBlLmNvZGUgPT09IEtub3duQ29kZXMuV1NfQ0xPU0VEX0FCUlVQVExZICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNGYXN0UmVjb25uZWN0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaWdyYXRpbmdBd2F5IHx8IGlzRmFzdFJlY29ubmVjdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlY2F1c2Ugb2YgYSBmYXN0IHJlY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb2RlID09PSBTdHJlYW1TZnVDbGllbnQuRVJST1JfQ09OTkVDVElPTl9CUk9LRU4pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LmlzRmFzdFJlY29ubmVjdGluZyA9IHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IHNmdUNsaWVudC5pc0Zhc3RSZWNvbm5lY3RpbmcgPyAnZmFzdCcgOiAnZnVsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3Qoc3RyYXRlZ3kpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl06ICR7c3RyYXRlZ3l9IHJlam9pbiBmYWlsZWQgZm9yICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gdGltZXMuIEdpdmluZyB1cC5gLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5SRUNPTk5FQ1RJTkdfRkFJTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1tSZWpvaW5dOiBSZWNvbm5lY3QgYXR0ZW1wdHMgZXhjZWVkZWQuIEdpdmluZyB1cC4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUoQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGhhbmRsZXJzIGZvciBjb25uZWN0aW9uIG9ubGluZS9vZmZsaW5lIGV2ZW50c1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVPbmxpbmVFdmVudCA9IHRoaXMuc3RyZWFtQ2xpZW50Lm9uKCdjb25uZWN0aW9uLmNoYW5nZWQnLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgIT09ICdjb25uZWN0aW9uLmNoYW5nZWQnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFlLm9ubGluZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlT25saW5lRXZlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2FsbGluZ1N0YXRlID0gdGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVjb25uZWN0ID0gY3VycmVudENhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLk9GRkxJTkUgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLlJFQ09OTkVDVElOR19GQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSZWNvbm5lY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdbUmVqb2luXTogR29pbmcgb25saW5lLi4uJyk7XG4gICAgICAgICAgICAgICAgbGV0IGlzRmlyc3RSZWNvbm5lY3RBdHRlbXB0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZnVDbGllbnQuaXNGYXN0UmVjb25uZWN0aW5nID0gaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZWNvbm5lY3QoaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQgPyAnZmFzdCcgOiAnZnVsbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBicmVhayB0aGUgbG9vcCBpZiByZWpvaW4gaXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBbUmVqb2luXVtOZXR3b3JrXTogUmVqb2luIGZhaWxlZCBmb3IgYXR0ZW1wdCAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBhIGJpdCBiZWZvcmUgdHJ5aW5nIHRvIHJlY29ubmVjdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpKTtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaGVyZSwgaXQgbWVhbnMgdGhhdCB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHRoZSByZWNvbm5lY3QgYXR0ZW1wdHNcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgW1Jlam9pbl1bTmV0d29ya106IFJlam9pbiBmYWlsZWQuIEdpdmluZyB1cC5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldENhbGxpbmdTdGF0ZShDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlT2ZmbGluZUV2ZW50ID0gdGhpcy5zdHJlYW1DbGllbnQub24oJ2Nvbm5lY3Rpb24uY2hhbmdlZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSAhPT0gJ2Nvbm5lY3Rpb24uY2hhbmdlZCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZS5vbmxpbmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5PRkZMSU5FKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlT25saW5lRXZlbnQoKTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU9mZmxpbmVFdmVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKHtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyOiB0aGlzLmRpc3BhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXVkaW9TZXR0aW5ncyA9IHRoaXMuc3RhdGUuc2V0dGluZ3M/LmF1ZGlvO1xuICAgICAgICAgICAgY29uc3QgaXNEdHhFbmFibGVkID0gISFhdWRpb1NldHRpbmdzPy5vcHVzX2R0eF9lbmFibGVkO1xuICAgICAgICAgICAgY29uc3QgaXNSZWRFbmFibGVkID0gISFhdWRpb1NldHRpbmdzPy5yZWR1bmRhbnRfY29kaW5nX2VuYWJsZWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHVibGlzaGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSBuZXcgUHVibGlzaGVyKHtcbiAgICAgICAgICAgICAgICAgICAgc2Z1Q2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVyOiB0aGlzLmRpc3BhdGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBpc0R0eEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGlzUmVkRW5hYmxlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0c1JlcG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0c1JlcG9ydGVyID0gY3JlYXRlU3RhdHNSZXBvcnRlcih7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXI6IHRoaXMuc3Vic2NyaWJlcixcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVyOiB0aGlzLnB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIDEuIHdhaXQgZm9yIHRoZSBzaWduYWwgc2VydmVyIHRvIGJlIHJlYWR5IGJlZm9yZSBzZW5kaW5nIFwiam9pblJlcXVlc3RcIlxuICAgICAgICAgICAgICAgIHNmdUNsaWVudC5zaWduYWxSZWFkeVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1NpZ25hbCByZWFkeSBmYWlsZWQnLCBlcnIpKVxuICAgICAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIGEgZ2VuZXJpYyBTRFAgYW5kIHNlbmQgaXQgdG8gdGhlIFNGVS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHRocm93LWF3YXkgU0RQIHRoYXQgdGhlIFNGVSB3aWxsIHVzZSB0byBkZXRlcm1pbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgY2xpZW50IChjb2RlYyBzdXBwb3J0LCBldGMuKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiBnZXRHZW5lcmljU2RwKCdyZWN2b25seScpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoc2RwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBnZXRDdXJyZW50VmFsdWUodGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlncmF0aW9uID0gaXNNaWdyYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21TZnVJZDogZGF0YT8ubWlncmF0aW5nX2Zyb20gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogc3Vic2NyaXB0aW9ucy5kYXRhIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm91bmNlZFRyYWNrczogdGhpcy5wdWJsaXNoZXI/LmdldEN1cnJlbnRUcmFja0luZm9zKCkgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNmdUNsaWVudC5qb2luKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJTZHA6IHNkcCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudERldGFpbHM6IGdldENsaWVudERldGFpbHMoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZ3JhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhc3RSZWNvbm5lY3Q6IHByZXZpb3VzU2Z1Q2xpZW50Py5pc0Zhc3RSZWNvbm5lY3RpbmcgPz8gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIDIuIGluIHBhcmFsbGVsLCB3YWl0IGZvciB0aGUgU0ZVIHRvIHNlbmQgdXMgdGhlIFwiam9pblJlc3BvbnNlXCJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIFNGVSByZWplY3RzIHRoZSBqb2luIHJlcXVlc3Qgb3JcbiAgICAgICAgICAgICAgICAvLyBmYWlscyB0byByZXNwb25kIGluIHRpbWVcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhbGxTdGF0ZSwgcmVjb25uZWN0ZWQgfSA9IGF3YWl0IHRoaXMud2FpdEZvckpvaW5SZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCAnW1Jlam9pbl0gZmFzdCByZWNvbm5lY3RlZDonLCByZWNvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc01pZ3JhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIubWlncmF0ZVRvKHNmdUNsaWVudCwgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLm1pZ3JhdGVUbyhzZnVDbGllbnQsIGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgU0ZVIGNsaWVudCBpbnN0YW5jZSBvbiB0aGUgc3Vic2NyaWJlciBhbmQgcHVibGlzaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuc2V0U2Z1Q2xpZW50KHNmdUNsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5zZXRTZnVDbGllbnQoc2Z1Q2xpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwZXJmb3JtIGEgZnVsbCBJQ0UgcmVzdGFydCBvbiB0aGUgcHVibGlzaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5yZXN0YXJ0SWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldmlvdXNTZnVDbGllbnQ/LmlzRmFzdFJlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb25uZWN0aW9uIHdhc24ndCBwb3NzaWJsZSwgc28gd2UgbmVlZCB0byBkbyBhIGZ1bGwgcmVqb2luXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVjb25uZWN0KCdmdWxsJykuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsIGBbUmVqb2luXTogUmVqb2luIGZhaWxlZCBmb3JjZWQgZnVsbCByZWpvaW4uYCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0aWNpcGFudHMgPSBjYWxsU3RhdGU/LnBhcnRpY2lwYW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudENvdW50ID0gY2FsbFN0YXRlPy5wYXJ0aWNpcGFudENvdW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IGNhbGxTdGF0ZT8uc3RhcnRlZEF0XG4gICAgICAgICAgICAgICAgICAgID8gVGltZXN0YW1wLnRvRGF0ZShjYWxsU3RhdGUuc3RhcnRlZEF0KVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGlucyA9IGNhbGxTdGF0ZT8ucGlucyA/PyBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldFBhcnRpY2lwYW50cygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50TG9va3VwID0gdGhpcy5zdGF0ZS5nZXRQYXJ0aWNpcGFudExvb2t1cEJ5U2Vzc2lvbklkKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UGFydGljaXBhbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgbG9jYWwgc3RhdGUgb2YgdGhlIHBhcnRpY2lwYW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoZS5nLiB2aWRlb0RpbWVuc2lvbiwgdmlzaWJpbGl0eVN0YXRlLCBwaW5uZWRBdCwgZXRjLilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIGl0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUGFydGljaXBhbnQgPSBwYXJ0aWNpcGFudExvb2t1cFtwLnNlc3Npb25JZF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwLCBleGlzdGluZ1BhcnRpY2lwYW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFBhcnRpY2lwYW50OiBwLnNlc3Npb25JZCA9PT0gc2Z1Q2xpZW50LnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZTogZXhpc3RpbmdQYXJ0aWNpcGFudD8udmlld3BvcnRWaXNpYmlsaXR5U3RhdGUgPz8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1RyYWNrOiBWaXNpYmlsaXR5U3RhdGUuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hhcmVUcmFjazogVmlzaWJpbGl0eVN0YXRlLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldFBhcnRpY2lwYW50Q291bnQocGFydGljaXBhbnRDb3VudD8udG90YWwgfHwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50KHBhcnRpY2lwYW50Q291bnQ/LmFub255bW91cyB8fCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldFN0YXJ0ZWRBdChzdGFydGVkQXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0U2VydmVyU2lkZVBpbnMocGlucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7IC8vIHJlc2V0IHRoZSByZWNvbm5lY3QgYXR0ZW1wdHMgY291bnRlclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5KT0lORUQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdENhbWVyYSh7IHNldFN0YXR1czogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0TWljKHsgc2V0U3RhdHVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ3dhcm4nLCAnQ2FtZXJhIGFuZC9vciBtaWMgaW5pdCBmYWlsZWQgZHVyaW5nIGpvaW4gY2FsbCcsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMy4gb25jZSB3ZSBoYXZlIHRoZSBcImpvaW5SZXNwb25zZVwiLCBhbmQgcG9zc2libHkgcmVjb25jaWxlZCB0aGUgbG9jYWwgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyB3ZSBzY2hlZHVsZSBhIGZhc3Qgc3Vic2NyaXB0aW9uIHVwZGF0ZSBmb3IgYWxsIHJlbW90ZSBwYXJ0aWNpcGFudHNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlcmUgdmlzaWJsZSBiZWZvcmUgd2UgcmVjb25uZWN0ZWQgb3IgbWlncmF0ZWQgdG8gYSBuZXcgU0ZVLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlUGFydGljaXBhbnRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVQYXJ0aWNpcGFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMocmVtb3RlUGFydGljaXBhbnRzLCBEZWJvdW5jZVR5cGUuRkFTVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYEpvaW5lZCBjYWxsICR7dGhpcy5jaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gam9pbiBmYWlsZWQsIHRyeSB0byByZWpvaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA8IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFtSZWpvaW5dOiBSZWpvaW4gJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBmYWlsZWQuYCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYFtSZWpvaW5dOiBSZWpvaW4gJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfSBzdWNjZXNzZnVsIWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFtSZWpvaW5dOiBSZWpvaW4gZmFpbGVkIGZvciAke3RoaXMucmVjb25uZWN0QXR0ZW1wdHN9IHRpbWVzLiBHaXZpbmcgdXAuYCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5SRUNPTk5FQ1RJTkdfRkFJTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKb2luIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53YWl0Rm9ySm9pblJlc3BvbnNlID0gKHRpbWVvdXQgPSA1MDAwKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbignam9pblJlc3BvbnNlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignV2FpdGluZyBmb3IgXCJqb2luUmVzcG9uc2VcIiBoYXMgdGltZWQgb3V0JykpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdmlkZW8gc3RyZWFtIHRvIHRoZSBjYWxsLlxuICAgICAgICAgKiBUaGUgc3RyZWFtIHdpbGwgYmUgc3RvcHBlZCBpZiB0aGUgdXNlciBjaGFuZ2VzIGFuIGlucHV0IGRldmljZSwgb3IgaWYgdGhlIHVzZXIgbGVhdmVzIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb25zZWN1dGl2ZSBjYWxscyB0byB0aGlzIG1ldGhvZCB3aWxsIHJlcGxhY2UgdGhlIHByZXZpb3VzbHkgcHVibGlzaGVkIHN0cmVhbS5cbiAgICAgICAgICogVGhlIHByZXZpb3VzIHZpZGVvIHN0cmVhbSB3aWxsIGJlIHN0b3BwZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB2aWRlb1N0cmVhbSB0aGUgdmlkZW8gc3RyZWFtIHRvIHB1Ymxpc2guXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIHB1Ymxpc2hpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHVibGlzaFZpZGVvU3RyZWFtID0gYXN5bmMgKHZpZGVvU3RyZWFtLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCB3YWl0IHVudGlsIHdlIGdldCBhIEpvaW5SZXNwb25zZSBmcm9tIHRoZSBTRlUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgcmlzayBicmVha2luZyB0aGUgSUNFVHJpY2tsZSBmbG93LlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRDYWxsSm9pbmVkKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHVibGlzaGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1RyeWluZyB0byBwdWJsaXNoIHZpZGVvIGJlZm9yZSBqb2luIGlzIGNvbXBsZXRlZCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCBub3Qgam9pbmVkIHlldC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt2aWRlb1RyYWNrXSA9IHZpZGVvU3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgICAgICBpZiAoIXZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgVGhlcmUgaXMgbm8gdmlkZW8gdHJhY2sgdG8gcHVibGlzaCBpbiB0aGUgc3RyZWFtLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLnB1Ymxpc2hTdHJlYW0odmlkZW9TdHJlYW0sIHZpZGVvVHJhY2ssIFRyYWNrVHlwZS5WSURFTywgb3B0cyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gYXVkaW8gc3RyZWFtIHRvIHRoZSBjYWxsLlxuICAgICAgICAgKiBUaGUgc3RyZWFtIHdpbGwgYmUgc3RvcHBlZCBpZiB0aGUgdXNlciBjaGFuZ2VzIGFuIGlucHV0IGRldmljZSwgb3IgaWYgdGhlIHVzZXIgbGVhdmVzIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb25zZWN1dGl2ZSBjYWxscyB0byB0aGlzIG1ldGhvZCB3aWxsIHJlcGxhY2UgdGhlIGF1ZGlvIHN0cmVhbSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwdWJsaXNoZWQuXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBhdWRpbyBzdHJlYW0gd2lsbCBiZSBzdG9wcGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYXVkaW9TdHJlYW0gdGhlIGF1ZGlvIHN0cmVhbSB0byBwdWJsaXNoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wdWJsaXNoQXVkaW9TdHJlYW0gPSBhc3luYyAoYXVkaW9TdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCB3YWl0IHVudGlsIHdlIGdldCBhIEpvaW5SZXNwb25zZSBmcm9tIHRoZSBTRlUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgcmlzayBicmVha2luZyB0aGUgSUNFVHJpY2tsZSBmbG93LlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRDYWxsSm9pbmVkKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHVibGlzaGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1RyeWluZyB0byBwdWJsaXNoIGF1ZGlvIGJlZm9yZSBqb2luIGlzIGNvbXBsZXRlZCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FsbCBub3Qgam9pbmVkIHlldC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFthdWRpb1RyYWNrXSA9IGF1ZGlvU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7XG4gICAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgVGhlcmUgaXMgbm8gYXVkaW8gdHJhY2sgaW4gdGhlIHN0cmVhbSB0byBwdWJsaXNoYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIucHVibGlzaFN0cmVhbShhdWRpb1N0cmVhbSwgYXVkaW9UcmFjaywgVHJhY2tUeXBlLkFVRElPKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBwdWJsaXNoaW5nIHRoZSBnaXZlbiBzY3JlZW4tc2hhcmUgc3RyZWFtIHRvIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBDb25zZWN1dGl2ZSBjYWxscyB0byB0aGlzIG1ldGhvZCB3aWxsIHJlcGxhY2UgdGhlIHByZXZpb3VzIHNjcmVlbi1zaGFyZSBzdHJlYW0uXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBzY3JlZW4tc2hhcmUgc3RyZWFtIHdpbGwgYmUgc3RvcHBlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNjcmVlblNoYXJlU3RyZWFtIHRoZSBzY3JlZW4tc2hhcmUgc3RyZWFtIHRvIHB1Ymxpc2guXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIHRoZSBvcHRpb25zIHRvIHVzZSB3aGVuIHB1Ymxpc2hpbmcgdGhlIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHVibGlzaFNjcmVlblNoYXJlU3RyZWFtID0gYXN5bmMgKHNjcmVlblNoYXJlU3RyZWFtLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCB3YWl0IHVudGlsIHdlIGdldCBhIEpvaW5SZXNwb25zZSBmcm9tIHRoZSBTRlUsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgcmlzayBicmVha2luZyB0aGUgSUNFVHJpY2tsZSBmbG93LlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRDYWxsSm9pbmVkKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHVibGlzaGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgJ1RyeWluZyB0byBwdWJsaXNoIHNjcmVlbiBzaGFyZSBiZWZvcmUgam9pbiBpcyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgbm90IGpvaW5lZCB5ZXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbc2NyZWVuU2hhcmVUcmFja10gPSBzY3JlZW5TaGFyZVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICAgICAgaWYgKCFzY3JlZW5TaGFyZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYFRoZXJlIGlzIG5vIHZpZGVvIHRyYWNrIGluIHRoZSBzY3JlZW4gc2hhcmUgc3RyZWFtIHRvIHB1Ymxpc2hgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoU3RyZWFtKHNjcmVlblNoYXJlU3RyZWFtLCBzY3JlZW5TaGFyZVRyYWNrLCBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLCBvcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IFtzY3JlZW5TaGFyZUF1ZGlvVHJhY2tdID0gc2NyZWVuU2hhcmVTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICAgICAgICAgIGlmIChzY3JlZW5TaGFyZUF1ZGlvVHJhY2spIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoU3RyZWFtKHNjcmVlblNoYXJlU3RyZWFtLCBzY3JlZW5TaGFyZUF1ZGlvVHJhY2ssIFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8sIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgcHVibGlzaGluZyB0aGUgZ2l2ZW4gdHJhY2sgdHlwZSB0byB0aGUgY2FsbCwgaWYgaXQgaXMgY3VycmVudGx5IGJlaW5nIHB1Ymxpc2hlZC5cbiAgICAgICAgICogVW5kZXJseWluZyB0cmFjayB3aWxsIGJlIHN0b3BwZWQgYW5kIHJlbW92ZWQgZnJvbSB0aGUgcHVibGlzaGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSB0cmFjayB0eXBlIHRvIHN0b3AgcHVibGlzaGluZy5cbiAgICAgICAgICogQHBhcmFtIHN0b3BUcmFjayBpZiBgdHJ1ZWAgdGhlIHRyYWNrIHdpbGwgYmUgc3RvcHBlZCwgZWxzZSBpdCB3aWxsIGJlIGp1c3QgZGlzYWJsZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcFB1Ymxpc2ggPSBhc3luYyAodHJhY2tUeXBlLCBzdG9wVHJhY2sgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsIGBzdG9wUHVibGlzaCAke1RyYWNrVHlwZVt0cmFja1R5cGVdfSwgc3RvcCB0cmFja3M6ICR7c3RvcFRyYWNrfWApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXI/LnVucHVibGlzaFN0cmVhbSh0cmFja1R5cGUsIHN0b3BUcmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdHJhY2sgc3Vic2NyaXB0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIG9uZSBvciBtb3JlIHBhcnRpY2lwYW50cy5cbiAgICAgICAgICogWW91IGhhdmUgdG8gY3JlYXRlIGEgc3Vic2NyaXB0aW9uIGZvciBlYWNoIHBhcnRpY2lwYW50IGZvciBhbGwgdGhlIGRpZmZlcmVudCBraW5kcyBvZiB0cmFja3MgeW91IHdhbnQgdG8gcmVjZWl2ZS5cbiAgICAgICAgICogWW91IGNhbiBvbmx5IHN1YnNjcmliZSBmb3IgdHJhY2tzIGFmdGVyIHRoZSBwYXJ0aWNpcGFudCBzdGFydGVkIHB1Ymxpc2hpbmcgdGhlIGdpdmVuIGtpbmQgb2YgdHJhY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0cmFja1R5cGUgdGhlIGtpbmQgb2Ygc3Vic2NyaXB0aW9uIHRvIHVwZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIGNoYW5nZXMgdGhlIGxpc3Qgb2Ygc3Vic2NyaXB0aW9uIGNoYW5nZXMgdG8gZG8uXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSBkZWJvdW5jZSB0eXBlIHRvIHVzZSBmb3IgdGhlIHVwZGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWwgPSAodHJhY2tUeXBlLCBjaGFuZ2VzLCB0eXBlID0gRGVib3VuY2VUeXBlLlNMT1cpID0+IHtcbiAgICAgICAgICAgIGlmICh0cmFja1R5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignd2FybicsIGB1cGRhdGVTdWJzY3JpcHRpb25zUGFydGlhbDogJHt0cmFja1R5cGV9IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBzd2l0Y2ggdG8gJ3ZpZGVvVHJhY2snYCk7XG4gICAgICAgICAgICAgICAgdHJhY2tUeXBlID0gJ3ZpZGVvVHJhY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2tUeXBlID09PSAnc2NyZWVuJykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgYHVwZGF0ZVN1YnNjcmlwdGlvbnNQYXJ0aWFsOiAke3RyYWNrVHlwZX0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHN3aXRjaCB0byAnc2NyZWVuU2hhcmVUcmFjaydgKTtcbiAgICAgICAgICAgICAgICB0cmFja1R5cGUgPSAnc2NyZWVuU2hhcmVUcmFjayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50cyhPYmplY3QuZW50cmllcyhjaGFuZ2VzKS5yZWR1Y2UoKGFjYywgW3Nlc3Npb25JZCwgY2hhbmdlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UuZGltZW5zaW9uPy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRpbWVuc2lvbi5oZWlnaHQgPSBNYXRoLmNlaWwoY2hhbmdlLmRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLmRpbWVuc2lvbj8ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlLmRpbWVuc2lvbi53aWR0aCA9IE1hdGguY2VpbChjaGFuZ2UuZGltZW5zaW9uLndpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snXG4gICAgICAgICAgICAgICAgICAgID8gJ3ZpZGVvRGltZW5zaW9uJ1xuICAgICAgICAgICAgICAgICAgICA6IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlVHJhY2snXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdzY3JlZW5TaGFyZURpbWVuc2lvbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1tzZXNzaW9uSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3Byb3BdOiBjaGFuZ2UuZGltZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pKTtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMocGFydGljaXBhbnRzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zID0gKHBhcnRpY2lwYW50cywgdHlwZSA9IERlYm91bmNlVHlwZS5TTE9XKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGFydGljaXBhbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzdWJzY3JpYmUgdG8gb3VyIG93biB0cmFja3NcbiAgICAgICAgICAgICAgICBpZiAocC5pc0xvY2FsUGFydGljaXBhbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGF1ZGlvIHRyYWNrcyBkb24ndCBoYXZlIHRvIGJlIHJlcXVlc3RlZCBleHBsaWNpdGx5XG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIFNGVSB3aWxsIGltcGxpY2l0bHkgc3Vic2NyaWJlIHVzIHRvIGFsbCBvZiB0aGVtLFxuICAgICAgICAgICAgICAgIC8vIG9uY2UgdGhleSBiZWNvbWUgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGlmIChwLnZpZGVvRGltZW5zaW9uICYmIHAucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFRyYWNrVHlwZS5WSURFTykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZDogcC51c2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHAuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUeXBlOiBUcmFja1R5cGUuVklERU8sXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246IHAudmlkZW9EaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocC5zY3JlZW5TaGFyZURpbWVuc2lvbiAmJlxuICAgICAgICAgICAgICAgICAgICBwLnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhUcmFja1R5cGUuU0NSRUVOX1NIQVJFKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkOiBwLnVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcC5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1R5cGU6IFRyYWNrVHlwZS5TQ1JFRU5fU0hBUkUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246IHAuc2NyZWVuU2hhcmVEaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZDogcC51c2VySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHAuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUeXBlOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzY2hlZHVsZSB1cGRhdGVcbiAgICAgICAgICAgIHRoaXMudHJhY2tTdWJzY3JpcHRpb25zU3ViamVjdC5uZXh0KHsgdHlwZSwgZGF0YTogc3Vic2NyaXB0aW9ucyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgZW5oYW5jZSB0aGUgcmVwb3J0ZWQgc3RhdHMgd2l0aCBhZGRpdGlvbmFsIHBhcnRpY2lwYW50LXNwZWNpZmljIGluZm9ybWF0aW9uIChgY2FsbFN0YXRzUmVwb3J0JGAgc3RhdGUgW3N0b3JlIHZhcmlhYmxlXSguL1N0cmVhbVZpZGVvQ2xpZW50Lm1kLyNyZWFkb25seXN0YXRlc3RvcmUpKS5cbiAgICAgICAgICogVGhpcyBpcyB1c3VhbGx5IGhlbHBmdWwgd2hlbiBkZXRhaWxlZCBzdGF0cyBmb3IgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudCBhcmUgbmVlZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uSWQgdG8gc3RhcnQgcmVwb3J0aW5nIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRSZXBvcnRpbmdTdGF0c0ZvciA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRzUmVwb3J0ZXI/LnN0YXJ0UmVwb3J0aW5nU3RhdHNGb3Ioc2Vzc2lvbklkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wcG9zaXRlIG9mIGBzdGFydFJlcG9ydGluZ1N0YXRzRm9yYC5cbiAgICAgICAgICogV2lsbCB0dXJuIG9mZiBzdGF0cyByZXBvcnRpbmcgZm9yIGEgc3BlY2lmaWMgcGFydGljaXBhbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb25JZCB0byBzdG9wIHJlcG9ydGluZyBmb3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BSZXBvcnRpbmdTdGF0c0ZvciA9IChzZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRzUmVwb3J0ZXI/LnN0b3BSZXBvcnRpbmdTdGF0c0ZvcihzZXNzaW9uSWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSBsYXN0IHNlbnQgcmVhY3Rpb24gZm9yIHRoZSB1c2VyIGhvbGRpbmcgdGhlIGdpdmVuIGBzZXNzaW9uSWRgLiBUaGlzIGlzIGEgbG9jYWwgYWN0aW9uLCBpdCB3b24ndCByZXNldCB0aGUgcmVhY3Rpb24gb24gdGhlIGJhY2tlbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb24gaWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0UmVhY3Rpb24gPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwge1xuICAgICAgICAgICAgICAgIHJlYWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGxpc3Qgb2YgY3JpdGVyaWEgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzIGJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gY3JpdGVyaWEgdGhlIGxpc3Qgb2YgY3JpdGVyaWEgdG8gc29ydCB0aGUgcGFydGljaXBhbnRzIGJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRTb3J0UGFydGljaXBhbnRzQnkgPSAoY3JpdGVyaWEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNldFNvcnRQYXJ0aWNpcGFudHNCeShjcml0ZXJpYSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBsaXN0IG9mIHZpZGVvIGxheWVycyB0byBwdWJsaXNoLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIGVuYWJsZWRMYXllcnMgdGhlIGxpc3Qgb2YgbGF5ZXJzIHRvIGVuYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlUHVibGlzaFF1YWxpdHkgPSBhc3luYyAoZW5hYmxlZExheWVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyPy51cGRhdGVWaWRlb1B1Ymxpc2hRdWFsaXR5KGVuYWJsZWRMYXllcnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFzc2VydENhbGxKb2luZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxpbmdTdGF0ZSRcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKChzdGF0ZSkgPT4gc3RhdGUgIT09IENhbGxpbmdTdGF0ZS5KT0lORUQsIHRydWUpLCBmaWx0ZXIoKHMpID0+IHMgPT09IENhbGxpbmdTdGF0ZS5KT0lORUQpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmRzIGEgcmVhY3Rpb24gdG8gdGhlIG90aGVyIGNhbGwgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVhY3Rpb24gdGhlIHJlYWN0aW9uIHRvIHNlbmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRSZWFjdGlvbiA9IGFzeW5jIChyZWFjdGlvbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vcmVhY3Rpb25gLCByZWFjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9ja3MgdGhlIHVzZXIgd2l0aCB0aGUgZ2l2ZW4gYHVzZXJJZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyIHRvIGJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1VzZXIgPSBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9ibG9ja2AsIHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmxvY2tzIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIGB1c2VySWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byB1bmJsb2NrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmJsb2NrVXNlciA9IGFzeW5jICh1c2VySWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3VuYmxvY2tgLCB7XG4gICAgICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXRlcyB0aGUgY3VycmVudCB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11dGVTZWxmID0gKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG15VXNlcklkID0gdGhpcy5jdXJyZW50VXNlcklkO1xuICAgICAgICAgICAgaWYgKG15VXNlcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXV0ZVVzZXIobXlVc2VySWQsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTXV0ZXMgYWxsIHRoZSBvdGhlciBwYXJ0aWNpcGFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBtdXRlIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubXV0ZU90aGVycyA9ICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFja1R5cGUgPSBtdXRlVHlwZVRvVHJhY2tUeXBlKHR5cGUpO1xuICAgICAgICAgICAgaWYgKCF0cmFja1R5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdXNlcklkc1RvTXV0ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0aWNpcGFudCBvZiB0aGlzLnN0YXRlLnJlbW90ZVBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXModHJhY2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VySWRzVG9NdXRlLnB1c2gocGFydGljaXBhbnQudXNlcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdXRlVXNlcih1c2VySWRzVG9NdXRlLCB0eXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11dGVzIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIGB1c2VySWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBtdXRlLlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11dGVVc2VyID0gKHVzZXJJZCwgdHlwZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbXV0ZV91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkczogQXJyYXkuaXNBcnJheSh1c2VySWQpID8gdXNlcklkIDogW3VzZXJJZF0sXG4gICAgICAgICAgICAgICAgW3R5cGVdOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIG11dGUgYWxsIHVzZXJzIGluIHRoZSBjYWxsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgbXV0ZSBvcGVyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11dGVBbGxVc2VycyA9ICh0eXBlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9tdXRlX3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIG11dGVfYWxsX3VzZXJzOiB0cnVlLFxuICAgICAgICAgICAgICAgIFt0eXBlXTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHJlY29yZGluZyB0aGUgY2FsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFJlY29yZGluZyA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS9zdGFydF9yZWNvcmRpbmdgLCByZXF1ZXN0ID8gcmVxdWVzdCA6IHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3BzIHJlY29yZGluZyB0aGUgY2FsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RvcF9yZWNvcmRpbmdgLCB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kcyBhIGBjYWxsLnBlcm1pc3Npb25fcmVxdWVzdGAgZXZlbnQgdG8gYWxsIHVzZXJzIGNvbm5lY3RlZCB0byB0aGUgY2FsbC4gVGhlIGNhbGwgc2V0dGluZ3Mgb2JqZWN0IGNvbnRhaW5zIGluZm9tcmF0aW9uIGFib3V0IHdoaWNoIHBlcm1pc3Npb25zIGNhbiBiZSByZXF1ZXN0ZWQgZHVyaW5nIGEgY2FsbCAoZm9yIGV4YW1wbGUgYSB1c2VyIG1pZ2h0IGJlIGFsbG93ZWQgdG8gcmVxdWVzdCBwZXJtaXNzaW9uIHRvIHB1Ymxpc2ggYXVkaW8sIGJ1dCBub3QgdmlkZW8pLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1ZXN0UGVybWlzc2lvbnMgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNhblJlcXVlc3RQZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zLmV2ZXJ5KChwZXJtaXNzaW9uKSA9PiB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5jYW5SZXF1ZXN0KHBlcm1pc3Npb24pKTtcbiAgICAgICAgICAgIGlmICghY2FuUmVxdWVzdFBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIHJlcXVlc3QgcGVybWlzc2lvbnM6ICR7cGVybWlzc2lvbnMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3JlcXVlc3RfcGVybWlzc2lvbmAsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHlvdSB0byBncmFudCBjZXJ0YWluIHBlcm1pc3Npb25zIHRvIGEgdXNlciBpbiBhIGNhbGwuXG4gICAgICAgICAqIFRoZSBwZXJtaXNzaW9ucyBhcmUgc3BlY2lmaWMgdG8gdGhlIGNhbGwgZXhwZXJpZW5jZSBhbmQgZG8gbm90IHN1cnZpdmUgdGhlIGNhbGwgaXRzZWxmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTdXBwb3J0ZWQgcGVybWlzc2lvbnMgdGhhdCBjYW4gYmUgZ3JhbnRlZCBhcmU6XG4gICAgICAgICAqIC0gYHNlbmQtYXVkaW9gXG4gICAgICAgICAqIC0gYHNlbmQtdmlkZW9gXG4gICAgICAgICAqIC0gYHNjcmVlbnNoYXJlYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlcklkIHRoZSBpZCBvZiB0aGUgdXNlciB0byBncmFudCBwZXJtaXNzaW9ucyB0by5cbiAgICAgICAgICogQHBhcmFtIHBlcm1pc3Npb25zIHRoZSBwZXJtaXNzaW9ucyB0byBncmFudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhbnRQZXJtaXNzaW9ucyA9IGFzeW5jICh1c2VySWQsIHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBncmFudF9wZXJtaXNzaW9uczogcGVybWlzc2lvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gcmV2b2tlIGNlcnRhaW4gcGVybWlzc2lvbnMgZnJvbSBhIHVzZXIgaW4gYSBjYWxsLlxuICAgICAgICAgKiBUaGUgcGVybWlzc2lvbnMgYXJlIHNwZWNpZmljIHRvIHRoZSBjYWxsIGV4cGVyaWVuY2UgYW5kIGRvIG5vdCBzdXJ2aXZlIHRoZSBjYWxsIGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIHJldm9rZWQgYXJlOlxuICAgICAgICAgKiAtIGBzZW5kLWF1ZGlvYFxuICAgICAgICAgKiAtIGBzZW5kLXZpZGVvYFxuICAgICAgICAgKiAtIGBzY3JlZW5zaGFyZWBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVzZXJJZCB0aGUgaWQgb2YgdGhlIHVzZXIgdG8gcmV2b2tlIHBlcm1pc3Npb25zIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSBwZXJtaXNzaW9ucyB0aGUgcGVybWlzc2lvbnMgdG8gcmV2b2tlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXZva2VQZXJtaXNzaW9ucyA9IGFzeW5jICh1c2VySWQsIHBlcm1pc3Npb25zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVVc2VyUGVybWlzc2lvbnMoe1xuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICByZXZva2VfcGVybWlzc2lvbnM6IHBlcm1pc3Npb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgeW91IHRvIGdyYW50IG9yIHJldm9rZSBhIHNwZWNpZmljIHBlcm1pc3Npb24gdG8gYSB1c2VyIGluIGEgY2FsbC4gVGhlIHBlcm1pc3Npb25zIGFyZSBzcGVjaWZpYyB0byB0aGUgY2FsbCBleHBlcmllbmNlIGFuZCBkbyBub3Qgc3Vydml2ZSB0aGUgY2FsbCBpdHNlbGYuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gcmV2b2tpbmcgYSBwZXJtaXNzaW9uLCB0aGlzIGVuZHBvaW50IHdpbGwgYWxzbyBtdXRlIHRoZSByZWxldmFudCB0cmFjayBmcm9tIHRoZSB1c2VyLiBUaGlzIGlzIHNpbWlsYXIgdG8gbXV0aW5nIGEgdXNlciB3aXRoIHRoZSBkaWZmZXJlbmNlIHRoYXQgdGhlIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byB1bm11dGUgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICpcbiAgICAgICAgICogU3VwcG9ydGVkIHBlcm1pc3Npb25zIHRoYXQgY2FuIGJlIGdyYW50ZWQgb3IgcmV2b2tlZDogYHNlbmQtYXVkaW9gLCBgc2VuZC12aWRlb2AgYW5kIGBzY3JlZW5zaGFyZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWRgIGV2ZW50IGlzIHNlbnQgdG8gYWxsIG1lbWJlcnMgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS91c2VyX3Blcm1pc3Npb25zYCwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdGhlIGxpdmVzdHJlYW1pbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSByZXF1ZXN0IGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgdGhlIHJlcXVlc3QgcGFyYW1zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nb0xpdmUgPSBhc3luYyAoZGF0YSA9IHt9LCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L2dvX2xpdmVgLCBkYXRhLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGxpdmVzdHJlYW1pbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BMaXZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RvcF9saXZlYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRzIHRoZSBicm9hZGNhc3Rpbmcgb2YgdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0SExTID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vc3RhcnRfYnJvYWRjYXN0aW5nYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcHMgdGhlIGJyb2FkY2FzdGluZyBvZiB0aGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcEhMUyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3N0b3BfYnJvYWRjYXN0aW5nYCwge30pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgY2FsbCBzZXR0aW5ncyBvciBjdXN0b20gZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVwZGF0ZXMgdGhlIHVwZGF0ZXMgdG8gYXBwbHkgdG8gdGhlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IGFzeW5jICh1cGRhdGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBhdGNoKGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9YCwgdXBkYXRlcyk7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGwsIG1lbWJlcnMsIG93bl9jYXBhYmlsaXRpZXMgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRNZW1iZXJzKG1lbWJlcnMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMob3duX2NhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmRzIHRoZSBjYWxsLiBPbmNlIHRoZSBjYWxsIGlzIGVuZGVkLCBpdCBjYW5ub3QgYmUgcmUtam9pbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmRDYWxsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbWFya19lbmRlZGApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGlucyB0aGUgZ2l2ZW4gc2Vzc2lvbiB0byB0aGUgdG9wIG9mIHRoZSBwYXJ0aWNpcGFudHMgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbklkIHRvIHBpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGluID0gKHNlc3Npb25JZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVQYXJ0aWNpcGFudChzZXNzaW9uSWQsIHtcbiAgICAgICAgICAgICAgICBwaW46IHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2NhbFBpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGlubmVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5waW5zIHRoZSBnaXZlbiBzZXNzaW9uIGZyb20gdGhlIHRvcCBvZiB0aGUgcGFydGljaXBhbnRzIGxpc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzZXNzaW9uSWQgdGhlIHNlc3Npb25JZCB0byB1bnBpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5waW4gPSAoc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZVBhcnRpY2lwYW50KHNlc3Npb25JZCwge1xuICAgICAgICAgICAgICAgIHBpbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQaW5zIHRoZSBnaXZlbiBzZXNzaW9uIHRvIHRoZSB0b3Agb2YgdGhlIHBhcnRpY2lwYW50cyBsaXN0IGZvciBldmVyeW9uZVxuICAgICAgICAgKiBpbiB0aGUgY2FsbC5cbiAgICAgICAgICogWW91IGNhbiBleGVjdXRlIHRoaXMgbWV0aG9kIG9ubHkgaWYgeW91IGhhdmUgdGhlIGBwaW4tZm9yLWV2ZXJ5b25lYCBjYXBhYmlsaXR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBpbkZvckV2ZXJ5b25lID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KGAke3RoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGh9L3BpbmAsIHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5waW5zIHRoZSBnaXZlbiBzZXNzaW9uIGZyb20gdGhlIHRvcCBvZiB0aGUgcGFydGljaXBhbnRzIGxpc3QgZm9yIGV2ZXJ5b25lXG4gICAgICAgICAqIGluIHRoZSBjYWxsLlxuICAgICAgICAgKiBZb3UgY2FuIGV4ZWN1dGUgdGhpcyBtZXRob2Qgb25seSBpZiB5b3UgaGF2ZSB0aGUgYHBpbi1mb3ItZXZlcnlvbmVgIGNhcGFiaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0IHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5waW5Gb3JFdmVyeW9uZSA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdChgJHt0aGlzLnN0cmVhbUNsaWVudEJhc2VQYXRofS91bnBpbmAsIHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgY2FsbCBtZW1iZXJzIHdpdGggZmlsdGVyIHF1ZXJ5LiBUaGUgcmVzdWx0IHdvbid0IGJlIHN0b3JlZCBpbiBjYWxsIHN0YXRlLlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeU1lbWJlcnMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoJy9jYWxsL21lbWJlcnMnLCB7XG4gICAgICAgICAgICAgICAgLi4uKHJlcXVlc3QgfHwge30pLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCB1cGRhdGUgdGhlIGNhbGwgbWVtYmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRhdGEgdGhlIHJlcXVlc3QgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlQ2FsbE1lbWJlcnMgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vbWVtYmVyc2AsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGVzIGFuIGF1dG8tZHJvcCB0aW1lb3V0IGJhc2VkIG9uIHRoZSBjYWxsIHNldHRpbmdzLlxuICAgICAgICAgKiBBcHBsaWNhYmxlIG9ubHkgZm9yIHJpbmdpbmcgY2FsbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlQXV0b0Ryb3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kcm9wVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5zZXR0aW5ncyQsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgaWYgdGhlIGNhbGwgaXMgbm90IHJpbmdpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsaW5nU3RhdGUgIT09IENhbGxpbmdTdGF0ZS5SSU5HSU5HKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEluTXMgPSBzZXR0aW5ncy5yaW5nLmF1dG9fY2FuY2VsX3RpbWVvdXRfbXM7XG4gICAgICAgICAgICAgICAgLy8gMCBtZWFucyBubyBhdXRvLWRyb3BcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dEluTXMgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRyb3BUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVhdmUoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCAnRmFpbGVkIHRvIGRyb3AgY2FsbCcsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXRJbk1zKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiByZWNvcmRpbmdzIGZvciB0aGUgY3VycmVudCBjYWxsIG9yIGNhbGwgc2Vzc2lvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGNhbGxTZXNzaW9uSWRgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybiB0aGUgcmVjb3JkaW5ncyBmb3IgdGhhdCBjYWxsIHNlc3Npb24uXG4gICAgICAgICAqIE90aGVyd2lzZSwgYWxsIHJlY29yZGluZ3MgZm9yIHRoZSBjdXJyZW50IGNhbGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNhbGxTZXNzaW9uSWQgdGhlIGNhbGwgc2Vzc2lvbiBpZCB0byByZXRyaWV2ZSByZWNvcmRpbmdzIGZvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVlcnlSZWNvcmRpbmdzID0gYXN5bmMgKGNhbGxTZXNzaW9uSWQpID0+IHtcbiAgICAgICAgICAgIGxldCBlbmRwb2ludCA9IHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGg7XG4gICAgICAgICAgICBpZiAoY2FsbFNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ID0gYCR7ZW5kcG9pbnR9LyR7Y2FsbFNlc3Npb25JZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChgJHtlbmRwb2ludH0vcmVjb3JkaW5nc2ApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZHMgYSBjdXN0b20gZXZlbnQgdG8gYWxsIGNhbGwgcGFydGljaXBhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZCB0aGUgcGF5bG9hZCB0byBzZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kQ3VzdG9tRXZlbnQgPSBhc3luYyAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoYCR7dGhpcy5zdHJlYW1DbGllbnRCYXNlUGF0aH0vZXZlbnRgLCB7IGN1c3RvbTogcGF5bG9hZCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBseURldmljZUNvbmZpZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENhbWVyYSh7IHNldFN0YXR1czogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLmluaXRNaWMoeyBzZXRTdGF0dXM6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2lsbCBiZWdpbiB0cmFja2luZyB0aGUgZ2l2ZW4gZWxlbWVudCBmb3IgdmlzaWJpbGl0eSBjaGFuZ2VzIHdpdGhpbiB0aGVcbiAgICAgICAgICogY29uZmlndXJlZCB2aWV3cG9ydCBlbGVtZW50IChgY2FsbC5zZXRWaWV3cG9ydGApLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byB0cmFjay5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUgdmlkZW8gbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tFbGVtZW50VmlzaWJpbGl0eSA9IChlbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHluYXNjYWxlTWFuYWdlci50cmFja0VsZW1lbnRWaXNpYmlsaXR5KGVsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZpZXdwb3J0IGVsZW1lbnQgdG8gdHJhY2sgYm91bmQgdmlkZW8gZWxlbWVudHMgZm9yIHZpc2liaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBlbGVtZW50IHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5keW5hc2NhbGVNYW5hZ2VyLnNldFZpZXdwb3J0KGVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYSBET00gPHZpZGVvPiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgcGxheVxuICAgICAgICAgKiB0aGUgY29ycmVjdCB2aWRlbyBzdHJlYW0gZm9yIHRoZSBnaXZlbiBzZXNzaW9uIGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVbmRlciB0aGUgaG9vZCwgaXQgd291bGQgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSB2aWRlbyBlbGVtZW50IGRpbWVuc2lvbnNcbiAgICAgICAgICogYW5kIHVwZGF0ZSB0aGUgc3Vic2NyaXB0aW9uIGFjY29yZGluZ2x5IGluIG9yZGVyIHRvIG9wdGltaXplIHRoZSBiYW5kd2lkdGguXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgXCJ2aWV3cG9ydFwiIGlzIGNvbmZpZ3VyZWQsIHRoZSB2aWRlbyBlbGVtZW50IHdpbGwgYmUgYXV0b21hdGljYWxseVxuICAgICAgICAgKiB0cmFja2VkIGZvciB2aXNpYmlsaXR5IGFuZCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHZpZGVvRWxlbWVudCB0aGUgdmlkZW8gZWxlbWVudCB0byBiaW5kIHRvLlxuICAgICAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIHRoZSBzZXNzaW9uIGlkLlxuICAgICAgICAgKiBAcGFyYW0gdHJhY2tUeXBlIHRoZSBraW5kIG9mIHZpZGVvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kVmlkZW9FbGVtZW50ID0gKHZpZGVvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVuYmluZCA9IHRoaXMuZHluYXNjYWxlTWFuYWdlci5iaW5kVmlkZW9FbGVtZW50KHZpZGVvRWxlbWVudCwgc2Vzc2lvbklkLCB0cmFja1R5cGUpO1xuICAgICAgICAgICAgaWYgKCF1bmJpbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQodW5iaW5kKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5kZWxldGUodW5iaW5kKTtcbiAgICAgICAgICAgICAgICB1bmJpbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kcyBhIERPTSA8YXVkaW8+IGVsZW1lbnQgdG8gdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlIGF1ZGlvIGVsZW1lbnQgd2lsbFxuICAgICAgICAgKiBwbGF5IHRoZSBjb3JyZWN0IGF1ZGlvIHN0cmVhbSBmb3IgdGhlIGdpdmVuIHNlc3Npb24gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhdWRpb0VsZW1lbnQgdGhlIGF1ZGlvIGVsZW1lbnQgdG8gYmluZCB0by5cbiAgICAgICAgICogQHBhcmFtIHNlc3Npb25JZCB0aGUgc2Vzc2lvbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHRyYWNrVHlwZSB0aGUga2luZCBvZiBhdWRpby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmluZEF1ZGlvRWxlbWVudCA9IChhdWRpb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlID0gJ2F1ZGlvVHJhY2snKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmJpbmQgPSB0aGlzLmR5bmFzY2FsZU1hbmFnZXIuYmluZEF1ZGlvRWxlbWVudChhdWRpb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKTtcbiAgICAgICAgICAgIGlmICghdW5iaW5kKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKHVuYmluZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuZGVsZXRlKHVuYmluZCk7XG4gICAgICAgICAgICAgICAgdW5iaW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQmluZHMgYSBET00gPGltZz4gZWxlbWVudCB0byB0aGlzIGNhbGwncyB0aHVtYm5haWwgKGlmIGVuYWJsZWQgaW4gc2V0dGluZ3MpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW1hZ2VFbGVtZW50IHRoZSBpbWFnZSBlbGVtZW50IHRvIGJpbmQgdG8uXG4gICAgICAgICAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIHRoZSBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaW5kQ2FsbFRodW1ibmFpbEVsZW1lbnQgPSAoaW1hZ2VFbGVtZW50LCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPVxuICAgICAgICAgICAgICAgICAgICBvcHRzLmZhbGxiYWNrSW1hZ2VTb3VyY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2dldHN0cmVhbS5pby9yYW5kb21fc3ZnLz9uYW1lPXgmaWQ9eCc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS50aHVtYm5haWxzJCwgKHRodW1ibmFpbHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRodW1ibmFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdGh1bWJuYWlsVXJsID0gbmV3IFVSTCh0aHVtYm5haWxzLmltYWdlX3VybCk7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3cnLCBTdHJpbmcoaW1hZ2VFbGVtZW50LmNsaWVudFdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2gnLCBTdHJpbmcoaW1hZ2VFbGVtZW50LmNsaWVudEhlaWdodCkpO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSB0aHVtYm5haWxVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jaWQgPSBgJHt0eXBlfToke2lkfWA7XG4gICAgICAgIHRoaXMucmluZ2luZ1N1YmplY3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHJpbmdpbmcpO1xuICAgICAgICB0aGlzLndhdGNoaW5nID0gd2F0Y2hpbmc7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gc3RyZWFtQ2xpZW50O1xuICAgICAgICB0aGlzLmNsaWVudFN0b3JlID0gY2xpZW50U3RvcmU7XG4gICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50QmFzZVBhdGggPSBgL2NhbGwvJHt0aGlzLnR5cGV9LyR7dGhpcy5pZH1gO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihbJ0NhbGwnXSk7XG4gICAgICAgIGNvbnN0IGNhbGxUeXBlQ29uZmlnID0gQ2FsbFR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgY29uc3QgcGFydGljaXBhbnRTb3J0ZXIgPSBzb3J0UGFydGljaXBhbnRzQnkgfHwgY2FsbFR5cGVDb25maWcub3B0aW9ucy5zb3J0UGFydGljaXBhbnRzQnk7XG4gICAgICAgIGlmIChwYXJ0aWNpcGFudFNvcnRlcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZXRTb3J0UGFydGljaXBhbnRzQnkocGFydGljaXBhbnRTb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc2V0TWVtYmVycyhtZW1iZXJzIHx8IFtdKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRPd25DYXBhYmlsaXRpZXMob3duQ2FwYWJpbGl0aWVzIHx8IFtdKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZXRDYWxsaW5nU3RhdGUocmluZ2luZyA/IENhbGxpbmdTdGF0ZS5SSU5HSU5HIDogQ2FsbGluZ1N0YXRlLklETEUpO1xuICAgICAgICB0aGlzLm9uKCdhbGwnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdGF0ZSB3aXRoIHRoZSBsYXRlc3QgZXZlbnQgZGF0YVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVGcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQocmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMsIHRoaXMuc3RhdGUsIHRoaXMuZGlzcGF0Y2hlcikpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRWZmZWN0cygpO1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChjcmVhdGVTdWJzY3JpcHRpb24odGhpcy50cmFja1N1YnNjcmlwdGlvbnNTdWJqZWN0LnBpcGUoZGVib3VuY2UoKHYpID0+IHRpbWVyKHYudHlwZSkpLCBtYXAkMSgodikgPT4gdi5kYXRhKSksIChzdWJzY3JpcHRpb25zKSA9PiB0aGlzLnNmdUNsaWVudD8udXBkYXRlU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zKSkpO1xuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmFNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLm1pY3JvcGhvbmUgPSBuZXcgTWljcm9waG9uZU1hbmFnZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc3BlYWtlciA9IG5ldyBTcGVha2VyTWFuYWdlcigpO1xuICAgICAgICB0aGlzLnNjcmVlblNoYXJlID0gbmV3IFNjcmVlblNoYXJlTWFuYWdlcih0aGlzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFZmZlY3RzKCkge1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgICAgLy8gaGFuZGxlcyB1cGRhdGluZyB0aGUgcGVybWlzc2lvbnMgY29udGV4dCB3aGVuIHRoZSBzZXR0aW5ncyBjaGFuZ2UuXG4gICAgICAgIGNyZWF0ZVN1YnNjcmlwdGlvbih0aGlzLnN0YXRlLnNldHRpbmdzJCwgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbnNDb250ZXh0LnNldENhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZSB1c2VyIHBlcm1pc3Npb25zIGFyZSBtb2RpZmllZC5cbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUub3duQ2FwYWJpbGl0aWVzJCwgKG93bkNhcGFiaWxpdGllcykgPT4ge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwZXJtaXNzaW9uIGNvbnRleHQuXG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5zZXRQZXJtaXNzaW9ucyhvd25DYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgdXNlciBzdGlsbCBoYXMgcHVibGlzaGluZyBwZXJtaXNzaW9ucyBhbmQgc3RvcCBwdWJsaXNoaW5nIGlmIG5vdC5cbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25Ub1RyYWNrVHlwZSA9IHtcbiAgICAgICAgICAgICAgICBbT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPXTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgICAgICAgIFtPd25DYXBhYmlsaXR5LlNFTkRfVklERU9dOiBUcmFja1R5cGUuVklERU8sXG4gICAgICAgICAgICAgICAgW093bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkVdOiBUcmFja1R5cGUuU0NSRUVOX1NIQVJFLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3Blcm1pc3Npb24sIHRyYWNrVHlwZV0gb2YgT2JqZWN0LmVudHJpZXMocGVybWlzc2lvblRvVHJhY2tUeXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5oYXNQZXJtaXNzaW9uKHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgICAgIGlmICghaGFzUGVybWlzc2lvbiAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5wdWJsaXNoZXIuaXNQdWJsaXNoaW5nKHRyYWNrVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaGVyLmlzTGl2ZSh0cmFja1R5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHRyYWNrcywgdGhlbiBub3RpZnkgZGV2aWNlIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wUHVibGlzaCh0cmFja1R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2Vycm9yJywgYEVycm9yIHN0b3BwaW5nIHB1Ymxpc2ggJHt0cmFja1R5cGV9YCwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1R5cGUgPT09IFRyYWNrVHlwZS5WSURFTyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW1lcmFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRpc2FibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5sb2dnZXIoJ2Vycm9yJywgYEVycm9yIGRpc2FibGluZyBjYW1lcmEgYWZ0ZXIgcGVybWlzc2lvbiByZXZva2VkYCwgZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tUeXBlID09PSBUcmFja1R5cGUuQVVESU8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRpc2FibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4gdGhpcy5sb2dnZXIoJ2Vycm9yJywgYEVycm9yIGRpc2FibGluZyBtaWNyb3Bob25lIGFmdGVyIHBlcm1pc3Npb24gcmV2b2tlZGAsIGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgdXNlciBpcyBibG9ja2VkIGJ5IHRoZSBjYWxsIG93bmVyLlxuICAgICAgICBjcmVhdGVTdWJzY3JpcHRpb24odGhpcy5zdGF0ZS5ibG9ja2VkVXNlcklkcyQsIGFzeW5jIChibG9ja2VkVXNlcklkcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFibG9ja2VkVXNlcklkcyB8fCBibG9ja2VkVXNlcklkcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFVzZXJJZCA9IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VXNlcklkICYmIGJsb2NrZWRVc2VySWRzLmluY2x1ZGVzKGN1cnJlbnRVc2VySWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnTGVhdmluZyBjYWxsIGJlY2F1c2Ugb2YgYmVpbmcgYmxvY2tlZCcpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmxlYXZlQ2FsbEhvb2tzLmFkZChcbiAgICAgICAgLy8gd2F0Y2ggZm9yIGF1dG8gZHJvcCBjYW5jZWxsYXRpb25cbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlJCwgKGNhbGxpbmdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJpbmdpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5FRCB8fFxuICAgICAgICAgICAgICAgIGNhbGxpbmdTdGF0ZSA9PT0gQ2FsbGluZ1N0YXRlLkpPSU5JTkcgfHxcbiAgICAgICAgICAgICAgICBjYWxsaW5nU3RhdGUgPT09IENhbGxpbmdTdGF0ZS5MRUZUKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZHJvcFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5sZWF2ZUNhbGxIb29rcy5hZGQoXG4gICAgICAgIC8vIFwicmluZ2luZ1wiIG1vZGUgZWZmZWN0cyBhbmQgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgY3JlYXRlU3Vic2NyaXB0aW9uKHRoaXMucmluZ2luZ1N1YmplY3QsIChpc1JpbmdpbmcpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNSaW5naW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVBdXRvRHJvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbGluZ1N0YXRlID09PSBDYWxsaW5nU3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2FsbGluZ1N0YXRlKENhbGxpbmdTdGF0ZS5SSU5HSU5HKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVhdmVDYWxsSG9va3MuYWRkKHJlZ2lzdGVyUmluZ2luZ0NhbGxFdmVudEhhbmRsZXJzKHRoaXMpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjYWxsIGlzIFwicmluZ2luZ1wiIHR5cGUgb2YgY2FsbC5cbiAgICAgKi9cbiAgICBnZXQgcmluZ2luZygpIHtcbiAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRWYWx1ZSh0aGlzLnJpbmdpbmdTdWJqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IHVzZXIgSUQuXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRVc2VySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFN0b3JlLmNvbm5lY3RlZFVzZXI/LmlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjYWxsIHdhcyBjcmVhdGVkIGJ5IHRoZSBjdXJyZW50IHVzZXIuXG4gICAgICovXG4gICAgZ2V0IGlzQ3JlYXRlZEJ5TWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNyZWF0ZWRCeT8uaWQgPT09IHRoaXMuY3VycmVudFVzZXJJZDtcbiAgICB9XG4gICAgYXN5bmMgaW5pdENhbWVyYShvcHRpb25zKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBpbiBwcm9ncmVzcyBjYW1lcmEgb3BlcmF0aW9uXG4gICAgICAgIGlmICh0aGlzLmNhbWVyYS5lbmFibGVQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNhbWVyYS5lbmFibGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbWVyYS5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuZGlzYWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubG9jYWxQYXJ0aWNpcGFudD8udmlkZW9TdHJlYW0gfHxcbiAgICAgICAgICAgICF0aGlzLnBlcm1pc3Npb25zQ29udGV4dC5oYXNQZXJtaXNzaW9uKCdzZW5kLXZpZGVvJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgY2FtZXJhIGRpcmVjdGlvbiBpZiBpdCdzIG5vdCB5ZXQgc2V0XG4gICAgICAgIGlmICghdGhpcy5jYW1lcmEuc3RhdGUuZGlyZWN0aW9uICYmICF0aGlzLmNhbWVyYS5zdGF0ZS5zZWxlY3RlZERldmljZSkge1xuICAgICAgICAgICAgbGV0IGRlZmF1bHREaXJlY3Rpb24gPSAnZnJvbnQnO1xuICAgICAgICAgICAgY29uc3QgYmFja2VuZFNldHRpbmcgPSB0aGlzLnN0YXRlLnNldHRpbmdzPy52aWRlby5jYW1lcmFfZmFjaW5nO1xuICAgICAgICAgICAgaWYgKGJhY2tlbmRTZXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpcmVjdGlvbiA9IGJhY2tlbmRTZXR0aW5nID09PSAnZnJvbnQnID8gJ2Zyb250JyA6ICdiYWNrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLnN0YXRlLnNldERpcmVjdGlvbihkZWZhdWx0RGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGFyZ2V0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLnRhcmdldF9yZXNvbHV0aW9uO1xuICAgICAgICBpZiAodGFyZ2V0UmVzb2x1dGlvbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuc2VsZWN0VGFyZ2V0UmVzb2x1dGlvbih0YXJnZXRSZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zZXRTdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggYWxyZWFkeSB0aGF0IHdhcyBzZXQgYmVmb3JlIHdlIGpvaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMuY2FtZXJhLnN0YXRlLnN0YXR1cyA9PT0gJ2VuYWJsZWQnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYW1lcmEuc3RhdGUubWVkaWFTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wdWJsaXNoZXI/LmlzUHVibGlzaGluZyhUcmFja1R5cGUuVklERU8pKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoVmlkZW9TdHJlYW0odGhpcy5jYW1lcmEuc3RhdGUubWVkaWFTdHJlYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkQ29kZWM6IHRoaXMuY2FtZXJhLnByZWZlcnJlZENvZGVjLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgY2FtZXJhIGlmIGJhY2tlbmQgY29uZmlnIHNwZWNpZmllcywgYW5kIHRoZXJlIGlzIG5vIGxvY2FsIHNldHRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbWVyYS5zdGF0ZS5zdGF0dXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0dGluZ3M/LnZpZGVvLmNhbWVyYV9kZWZhdWx0X29uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jYW1lcmEuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW5pdE1pYyhvcHRpb25zKSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBpbiBwcm9ncmVzcyBtaWMgb3BlcmF0aW9uXG4gICAgICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuZW5hYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5taWNyb3Bob25lLmVuYWJsZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5kaXNhYmxlUHJvbWlzZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5taWNyb3Bob25lLmRpc2FibGVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmxvY2FsUGFydGljaXBhbnQ/LmF1ZGlvU3RyZWFtIHx8XG4gICAgICAgICAgICAhdGhpcy5wZXJtaXNzaW9uc0NvbnRleHQuaGFzUGVybWlzc2lvbignc2VuZC1hdWRpbycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2V0U3RhdHVzKSB7XG4gICAgICAgICAgICAvLyBQdWJsaXNoIG1lZGlhIHN0cmVhbSB0aGF0IHdhcyBzZXQgYmVmb3JlIHdlIGpvaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMubWljcm9waG9uZS5zdGF0ZS5zdGF0dXMgPT09ICdlbmFibGVkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMubWljcm9waG9uZS5zdGF0ZS5tZWRpYVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnB1Ymxpc2hlcj8uaXNQdWJsaXNoaW5nKFRyYWNrVHlwZS5BVURJTykpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBdWRpb1N0cmVhbSh0aGlzLm1pY3JvcGhvbmUuc3RhdGUubWVkaWFTdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgbWljIGlmIGJhY2tlbmQgY29uZmlnIHNwZWNpZmllcywgYW5kIHRoZXJlIGlzIG5vIGxvY2FsIHNldHRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLm1pY3JvcGhvbmUuc3RhdGUuc3RhdHVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNldHRpbmdzPy5hdWRpby5taWNfZGVmYXVsdF9vbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubWljcm9waG9uZS5lbmFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgSW5zaWdodE1ldHJpY3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGFydFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMud3NUb3RhbEZhaWx1cmVzID0gMDtcbiAgICAgICAgdGhpcy53c0NvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmluc3RhbmNlQ2xpZW50SWQgPSByYW5kb21JZCgpO1xuICAgIH1cbn1cbi8qKlxuICogcG9zdEluc2lnaHRzIGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGJ5IGVuZCB1c2VycyBkaXJlY3RseSB3aXRoaW4gY2hhdCBhcHBsaWNhdGlvbiwgYW5kIHRodXMgaXMga2VwdCBpc29sYXRlZFxuICogZnJvbSBhbGwgdGhlIGNsaWVudC9jb25uZWN0aW9uIGNvZGUvbG9naWMuXG4gKlxuICogQHBhcmFtIGluc2lnaHRUeXBlXG4gKiBAcGFyYW0gaW5zaWdodHNcbiAqL1xuY29uc3QgcG9zdEluc2lnaHRzID0gYXN5bmMgKGluc2lnaHRUeXBlLCBpbnNpZ2h0cykgPT4ge1xuICAgIGNvbnN0IG1heEF0dGVtcHRzID0gMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heEF0dGVtcHRzOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGF4aW9zLnBvc3QoYGh0dHBzOi8vY2hhdC1pbnNpZ2h0cy5nZXRzdHJlYW0uaW8vaW5zaWdodHMvJHtpbnNpZ2h0VHlwZX1gLCBpbnNpZ2h0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKChpICsgMSkgKiAzMDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5mdW5jdGlvbiBidWlsZFdzRmF0YWxJbnNpZ2h0KGNvbm5lY3Rpb24sIGV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIC4uLmJ1aWxkV3NCYXNlSW5zaWdodChjb25uZWN0aW9uKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRXc0Jhc2VJbnNpZ2h0KGNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCB7IGNsaWVudCB9ID0gY29ubmVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkeV9zdGF0ZTogY29ubmVjdGlvbi53cz8ucmVhZHlTdGF0ZSxcbiAgICAgICAgdXJsOiBjb25uZWN0aW9uLl9idWlsZFVybCgpLFxuICAgICAgICBhcGlfa2V5OiBjbGllbnQua2V5LFxuICAgICAgICBzdGFydF90czogY2xpZW50Lmluc2lnaHRNZXRyaWNzLmNvbm5lY3Rpb25TdGFydFRpbWVzdGFtcCxcbiAgICAgICAgZW5kX3RzOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgYXV0aF90eXBlOiBjbGllbnQuZ2V0QXV0aFR5cGUoKSxcbiAgICAgICAgdG9rZW46IGNsaWVudC50b2tlbk1hbmFnZXIudG9rZW4sXG4gICAgICAgIHVzZXJfaWQ6IGNsaWVudC51c2VySUQsXG4gICAgICAgIHVzZXJfZGV0YWlsczogY2xpZW50Ll91c2VyLFxuICAgICAgICAvLyBkZXZpY2U6IGNsaWVudC5vcHRpb25zLmRldmljZSxcbiAgICAgICAgZGV2aWNlOiAnYnJvd3NlcicsXG4gICAgICAgIGNsaWVudF9pZDogY29ubmVjdGlvbi5jb25uZWN0aW9uSUQsXG4gICAgICAgIHdzX2RldGFpbHM6IGNvbm5lY3Rpb24ud3MsXG4gICAgICAgIHdzX2NvbnNlY3V0aXZlX2ZhaWx1cmVzOiBjbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzLFxuICAgICAgICB3c190b3RhbF9mYWlsdXJlczogY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzVG90YWxGYWlsdXJlcyxcbiAgICAgICAgcmVxdWVzdF9pZDogY29ubmVjdGlvbi5yZXF1ZXN0SUQsXG4gICAgICAgIG9ubGluZTogdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3I/Lm9uTGluZSA6IG51bGwsXG4gICAgICAgIHVzZXJfYWdlbnQ6IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yPy51c2VyQWdlbnQgOiBudWxsLFxuICAgICAgICBpbnN0YW5jZV9jbGllbnRfaWQ6IGNsaWVudC5pbnNpZ2h0TWV0cmljcy5pbnN0YW5jZUNsaWVudElkLFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFdzU3VjY2Vzc0FmdGVyRmFpbHVyZUluc2lnaHQoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBidWlsZFdzQmFzZUluc2lnaHQoY29ubmVjdGlvbik7XG59XG5cbi8vIFR5cGUgZ3VhcmRzIHRvIGNoZWNrIFdlYlNvY2tldCBlcnJvciB0eXBlXG5jb25zdCBpc0Nsb3NlRXZlbnQgPSAocmVzKSA9PiByZXMuY29kZSAhPT0gdW5kZWZpbmVkO1xuY29uc3QgaXNFcnJvckV2ZW50ID0gKHJlcykgPT4gcmVzLmVycm9yICE9PSB1bmRlZmluZWQ7XG4vKipcbiAqIFN0YWJsZVdTQ29ubmVjdGlvbiAtIEEgV1MgY29ubmVjdGlvbiB0aGF0IHJlY29ubmVjdHMgdXBvbiBmYWlsdXJlLlxuICogLSB0aGUgYnJvd3NlciB3aWxsIHNvbWV0aW1lcyByZXBvcnQgdGhhdCB5b3UncmUgb25saW5lIG9yIG9mZmxpbmVcbiAqIC0gdGhlIFdTIGNvbm5lY3Rpb24gY2FuIGJyZWFrIGFuZCBmYWlsICh0aGVyZSBpcyBhIDMwcyBoZWFsdGggY2hlY2spXG4gKiAtIHNvbWV0aW1lcyB5b3VyIFdTIGNvbm5lY3Rpb24gd2lsbCBzZWVtIHRvIHdvcmsgd2hpbGUgdGhlIHVzZXIgaXMgaW4gZmFjdCBvZmZsaW5lXG4gKiAtIHRvIHNwZWVkIHVwIG9ubGluZS9vZmZsaW5lIGRldGVjdGlvbiB5b3UgY2FuIHVzZSB0aGUgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnKTtcbiAqXG4gKiBUaGVyZSBhcmUgNCB3YXlzIGluIHdoaWNoIGEgY29ubmVjdGlvbiBjYW4gYmVjb21lIHVuaGVhbHRoeTpcbiAqIC0gd2Vic29ja2V0Lm9uZXJyb3IgaXMgY2FsbGVkXG4gKiAtIHdlYnNvY2tldC5vbmNsb3NlIGlzIGNhbGxlZFxuICogLSB0aGUgaGVhbHRoIGNoZWNrIGZhaWxzIGFuZCBubyBldmVudCBpcyByZWNlaXZlZCBmb3IgfjQwIHNlY29uZHNcbiAqIC0gdGhlIGJyb3dzZXIgaW5kaWNhdGVzIHRoZSBjb25uZWN0aW9uIGlzIG5vdyBvZmZsaW5lXG4gKlxuICogVGhlcmUgYXJlIDIgYXNzdW1wdGlvbnMgd2UgbWFrZSBhYm91dCB0aGUgc2VydmVyOlxuICogLSBzdGF0ZSBjYW4gYmUgcmVjb3ZlcmVkIGJ5IHF1ZXJ5aW5nIHRoZSBjaGFubmVsIGFnYWluXG4gKiAtIGlmIHRoZSBzZXJ2ZXJzIGZhaWxzIHRvIHB1Ymxpc2ggYSBtZXNzYWdlIHRvIHRoZSBjbGllbnQsIHRoZSBXUyBjb25uZWN0aW9uIGlzIGRlc3Ryb3llZFxuICovXG5jbGFzcyBTdGFibGVXU0Nvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLl9sb2cgPSAobXNnLCBleHRyYSA9IHt9LCBsZXZlbCA9ICdpbmZvJykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyKGxldmVsLCAnY29ubmVjdGlvbjonICsgbXNnLCB7XG4gICAgICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDbGllbnQgPSAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkcyBhbmQgcmV0dXJucyB0aGUgdXJsIGZvciB3ZWJzb2NrZXQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHVybCBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2J1aWxkVXJsID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgLy8gY29uc3QgcXMgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5jbGllbnQuX2J1aWxkV1NQYXlsb2FkKHRoaXMucmVxdWVzdElEKSk7XG4gICAgICAgICAgICAvLyBwYXJhbXMuc2V0KCdqc29uJywgcXMpO1xuICAgICAgICAgICAgcGFyYW1zLnNldCgnYXBpX2tleScsIHRoaXMuY2xpZW50LmtleSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdzdHJlYW0tYXV0aC10eXBlJywgdGhpcy5jbGllbnQuZ2V0QXV0aFR5cGUoKSk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdYLVN0cmVhbS1DbGllbnQnLCB0aGlzLmNsaWVudC5nZXRVc2VyQWdlbnQoKSk7XG4gICAgICAgICAgICAvLyBwYXJhbXMuYXBwZW5kKCdhdXRob3JpemF0aW9uJywgdGhpcy5jbGllbnQuX2dldFRva2VuKCkhKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmNsaWVudC53c0Jhc2VVUkx9L2Nvbm5lY3Q/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogb25saW5lU3RhdHVzQ2hhbmdlZCAtIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgY29ubmVjdHMgb3IgZGlzY29ubmVjdHMgZnJvbSB0aGUgaW50ZXJuZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50IHdpdGggdHlwZSBvbmxpbmUgb3Igb2ZmbGluZVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0dXNDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ29mZmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFyayB0aGUgY29ubmVjdGlvbiBhcyBkb3duXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKCdvbmxpbmVTdGF0dXNDaGFuZ2VkKCkgLSBTdGF0dXMgY2hhbmdpbmcgdG8gb2ZmbGluZScpO1xuICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgYXBwIGlzIG9mZmxpbmUgc28gZGlzcGF0Y2ggdGhlIHVuaGVhbHRoeSBjb25uZWN0aW9uIGV2ZW50IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdvbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgcmlnaHQgbm93Li4uXG4gICAgICAgICAgICAgICAgLy8gV2UgY2hlY2sgdGhpcy5pc0hlYWx0aHksIG5vdCBzdXJlIGlmIGl0J3MgYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gc21hcnQgdG8gY3JlYXRlIGEgbmV3IFdTIGNvbm5lY3Rpb24gaWYgdGhlIG9sZCBvbmUgaXMgc3RpbGwgdXAgYW5kIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB3ZSBkaWRuJ3QgbWlzcyBhbnkgbWVzc2FnZXMsIHNvIHRoaXMgcHJvY2VzcyBpcyBqdXN0IGV4cGVuc2l2ZSBhbmQgbm90IG5lZWRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coYG9ubGluZVN0YXR1c0NoYW5nZWQoKSAtIFN0YXR1cyBjaGFuZ2luZyB0byBvbmxpbmUuIGlzSGVhbHRoeTogJHt0aGlzLmlzSGVhbHRoeX1gKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCh7IGludGVydmFsOiAxMCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25vcGVuID0gKHdzSUQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzSUQgIT09IHdzSUQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IHRoaXMuY2xpZW50LnVzZXI7XG4gICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIoJ2Vycm9yJywgYFVzZXIgbm90IHNldCwgY2FuJ3QgY29ubmVjdCB0byBXU2ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5jbGllbnQuX2dldFRva2VuKCk7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQubG9nZ2VyKCdlcnJvcicsIGBUb2tlbiBub3Qgc2V0LCBjYW4ndCBjb25uZWN0IGF1dGhlbnRpY2F0ZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIHVzZXJfZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgICBpZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdXNlci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogdXNlci5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tOiB1c2VyLmN1c3RvbSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25TZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMud3M/LnNlbmQoSlNPTi5zdHJpbmdpZnkoYXV0aE1lc3NhZ2UpKTtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnb25vcGVuKCkgLSBvbm9wZW4gY2FsbGJhY2snLCB7IHdzSUQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25tZXNzYWdlID0gKHdzSUQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy53c0lEICE9PSB3c0lEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnb25tZXNzYWdlKCkgLSBvbm1lc3NhZ2UgY2FsbGJhY2snLCB7IGV2ZW50LCB3c0lEIH0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIC8vIHdlIHdhaXQgdGlsbCB0aGUgZmlyc3QgbWVzc2FnZSBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gb3Blbi5cbiAgICAgICAgICAgIC8vIHRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBhdXRoIGVycm9ycyBhbmQgc2ltaWxhciBlcnJvcnMgdHJpZ2dlciBhIHdzLm9ub3BlbiBhbmQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIGFmdGVyIHRoYXQgYSB3cy5vbmNsb3NlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVzb2x2ZWQgJiYgZGF0YSAmJiBkYXRhLnR5cGUgPT09ICdjb25uZWN0aW9uLmVycm9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoZSB0eXBlcyBvZiBfZXJyb3JGcm9tV1NFdmVudCBhcmUgaW5jb3JyZWN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZT8uKHRoaXMuX2Vycm9yRnJvbVdTRXZlbnQoZGF0YSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50Li5cbiAgICAgICAgICAgIHRoaXMubGFzdEV2ZW50ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkYXRhICYmXG4gICAgICAgICAgICAgICAgKGRhdGEudHlwZSA9PT0gJ2hlYWx0aC5jaGVjaycgfHwgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5vaycpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgaGVhbHRoLWNoZWNrIHNob3VsZCBjb21lIGZyb20gdGhlIGNsaWVudFxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVOZXh0UGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5vaycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVQcm9taXNlPy4oZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSAnY29ubmVjdGlvbi5lcnJvcicgJiYgZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZGF0YS5lcnJvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSGVhbHRoeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnY29ubmVjdCgpIC0gV1MgZmFpbHVyZSBkdWUgdG8gZXhwaXJlZCB0b2tlbiwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlbG9hZCB0b2tlbiBhbmQgcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCh7IHJlZnJlc2hUb2tlbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jbG9zZSA9ICh3c0lELCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9sb2coJ29uY2xvc2UoKSAtIG9uY2xvc2UgY2FsbGJhY2sgLSAnICsgZXZlbnQuY29kZSwgeyBldmVudCwgd3NJRCB9KTtcbiAgICAgICAgICAgIGlmIChldmVudC5jb2RlID09PSBLbm93bkNvZGVzLldTX0NMT1NFRF9TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHBlcm1hbmVudCBlcnJvciByYWlzZWQgYnkgc3RyZWFtLi5cbiAgICAgICAgICAgICAgICAvLyB1c3VhbGx5IGNhdXNlZCBieSBpbnZhbGlkIGF1dGggZGV0YWlsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBXUyBjb25uZWN0aW9uIHJlamVjdCB3aXRoIGVycm9yICR7ZXZlbnQucmVhc29ufWApO1xuICAgICAgICAgICAgICAgIGVycm9yLnJlYXNvbiA9IGV2ZW50LnJlYXNvbjtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gZXZlbnQuY29kZTtcbiAgICAgICAgICAgICAgICBlcnJvci53YXNDbGVhbiA9IGV2ZW50Lndhc0NsZWFuO1xuICAgICAgICAgICAgICAgIGVycm9yLnRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdFByb21pc2U/LihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBvbmNsb3NlKCkgLSBXUyBjb25uZWN0aW9uIHJlamVjdCB3aXRoIGVycm9yICR7ZXZlbnQucmVhc29ufWAsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRIZWFsdGgoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3RQcm9taXNlPy4odGhpcy5fZXJyb3JGcm9tV1NFdmVudChldmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgb25jbG9zZSgpIC0gV1MgY29ubmVjdGlvbiBjbG9zZWQuIENhbGxpbmcgcmVjb25uZWN0IC4uLmAsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVjb25uZWN0IGlmIGl0cyBhbiBhYm5vcm1hbCBmYWlsdXJlXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25lcnJvciA9ICh3c0lELCBldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMud3NJRCAhPT0gd3NJRClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgIHRoaXMudG90YWxGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5fc2V0SGVhbHRoKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlamVjdFByb21pc2U/Lih0aGlzLl9lcnJvckZyb21XU0V2ZW50KGV2ZW50KSk7XG4gICAgICAgICAgICB0aGlzLl9sb2coYG9uZXJyb3IoKSAtIFdTIGNvbm5lY3Rpb24gcmVzdWx0ZWQgaW50byBlcnJvcmAsIHsgZXZlbnQgfSk7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIF9zZXRIZWFsdGggLSBTZXRzIHRoZSBjb25uZWN0aW9uIHRvIGhlYWx0aHkgb3IgdW5oZWFsdGh5LlxuICAgICAgICAgKiBCcm9hZGNhc3RzIGFuIGV2ZW50IGluIGNhc2UgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGVhbHRoeSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeSBvciBub3RcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkaXNwYXRjaEltbWVkaWF0ZWx5IGJvb2xlYW4gaW5kaWNhdGluZyB0byBkaXNwYXRjaCBldmVudCBpbW1lZGlhdGVseSBldmVuIGlmIHRoZSBjb25uZWN0aW9uIGlzIHVuaGVhbHRoeVxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2V0SGVhbHRoID0gKGhlYWx0aHksIGRpc3BhdGNoSW1tZWRpYXRlbHkgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGhlYWx0aHkgPT09IHRoaXMuaXNIZWFsdGh5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gaGVhbHRoeTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhbHRoeSB8fCBkaXNwYXRjaEltbWVkaWF0ZWx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW9uLmNoYW5nZWQnLFxuICAgICAgICAgICAgICAgICAgICBvbmxpbmU6IHRoaXMuaXNIZWFsdGh5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlJ3JlIG9mZmxpbmUsIHdhaXQgZmV3IHNlY29uZHMgYW5kIGZpcmUgYW5kIGV2ZW50IGlmIHN0aWxsIG9mZmxpbmVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhbHRoeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29ubmVjdGlvbi5jaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICAgICAgb25saW5lOiB0aGlzLmlzSGVhbHRoeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogX2Vycm9yRnJvbVdTRXZlbnQgLSBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCBmb3IgdGhlIFdTIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9lcnJvckZyb21XU0V2ZW50ID0gKGV2ZW50LCBpc1dTRmFpbHVyZSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGxldCBjb2RlO1xuICAgICAgICAgICAgbGV0IHN0YXR1c0NvZGU7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGV2ZW50LmNvZGU7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9ICd1bmtub3duJztcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXZlbnQucmVhc29uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXJyb3JFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gZXZlbnQuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gZXZlbnQuZXJyb3IuU3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gZXZlbnQuZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEtlZXBpbmcgdGhpcyBgd2FybmAgbGV2ZWwgbG9nLCB0byBhdm9pZCBjbHV0dGVyaW5nIG9mIGVycm9yIGxvZ3MgZnJvbSB3cyBmYWlsdXJlcy5cbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Vycm9yRnJvbVdTRXZlbnQoKSAtIFdTIGZhaWxlZCB3aXRoIGNvZGUgJHtjb2RlfWAsIHsgZXZlbnQgfSwgJ3dhcm4nKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBXUyBmYWlsZWQgd2l0aCBjb2RlICR7Y29kZX0gYW5kIHJlYXNvbiAtICR7bWVzc2FnZX1gKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGF0dXNDb2RlIGRvZXMgbm90IGV4aXN0IG9uIGFueSBldmVudCB0eXBlcyBidXQgaGFzIGJlZW4gbGVmdFxuICAgICAgICAgICAgICogYXMgaXMgdG8gcHJlc2VydmUgSlMgZnVuY3Rpb25hbGl0eSBkdXJpbmcgdGhlIFRTIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVycm9yLlN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICAgICAgZXJyb3IuaXNXU0ZhaWx1cmUgPSBpc1dTRmFpbHVyZTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIF9zZXR1cFByb21pc2UgLSBzZXRzIHVwIHRoZSB0aGlzLmNvbm5lY3RPcGVuIHByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvblByb21pc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHdzLm9wZW4gaXMgY2FsbGVkICovXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcGVuID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGVzIGEgbmV4dCBoZWFsdGggY2hlY2sgcGluZyBmb3Igd2Vic29ja2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZU5leHRQaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDMwIHNlY29uZHMgaXMgdGhlIHJlY29tbWVuZGVkIGludGVydmFsIChtZXNzZW5nZXIgdXNlcyB0aGlzKVxuICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVja1RpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzZW5kIHRoZSBoZWFsdGhjaGVjay4uLiwgc2VydmVyIHJlcGxpZXMgd2l0aCBhIGhlYWx0aCBjaGVjayBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbeyB0eXBlOiAnaGVhbHRoLmNoZWNrJywgY2xpZW50X2lkOiB0aGlzLmNsaWVudC5jbGllbnRJRCB9XTtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gc2VuZCBvbiB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3M/LnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciB3aWxsIGFscmVhZHkgYmUgZGV0ZWN0ZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5waW5nSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogc2NoZWR1bGVDb25uZWN0aW9uQ2hlY2sgLSBzY2hlZHVsZXMgYSBjaGVjayBmb3IgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gbGFzdCByZWNlaXZlZCBldmVudCBhbmQgbm93LlxuICAgICAgICAgKiBJZiB0aGUgZGlmZmVyZW5jZSBpcyBtb3JlIHRoYW4gMzUgc2Vjb25kcywgaXQgbWVhbnMgb3VyIGhlYWx0aCBjaGVjayBsb2dpYyBoYXMgZmFpbGVkIGFuZCB3ZWJzb2NrZXQgbmVlZHNcbiAgICAgICAgICogdG8gYmUgcmVjb25uZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdGlvbkNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25DaGVja1RpbWVvdXRSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0RXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgbm93LmdldFRpbWUoKSAtIHRoaXMubGFzdEV2ZW50LmdldFRpbWUoKSA+IHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ3NjaGVkdWxlQ29ubmVjdGlvbkNoZWNrIC0gZ29pbmcgdG8gcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEhlYWx0aChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvKiogY29uc2VjdXRpdmUgZmFpbHVyZXMgaW5mbHVlbmNlIHRoZSBkdXJhdGlvbiBvZiB0aGUgdGltZW91dCAqL1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICAvKioga2VlcCB0cmFjayBvZiB0aGUgdG90YWwgbnVtYmVyIG9mIGZhaWx1cmVzICovXG4gICAgICAgIHRoaXMudG90YWxGYWlsdXJlcyA9IDA7XG4gICAgICAgIC8qKiBXZSBvbmx5IG1ha2UgMSBhdHRlbXB0IHRvIHJlY29ubmVjdCBhdCB0aGUgc2FtZSB0aW1lLi4gKi9cbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRydWUgYWZ0ZXIgdGhlIGF1dGggcGF5bG9hZCBpcyBzZW50IHRvIHRoZSBzZXJ2ZXIgKi9cbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGlvblNlbnQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvIGF2b2lkIHJlY29ubmVjdCBpZiBjbGllbnQgaXMgZGlzY29ubmVjdGVkICovXG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGNvbm5lY3Rpb24gcHJvbWlzZSBpcyByZXNvbHZlZCAqL1xuICAgICAgICB0aGlzLmlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgd2UgaGF2ZSBhIHdvcmtpbmcgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyICovXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBJbmNyZW1lbnRlZCB3aGVuIGEgbmV3IFdTIGNvbm5lY3Rpb24gaXMgbWFkZSAqL1xuICAgICAgICB0aGlzLndzSUQgPSAxO1xuICAgICAgICAvKiogU3RvcmUgdGhlIGxhc3QgZXZlbnQgdGltZSBmb3IgaGVhbHRoIGNoZWNrcyAqL1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IG51bGw7XG4gICAgICAgIC8qKiBTZW5kIGEgaGVhbHRoIGNoZWNrIG1lc3NhZ2UgZXZlcnkgMjUgc2Vjb25kcyAqL1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IDI1ICogMTAwMDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0ID0gdGhpcy5waW5nSW50ZXJ2YWwgKyAxMCAqIDEwMDA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25FdmVudExpc3RlbmVycyh0aGlzLm9ubGluZVN0YXR1c0NoYW5nZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25uZWN0IC0gQ29ubmVjdCB0byB0aGUgV1MgVVJMXG4gICAgICogdGhlIGRlZmF1bHQgMTVzIHRpbWVvdXQgYWxsb3dzIGJldHdlZW4gMn4zIHRyaWVzXG4gICAgICogQHJldHVybiB7Q29ubmVjdEFQSVJlc3BvbnNlPENvbm5lY3RlZEV2ZW50Pn0gUHJvbWlzZSB0aGF0IGNvbXBsZXRlcyBvbmNlIHRoZSBmaXJzdCBoZWFsdGggY2hlY2sgbWVzc2FnZSBpcyByZWNlaXZlZFxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QodGltZW91dCA9IDE1MDAwKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFlvdSd2ZSBjYWxsZWQgY29ubmVjdCB0d2ljZSwgY2FuIG9ubHkgYXR0ZW1wdCAxIGNvbm5lY3Rpb24gYXQgdGhlIHRpbWVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoZWFsdGhDaGVjayA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9sb2coYGNvbm5lY3QoKSAtIEVzdGFibGlzaGVkIHdzIGNvbm5lY3Rpb24gd2l0aCBoZWFsdGhjaGVjazogJHtoZWFsdGhDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IEtub3duQ29kZXMuVE9LRU5fRVhQSVJFRCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZygnY29ubmVjdCgpIC0gV1MgZmFpbHVyZSBkdWUgdG8gZXhwaXJlZCB0b2tlbiwgc28gZ29pbmcgdG8gdHJ5IHRvIHJlbG9hZCB0b2tlbiBhbmQgcmVjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjb25uZWN0KHsgcmVmcmVzaFRva2VuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IuaXNXU0ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQVBJIHJlamVjdGVkIHRoZSBjb25uZWN0aW9uIGFuZCB3ZSBzaG91bGQgbm90IHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgU3RhdHVzQ29kZTogZXJyb3IuU3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1dTRmFpbHVyZTogZXJyb3IuaXNXU0ZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dhaXRGb3JIZWFsdGh5KHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfd2FpdEZvckhlYWx0aHkgcG9sbHMgdGhlIHByb21pc2UgY29ubmVjdGlvbiB0byBzZWUgaWYgaXRzIHJlc29sdmVkIHVudGlsIGl0IHRpbWVzIG91dFxuICAgICAqIHRoZSBkZWZhdWx0IDE1cyB0aW1lb3V0IGFsbG93cyBiZXR3ZWVuIDJ+MyB0cmllc1xuICAgICAqIEBwYXJhbSB0aW1lb3V0IGR1cmF0aW9uKG1zKVxuICAgICAqL1xuICAgIGFzeW5jIF93YWl0Rm9ySGVhbHRoeSh0aW1lb3V0ID0gMTUwMDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gNTA7IC8vIG1zXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGltZW91dDsgaSArPSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdGlvbk9wZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0YXR1c0NvZGU6IGVycm9yLlN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlOiBlcnJvci5pc1dTRmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBTdGF0dXNDb2RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ2luaXRpYWwgV1MgY29ubmVjdGlvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQnLFxuICAgICAgICAgICAgICAgICAgICBpc1dTRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZGlzY29ubmVjdCAtIERpc2Nvbm5lY3QgdGhlIGNvbm5lY3Rpb24gYW5kIGRvZXNuJ3QgcmVjb3Zlci4uLlxuICAgICAqXG4gICAgICovXG4gICAgZGlzY29ubmVjdCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gQ2xvc2luZyB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gZm9yIHdzSUQgJHt0aGlzLndzSUR9YCk7XG4gICAgICAgIHRoaXMud3NJRCArPSAxO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gc3RhcnQgYnkgcmVtb3ZpbmcgYWxsIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhbHRoQ2hlY2tUaW1lb3V0UmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvbkNoZWNrVGltZW91dFJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKHRoaXMub25saW5lU3RhdHVzQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgIC8vIHJlbW92ZSB3cyBoYW5kbGVycy4uLlxuICAgICAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlbW92ZUFsbExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy53cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNDbG9zZWRQcm9taXNlO1xuICAgICAgICAvLyBhbmQgZmluYWxseSBjbG9zZS4uLlxuICAgICAgICAvLyBBc3NpZ25pbmcgdG8gbG9jYWwgaGVyZSBiZWNhdXNlIHdlIHdpbGwgcmVtb3ZlIGl0IGZyb20gdGhpcyBiZWZvcmUgdGhlXG4gICAgICAgIC8vIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgICAgIGNvbnN0IHsgd3MgfSA9IHRoaXM7XG4gICAgICAgIGlmICh3cyAmJiB3cy5jbG9zZSAmJiB3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOKSB7XG4gICAgICAgICAgICBpc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBkaXNjb25uZWN0KCkgLSByZXNvbHZpbmcgaXNDbG9zZWRQcm9taXNlICR7ZXZlbnQgPyAnd2l0aCcgOiAnd2l0aG91dCd9IGNsb3NlIGZyYW1lYCwgeyBldmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3Mub25jbG9zZSA9IG9uY2xvc2U7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB3ZSBkb24ndCByZWNlaXZlIGNsb3NlIGZyYW1lIHdlYnNvY2tldCBzZXJ2ZXIgaW4gdGltZSxcbiAgICAgICAgICAgICAgICAvLyBsZXRzIG5vdCB3YWl0IGZvciBtb3JlIHRoYW4gMSBzZWNvbmQuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChvbmNsb3NlLCB0aW1lb3V0ICE9IG51bGwgPyB0aW1lb3V0IDogMTAwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgZGlzY29ubmVjdCgpIC0gTWFudWFsbHkgY2xvc2VkIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBjbGllbnQuZGlzY29ubmVjdCgpYCk7XG4gICAgICAgICAgICB3cy5jbG9zZShLbm93bkNvZGVzLldTX0NMT1NFRF9TVUNDRVNTLCAnTWFudWFsbHkgY2xvc2VkIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBjbGllbnQuZGlzY29ubmVjdCgpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sb2coYGRpc2Nvbm5lY3QoKSAtIHdzIGNvbm5lY3Rpb24gZG9lc24ndCBleGlzdCBvciBpdCBpcyBhbHJlYWR5IGNsb3NlZC5gKTtcbiAgICAgICAgICAgIGlzQ2xvc2VkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLndzO1xuICAgICAgICByZXR1cm4gaXNDbG9zZWRQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfY29ubmVjdCAtIENvbm5lY3QgdG8gdGhlIFdTIGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDb25uZWN0QVBJUmVzcG9uc2U8Q29ubmVjdGVkRXZlbnQ+fSBQcm9taXNlIHRoYXQgY29tcGxldGVzIG9uY2UgdGhlIGZpcnN0IGhlYWx0aCBjaGVjayBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgICovXG4gICAgYXN5bmMgX2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fFxuICAgICAgICAgICAgKHRoaXMuaXNEaXNjb25uZWN0ZWQgJiYgdGhpcy5jbGllbnQub3B0aW9ucy5lbmFibGVXU0ZhbGxiYWNrKSlcbiAgICAgICAgICAgIHJldHVybjsgLy8gc2ltcGx5IGlnbm9yZSBfY29ubmVjdCBpZiBpdCdzIGN1cnJlbnRseSB0cnlpbmcgdG8gY29ubmVjdFxuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdElEID0gcmFuZG9tSWQoKTtcbiAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3MuY29ubmVjdGlvblN0YXJ0VGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGxldCBpc1Rva2VuUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIHdhaXRpbmcgZm9yIHRva2VuYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIudG9rZW5SZWFkeSgpO1xuICAgICAgICAgICAgaXNUb2tlblJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gdG9rZW4gcHJvdmlkZXIgaGFzIGZhaWxlZCBiZWZvcmUsIHNvIHRyeSBhZ2FpblxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzVG9rZW5SZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgX2Nvbm5lY3QoKSAtIHRva2VuUHJvdmlkZXIgZmFpbGVkIGJlZm9yZSwgc28gZ29pbmcgdG8gcmV0cnlgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC50b2tlbk1hbmFnZXIubG9hZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXR1cENvbm5lY3Rpb25Qcm9taXNlKCk7XG4gICAgICAgICAgICBjb25zdCB3c1VSTCA9IHRoaXMuX2J1aWxkVXJsKCk7XG4gICAgICAgICAgICB0aGlzLl9sb2coYF9jb25uZWN0KCkgLSBDb25uZWN0aW5nIHRvICR7d3NVUkx9YCwge1xuICAgICAgICAgICAgICAgIHdzVVJMLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJRDogdGhpcy5yZXF1ZXN0SUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHdzVVJMKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbm9wZW4uYmluZCh0aGlzLCB0aGlzLndzSUQpO1xuICAgICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5vbmNsb3NlLmJpbmQodGhpcywgdGhpcy53c0lEKTtcbiAgICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMub25lcnJvci5iaW5kKHRoaXMsIHRoaXMud3NJRCk7XG4gICAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25tZXNzYWdlLmJpbmQodGhpcywgdGhpcy53c0lEKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uT3BlbjtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JRCA9IHJlc3BvbnNlLmNvbm5lY3Rpb25faWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQucmVzb2x2ZUNvbm5lY3Rpb25JZD8uKHRoaXMuY29ubmVjdGlvbklEKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZUluc2lnaHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RJbnNpZ2h0cygnd3Nfc3VjY2Vzc19hZnRlcl9mYWlsdXJlJywgYnVpbGRXc1N1Y2Nlc3NBZnRlckZhaWx1cmVJbnNpZ2h0KHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuaW5zaWdodE1ldHJpY3Mud3NDb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLl9sb2coYF9jb25uZWN0KCkgLSBFcnJvciAtIGAsIGVycik7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5lbmFibGVJbnNpZ2h0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzQ29uc2VjdXRpdmVGYWlsdXJlcysrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50Lmluc2lnaHRNZXRyaWNzLndzVG90YWxGYWlsdXJlcysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc2lnaHRzID0gYnVpbGRXc0ZhdGFsSW5zaWdodCh0aGlzLCBjb252ZXJ0RXJyb3JUb0pzb24oZXJyKSk7XG4gICAgICAgICAgICAgICAgcG9zdEluc2lnaHRzPy4oJ3dzX2ZhdGFsJywgaW5zaWdodHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGllbnQucmVqZWN0Q29ubmVjdGlvbklkPy4oKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBfcmVjb25uZWN0IC0gUmV0cnkgdGhlIGNvbm5lY3Rpb24gdG8gV1MgZW5kcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7eyBpbnRlcnZhbD86IG51bWJlcjsgcmVmcmVzaFRva2VuPzogYm9vbGVhbiB9fSBvcHRpb25zIEZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqIC0gYGludGVydmFsYFx0e2ludH1cdFx0XHRudW1iZXIgb2YgbXMgdGhhdCBmdW5jdGlvbiBzaG91bGQgd2FpdCBiZWZvcmUgcmVjb25uZWN0aW5nXG4gICAgICogLSBgcmVmcmVzaFRva2VuYCB7Ym9vbGVhbn1cdHJlbG9hZC9yZWZyZXNoIHVzZXIgdG9rZW4gYmUgcmVmcmVzaGVkIGJlZm9yZSBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb25uZWN0KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIEluaXRpYXRpbmcgdGhlIHJlY29ubmVjdCcpO1xuICAgICAgICAvLyBvbmx5IGFsbG93IDEgY29ubmVjdGlvbiBhdCB0aGUgdGltZVxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcgfHwgdGhpcy5pc0hlYWx0aHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gQWJvcnQgKDEpIHNpbmNlIGFscmVhZHkgY29ubmVjdGluZyBvciBoZWFsdGh5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb25uZWN0IGluIGNhc2Ugb2Ygb24gZXJyb3Igb3Igb24gY2xvc2VcbiAgICAgICAgLy8gYWxzbyByZWNvbm5lY3QgaWYgdGhlIGhlYWx0aCBjaGVjayBjeWNsZSBmYWlsc1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHJldHJ5SW50ZXJ2YWwodGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvbm5lY3QsIG9yIHRyeSBhZ2FpbiBhZnRlciBhIGxpdHRsZSB3aGlsZS4uLlxuICAgICAgICBhd2FpdCBzbGVlcChpbnRlcnZhbCk7XG4gICAgICAgIC8vIENoZWNrIG9uY2UgYWdhaW4gaWYgYnkgc29tZSBvdGhlciBjYWxsIHRvIF9yZWNvbm5lY3QgaXMgYWN0aXZlIG9yIGNvbm5lY3Rpb24gaXNcbiAgICAgICAgLy8gYWxyZWFkeSByZXN0b3JlZCwgdGhlbiBubyBuZWVkIHRvIHByb2NlZWQuXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fCB0aGlzLmlzSGVhbHRoeSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nKCdfcmVjb25uZWN0KCkgLSBBYm9ydCAoMikgc2luY2UgYWxyZWFkeSBjb25uZWN0aW5nIG9yIGhlYWx0aHknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Rpc2Nvbm5lY3RlZCAmJiB0aGlzLmNsaWVudC5vcHRpb25zLmVuYWJsZVdTRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZygnX3JlY29ubmVjdCgpIC0gQWJvcnQgKDMpIHNpbmNlIGRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIERlc3Ryb3lpbmcgY3VycmVudCBXUyBjb25uZWN0aW9uJyk7XG4gICAgICAgIC8vIGNsZWFudXAgdGhlIG9sZCBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmxvYWRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIFdhaXRpbmcgZm9yIHJlY292ZXJDYWxsQmFjaycpO1xuICAgICAgICAgICAgLy8gYXdhaXQgdGhpcy5jbGllbnQucmVjb3ZlclN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIEZpbmlzaGVkIHJlY292ZXJDYWxsQmFjaycpO1xuICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgKz0gMTtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBLbm93bkNvZGVzLlRPS0VOX0VYUElSRUQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5jbGllbnQudG9rZW5NYW5hZ2VyLmlzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIFdTIGZhaWx1cmUgZHVlIHRvIGV4cGlyZWQgdG9rZW4sIHNvIGdvaW5nIHRvIHRyeSB0byByZWxvYWQgdG9rZW4gYW5kIHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvbm5lY3QoeyByZWZyZXNoVG9rZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWNvbm5lY3Qgb24gV1MgZmFpbHVyZXMsIGRvbid0IHJlY29ubmVjdCBpZiB0aGVyZSBpcyBhIGNvZGUgYnVnXG4gICAgICAgICAgICBpZiAoZXJyb3IuaXNXU0ZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtIFdTIGZhaWx1cmUsIHNvIGdvaW5nIHRvIHRyeSB0byByZWNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2coJ19yZWNvbm5lY3QoKSAtID09IEVORCA9PScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfZGVzdHJveUN1cnJlbnRXU0Nvbm5lY3Rpb24gLSBSZW1vdmVzIHRoZSBjdXJyZW50IFdTIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIF9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbigpIHtcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSBJRCwgbWVhbmluZyB3ZSB3aWxsIGlnbm9yZSBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgb2xkXG4gICAgICAgIC8vIHdzIGNvbm5lY3Rpb24gZnJvbSBub3cgb24uXG4gICAgICAgIHRoaXMud3NJRCArPSAxO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcz8ud3M/LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcz8ud3M/LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNhcmVcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJyYXlPclN0cmluZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJyYXlPclN0cmluZyA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiBpc01hcFN0cmluZ0NhbGxiYWNrKGFycmF5T3JTdHJpbmcsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuICEhY2FsbGJhY2sgJiYgaXNTdHJpbmcoYXJyYXlPclN0cmluZyk7XG59XG5mdW5jdGlvbiBtYXAoYXJyYXlPclN0cmluZywgY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBpZiAoaXNTdHJpbmcoYXJyYXlPclN0cmluZykgJiYgaXNNYXBTdHJpbmdDYWxsYmFjayhhcnJheU9yU3RyaW5nLCBjYWxsYmFjaykpIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGFycmF5T3JTdHJpbmcubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheU9yU3RyaW5nLmNoYXJBdChrKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtWYWx1ZSA9IGFycmF5T3JTdHJpbmcuY2hhckF0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gY2FsbGJhY2soa1ZhbHVlLCBrLCBhcnJheU9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXNba10gPSBtYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdHJpbmcoYXJyYXlPclN0cmluZykgJiZcbiAgICAgICAgIWlzTWFwU3RyaW5nQ2FsbGJhY2soYXJyYXlPclN0cmluZywgY2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBhcnJheU9yU3RyaW5nLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgICBpZiAoayBpbiBhcnJheU9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga1ZhbHVlID0gYXJyYXlPclN0cmluZ1trXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWRWYWx1ZSA9IGNhbGxiYWNrKGtWYWx1ZSwgaywgYXJyYXlPclN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmVzW2tdID0gbWFwcGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGVuY29kZUJhc2U2NCA9IChkYXRhKSA9PiBmcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KG1hcChkYXRhLCAoY2hhcikgPT4gY2hhci5jaGFyQ29kZUF0KDApKSkpO1xuLy8gYmFzZS02NCBkZWNvZGVyIHRocm93cyBleGNlcHRpb24gaWYgZW5jb2RlZCBzdHJpbmcgaXMgbm90IHBhZGRlZCBieSAnPScgdG8gbWFrZSBzdHJpbmcgbGVuZ3RoXG4vLyBpbiBtdWx0aXBsZXMgb2YgNC4gU28gZ29ubmEgdXNlIG91ciBvd24gbWV0aG9kIGZvciB0aGlzIHB1cnBvc2UgdG8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wyNlxuY29uc3QgZGVjb2RlQmFzZTY0ID0gKHMpID0+IHtcbiAgICBjb25zdCBlID0ge30sIHcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLCBMID0gcy5sZW5ndGg7XG4gICAgbGV0IGksIGIgPSAwLCBjLCB4LCBsID0gMCwgYSwgciA9ICcnO1xuICAgIGNvbnN0IEEgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgZVtBLmNoYXJBdChpKV0gPSBpO1xuICAgIH1cbiAgICBmb3IgKHggPSAwOyB4IDwgTDsgeCsrKSB7XG4gICAgICAgIGMgPSBlW3MuY2hhckF0KHgpXTtcbiAgICAgICAgYiA9IChiIDw8IDYpICsgYztcbiAgICAgICAgbCArPSA2O1xuICAgICAgICB3aGlsZSAobCA+PSA4KSB7XG4gICAgICAgICAgICAoKGEgPSAoYiA+Pj4gKGwgLT0gOCkpICYgMHhmZikgfHwgeCA8IEwgLSAyKSAmJiAociArPSB3KGEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgSldUIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgVXNlclNlc3Npb25cbiAqIEBtZXRob2QgSldUVXNlclRva2VuXG4gKiBAbWVtYmVyb2Ygc2lnbmluZ1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U2VjcmV0fSBhcGlTZWNyZXQgLSBBUEkgU2VjcmV0IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFRoZSB1c2VyX2lkIGtleSBpbiB0aGUgSldUIHBheWxvYWRcbiAqIEBwYXJhbSB7VVJ9IFtleHRyYURhdGFdIC0gRXh0cmEgdGhhdCBzaG91bGQgYmUgcGFydCBvZiB0aGUgSldUIHRva2VuXG4gKiBAcGFyYW0ge1NpZ25PcHRpb25zfSBband0T3B0aW9uc10gLSBPcHRpb25zIHRoYXQgY2FuIGJlIHBhc3QgdG8gand0LnNpZ25cbiAqIEByZXR1cm4ge3N0cmluZ30gSldUIFRva2VuXG4gKi9cbmZ1bmN0aW9uIEpXVFVzZXJUb2tlbihhcGlTZWNyZXQsIHVzZXJJZCwgZXh0cmFEYXRhID0ge30sIGp3dE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2VySWQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgLi4uZXh0cmFEYXRhLFxuICAgIH07XG4gICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIGNsZWFyIGVycm9yIHdoZW4gand0IGlzIHNoaW1tZWQgKGllLiBicm93c2VyIGJ1aWxkKVxuICAgIGlmIChqd3QgPT0gbnVsbCB8fCBqd3Quc2lnbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBqd3QgY3J5cHRvLCBpZiB5b3UgYXJlIGdldHRpbmcgdGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSBhcmUgdHJ5aW5nIHRvIGdlbmVyYXRlIHRva2VucyBvbiBicm93c2VyIG9yIFJlYWN0IE5hdGl2ZSAob3Igb3RoZXIgZW52aXJvbm1lbnQgd2hlcmUgY3J5cHRvIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZSkuIFBsZWFzZSBOb3RlOiB0b2tlbiBzaG91bGQgb25seSBiZSBnZW5lcmF0ZWQgc2VydmVyLXNpZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgYWxnb3JpdGhtOiAnSFMyNTYnLCBub1RpbWVzdGFtcDogdHJ1ZSB9LCBqd3RPcHRpb25zKTtcbiAgICBpZiAocGF5bG9hZC5pYXQpIHtcbiAgICAgICAgb3B0cy5ub1RpbWVzdGFtcCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgYXBpU2VjcmV0LCBvcHRzKTtcbn1cbmZ1bmN0aW9uIEpXVFNlcnZlclRva2VuKGFwaVNlY3JldCwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc2VydmVyOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuZnVuY3Rpb24gVXNlckZyb21Ub2tlbih0b2tlbikge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBiNjRQYXlsb2FkID0gZnJhZ21lbnRzWzFdO1xuICAgIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVCYXNlNjQoYjY0UGF5bG9hZCk7XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgcmV0dXJuIGRhdGEudXNlcl9pZDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgdGhlIGlkIG9mIHRoZSB1c2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIERldlRva2VuKHVzZXJJZCkge1xuICAgIHJldHVybiBbXG4gICAgICAgICdleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjknLFxuICAgICAgICBlbmNvZGVCYXNlNjQoSlNPTi5zdHJpbmdpZnkoeyB1c2VyX2lkOiB1c2VySWQgfSkpLFxuICAgICAgICAnZGV2dG9rZW4nLCAvLyBoYXJkY29kZWQgc2lnbmF0dXJlXG4gICAgXS5qb2luKCcuJyk7XG59XG5cbi8qKlxuICogVG9rZW5NYW5hZ2VyXG4gKlxuICogSGFuZGxlcyBhbGwgdGhlIG9wZXJhdGlvbnMgYXJvdW5kIHVzZXIgdG9rZW4uXG4gKi9cbmNsYXNzIFRva2VuTWFuYWdlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VjcmV0fSBzZWNyZXRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZWNyZXQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgc3RhdGljIHN0cmluZyB0b2tlbiBvciB0b2tlbiBwcm92aWRlci5cbiAgICAgICAgICogVG9rZW4gcHJvdmlkZXIgc2hvdWxkIHJldHVybiBhIHRva2VuIHN0cmluZyBvciBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gc3RyaW5nIHRva2VuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1Rva2VuT3JQcm92aWRlcn0gdG9rZW5PclByb3ZpZGVyIC0gdGhlIHRva2VuIG9yIHRva2VuIHByb3ZpZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge1VzZXJSZXNwb25zZX0gdXNlciAtIHRoZSB1c2VyIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc0Fub255bW91cyAtIHdoZXRoZXIgdGhlIHVzZXIgaXMgYW5vbnltb3VzIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0VG9rZW5PclByb3ZpZGVyID0gYXN5bmMgKHRva2VuT3JQcm92aWRlciwgdXNlciwgaXNBbm9ueW1vdXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVUb2tlbih0b2tlbk9yUHJvdmlkZXIsIHVzZXIsIGlzQW5vbnltb3VzKTtcbiAgICAgICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0b2tlbk9yUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblByb3ZpZGVyID0gdG9rZW5PclByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdwcm92aWRlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuT3JQcm92aWRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW5PclByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdzdGF0aWMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0b2tlbk9yUHJvdmlkZXIgJiYgdGhpcy51c2VyICYmIHRoaXMuc2VjcmV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbiA9IEpXVFVzZXJUb2tlbih0aGlzLnNlY3JldCwgdXNlci5pZCwge30sIHt9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAnc3RhdGljJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZFRva2VuKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIHRva2VuIG1hbmFnZXIuXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgY2xpZW50IGRpc2Nvbm5lY3Rpb24gb3Igc3dpdGNoaW5nIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudXNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubG9hZFRva2VuUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFZhbGlkYXRlcyB0aGUgdXNlciB0b2tlbi5cbiAgICAgICAgdGhpcy52YWxpZGF0ZVRva2VuID0gKHRva2VuT3JQcm92aWRlciwgdXNlciwgaXNBbm9ueW1vdXMpID0+IHtcbiAgICAgICAgICAgIC8vIGFsbG93IGVtcHR5IHRva2VuIGZvciBhbm9uIHVzZXJcbiAgICAgICAgICAgIGlmICh1c2VyICYmIGlzQW5vbnltb3VzICYmICF0b2tlbk9yUHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgZW1wdHkgdG9rZW4gZm9yIG5vbi1zZXJ2ZXIgc2lkZSBjbGllbnQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VjcmV0ICYmICF0b2tlbk9yUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXJXaXRoSWQgdG9rZW4gY2FuIG5vdCBiZSBlbXB0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuT3JQcm92aWRlciAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0b2tlbk9yUHJvdmlkZXIgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgIWlzRnVuY3Rpb24odG9rZW5PclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlciB0b2tlbiBzaG91bGQgZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5PclByb3ZpZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IGVtcHR5IHRva2VuIGZvciBhbm9ueW1vdXMgdXNlcnNcbiAgICAgICAgICAgICAgICBpZiAoaXNBbm9ueW1vdXMgJiYgdG9rZW5PclByb3ZpZGVyID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuVXNlcklkID0gVXNlckZyb21Ub2tlbih0b2tlbk9yUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbk9yUHJvdmlkZXIgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAodG9rZW5Vc2VySWQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2VySWQgPT09ICcnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoIWlzQW5vbnltb3VzICYmIHRva2VuVXNlcklkICE9PSB1c2VyLmlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyVG9rZW4gZG9lcyBub3QgaGF2ZSBhIHVzZXJfaWQgb3IgaXMgbm90IG1hdGNoaW5nIHdpdGggdXNlci5pZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVzb2x2ZXMgd2hlbiB0b2tlbiBpcyByZWFkeS4gVGhpcyBmdW5jdGlvbiBpcyBzaW1wbHkgdG8gY2hlY2sgaWYgbG9hZFRva2VuIGlzIGluIHByb2dyZXNzLCBpbiB3aGljaFxuICAgICAgICAvLyBjYXNlIGEgZnVuY3Rpb24gc2hvdWxkIHdhaXQuXG4gICAgICAgIHRoaXMudG9rZW5SZWFkeSA9ICgpID0+IHRoaXMubG9hZFRva2VuUHJvbWlzZTtcbiAgICAgICAgLy8gRmV0Y2hlcyBhIHRva2VuIGZyb20gdG9rZW5Qcm92aWRlciBmdW5jdGlvbiBhbmQgc2V0cyBpbiB0b2tlbk1hbmFnZXIuXG4gICAgICAgIC8vIEluIGNhc2Ugb2Ygc3RhdGljIHRva2VuLCBpdCB3aWxsIHNpbXBseSByZXNvbHZlIHRvIHN0YXRpYyB0b2tlbi5cbiAgICAgICAgdGhpcy5sb2FkVG9rZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXN5bmMtcHJvbWlzZS1leGVjdXRvclxuICAgICAgICAgICAgdGhpcy5sb2FkVG9rZW5Qcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlblByb3ZpZGVyICYmIHR5cGVvZiB0aGlzLnRva2VuUHJvdmlkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuID0gYXdhaXQgdGhpcy50b2tlblByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBDYWxsIHRvIHRva2VuUHJvdmlkZXIgZmFpbGVkIHdpdGggbWVzc2FnZTogJHtlfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZFRva2VuUHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmV0dXJucyBhIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgdGhpcy5nZXRUb2tlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51c2VyICYmICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZWNyZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSldUU2VydmVyVG9rZW4odGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCb3RoIHNlY3JldCBhbmQgdXNlciB0b2tlbnMgYXJlIG5vdCBzZXQuIEVpdGhlciBjbGllbnQuY29ubmVjdFVzZXIgd2Fzbid0IGNhbGxlZCBvciBjbGllbnQuZGlzY29ubmVjdCB3YXMgY2FsbGVkYCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSAoKSA9PiB0aGlzLnR5cGUgPT09ICdzdGF0aWMnO1xuICAgICAgICB0aGlzLmxvYWRUb2tlblByb21pc2UgPSBudWxsO1xuICAgICAgICBpZiAoc2VjcmV0KSB7XG4gICAgICAgICAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSAnc3RhdGljJztcbiAgICAgICAgaWYgKHRoaXMuc2VjcmV0KSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gSldUU2VydmVyVG9rZW4odGhpcy5zZWNyZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBBUElFcnJvckNvZGVzID0ge1xuICAgICctMSc6IHsgbmFtZTogJ0ludGVybmFsU3lzdGVtRXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnMic6IHsgbmFtZTogJ0FjY2Vzc0tleUVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICczJzogeyBuYW1lOiAnQXV0aGVudGljYXRpb25GYWlsZWRFcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICc0JzogeyBuYW1lOiAnSW5wdXRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNic6IHsgbmFtZTogJ0R1cGxpY2F0ZVVzZXJuYW1lRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzknOiB7IG5hbWU6ICdSYXRlTGltaXRFcnJvcicsIHJldHJ5YWJsZTogdHJ1ZSB9LFxuICAgICcxNic6IHsgbmFtZTogJ0RvZXNOb3RFeGlzdEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcxNyc6IHsgbmFtZTogJ05vdEFsbG93ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMTgnOiB7IG5hbWU6ICdFdmVudE5vdFN1cHBvcnRlZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcxOSc6IHsgbmFtZTogJ0NoYW5uZWxGZWF0dXJlTm90U3VwcG9ydGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzIwJzogeyBuYW1lOiAnTWVzc2FnZVRvb0xvbmdFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMjEnOiB7IG5hbWU6ICdNdWx0aXBsZU5lc3RpbmdMZXZlbEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICcyMic6IHsgbmFtZTogJ1BheWxvYWRUb29CaWdFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnMjMnOiB7IG5hbWU6ICdSZXF1ZXN0VGltZW91dEVycm9yJywgcmV0cnlhYmxlOiB0cnVlIH0sXG4gICAgJzI0JzogeyBuYW1lOiAnTWF4SGVhZGVyU2l6ZUV4Y2VlZGVkRXJyb3InLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzQwJzogeyBuYW1lOiAnQXV0aEVycm9yVG9rZW5FeHBpcmVkJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc0MSc6IHsgbmFtZTogJ0F1dGhFcnJvclRva2VuTm90VmFsaWRZZXQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzQyJzogeyBuYW1lOiAnQXV0aEVycm9yVG9rZW5Vc2VkQmVmb3JlSXNzdWVkQXQnLCByZXRyeWFibGU6IGZhbHNlIH0sXG4gICAgJzQzJzogeyBuYW1lOiAnQXV0aEVycm9yVG9rZW5TaWduYXR1cmVJbnZhbGlkJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc0NCc6IHsgbmFtZTogJ0N1c3RvbUNvbW1hbmRFbmRwb2ludE1pc3NpbmdFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNDUnOiB7IG5hbWU6ICdDdXN0b21Db21tYW5kRW5kcG9pbnRDYWxsRXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnNDYnOiB7IG5hbWU6ICdDb25uZWN0aW9uSUROb3RGb3VuZEVycm9yJywgcmV0cnlhYmxlOiBmYWxzZSB9LFxuICAgICc2MCc6IHsgbmFtZTogJ0Nvb2xEb3duRXJyb3InLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnNjknOiB7IG5hbWU6ICdFcnJXcm9uZ1JlZ2lvbicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNzAnOiB7IG5hbWU6ICdFcnJRdWVyeUNoYW5uZWxQZXJtaXNzaW9ucycsIHJldHJ5YWJsZTogZmFsc2UgfSxcbiAgICAnNzEnOiB7IG5hbWU6ICdFcnJUb29NYW55Q29ubmVjdGlvbnMnLCByZXRyeWFibGU6IHRydWUgfSxcbiAgICAnOTknOiB7IG5hbWU6ICdBcHBTdXNwZW5kZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2UgfSxcbn07XG5mdW5jdGlvbiBpc0FQSUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXRyeWFibGUoZXJyb3IpIHtcbiAgICBpZiAoIWVycm9yLmNvZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlcnIgPSBBUElFcnJvckNvZGVzW2Ake2Vycm9yLmNvZGV9YF07XG4gICAgaWYgKCFlcnIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZXJyLnJldHJ5YWJsZTtcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvbklERXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSA9PT0gNDY7IC8vIENvbm5lY3Rpb25JRE5vdEZvdW5kRXJyb3Jcbn1cbmZ1bmN0aW9uIGlzV1NGYWlsdXJlKGVycikge1xuICAgIGlmICh0eXBlb2YgZXJyLmlzV1NGYWlsdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGVyci5pc1dTRmFpbHVyZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZXJyLm1lc3NhZ2UpLmlzV1NGYWlsdXJlO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFcnJvclJlc3BvbnNlKHJlcykge1xuICAgIHJldHVybiAhcmVzLnN0YXR1cyB8fCByZXMuc3RhdHVzIDwgMjAwIHx8IDMwMCA8PSByZXMuc3RhdHVzO1xufVxuXG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBDb25uZWN0aW9uU3RhdGVbXCJDbG9zZWRcIl0gPSBcIkNMT1NFRFwiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RlZFwiXSA9IFwiQ09OTkVDVEVEXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGluZ1wiXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiRElTQ09OTkVDVEVEXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW1wiSW5pdFwiXSA9IFwiSU5JVFwiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuY2xhc3MgV1NDb25uZWN0aW9uRmFsbGJhY2sge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5fb25saW5lU3RhdHVzQ2hhbmdlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9nKGBfb25saW5lU3RhdHVzQ2hhbmdlZCgpIC0gJHtldmVudC50eXBlfWApO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdvZmZsaW5lJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsVG9rZW4/LmNhbmNlbCgnZGlzY29ubmVjdCgpIGlzIGNhbGxlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdvbmxpbmUnICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLl9yZXEgPSBhc3luYyAocGFyYW1zLCBjb25maWcsIHJldHJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuY2VsVG9rZW4gJiYgIXBhcmFtcy5jbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsVG9rZW4gPSBheGlvcy5DYW5jZWxUb2tlbi5zb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQuZG9BeGlvc1JlcXVlc3QoJ2dldCcsIHRoaXMuY2xpZW50LmJhc2VVUkwucmVwbGFjZSgnOjMwMzAnLCAnOjg5MDAnKSArICcvbG9uZ3BvbGwnLCAvLyByZXBsYWNlIHBvcnQgaWYgcHJlc2VudCBmb3IgdGVzdGluZyB3aXRoIGxvY2FsIEFQSVxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICBjb25maWc6IHsgLi4uY29uZmlnLCBjYW5jZWxUb2tlbjogdGhpcy5jYW5jZWxUb2tlbj8udG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNFbmRwb2ludDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwOyAvLyBhbHdheXMgcmVzZXQgaW4gY2FzZSBvZiBubyBlcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZUZhaWx1cmVzICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmIChyZXRyeSAmJiBpc0Vycm9yUmV0cnlhYmxlKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBfcmVxKCkgLSBSZXRyeWFibGUgZXJyb3IsIHJldHJ5aW5nIHJlcXVlc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbCh0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlcShwYXJhbXMsIGNvbmZpZywgcmV0cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLl9wb2xsID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcmVxKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7IC8vIDMwcyA9PiBBUEkgcmVzcG9uZHMgaW4gMjBzIGlmIHRoZXJlIGlzIG5vIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmV2ZW50cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudChkYXRhLmV2ZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpb3MuaXNDYW5jZWwoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKGBfcG9sbCgpIC0gYXhpb3MgY2FuY2VsZWQgcmVxdWVzdGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qKiBjbGllbnQuZG9BeGlvc1JlcXVlc3Qgd2lsbCB0YWtlIGNhcmUgb2YgVE9LRU5fRVhQSVJFRCBlcnJvciAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Nvbm5lY3Rpb25JREVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhgX3BvbGwoKSAtIENvbm5lY3Rpb25JRCBlcnJvciwgY29ubmVjdGluZyB3aXRob3V0IElELi4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FQSUVycm9yKGVycikgJiYgIWlzRXJyb3JSZXRyeWFibGUoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNsb3NlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbCh0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb25uZWN0IHRyeSB0byBvcGVuIGEgbG9uZ3BvbGwgcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0gcmVjb25uZWN0IHNob3VsZCBiZSBmYWxzZSBmb3IgZmlyc3QgY2FsbCBhbmQgdHJ1ZSBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlIGFuZCBjYWxsIHJlY292ZXJTdGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0ID0gYXN5bmMgKHJlY29ubmVjdCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ2Nvbm5lY3QoKSAtIGNvbm5lY3RpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcycsIHsgcmVjb25uZWN0IH0sICd3YXJuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coJ2Nvbm5lY3QoKSAtIGFscmVhZHkgY29ubmVjdGVkIGFuZCBwb2xsaW5nJywgeyByZWNvbm5lY3QgfSwgJ3dhcm4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JRCA9IHVuZGVmaW5lZDsgLy8gY29ubmVjdCBzaG91bGQgYmUgc2VudCB3aXRoIGVtcHR5IGNvbm5lY3Rpb25faWQgc28gQVBJIGNyZWF0ZXMgb25lXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQgfSA9IGF3YWl0IHRoaXMuX3JlcSh7IGpzb246IHRoaXMuY2xpZW50Ll9idWlsZFdTUGF5bG9hZCgpIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogODAwMCwgLy8gOHNcbiAgICAgICAgICAgICAgICB9LCByZWNvbm5lY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklEID0gZXZlbnQuY29ubmVjdGlvbl9pZDtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5yZXNvbHZlQ29ubmVjdGlvbklkPy4oKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ2xvc2VkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudC5yZWplY3RDb25uZWN0aW9uSWQ/LigpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlzSGVhbHRoeSBjaGVja3MgaWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uSUQgYW5kIGNvbm5lY3Rpb24gaXMgaW4gQ29ubmVjdGVkIHN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSGVhbHRoeSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuY29ubmVjdGlvbklEICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCA9IGFzeW5jICh0aW1lb3V0ID0gMjAwMCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzKHRoaXMuX29ubGluZVN0YXR1c0NoYW5nZWQpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFRva2VuPy5jYW5jZWwoJ2Rpc2Nvbm5lY3QoKSBpcyBjYWxsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uX2lkID0gdGhpcy5jb25uZWN0aW9uSUQ7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JRCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVxKHsgY2xvc2U6IHRydWUsIGNvbm5lY3Rpb25faWQgfSwge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coYGRpc2Nvbm5lY3QoKSAtIENsb3NlZCBjb25uZWN0aW9uSURgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coYGRpc2Nvbm5lY3QoKSAtIEZhaWxlZGAsIHsgZXJyIH0sICdlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENvbm5lY3Rpb25TdGF0ZS5Jbml0O1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICBhZGRDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnModGhpcy5fb25saW5lU3RhdHVzQ2hhbmdlZCk7XG4gICAgfVxuICAgIF9sb2cobXNnLCBleHRyYSA9IHt9LCBsZXZlbCA9ICdpbmZvJykge1xuICAgICAgICB0aGlzLmNsaWVudC5sb2dnZXIobGV2ZWwsICdXU0Nvbm5lY3Rpb25GYWxsYmFjazonICsgbXNnLCB7XG4gICAgICAgICAgICAuLi5leHRyYSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLl9sb2coYF9zZXRTdGF0ZSgpIC0gJHtzdGF0ZX1gKTtcbiAgICAgICAgLy8gdHJhbnNpdGlvbiBmcm9tIGNvbm5lY3RpbmcgPT4gY29ubmVjdGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyAmJlxuICAgICAgICAgICAgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAnY29ubmVjdGlvbi5jaGFuZ2VkJywgb25saW5lOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZCB8fFxuICAgICAgICAgICAgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc3BhdGNoRXZlbnQoeyB0eXBlOiAnY29ubmVjdGlvbi5jaGFuZ2VkJywgb25saW5lOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxufVxuXG5jb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoWydsb2NhdGlvbiddKTtcbmNvbnN0IEhJTlRfVVJMID0gYGh0dHBzOi8vaGludC5zdHJlYW0taW8tdmlkZW8uY29tL2A7XG5jb25zdCBnZXRMb2NhdGlvbkhpbnQgPSBhc3luYyAoaGludFVybCA9IEhJTlRfVVJMLCB0aW1lb3V0ID0gMjAwMCkgPT4ge1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKEhJTlRfVVJMLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGF3c1BvcCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWFtei1jZi1wb3AnKSB8fCAnRVJSJztcbiAgICAgICAgbG9nZ2VyKCdkZWJ1ZycsIGBMb2NhdGlvbiBoZWFkZXI6ICR7YXdzUG9wfWApO1xuICAgICAgICByZXR1cm4gYXdzUG9wLnN1YnN0cmluZygwLCAzKTsgLy8gQU1TMS1QMiAtPiBBTVNcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyKCd3YXJuJywgYEZhaWxlZCB0byBnZXQgbG9jYXRpb24gaGludCBmcm9tICR7SElOVF9VUkx9YCwgZSk7XG4gICAgICAgIHJldHVybiAnRVJSJztcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbn07XG5cbmNsYXNzIFN0cmVhbUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUgYXBpIGtleVxuICAgICAqIEBwYXJhbSB7U3RyZWFtQ2xpZW50T3B0aW9uc30gW29wdGlvbnNdIC0gYWRkaXRpb25hbCBvcHRpb25zLCBoZXJlIHlvdSBjYW4gcGFzcyBjdXN0b20gb3B0aW9ucyB0byBheGlvcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zZWNyZXRdIC0gdGhlIGFwaSBzZWNyZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJyb3dzZXJdIC0gZW5mb3JjZSB0aGUgY2xpZW50IHRvIGJlIGluIGJyb3dzZXIgbW9kZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2FybVVwXSAtIGRlZmF1bHQgdG8gZmFsc2UsIGlmIHRydWUsIGNsaWVudCB3aWxsIG9wZW4gYSBjb25uZWN0aW9uIGFzIHNvb24gYXMgcG9zc2libGUgdG8gc3BlZWQgdXAgZm9sbG93aW5nIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtMb2dnZXJ9IFtvcHRpb25zLkxvZ2dlcl0gLSBjdXN0b20gbG9nZ2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRpbWVvdXRdIC0gZGVmYXVsdCB0byAzMDAwXG4gICAgICogQHBhcmFtIHtodHRwc0FnZW50fSBbb3B0aW9ucy5odHRwc0FnZW50XSAtIGN1c3RvbSBodHRwc0FnZW50LCBpbiBub2RlIGl0J3MgZGVmYXVsdCB0byBodHRwcy5hZ2VudCgpXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHRoaXMubmV4dFJlcXVlc3RBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRldlRva2VuID0gKHVzZXJJRCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIERldlRva2VuKHVzZXJJRCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QXV0aFR5cGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbm9ueW1vdXMgPyAnYW5vbnltb3VzJyA6ICdqd3QnO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEJhc2VVUkwgPSAoYmFzZVVSTCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICAgICAgICAgIHRoaXMud3NCYXNlVVJMID0gdGhpcy5iYXNlVVJMXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ2h0dHAnLCAnd3MnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCc6MzAzMCcsICc6ODgwMCcpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldExvY2F0aW9uSGludCA9IGFzeW5jIChoaW50VXJsLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaW50ID0gYXdhaXQgdGhpcy5sb2NhdGlvbkhpbnQ7XG4gICAgICAgICAgICBpZiAoIWhpbnQgfHwgaGludCA9PT0gJ0VSUicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGludCA9IGdldExvY2F0aW9uSGludChoaW50VXJsID8/IHRoaXMub3B0aW9ucy5sb2NhdGlvbkhpbnRVcmwsIHRpbWVvdXQgPz8gdGhpcy5vcHRpb25zLmxvY2F0aW9uSGludFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uSGludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoaW50O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9nZXRDb25uZWN0aW9uSUQgPSAoKSA9PiB0aGlzLndzQ29ubmVjdGlvbj8uY29ubmVjdGlvbklEIHx8IHRoaXMud3NGYWxsYmFjaz8uY29ubmVjdGlvbklEO1xuICAgICAgICB0aGlzLl9oYXNDb25uZWN0aW9uSUQgPSAoKSA9PiBCb29sZWFuKHRoaXMuX2dldENvbm5lY3Rpb25JRCgpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbm5lY3RVc2VyIC0gU2V0IHRoZSBjdXJyZW50IHVzZXIgYW5kIG9wZW4gYSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdXNlciBEYXRhIGFib3V0IHRoaXMgdXNlci4gSUUge25hbWU6IFwiam9oblwifVxuICAgICAgICAgKiBAcGFyYW0ge1Rva2VuT3JQcm92aWRlcn0gdXNlclRva2VuT3JQcm92aWRlciBUb2tlbiBvciBwcm92aWRlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtDb25uZWN0QVBJUmVzcG9uc2V9IFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBzZXR1cFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0VXNlciA9IGFzeW5jICh1c2VyLCB1c2VyVG9rZW5PclByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcImlkXCIgZmllbGQgb24gdGhlIHVzZXIgaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsaW5nIGNvbm5lY3RVc2VyIG11bHRpcGxlIHRpbWVzIGlzIHBvdGVudGlhbGx5IHRoZSByZXN1bHQgb2YgYSAgYmFkIGludGVncmF0aW9uLCBob3dldmVyLFxuICAgICAgICAgICAgICogSWYgdGhlIHVzZXIgaWQgcmVtYWlucyB0aGUgc2FtZSB3ZSBkb24ndCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy51c2VySUQgPT09IHVzZXIuaWQgJiYgdGhpcy5zZXRVc2VyUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ0NvbnNlY3V0aXZlIGNhbGxzIHRvIGNvbm5lY3RVc2VyIGlzIGRldGVjdGVkLCBpZGVhbGx5IHlvdSBzaG91bGQgb25seSBjYWxsIHRoaXMgZnVuY3Rpb24gb25jZSBpbiB5b3VyIGFwcC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRVc2VyUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlIGNsaWVudC5kaXNjb25uZWN0KCkgYmVmb3JlIHRyeWluZyB0byBjb25uZWN0IGFzIGEgZGlmZmVyZW50IHVzZXIuIGNvbm5lY3RVc2VyIHdhcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRoaXMuX2lzVXNpbmdTZXJ2ZXJBdXRoKCkgfHwgdGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuYWxsb3dTZXJ2ZXJTaWRlQ29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ1BsZWFzZSBkbyBub3QgdXNlIGNvbm5lY3RVc2VyIHNlcnZlciBzaWRlLiBjb25uZWN0VXNlciBpbXBhY3RzIE1BVSBhbmQgY29uY3VycmVudCBjb25uZWN0aW9uIHVzYWdlIGFuZCB0aHVzIHlvdXIgYmlsbC4gSWYgeW91IGhhdmUgYSB2YWxpZCB1c2UtY2FzZSwgYWRkIFwiYWxsb3dTZXJ2ZXJTaWRlQ29ubmVjdDogdHJ1ZVwiIHRvIHRoZSBjbGllbnQgb3B0aW9ucyB0byBkaXNhYmxlIHRoaXMgd2FybmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGdlbmVyYXRlIHRoZSBjbGllbnQgaWQgY2xpZW50IHNpZGVcbiAgICAgICAgICAgIHRoaXMudXNlcklEID0gdXNlci5pZDtcbiAgICAgICAgICAgIHRoaXMuYW5vbnltb3VzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzZXRUb2tlblByb21pc2UgPSB0aGlzLl9zZXRUb2tlbih1c2VyLCB1c2VyVG9rZW5PclByb3ZpZGVyLCB0aGlzLmFub255bW91cyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVc2VyKHVzZXIpO1xuICAgICAgICAgICAgY29uc3Qgd3NQcm9taXNlID0gdGhpcy5vcGVuQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zZXRVc2VyUHJvbWlzZSA9IFByb21pc2UuYWxsKFtzZXRUb2tlblByb21pc2UsIHdzUHJvbWlzZV0pLnRoZW4oKHJlc3VsdCkgPT4gcmVzdWx0WzFdKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2V0VXNlclByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgY2xpZW50IHRvIGFsbG93IHRoZSB1c2VyIHRvIHJldHJ5IGNvbm5lY3RVc2VyIGFnYWluXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVc2VyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2V0VG9rZW4gPSAodXNlciwgdXNlclRva2VuT3JQcm92aWRlciwgaXNBbm9ueW1vdXMpID0+IHRoaXMudG9rZW5NYW5hZ2VyLnNldFRva2VuT3JQcm92aWRlcih1c2VyVG9rZW5PclByb3ZpZGVyLCB1c2VyLCBpc0Fub255bW91cyk7XG4gICAgICAgIHRoaXMuX3NldFVzZXIgPSAodXNlcikgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIG9uZSBpcyB1c2VkIGJ5IHRoZSBmcm9udGVuZC4gVGhpcyBpcyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdXNlciBvYmplY3Qgc3RvcmVkIG9uIGJhY2tlbmQuXG4gICAgICAgICAgICAgKiBJdCBjb250YWlucyByZXNlcnZlZCBwcm9wZXJ0aWVzIGFuZCBvd24gdXNlciBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBub3QgcHJlc2VudCBpbiBgdGhpcy5fdXNlcmAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgICAgICB0aGlzLnVzZXJJRCA9IHVzZXIuaWQ7XG4gICAgICAgICAgICAvLyB0aGlzIG9uZSBpcyBhY3R1YWxseSB1c2VkIGZvciByZXF1ZXN0cy4gVGhpcyBpcyBhIGNvcHkgb2YgY3VycmVudCB1c2VyIHByb3ZpZGVkIHRvIGBjb25uZWN0VXNlcmAgZnVuY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl91c2VyID0geyAuLi51c2VyIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNjb25uZWN0cyB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24sIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIHVzZXIgc2V0IG9uIGNsaWVudC5cbiAgICAgICAgICogY2xpZW50LmNsb3NlQ29ubmVjdGlvbiB3aWxsIG5vdCB0cmlnZ2VyIGRlZmF1bHQgYXV0by1yZXRyeSBtZWNoYW5pc20gZm9yIHJlY29ubmVjdGlvbi4gWW91IG5lZWRcbiAgICAgICAgICogdG8gY2FsbCBjbGllbnQub3BlbkNvbm5lY3Rpb24gdG8gcmVjb25uZWN0IHRvIHdlYnNvY2tldC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBtYWlubHkgdXNlZnVsIG9uIG1vYmlsZSBzaWRlLiBZb3UgY2FuIG9ubHkgcmVjZWl2ZSBwdXNoIG5vdGlmaWNhdGlvbnNcbiAgICAgICAgICogaWYgeW91IGRvbid0IGhhdmUgYWN0aXZlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgICAgKiBTbyB3aGVuIHlvdXIgYXBwIGdvZXMgdG8gYmFja2dyb3VuZCwgeW91IGNhbiBjYWxsIGBjbGllbnQuY2xvc2VDb25uZWN0aW9uYC5cbiAgICAgICAgICogQW5kIHdoZW4gYXBwIGNvbWVzIGJhY2sgdG8gZm9yZWdyb3VuZCwgY2FsbCBgY2xpZW50Lm9wZW5Db25uZWN0aW9uYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNmdWwgZGlzY29ubmVjdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsZWFuaW5nSW50ZXJ2YWxSZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbmluZ0ludGVydmFsUmVmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFuaW5nSW50ZXJ2YWxSZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy53c0Nvbm5lY3Rpb24/LmRpc2Nvbm5lY3QodGltZW91dCksXG4gICAgICAgICAgICAgICAgdGhpcy53c0ZhbGxiYWNrPy5kaXNjb25uZWN0KHRpbWVvdXQpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFdlYlNvY2tldCBjb25uZWN0aW9uIHdpdGggdGhlIGN1cnJlbnQgdXNlci4gUmV0dXJucyBlbXB0eSBwcm9taXNlLCBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgY29ubmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy51c2VySUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVXNlcldpdGhJZCBpcyBub3Qgc2V0IG9uIGNsaWVudCwgdXNlIGNsaWVudC5jb25uZWN0VXNlciBvciBjbGllbnQuY29ubmVjdEFub255bW91c1VzZXIgaW5zdGVhZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMud3NDb25uZWN0aW9uPy5pc0Nvbm5lY3RpbmcgJiYgdGhpcy53c1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlcignaW5mbycsICdjbGllbnQ6b3BlbkNvbm5lY3Rpb24oKSAtIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndzUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy53c0Nvbm5lY3Rpb24/LmlzSGVhbHRoeSB8fCB0aGlzLndzRmFsbGJhY2s/LmlzSGVhbHRoeSgpKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc0Nvbm5lY3Rpb25JRCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnY2xpZW50Om9wZW5Db25uZWN0aW9uKCkgLSBvcGVuQ29ubmVjdGlvbiBjYWxsZWQgdHdpY2UsIGhlYWx0aHkgY29ubmVjdGlvbiBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbklkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVDb25uZWN0aW9uSWQgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0Q29ubmVjdGlvbklkID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNsaWVudElEID0gYCR7dGhpcy51c2VySUR9LS0ke3JhbmRvbUlkKCl9YDtcbiAgICAgICAgICAgIHRoaXMud3NQcm9taXNlID0gdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53c1Byb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZURhdGUgPSAoYmVmb3JlKSA9PiB7XG4gICAgICAgICAgICBpZiAoYmVmb3JlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IGJlZm9yZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZm9yZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBwYXNzIGJsYW5rIHN0cmluZyBmb3Igc2luY2UsIHVzZSBudWxsIGluc3RlYWQgaWYgcmVzZXR0aW5nIHRoZSB0b2tlbiByZXZva2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVmb3JlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY29ubmVjdHMgdGhlIHdlYnNvY2tldCBhbmQgcmVtb3ZlcyB0aGUgdXNlciBmcm9tIGNsaWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHRpbWVvdXQgTWF4IG51bWJlciBvZiBtcywgdG8gd2FpdCBmb3IgY2xvc2UgZXZlbnQgb2Ygd2Vic29ja2V0LCBiZWZvcmUgZm9yY2VmdWxseSBhc3N1bWluZyBzdWNjZXNzZnVsIGRpc2Nvbm5lY3Rpb24uXG4gICAgICAgICAqICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RVc2VyID0gYXN5bmMgKHRpbWVvdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgJ2NsaWVudDpkaXNjb25uZWN0KCkgLSBEaXNjb25uZWN0aW5nIHRoZSBjbGllbnQnKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgdXNlciBzcGVjaWZpYyBmaWVsZHNcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVzZXI7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXNlcjtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVzZXJJRDtcbiAgICAgICAgICAgIHRoaXMuYW5vbnltb3VzID0gZmFsc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlQ29ubmVjdGlvbih0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5NYW5hZ2VyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnJlamVjdENvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0R3Vlc3RVc2VyID0gYXN5bmMgKHVzZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSA9IHRoaXMuZG9BeGlvc1JlcXVlc3QoJ3Bvc3QnLCAnL2d1ZXN0Jywge1xuICAgICAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udXNlcixcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2d1ZXN0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgeyBwdWJsaWNFbmRwb2ludDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlO1xuICAgICAgICAgICAgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuZ3Vlc3RVc2VyQ3JlYXRlUHJvbWlzZSA9IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFVzZXIocmVzcG9uc2UudXNlciwgcmVzcG9uc2UuYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbm5lY3RBbm9ueW1vdXNVc2VyIC0gU2V0IGFuIGFub255bW91cyB1c2VyIGFuZCBvcGVuIGEgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdEFub255bW91c1VzZXIgPSBhc3luYyAodXNlciwgdG9rZW5PclByb3ZpZGVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29ubmVjdGlvbklkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdENvbm5lY3Rpb25JZCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hbm9ueW1vdXMgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0VG9rZW4odXNlciwgdG9rZW5PclByb3ZpZGVyLCB0aGlzLmFub255bW91cyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVc2VyKHVzZXIpO1xuICAgICAgICAgICAgLy8gc29tZSBlbmRwb2ludHMgcmVxdWlyZSBhIGNvbm5lY3Rpb25faWQgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgICAvLyBhcyBhbm9ueW1vdXMgdXNlcnMgYXJlbid0IGFsbG93ZWQgdG8gb3BlbiBXUyBjb25uZWN0aW9ucywgd2UganVzdFxuICAgICAgICAgICAgLy8gcmVzb2x2ZSB0aGUgY29ubmVjdGlvbl9pZCBoZXJlLlxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29ubmVjdGlvbklkPy4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9uIC0gTGlzdGVuIHRvIGV2ZW50cyBvbiBhbGwgY2hhbm5lbHMgYW5kIHVzZXJzIHlvdXIgd2F0Y2hpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogY2xpZW50Lm9uKCdtZXNzYWdlLm5ldycsIGV2ZW50ID0+IHtjb25zb2xlLmxvZyhcIm15IG5ldyBtZXNzYWdlXCIsIGV2ZW50LCBjaGFubmVsLnN0YXRlLm1lc3NhZ2VzKX0pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvciAob3B0aW9uYWwpXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gY2FsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuICBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCB1bnN1YnNjcmliZXMgdGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdkZWJ1ZycsIGBBZGRpbmcgbGlzdGVuZXIgZm9yICR7ZXZlbnROYW1lfSBldmVudGApO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXT8ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9mZiAtIFJlbW92ZSB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmYgPSAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgYFJlbW92aW5nIGxpc3RlbmVyIGZvciAke2V2ZW50TmFtZX0gZXZlbnRgKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0gPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdPy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2dBcGlSZXF1ZXN0ID0gKHR5cGUsIHVybCwgZGF0YSwgY29uZmlnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCBgY2xpZW50OiAke3R5cGV9IC0gUmVxdWVzdCAtICR7dXJsfWAsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2dBcGlSZXNwb25zZSA9ICh0eXBlLCB1cmwsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcigndHJhY2UnLCBgY2xpZW50OiR7dHlwZX0gLSBSZXNwb25zZSAtIHVybDogJHt1cmx9ID4gc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWAsIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9sb2dBcGlFcnJvciA9ICh0eXBlLCB1cmwsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZXJyb3InLCBgY2xpZW50OiR7dHlwZX0gLSBFcnJvciAtIHVybDogJHt1cmx9YCwge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRvQXhpb3NSZXF1ZXN0ID0gYXN5bmMgKHR5cGUsIHVybCwgZGF0YSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHVibGljRW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5NYW5hZ2VyLnRva2VuUmVhZHkoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndWVzdFVzZXJDcmVhdGVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZFByb21pc2UsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0gdGhpcy5fZW5yaWNoQXhpb3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nQXBpUmVxdWVzdCh0eXBlLCB1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UuZ2V0KHVybCwgcmVxdWVzdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLmRlbGV0ZSh1cmwsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UucG9zdCh1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wdXQodXJsLCBkYXRhLCByZXF1ZXN0Q29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXhpb3NJbnN0YW5jZS5wYXRjaCh1cmwsIGRhdGEsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2Uub3B0aW9ucyh1cmwsIHJlcXVlc3RDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVxdWVzdCB0eXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ0FwaVJlc3BvbnNlKHR5cGUsIHVybCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSAvKipUT0RPOiBnZW5lcmFsaXplIGVycm9yIHR5cGVzICAqLykge1xuICAgICAgICAgICAgICAgIGUuY2xpZW50X3JlcXVlc3RfaWQgPSByZXF1ZXN0Q29uZmlnLmhlYWRlcnM/LlsneC1jbGllbnQtcmVxdWVzdC1pZCddO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ0FwaUVycm9yKHR5cGUsIHVybCwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBjb25uZWN0aW9uX2ZhbGxiYWNrIGRlcGVuZHMgb24gdGhpcyB0b2tlbiBleHBpcmF0aW9uIGxvZ2ljICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnJlc3BvbnNlLmRhdGEuY29kZSA9PT0gS25vd25Db2Rlcy5UT0tFTl9FWFBJUkVEICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy50b2tlbk1hbmFnZXIuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChyZXRyeUludGVydmFsKHRoaXMuY29uc2VjdXRpdmVGYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbk1hbmFnZXIubG9hZFRva2VuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5kb0F4aW9zUmVxdWVzdCh0eXBlLCB1cmwsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlKGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nQXBpRXJyb3IodHlwZSwgdXJsLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0ID0gKHVybCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgnZ2V0JywgdXJsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHV0ID0gKHVybCwgZGF0YSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgncHV0JywgdXJsLCBkYXRhLCB7IHBhcmFtcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb3N0ID0gKHVybCwgZGF0YSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgncG9zdCcsIHVybCwgZGF0YSwgeyBwYXJhbXMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGF0Y2ggPSAodXJsLCBkYXRhLCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQXhpb3NSZXF1ZXN0KCdwYXRjaCcsIHVybCwgZGF0YSwgeyBwYXJhbXMgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlID0gKHVybCwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0F4aW9zUmVxdWVzdCgnZGVsZXRlJywgdXJsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXJyb3JGcm9tUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGxldCBlcnI7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3JGcm9tUmVzcG9uc2UoYFN0cmVhbSBlcnJvciBIVFRQIGNvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKGBTdHJlYW0gZXJyb3IgY29kZSAke3Jlc3BvbnNlLmRhdGEuY29kZX06ICR7cmVzcG9uc2UuZGF0YS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gcmVzcG9uc2UuZGF0YS5jb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBlcnIuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBpZiAoaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3JGcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5yZWNlaXZlZF9hdClcbiAgICAgICAgICAgICAgICBldmVudC5yZWNlaXZlZF9hdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcignZGVidWcnLCBgRGlzcGF0Y2hpbmcgZXZlbnQ6ICR7ZXZlbnQudHlwZX1gLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIGNhbGwgZ2VuZXJpYyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMuYWxsIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsbCB0eXBlIHNwZWNpZmljIGxpc3RlbmVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSB8fCBbXSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXNlcklEIHx8ICF0aGlzLl91c2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbGwgY29ubmVjdFVzZXIgb3IgY29ubmVjdEFub255bW91c1VzZXIgYmVmb3JlIHN0YXJ0aW5nIHRoZSBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMud3NCYXNlVVJMKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1dlYnNvY2tldCBiYXNlIHVybCBub3Qgc2V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50SUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignY2xpZW50SUQgaXMgbm90IHNldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLndzQ29ubmVjdGlvbiAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMud2FybVVwIHx8IHRoaXMub3B0aW9ucy5lbmFibGVJbnNpZ2h0cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zYXlIaSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIFN0YWJsZVdTQ29ubmVjdGlvbiBoYW5kbGVzIGFsbCB0aGUgcmVjb25uZWN0aW9uIGxvZ2ljLlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53c0Nvbm5lY3Rpb24gJiYgdGhpcy5ub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBhdm9pZGluZyBhZGRpbmcgdHMgZ2VuZXJpY3Mgb24gd3NDb25uZWN0aW9uIGluIG9wdGlvbnMgc2luY2UgaXRzIG9ubHkgdXNlZnVsIGZvciB1bml0IHRlc3QgcHVycG9zZS5cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMud3NDb25uZWN0aW9uLnNldENsaWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLndzQ29ubmVjdGlvbiA9IHRoaXMub3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAud3NDb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53c0Nvbm5lY3Rpb24gPSBuZXcgU3RhYmxlV1NDb25uZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBmYWxsYmFjayBpcyB1c2VkIGJlZm9yZSwgY29udGludWUgdXNpbmcgaXQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBXUyB0byBmYWlsXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMud3NGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy53c0ZhbGxiYWNrLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2luZm8nLCAnU3RyZWFtQ2xpZW50LmNvbm5lY3Q6IHRoaXMud3NDb25uZWN0aW9uLmNvbm5lY3QoKScpO1xuICAgICAgICAgICAgICAgIC8vIGlmIFdTRmFsbGJhY2sgaXMgZW5hYmxlZCwgd3MgY29ubmVjdCBzaG91bGQgdGltZW91dCBmYXN0ZXIgc28gZmFsbGJhY2sgY2FuIHRyeVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzQ29ubmVjdGlvbi5jb25uZWN0KHRoaXMub3B0aW9ucy5lbmFibGVXU0ZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5kZWZhdWx0V1NUaW1lb3V0V2l0aEZhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5kZWZhdWx0V1NUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBydW4gZmFsbGJhY2sgb25seSBpZiBpdCdzIFdTL05ldHdvcmsgZXJyb3IgYW5kIG5vdCBhIG5vcm1hbCBBUEkgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYnJvd3NlciBpcyBvbmxpbmUgYmVmb3JlIGV2ZW4gdHJ5aW5nIHRoZSBsb25ncG9sbFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlV1NGYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGlzV1NGYWlsdXJlKGVycikgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPbmxpbmUodGhpcy5sb2dnZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ2NsaWVudDpjb25uZWN0KCkgLSBXUyBmYWlsZWQsIGZhbGxiYWNrIHRvIGxvbmdwb2xsJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6ICd0cmFuc3BvcnQuY2hhbmdlZCcsIG1vZGU6ICdsb25ncG9sbCcgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3NDb25uZWN0aW9uLl9kZXN0cm95Q3VycmVudFdTQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndzQ29ubmVjdGlvbi5kaXNjb25uZWN0KCkudGhlbigpOyAvLyBjbG9zZSBXUyBzbyBubyByZXRyeVxuICAgICAgICAgICAgICAgICAgICB0aGlzLndzRmFsbGJhY2sgPSBuZXcgV1NDb25uZWN0aW9uRmFsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLndzRmFsbGJhY2suY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB0aGUgY29ubmVjdGl2aXR5IHdpdGggc2VydmVyIGZvciB3YXJtdXAgcHVycG9zZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NheUhpID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50X3JlcXVlc3RfaWQgPSByYW5kb21JZCgpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBBeGlvc0hlYWRlcnMuZnJvbSh7XG4gICAgICAgICAgICAgICAgICAgICd4LWNsaWVudC1yZXF1ZXN0LWlkJzogY2xpZW50X3JlcXVlc3RfaWQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kb0F4aW9zUmVxdWVzdCgnZ2V0JywgdGhpcy5iYXNlVVJMICsgJy9oaScsIG51bGwsIG9wdHMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVJbnNpZ2h0cykge1xuICAgICAgICAgICAgICAgICAgICBwb3N0SW5zaWdodHMoJ2h0dHBfaGlfZmFpbGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnI6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfcmVxdWVzdF9pZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0VXNlckFnZW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IFwiMC42LjBcIiA7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudXNlckFnZW50IHx8XG4gICAgICAgICAgICAgICAgYHN0cmVhbS12aWRlby1qYXZhc2NyaXB0LWNsaWVudC0ke3RoaXMubm9kZSA/ICdub2RlJyA6ICdicm93c2VyJ30tJHt2ZXJzaW9ufWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldFVzZXJBZ2VudCA9ICh1c2VyQWdlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXNlckFnZW50ID0gdXNlckFnZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogX2lzVXNpbmdTZXJ2ZXJBdXRoIC0gUmV0dXJucyB0cnVlIGlmIHdlJ3JlIHVzaW5nIHNlcnZlciBzaWRlIGF1dGhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2lzVXNpbmdTZXJ2ZXJBdXRoID0gKCkgPT4gISF0aGlzLnNlY3JldDtcbiAgICAgICAgdGhpcy5fZW5yaWNoQXhpb3NPcHRpb25zID0gKG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IG9wdGlvbnMucHVibGljRW5kcG9pbnQgJiYgIXRoaXMudXNlciA/IHVuZGVmaW5lZCA6IHRoaXMuX2dldFRva2VuKCk7XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gdG9rZW4gPyB7IEF1dGhvcml6YXRpb246IHRva2VuIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc2lnbmFsID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRSZXF1ZXN0QWJvcnRDb250cm9sbGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsID0gdGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWVzdEFib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycz8uWyd4LWNsaWVudC1yZXF1ZXN0LWlkJ10pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiByYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICB1c2VyX2lkOiB0aGlzLnVzZXJJRCxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbl9pZDogdGhpcy5fZ2V0Q29ubmVjdGlvbklEKCksXG4gICAgICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgICAgICAgICAgJ3N0cmVhbS1hdXRoLXR5cGUnOiBvcHRpb25zLnB1YmxpY0VuZHBvaW50ICYmICF0aGlzLnVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ2Fub255bW91cydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5nZXRBdXRoVHlwZSgpLFxuICAgICAgICAgICAgICAgICAgICAnWC1TdHJlYW0tQ2xpZW50JzogdGhpcy5nZXRVc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uKHNpZ25hbCA/IHsgc2lnbmFsIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5jb25maWcsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmF4aW9zUmVxdWVzdENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2dldFRva2VuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRva2VuTWFuYWdlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuTWFuYWdlci5nZXRUb2tlbigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogZW5jb2RlIHdzIHVybCBwYXlsb2FkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIGpzb24gc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWlsZFdTUGF5bG9hZCA9IChjbGllbnRfcmVxdWVzdF9pZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB0aGlzLnVzZXJJRCxcbiAgICAgICAgICAgICAgICB1c2VyX2RldGFpbHM6IHRoaXMuX3VzZXIsXG4gICAgICAgICAgICAgICAgY2xpZW50X3JlcXVlc3RfaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNyZWF0ZXMgYW4gYWJvcnQgY29udHJvbGxlciB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgbmV4dCBIVFRQIFJlcXVlc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUFib3J0Q29udHJvbGxlckZvck5leHRSZXF1ZXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm5leHRSZXF1ZXN0QWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNyZWF0ZVRva2VuIC0gQ3JlYXRlcyBhIHRva2VuIHRvIGF1dGhlbnRpY2F0ZSB0aGlzIHVzZXIuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBzZXJ2ZXIgc2lkZS5cbiAgICAgICAgICogVGhlIHJlc3VsdGluZyB0b2tlbiBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjbGllbnQgc2lkZSB3aGVuIHRoZSB1c2VycyByZWdpc3RlcnMgb3IgbG9ncyBpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCBUaGUgVXNlcldpdGhJZCBJRFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2V4cF0gVGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRva2VuIGV4cHJlc3NlZCBpbiB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoXG4gICAgICAgICAqIEBwYXJhbSBjYWxsX2NpZHMgZm9yIGFub255bW91cyB0b2tlbnMgeW91IGhhdmUgdG8gcHJvdmlkZSB0aGUgY2FsbCBjaWRzIHRoZSB1c2UgY2FuIGpvaW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIGEgdG9rZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlVG9rZW4gPSAodXNlcklELCBleHAsIGlhdCwgY2FsbF9jaWRzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWNyZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGB0b2tlbnMgY2FuIG9ubHkgYmUgY3JlYXRlZCBzZXJ2ZXItc2lkZSB1c2luZyB0aGUgQVBJIFNlY3JldGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7fTtcbiAgICAgICAgICAgIGlmIChleHApIHtcbiAgICAgICAgICAgICAgICBleHRyYS5leHAgPSBleHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWF0KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuaWF0ID0gaWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxfY2lkcykge1xuICAgICAgICAgICAgICAgIGV4dHJhLmNhbGxfY2lkcyA9IGNhbGxfY2lkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEsIHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2V0IHRoZSBrZXlcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIC8vIHNldCB0aGUgc2VjcmV0XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gb3B0aW9ucz8uc2VjcmV0O1xuICAgICAgICAvLyBzZXQgdGhlIG9wdGlvbnMuLi4gYW5kIGZpZ3VyZSBvdXQgZGVmYXVsdHMuLi5cbiAgICAgICAgY29uc3QgaW5wdXRPcHRpb25zID0gb3B0aW9uc1xuICAgICAgICAgICAgPyBvcHRpb25zXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBicm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuYnJvd3NlciA9IGlucHV0T3B0aW9ucy5icm93c2VyIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB0aGlzLm5vZGUgPSAhdGhpcy5icm93c2VyO1xuICAgICAgICBpZiAodGhpcy5icm93c2VyKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uSGludCA9IGdldExvY2F0aW9uSGludChvcHRpb25zPy5sb2NhdGlvbkhpbnRVcmwsIG9wdGlvbnM/LmxvY2F0aW9uSGludFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgd2FybVVwOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLmlucHV0T3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubm9kZSAmJiAhdGhpcy5vcHRpb25zLmh0dHBzQWdlbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5odHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlTXNlY3M6IDMwMDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEJhc2VVUkwodGhpcy5vcHRpb25zLmJhc2VVUkwgfHwgJ2h0dHBzOi8vdmlkZW8uc3RyZWFtLWlvLWFwaS5jb20vdmlkZW8nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5TVFJFQU1fTE9DQUxfVEVTVF9SVU4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZVVSTCgnaHR0cDovL2xvY2FsaG9zdDozMDMwL3ZpZGVvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5TVFJFQU1fTE9DQUxfVEVTVF9IT1NUKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJhc2VVUkwoYGh0dHA6Ly8ke3Byb2Nlc3MuZW52LlNUUkVBTV9MT0NBTF9URVNUX0hPU1R9L3ZpZGVvYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5heGlvc0luc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGJhc2VVUkw6IHRoaXMuYmFzZVVSTCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdTIGNvbm5lY3Rpb24gaXMgaW5pdGlhbGl6ZWQgd2hlbiBzZXRVc2VyIGlzIGNhbGxlZFxuICAgICAgICB0aGlzLndzQ29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMud3NQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRVc2VyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8vIG1hcHBpbmcgYmV0d2VlbiBjaGFubmVsIGdyb3VwcyBhbmQgY29uZmlnc1xuICAgICAgICB0aGlzLmFub255bW91cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZSA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnM/LnBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZTtcbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZXJ2ZXItc2lkZSBjbGllbnQsIHRoZW4gbGV0cyBpbml0aWFsaXplIHRoZSB0b2tlbk1hbmFnZXIsIHNpbmNlIHRva2VuIHdpbGwgYmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZyb20gc2VjcmV0LlxuICAgICAgICB0aGlzLnRva2VuTWFuYWdlciA9IG5ldyBUb2tlbk1hbmFnZXIodGhpcy5zZWNyZXQpO1xuICAgICAgICB0aGlzLmNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmluc2lnaHRNZXRyaWNzID0gbmV3IEluc2lnaHRNZXRyaWNzKCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFdTVGltZW91dFdpdGhGYWxsYmFjayA9IDYwMDA7XG4gICAgICAgIHRoaXMuZGVmYXVsdFdTVGltZW91dCA9IDE1MDAwO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGlzRnVuY3Rpb24oaW5wdXRPcHRpb25zLmxvZ2dlcilcbiAgICAgICAgICAgID8gaW5wdXRPcHRpb25zLmxvZ2dlclxuICAgICAgICAgICAgOiAoKSA9PiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGBTdHJlYW1WaWRlb0NsaWVudGAgaW5zdGFuY2UgbGV0cyB5b3UgY29tbXVuaWNhdGUgd2l0aCBvdXIgQVBJLCBhbmQgYXV0aGVudGljYXRlIHVzZXJzLlxuICovXG5jbGFzcyBTdHJlYW1WaWRlb0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5T3JBcmdzLCBvcHRzKSB7XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSAnd2Fybic7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3RlciA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY29ubmVjdHMgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgdXNlciBmcm9tIHRoZSBjbGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBkaXNjb25uZWN0ZWQsIHRoZSBjb25uZWN0ZWQgdXNlciBbc3RhdGUgdmFyaWFibGVdKCNyZWFkb25seXN0YXRlc3RvcmUpIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gdGltZW91dCBNYXggbnVtYmVyIG9mIG1zLCB0byB3YWl0IGZvciBjbG9zZSBldmVudCBvZiB3ZWJzb2NrZXQsIGJlZm9yZSBmb3JjZWZ1bGx5IGFzc3VtaW5nIHN1Y2Nlc3NmdWwgZGlzY29ubmVjdGlvbi5cbiAgICAgICAgICogICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nsb3NlRXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFVzZXIgPSBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0cmVhbUNsaWVudC51c2VyICYmICF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlzY29ubmVjdFVzZXIgPSAoKSA9PiB0aGlzLnN0cmVhbUNsaWVudC5kaXNjb25uZWN0VXNlcih0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gZGlzY29ubmVjdFVzZXIoKSlcbiAgICAgICAgICAgICAgICA6IGRpc2Nvbm5lY3RVc2VyKCk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdGlvblByb21pc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIuZm9yRWFjaCgodW5yZWdpc3RlcikgPT4gdW5yZWdpc3RlcigpKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1RvVW5yZWdpc3RlciA9IFtdO1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnNldENvbm5lY3RlZFVzZXIodW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gc3Vic2NyaWJlIHRvIFdlYlNvY2tldCBldmVudHMgcHJvdmlkZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgICogVG8gcmVtb3ZlIGEgc3Vic2NyaXB0aW9uLCBjYWxsIHRoZSBgb2ZmYCBtZXRob2Qgb3IsIGV4ZWN1dGUgdGhlIHJldHVybmVkIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHN1YnNjcmliaW5nIHRvIFdlYlNvY2tldCBldmVudHMgaXMgYW4gYWR2YW5jZWQgdXNlLWNhc2UsIGZvciBtb3N0IHVzZS1jYXNlcyBpdCBzaG91bGQgYmUgZW5vdWdoIHRvIHdhdGNoIGZvciBjaGFuZ2VzIGluIHRoZSByZWFjdGl2ZSBbc3RhdGUgc3RvcmVdKCNyZWFkb25seXN0YXRlc3RvcmUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHRoZSBldmVudCBuYW1lIG9yICdhbGwnLlxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbiA9IChldmVudE5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQub24oZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgc3Vic2NyaXB0aW9uIGZvciBXZWJTb2NrZXQgZXZlbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGJ5IHRoZSBgb25gIG1ldGhvZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSB0aGUgZXZlbnQgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB3aGljaCB3YXMgcGFzc2VkIHRvIHRoZSBgb25gIG1ldGhvZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub2ZmID0gKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGNhbGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBjYWxsLlxuICAgICAgICAgKiBAcGFyYW0gaWQgdGhlIGlkIG9mIHRoZSBjYWxsLCBpZiBub3QgcHJvdmlkZWQgYSB1bmlxdWUgcmFuZG9tIHZhbHVlIGlzIHVzZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FsbCA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICBzdHJlYW1DbGllbnQ6IHRoaXMuc3RyZWFtQ2xpZW50LFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgZ3Vlc3QgdXNlciB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGd1ZXN0IHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUd1ZXN0VXNlciA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZG9BeGlvc1JlcXVlc3QoJ3Bvc3QnLCAnL2d1ZXN0JywgZGF0YSwgeyBwdWJsaWNFbmRwb2ludDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpbGwgcXVlcnkgdGhlIEFQSSBmb3IgY2FsbHMgbWF0Y2hpbmcgdGhlIGdpdmVuIGZpbHRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIHRoZSBxdWVyeSBkYXRhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWVyeUNhbGxzID0gYXN5bmMgKGRhdGEgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5wb3N0KCcvY2FsbHMnLCBkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxzID0gcmVzcG9uc2UuY2FsbHMubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbCA9IG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGMuY2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYy5jYWxsLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcnM6IGMubWVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgb3duQ2FwYWJpbGl0aWVzOiBjLm93bl9jYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoaW5nOiBkYXRhLndhdGNoLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjLmNhbGwpO1xuICAgICAgICAgICAgICAgIGNhbGwuYXBwbHlEZXZpY2VDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS53YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUucmVnaXN0ZXJDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBjYWxsczogY2FsbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGRhdGEgY2VudGVycyBhdmFpbGFibGUgZm9yIGhvc3RpbmcgY2FsbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChgL2VkZ2VzYCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGREZXZpY2UgLSBBZGRzIGEgcHVzaCBkZXZpY2UgZm9yIGEgdXNlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHB1c2hfcHJvdmlkZXIgdGhlIHB1c2ggcHJvdmlkZXIgbmFtZSAoZWcuIGFwbiwgZmlyZWJhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwdXNoX3Byb3ZpZGVyX25hbWUgdXNlciBwcm92aWRlZCBwdXNoIHByb3ZpZGVyIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VySURdIHRoZSB1c2VyIGlkIChkZWZhdWx0cyB0byBjdXJyZW50IHVzZXIpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZvaXBfdG9rZW5dIGVuYWJsZXMgdXNlIG9mIFZvSVAgdG9rZW4gZm9yIHB1c2ggbm90aWZpY2F0aW9ucyBvbiBpT1MgcGxhdGZvcm1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkRGV2aWNlID0gYXN5bmMgKGlkLCBwdXNoX3Byb3ZpZGVyLCBwdXNoX3Byb3ZpZGVyX25hbWUsIHVzZXJJRCwgdm9pcF90b2tlbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc3RyZWFtQ2xpZW50LnBvc3QoJy9kZXZpY2VzJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHB1c2hfcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgdm9pcF90b2tlbixcbiAgICAgICAgICAgICAgICAuLi4odXNlcklEICE9IG51bGwgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30pLFxuICAgICAgICAgICAgICAgIC4uLihwdXNoX3Byb3ZpZGVyX25hbWUgIT0gbnVsbCA/IHsgcHVzaF9wcm92aWRlcl9uYW1lIH0gOiB7fSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldERldmljZXMgLSBSZXR1cm5zIHRoZSBkZXZpY2VzIGFzc29jaWF0ZWQgd2l0aCBhIGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJJRF0gVXNlciBJRC4gT25seSB3b3JrcyBvbiBzZXJ2ZXJzaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERldmljZXMgPSBhc3luYyAodXNlcklEKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zdHJlYW1DbGllbnQuZ2V0KCcvZGV2aWNlcycsIHVzZXJJRCA/IHsgdXNlcl9pZDogdXNlcklEIH0gOiB7fSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVEZXZpY2UgLSBSZW1vdmVzIHRoZSBkZXZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZGV2aWNlIGlkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdXNlcklEXSBUaGUgdXNlciBpZC4gT25seSBzcGVjaWZ5IHRoaXMgZm9yIHNlcnZlcnNpZGUgcmVxdWVzdHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3ZlRGV2aWNlID0gYXN5bmMgKGlkLCB1c2VySUQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0cmVhbUNsaWVudC5kZWxldGUoJy9kZXZpY2VzJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIC4uLih1c2VySUQgPyB7IHVzZXJfaWQ6IHVzZXJJRCB9IDoge30pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHJpbmdpbmcgY2FsbHMgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMuIElmIHRoZSBjYWxsIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsX2NpZFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblJpbmdpbmdDYWxsID0gYXN5bmMgKGNhbGxfY2lkKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBmaW5kIHRoZSBjYWxsIGFuZCBpcyBhbHJlYWR5IHJpbmdpbmcsIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGNhbGxcbiAgICAgICAgICAgIC8vIGFzIGNsaWVudCB3b3VsZCBoYXZlIHJlY2VpdmVkIHRoZSBjYWxsLnJpbmcgc3RhdGUgYmVjYXVzZSB0aGUgYXBwIGhhZCBXUyBhbGl2ZSB3aGVuIHJlY2VpdmluZyBwdXNoIG5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgIGxldCBjYWxsID0gdGhpcy5yZWFkT25seVN0YXRlU3RvcmUuY2FsbHMuZmluZCgoYykgPT4gYy5jaWQgPT09IGNhbGxfY2lkICYmIGMucmluZ2luZyk7XG4gICAgICAgICAgICBpZiAoIWNhbGwpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgaXQgbWVhbnMgdGhhdCBXUyBpcyBub3QgYWxpdmUgd2hlbiByZWNlaXZpbmcgdGhlIHB1c2ggbm90aWZpY2F0aW9ucyBhbmQgd2UgbmVlZCB0byBmZXRjaCB0aGUgY2FsbFxuICAgICAgICAgICAgICAgIGNvbnN0IFtjYWxsVHlwZSwgY2FsbElkXSA9IGNhbGxfY2lkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgY2FsbCA9IG5ldyBDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2FsbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFN0b3JlOiB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHJpbmdpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5nZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29ubmVjdHMgdGhlIGdpdmVuIGFub255bW91cyB1c2VyIHRvIHRoZSBjbGllbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB1c2VyIHRoZSB1c2VyIHRvIGNvbm5lY3QuXG4gICAgICAgICAqIEBwYXJhbSB0b2tlbk9yUHJvdmlkZXIgYSB0b2tlbiBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRva2VuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0QW5vbnltb3VzVXNlciA9IGFzeW5jICh1c2VyLCB0b2tlbk9yUHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RBbm9ueW1vdXNVc2VyID0gKCkgPT4gdGhpcy5zdHJlYW1DbGllbnQuY29ubmVjdEFub255bW91c1VzZXIodXNlciwgdG9rZW5PclByb3ZpZGVyKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gY29ubmVjdEFub255bW91c1VzZXIoKSlcbiAgICAgICAgICAgICAgICA6IGNvbm5lY3RBbm9ueW1vdXNVc2VyKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLmZpbmFsbHkoKCkgPT4gKHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbG9nZ2VyID0gbG9nVG9Db25zb2xlO1xuICAgICAgICBsZXQgbG9nTGV2ZWwgPSAnd2Fybic7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5T3JBcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbG9nTGV2ZWwgPSBvcHRzPy5sb2dMZXZlbCB8fCBsb2dMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlciA9IG9wdHM/LmxvZ2dlciB8fCBsb2dnZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMZXZlbCA9IGFwaUtleU9yQXJncy5vcHRpb25zPy5sb2dMZXZlbCB8fCBsb2dMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlciA9IGFwaUtleU9yQXJncy5vcHRpb25zPy5sb2dnZXIgfHwgbG9nZ2VyO1xuICAgICAgICB9XG4gICAgICAgIHNldExvZ2dlcihsb2dnZXIsIGxvZ0xldmVsKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIoWydjbGllbnQnXSk7XG4gICAgICAgIGlmICh0eXBlb2YgYXBpS2V5T3JBcmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBuZXcgU3RyZWFtQ2xpZW50KGFwaUtleU9yQXJncywge1xuICAgICAgICAgICAgICAgIHBlcnNpc3RVc2VyT25Db25uZWN0aW9uRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50ID0gbmV3IFN0cmVhbUNsaWVudChhcGlLZXlPckFyZ3MuYXBpS2V5LCB7XG4gICAgICAgICAgICAgICAgcGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLmFwaUtleU9yQXJncy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2dnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNka0luZm8gPSBnZXRTZGtJbmZvKCk7XG4gICAgICAgICAgICBpZiAoc2RrSW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ2xpZW50LnNldFVzZXJBZ2VudCh0aGlzLnN0cmVhbUNsaWVudC5nZXRVc2VyQWdlbnQoKSArXG4gICAgICAgICAgICAgICAgICAgIGAtdmlkZW8tJHtTZGtUeXBlW3Nka0luZm8udHlwZV0udG9Mb3dlckNhc2UoKX0tc2RrLSR7c2RrSW5mby5tYWpvcn0uJHtzZGtJbmZvLm1pbm9yfS4ke3Nka0luZm8ucGF0Y2h9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlID0gbmV3IFN0cmVhbVZpZGVvV3JpdGVhYmxlU3RhdGVTdG9yZSgpO1xuICAgICAgICB0aGlzLnJlYWRPbmx5U3RhdGVTdG9yZSA9IG5ldyBTdHJlYW1WaWRlb1JlYWRPbmx5U3RhdGVTdG9yZSh0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUpO1xuICAgICAgICBpZiAodHlwZW9mIGFwaUtleU9yQXJncyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhcGlLZXlPckFyZ3MudXNlcjtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gYXBpS2V5T3JBcmdzLnRva2VuIHx8IGFwaUtleU9yQXJncy50b2tlblByb3ZpZGVyO1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RVc2VyKHVzZXIsIHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJlYWN0aXZlIHN0YXRlIHN0b3JlLCB1c2UgdGhpcyBpZiB5b3Ugd2FudCB0byBiZSBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvIHRoZSBjbGllbnQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRPbmx5U3RhdGVTdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdGhlIGdpdmVuIHVzZXIgdG8gdGhlIGNsaWVudC5cbiAgICAgKiBPbmx5IG9uZSB1c2VyIGNhbiBjb25uZWN0IGF0IGEgdGltZSwgaWYgeW91IHdhbnQgdG8gY2hhbmdlIHVzZXJzLCBjYWxsIGBkaXNjb25uZWN0VXNlcmAgYmVmb3JlIGNvbm5lY3RpbmcgYSBuZXcgdXNlci5cbiAgICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgY29ubmVjdGVkIHVzZXIgW3N0YXRlIHZhcmlhYmxlXSgjcmVhZG9ubHlzdGF0ZXN0b3JlKSB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlciB0aGUgdXNlciB0byBjb25uZWN0LlxuICAgICAqIEBwYXJhbSB0b2tlbiBhIHRva2VuIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdFVzZXIodXNlciwgdG9rZW4pIHtcbiAgICAgICAgaWYgKHVzZXIudHlwZSA9PT0gJ2Fub255bW91cycpIHtcbiAgICAgICAgICAgIHVzZXIuaWQgPSAnIWFub24nO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEFub255bW91c1VzZXIodXNlciwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb25uZWN0VXNlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5jb25uZWN0VXNlcih1c2VyLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1c2VyLnR5cGUgPT09ICdndWVzdCcpIHtcbiAgICAgICAgICAgIGNvbm5lY3RVc2VyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5jb25uZWN0R3Vlc3RVc2VyKHVzZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5kaXNjb25uZWN0aW9uUHJvbWlzZVxuICAgICAgICAgICAgPyB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4gY29ubmVjdFVzZXIoKSlcbiAgICAgICAgICAgIDogY29ubmVjdFVzZXIoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZT8uZmluYWxseSgoKSA9PiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCBjb25uZWN0VXNlclJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICAgICAgLy8gY29ubmVjdFVzZXJSZXNwb25zZSB3aWxsIGJlIHZvaWQgaWYgY29ubmVjdFVzZXIgY2FsbGVkIHR3aWNlIGZvciB0aGUgc2FtZSB1c2VyXG4gICAgICAgIGlmIChjb25uZWN0VXNlclJlc3BvbnNlPy5tZSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnNldENvbm5lY3RlZFVzZXIoY29ubmVjdFVzZXJSZXNwb25zZS5tZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLnB1c2godGhpcy5vbignY29ubmVjdGlvbi5jaGFuZ2VkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQub25saW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbHNUb1JlV2F0Y2ggPSB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuY2FsbHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoY2FsbCkgPT4gY2FsbC53YXRjaGluZylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoY2FsbCkgPT4gY2FsbC5jaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYFJld2F0Y2hpbmcgY2FsbHMgYWZ0ZXIgY29ubmVjdGlvbiBjaGFuZ2VkICR7Y2FsbHNUb1JlV2F0Y2guam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbHNUb1JlV2F0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5Q2FsbHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJfY29uZGl0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogeyAkaW46IGNhbGxzVG9SZVdhdGNoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydDogW3sgZmllbGQ6ICdjaWQnLCBkaXJlY3Rpb246IDEgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdlcnJvcicsICdGYWlsZWQgdG8gcmUtd2F0Y2ggY2FsbHMnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzVG9VbnJlZ2lzdGVyLnB1c2godGhpcy5vbignY2FsbC5jcmVhdGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNhbGwsIG1lbWJlcnMgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHVzZXIuaWQgPT09IGNhbGwuY3JlYXRlZF9ieS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyKCd3YXJuJywgJ1JlY2VpdmVkIGBjYWxsLmNyZWF0ZWRgIHNlbnQgYnkgdGhlIGN1cnJlbnQgdXNlcicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyKCdpbmZvJywgYE5ldyBjYWxsIGNyZWF0ZWQgYW5kIHJlZ2lzdGVyZWQ6ICR7Y2FsbC5jaWR9YCk7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWxsID0gbmV3IENhbGwoe1xuICAgICAgICAgICAgICAgIHN0cmVhbUNsaWVudDogdGhpcy5zdHJlYW1DbGllbnQsXG4gICAgICAgICAgICAgICAgdHlwZTogY2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIGlkOiBjYWxsLmlkLFxuICAgICAgICAgICAgICAgIG1lbWJlcnMsXG4gICAgICAgICAgICAgICAgY2xpZW50U3RvcmU6IHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3Q2FsbC5zdGF0ZS51cGRhdGVGcm9tQ2FsbFJlc3BvbnNlKGNhbGwpO1xuICAgICAgICAgICAgdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLnJlZ2lzdGVyQ2FsbChuZXdDYWxsKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIucHVzaCh0aGlzLm9uKCdjYWxsLnJpbmcnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FsbCwgbWVtYmVycyB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBpZiAodXNlci5pZCA9PT0gY2FsbC5jcmVhdGVkX2J5LmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIoJ2RlYnVnJywgJ1JlY2VpdmVkIGBjYWxsLnJpbmdgIHNlbnQgYnkgdGhlIGN1cnJlbnQgdXNlciBzbyBpZ25vcmluZyB0aGUgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY2FsbCBtaWdodCBhbHJlYWR5IGJlIHRyYWNrZWQgYnkgdGhlIGNsaWVudCxcbiAgICAgICAgICAgIC8vIGlmIGBjYWxsLmNyZWF0ZWRgIHdhcyByZWNlaXZlZCBiZWZvcmUgYGNhbGwucmluZ2AuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGNsZWFudXAgdGhlIGFscmVhZHkgdHJhY2tlZCBjYWxsLlxuICAgICAgICAgICAgY29uc3QgcHJldkNhbGwgPSB0aGlzLndyaXRlYWJsZVN0YXRlU3RvcmUuZmluZENhbGwoY2FsbC50eXBlLCBjYWxsLmlkKTtcbiAgICAgICAgICAgIGF3YWl0IHByZXZDYWxsPy5sZWF2ZSgpO1xuICAgICAgICAgICAgLy8gd2UgY3JlYXRlIGEgbmV3IGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHRoZUNhbGwgPSBuZXcgQ2FsbCh7XG4gICAgICAgICAgICAgICAgc3RyZWFtQ2xpZW50OiB0aGlzLnN0cmVhbUNsaWVudCxcbiAgICAgICAgICAgICAgICB0eXBlOiBjYWxsLnR5cGUsXG4gICAgICAgICAgICAgICAgaWQ6IGNhbGwuaWQsXG4gICAgICAgICAgICAgICAgbWVtYmVycyxcbiAgICAgICAgICAgICAgICBjbGllbnRTdG9yZTogdGhpcy53cml0ZWFibGVTdGF0ZVN0b3JlLFxuICAgICAgICAgICAgICAgIHJpbmdpbmc6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoZUNhbGwuc3RhdGUudXBkYXRlRnJvbUNhbGxSZXNwb25zZShjYWxsKTtcbiAgICAgICAgICAgIC8vIHdlIGZldGNoIHRoZSBsYXRlc3QgbWV0YWRhdGEgZm9yIHRoZSBjYWxsIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgYXdhaXQgdGhlQ2FsbC5nZXQoKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVhYmxlU3RhdGVTdG9yZS5yZWdpc3RlckNhbGwodGhlQ2FsbCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RVc2VyUmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGFkZERldmljZSAtIEFkZHMgYSBwdXNoIGRldmljZSBmb3IgYSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBkZXZpY2UgaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVzaF9wcm92aWRlciB0aGUgcHVzaCBwcm92aWRlciBuYW1lIChlZy4gYXBuLCBmaXJlYmFzZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVzaF9wcm92aWRlcl9uYW1lIHVzZXIgcHJvdmlkZWQgcHVzaCBwcm92aWRlciBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1c2VySURdIHRoZSB1c2VyIGlkIChkZWZhdWx0cyB0byBjdXJyZW50IHVzZXIpXG4gICAgICovXG4gICAgYXN5bmMgYWRkVm9pcERldmljZShpZCwgcHVzaF9wcm92aWRlciwgcHVzaF9wcm92aWRlcl9uYW1lLCB1c2VySUQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRkRGV2aWNlKGlkLCBwdXNoX3Byb3ZpZGVyLCBwdXNoX3Byb3ZpZGVyX25hbWUsIHVzZXJJRCwgdHJ1ZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgdGhlIGBAc3RyZWFtLWlvL25vZGUtc2RrYCBwYWNrYWdlIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL2dldHN0cmVhbS5pby92aWRlby9kb2NzL2FwaS9cbiAqL1xuY2xhc3MgU3RyZWFtVmlkZW9TZXJ2ZXJDbGllbnQgZXh0ZW5kcyBTdHJlYW1WaWRlb0NsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHsgYXBpS2V5LCBvcHRpb25zIH0pO1xuICAgICAgICB0aGlzLmdldENhbGxUeXBlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5nZXQoJy9jYWxsdHlwZXMnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDYWxsVHlwZSA9IChuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0KGAvY2FsbHR5cGVzLyR7bmFtZX1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVDYWxsVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdCgnL2NhbGx0eXBlcycsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlbGV0ZUNhbGxUeXBlID0gKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5kZWxldGUoYC9jYWxsdHlwZXMvJHtuYW1lfWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxUeXBlID0gKG5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUNsaWVudC5wdXQoYC9jYWxsdHlwZXMvJHtuYW1lfWAsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RFeHRlcm5hbFN0b3JhZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQuZ2V0KCcvZXh0ZXJuYWxfc3RvcmFnZScpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUV4dGVybmFsU3RvcmFnZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucG9zdCgnL2V4dGVybmFsX3N0b3JhZ2UnLCByZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVFeHRlcm5hbFN0b3JhZ2UgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmRlbGV0ZShgL2V4dGVybmFsX3N0b3JhZ2UvJHtuYW1lfWApO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVybmFsU3RvcmFnZSA9IChuYW1lLCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1DbGllbnQucHV0KGAvZXh0ZXJuYWxfc3RvcmFnZS8ke25hbWV9YCwgcmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlcm5hbFN0b3JhZ2UgPSAobmFtZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmdldChgL2V4dGVybmFsX3N0b3JhZ2UvJHtuYW1lfS9jaGVja2ApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGVUb2tlbiAtIENyZWF0ZXMgYSB0b2tlbiB0byBhdXRoZW50aWNhdGUgdGhpcyB1c2VyLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgc2VydmVyIHNpZGUuXG4gICAgICogVGhlIHJlc3VsdGluZyB0b2tlbiBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBjbGllbnQgc2lkZSB3aGVuIHRoZSB1c2VycyByZWdpc3RlciBvciBsb2dzIGluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCBUaGUgVXNlciBJRFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZXhwXSBUaGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdG9rZW4gZXhwcmVzc2VkIGluIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2lhdF0gVGhlIHRpbWVzdGFtcCB3aGVuIGEgdG9rZW4gaGFzIGJlZW4gaXNzdWVkXG4gICAgICogQHBhcmFtIGNhbGxfY2lkcyBmb3IgYW5vbnltb3VzIHRva2VucyB5b3UgaGF2ZSB0byBwcm92aWRlIHRoZSBjYWxsIGNpZHMgdGhlIHVzZSBjYW4gam9pblxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIGEgdG9rZW5cbiAgICAgKi9cbiAgICBjcmVhdGVUb2tlbih1c2VySUQsIGV4cCwgaWF0LCBjYWxsX2NpZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtQ2xpZW50LmNyZWF0ZVRva2VuKHVzZXJJRCwgZXhwLCBpYXQsIGNhbGxfY2lkcyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0sIEF1ZGlvU2V0dGluZ3NSZXF1ZXN0RGVmYXVsdERldmljZUVudW0sIGJyb3dzZXJzIGFzIEJyb3dzZXJzLCBDYWxsLCBDYWxsU3RhdGUsIENhbGxUeXBlLCBDYWxsVHlwZXMsIENhbGxpbmdTdGF0ZSwgQ2FtZXJhTWFuYWdlciwgQ2FtZXJhTWFuYWdlclN0YXRlLCBDcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSwgRGVib3VuY2VUeXBlLCBEeW5hc2NhbGVNYW5hZ2VyLCBFcnJvckZyb21SZXNwb25zZSwgSW5wdXRNZWRpYURldmljZU1hbmFnZXIsIElucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUsIExheW91dFNldHRpbmdzTmFtZUVudW0sIExheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtLCBNaWNyb3Bob25lTWFuYWdlciwgTWljcm9waG9uZU1hbmFnZXJTdGF0ZSwgT3duQ2FwYWJpbGl0eSwgUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFJlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtLCByeFV0aWxzIGFzIFJ4VXRpbHMsIFNjcmVlblNoYXJlTWFuYWdlciwgU2NyZWVuU2hhcmVTdGF0ZSwgZXZlbnRzIGFzIFNmdUV2ZW50cywgbW9kZWxzIGFzIFNmdU1vZGVscywgU3BlYWtlck1hbmFnZXIsIFNwZWFrZXJTdGF0ZSwgU3RyZWFtU2Z1Q2xpZW50LCBTdHJlYW1WaWRlb0NsaWVudCwgU3RyZWFtVmlkZW9SZWFkT25seVN0YXRlU3RvcmUsIFN0cmVhbVZpZGVvU2VydmVyQ2xpZW50LCBTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUsIFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtLCBUcmFuc2NyaXB0aW9uU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtLCBWaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0sIFZpZXdwb3J0VHJhY2tlciwgVmlzaWJpbGl0eVN0YXRlLCBjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQsIGNvbWJpbmVDb21wYXJhdG9ycywgY29uZGl0aW9uYWwsIGNyZWF0ZVNvdW5kRGV0ZWN0b3IsIGRlZmF1bHRTb3J0UHJlc2V0LCBkZXNjZW5kaW5nLCBkZXZpY2VJZHMkLCBkaXNwb3NlT2ZNZWRpYVN0cmVhbSwgZG9taW5hbnRTcGVha2VyLCBnZXRBdWRpb0RldmljZXMsIGdldEF1ZGlvT3V0cHV0RGV2aWNlcywgZ2V0QXVkaW9TdHJlYW0sIGdldENsaWVudERldGFpbHMsIGdldERldmljZUluZm8sIGdldExvZ2dlciwgZ2V0T1NJbmZvLCBnZXRTY3JlZW5TaGFyZVN0cmVhbSwgZ2V0U2RrSW5mbywgZ2V0VmlkZW9EZXZpY2VzLCBnZXRWaWRlb1N0cmVhbSwgbGl2ZXN0cmVhbU9yQXVkaW9Sb29tU29ydFByZXNldCwgbG9nTGV2ZWxzLCBsb2dUb0NvbnNvbGUsIG5hbWUsIG5vb3BDb21wYXJhdG9yLCBwYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0LCBwaW5uZWQsIHB1Ymxpc2hpbmdBdWRpbywgcHVibGlzaGluZ1ZpZGVvLCByZWFjdGlvblR5cGUsIHJvbGUsIHNjcmVlblNoYXJpbmcsIHNldERldmljZUluZm8sIHNldExvZ0xldmVsLCBzZXRMb2dnZXIsIHNldE9TSW5mbywgc2V0U2RrSW5mbywgc3BlYWtlckxheW91dFNvcnRQcmVzZXQsIHNwZWFraW5nIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNZXNzYWdlVHlwZSIsImlzSnNvbk9iamVjdCIsInR5cGVvZkpzb25WYWx1ZSIsInJlZmxlY3Rpb25NZXJnZVBhcnRpYWwiLCJVbmtub3duRmllbGRIYW5kbGVyIiwiV2lyZVR5cGUiLCJQYkxvbmciLCJTZXJ2aWNlVHlwZSIsInN0YWNrSW50ZXJjZXB0IiwiYXhpb3MiLCJBeGlvc0hlYWRlcnMiLCJBeGlvc0Vycm9yIiwiVHdpcnBGZXRjaFRyYW5zcG9ydCIsIlJlcGxheVN1YmplY3QiLCJjb21iaW5lTGF0ZXN0IiwiQmVoYXZpb3JTdWJqZWN0IiwibWFwIiwibWFwJDEiLCJzaGFyZVJlcGxheSIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwidGFrZVdoaWxlIiwiZGlzdGluY3RVbnRpbEtleUNoYW5nZWQiLCJtZXJnZSIsImZyb20iLCJPYnNlcnZhYmxlIiwiZGVib3VuY2VUaW1lIiwiY29uY2F0TWFwIiwicGFpcndpc2UiLCJvZiIsImZpbHRlciIsImRlYm91bmNlIiwidGltZXIiLCJTRFAiLCJVQVBhcnNlciIsIldlYlNvY2tldCIsImh0dHBzIiwiand0IiwiZnJvbUJ5dGVBcnJheSIsIkF1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSIsIlNQRUFLRVIiLCJFQVJQSUVDRSIsIkF1ZGlvU2V0dGluZ3NSZXF1ZXN0RGVmYXVsdERldmljZUVudW0iLCJDcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSIsIkZJUkVCQVNFIiwiQVBOIiwiSFVBV0VJIiwiWElBT01JIiwiTGF5b3V0U2V0dGluZ3NOYW1lRW51bSIsIlNQT1RMSUdIVCIsIkdSSUQiLCJTSU5HTEVfUEFSVElDSVBBTlQiLCJNT0JJTEUiLCJDVVNUT00iLCJMYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSIsIk93bkNhcGFiaWxpdHkiLCJCTE9DS19VU0VSUyIsIkNSRUFURV9DQUxMIiwiQ1JFQVRFX1JFQUNUSU9OIiwiRU5EX0NBTEwiLCJKT0lOX0JBQ0tTVEFHRSIsIkpPSU5fQ0FMTCIsIkpPSU5fRU5ERURfQ0FMTCIsIk1VVEVfVVNFUlMiLCJQSU5fRk9SX0VWRVJZT05FIiwiUkVBRF9DQUxMIiwiUkVNT1ZFX0NBTExfTUVNQkVSIiwiU0NSRUVOU0hBUkUiLCJTRU5EX0FVRElPIiwiU0VORF9WSURFTyIsIlNUQVJUX0JST0FEQ0FTVF9DQUxMIiwiU1RBUlRfUkVDT1JEX0NBTEwiLCJTVEFSVF9UUkFOU0NSSVBUSU9OX0NBTEwiLCJTVE9QX0JST0FEQ0FTVF9DQUxMIiwiU1RPUF9SRUNPUkRfQ0FMTCIsIlNUT1BfVFJBTlNDUklQVElPTl9DQUxMIiwiVVBEQVRFX0NBTEwiLCJVUERBVEVfQ0FMTF9NRU1CRVIiLCJVUERBVEVfQ0FMTF9QRVJNSVNTSU9OUyIsIlVQREFURV9DQUxMX1NFVFRJTkdTIiwiUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0iLCJBVkFJTEFCTEUiLCJESVNBQkxFRCIsIkFVVE9fT04iLCJSZWNvcmRTZXR0aW5nc1JlcXVlc3RRdWFsaXR5RW51bSIsIl8zNjBQIiwiXzQ4MFAiLCJfNzIwUCIsIl8xMDgwUCIsIl8xNDQwUCIsIlRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtIiwiVHJhbnNjcmlwdGlvblNldHRpbmdzUmVxdWVzdE1vZGVFbnVtIiwiVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0iLCJGUk9OVCIsIkJBQ0siLCJFWFRFUk5BTCIsIlZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSIsIkVycm9yRnJvbVJlc3BvbnNlIiwiRXJyb3IiLCJOdWxsVmFsdWUiLCJTdHJ1Y3QkVHlwZSIsImNvbnN0cnVjdG9yIiwibm8iLCJuYW1lIiwia2luZCIsIksiLCJWIiwiVCIsIlZhbHVlIiwiaW50ZXJuYWxKc29uV3JpdGUiLCJtZXNzYWdlIiwib3B0aW9ucyIsImpzb24iLCJrIiwidiIsIk9iamVjdCIsImVudHJpZXMiLCJmaWVsZHMiLCJ0b0pzb24iLCJpbnRlcm5hbEpzb25SZWFkIiwidGFyZ2V0IiwiZ2xvYmFsVGhpcyIsInR5cGVOYW1lIiwiY3JlYXRlIiwiZnJvbUpzb24iLCJ2YWx1ZSIsIm1lc3NhZ2VQcm90b3R5cGUiLCJ1bmRlZmluZWQiLCJpbnRlcm5hbEJpbmFyeVJlYWQiLCJyZWFkZXIiLCJsZW5ndGgiLCJlbmQiLCJwb3MiLCJmaWVsZE5vIiwid2lyZVR5cGUiLCJ0YWciLCJiaW5hcnlSZWFkTWFwMSIsInUiLCJyZWFkVW5rbm93bkZpZWxkIiwiZCIsInNraXAiLCJvblJlYWQiLCJsZW4iLCJ1aW50MzIiLCJrZXkiLCJ2YWwiLCJzdHJpbmciLCJpbnRlcm5hbEJpbmFyeVdyaXRlIiwid3JpdGVyIiwia2V5cyIsIkxlbmd0aERlbGltaXRlZCIsImZvcmsiLCJqb2luIiwid3JpdGVVbmtub3duRmllbGRzIiwib25Xcml0ZSIsIlN0cnVjdCIsIlZhbHVlJFR5cGUiLCJvbmVvZiIsIkxpc3RWYWx1ZSIsIm9uZW9mS2luZCIsImJvb2xWYWx1ZSIsIm51bWJlclZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdHJpbmdWYWx1ZSIsImxpc3RWYWx1ZUZpZWxkIiwiZmluZCIsImYiLCJsaXN0VmFsdWUiLCJzdHJ1Y3RWYWx1ZUZpZWxkIiwic3RydWN0VmFsdWUiLCJudWxsVmFsdWUiLCJOVUxMX1ZBTFVFIiwiQXJyYXkiLCJpc0FycmF5IiwiaW50MzIiLCJkb3VibGUiLCJib29sIiwiVmFyaW50IiwiQml0NjQiLCJMaXN0VmFsdWUkVHlwZSIsInJlcGVhdCIsInZhbHVlcyIsInB1c2giLCJpIiwiVGltZXN0YW1wJFR5cGUiLCJub3ciLCJtc2ciLCJtcyIsIkRhdGUiLCJzZWNvbmRzIiwiTWF0aCIsImZsb29yIiwidG9TdHJpbmciLCJuYW5vcyIsInRvRGF0ZSIsInRvTnVtYmVyIiwiY2VpbCIsImZyb21EYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJwYXJzZSIsInoiLCJuYW5vc1N0ciIsInN1YnN0cmluZyIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsIm1hdGNoZXMiLCJtYXRjaCIsImlzTmFOIiwicGFyc2VJbnQiLCJpbnQ2NCIsIlRpbWVzdGFtcCIsIlBlZXJUeXBlIiwiQ29ubmVjdGlvblF1YWxpdHkiLCJWaWRlb1F1YWxpdHkiLCJUcmFja1R5cGUiLCJFcnJvckNvZGUiLCJTZGtUeXBlIiwiVHJhY2tVbnB1Ymxpc2hSZWFzb24iLCJHb0F3YXlSZWFzb24iLCJDYWxsU3RhdGUkVHlwZSIsIlBhcnRpY2lwYW50IiwiUGFydGljaXBhbnRDb3VudCIsIlBpbiIsInBhcnRpY2lwYW50cyIsInBpbnMiLCJzdGFydGVkQXQiLCJwYXJ0aWNpcGFudENvdW50IiwiQ2FsbFN0YXRlJDEiLCJQYXJ0aWNpcGFudENvdW50JFR5cGUiLCJ0b3RhbCIsImFub255bW91cyIsIlBpbiRUeXBlIiwidXNlcklkIiwic2Vzc2lvbklkIiwiUGFydGljaXBhbnQkVHlwZSIsInB1Ymxpc2hlZFRyYWNrcyIsInRyYWNrTG9va3VwUHJlZml4IiwiY29ubmVjdGlvblF1YWxpdHkiLCJpc1NwZWFraW5nIiwiaXNEb21pbmFudFNwZWFrZXIiLCJhdWRpb0xldmVsIiwiaW1hZ2UiLCJyb2xlcyIsImUiLCJqb2luZWRBdCIsImZsb2F0IiwiY3VzdG9tIiwiQml0MzIiLCJTdHJlYW1RdWFsaXR5JFR5cGUiLCJ2aWRlb1F1YWxpdHkiLCJTdHJlYW1RdWFsaXR5IiwiVmlkZW9EaW1lbnNpb24kVHlwZSIsIndpZHRoIiwiaGVpZ2h0IiwiVmlkZW9EaW1lbnNpb24iLCJWaWRlb0xheWVyJFR5cGUiLCJyaWQiLCJiaXRyYXRlIiwiZnBzIiwicXVhbGl0eSIsInZpZGVvRGltZW5zaW9uIiwiVmlkZW9MYXllciIsIkNvZGVjJFR5cGUiLCJwYXlsb2FkVHlwZSIsImZtdHBMaW5lIiwiY2xvY2tSYXRlIiwiZW5jb2RpbmdQYXJhbWV0ZXJzIiwiZmVlZGJhY2tzIiwiQ29kZWMiLCJJQ0VUcmlja2xlJFR5cGUkMSIsIklDRVRyaWNrbGUkVHlwZSIsInBlZXJUeXBlIiwiaWNlQ2FuZGlkYXRlIiwiSUNFVHJpY2tsZSQxIiwiVHJhY2tJbmZvJFR5cGUiLCJ0cmFja0lkIiwidHJhY2tUeXBlIiwibGF5ZXJzIiwibWlkIiwiZHR4Iiwic3RlcmVvIiwicmVkIiwiVHJhY2tJbmZvIiwiQ2FsbCRUeXBlIiwidHlwZSIsImlkIiwiY3JlYXRlZEJ5VXNlcklkIiwiaG9zdFVzZXJJZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsIkNhbGwkMSIsIkVycm9yJFR5cGUkMSIsIkVycm9yJFR5cGUiLCJjb2RlIiwic2hvdWxkUmV0cnkiLCJFcnJvciQyIiwiQ2xpZW50RGV0YWlscyRUeXBlIiwiU2RrIiwiT1MiLCJCcm93c2VyIiwiRGV2aWNlIiwic2RrIiwib3MiLCJicm93c2VyIiwiZGV2aWNlIiwiQ2xpZW50RGV0YWlscyIsIlNkayRUeXBlIiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwiT1MkVHlwZSIsInZlcnNpb24iLCJhcmNoaXRlY3R1cmUiLCJCcm93c2VyJFR5cGUiLCJEZXZpY2UkVHlwZSIsIkNhbGxHcmFudHMkVHlwZSIsImNhblB1Ymxpc2hBdWRpbyIsImNhblB1Ymxpc2hWaWRlbyIsImNhblNjcmVlbnNoYXJlIiwiQ2FsbEdyYW50cyIsIm1vZGVscyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsIkNhbGwiLCJDYWxsU3RhdGUiLCJJQ0VUcmlja2xlIiwiSUNFUmVzdGFydFJlcXVlc3QkVHlwZSIsIklDRVJlc3RhcnRSZXF1ZXN0IiwiSUNFUmVzdGFydFJlc3BvbnNlJFR5cGUiLCJlcnJvciIsIklDRVJlc3RhcnRSZXNwb25zZSIsIlVwZGF0ZU11dGVTdGF0ZXNSZXF1ZXN0JFR5cGUiLCJUcmFja011dGVTdGF0ZSIsIm11dGVTdGF0ZXMiLCJVcGRhdGVNdXRlU3RhdGVzUmVxdWVzdCIsIlVwZGF0ZU11dGVTdGF0ZXNSZXNwb25zZSRUeXBlIiwiVXBkYXRlTXV0ZVN0YXRlc1Jlc3BvbnNlIiwiVHJhY2tNdXRlU3RhdGUkVHlwZSIsIm11dGVkIiwiQXVkaW9NdXRlQ2hhbmdlZCRUeXBlIiwiVmlkZW9NdXRlQ2hhbmdlZCRUeXBlIiwiVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QkVHlwZSIsIlRyYWNrU3Vic2NyaXB0aW9uRGV0YWlscyIsInRyYWNrcyIsIlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0IiwiVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlJFR5cGUiLCJVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UiLCJUcmFja1N1YnNjcmlwdGlvbkRldGFpbHMkVHlwZSIsImRpbWVuc2lvbiIsIlNlbmRBbnN3ZXJSZXF1ZXN0JFR5cGUiLCJzZHAiLCJTZW5kQW5zd2VyUmVxdWVzdCIsIlNlbmRBbnN3ZXJSZXNwb25zZSRUeXBlIiwiU2VuZEFuc3dlclJlc3BvbnNlIiwiSUNFVHJpY2tsZVJlc3BvbnNlJFR5cGUiLCJJQ0VUcmlja2xlUmVzcG9uc2UiLCJTZXRQdWJsaXNoZXJSZXF1ZXN0JFR5cGUiLCJTZXRQdWJsaXNoZXJSZXF1ZXN0IiwiU2V0UHVibGlzaGVyUmVzcG9uc2UkVHlwZSIsImljZVJlc3RhcnQiLCJTZXRQdWJsaXNoZXJSZXNwb25zZSIsIlNpZ25hbFNlcnZlciIsIkkiLCJPIiwiVmlkZW9MYXllclNldHRpbmdfUHJpb3JpdHkiLCJTZnVFdmVudCRUeXBlIiwiU3Vic2NyaWJlck9mZmVyIiwiUHVibGlzaGVyQW5zd2VyIiwiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwiQXVkaW9MZXZlbENoYW5nZWQiLCJDaGFuZ2VQdWJsaXNoUXVhbGl0eSIsIlBhcnRpY2lwYW50Sm9pbmVkIiwiUGFydGljaXBhbnRMZWZ0IiwiRG9taW5hbnRTcGVha2VyQ2hhbmdlZCIsIkpvaW5SZXNwb25zZSIsIkhlYWx0aENoZWNrUmVzcG9uc2UiLCJUcmFja1B1Ymxpc2hlZCIsIlRyYWNrVW5wdWJsaXNoZWQiLCJFcnJvciQxIiwiQ2FsbEdyYW50c1VwZGF0ZWQiLCJHb0F3YXkiLCJJQ0VSZXN0YXJ0IiwiUGluc0NoYW5nZWQiLCJldmVudFBheWxvYWQiLCJzdWJzY3JpYmVyT2ZmZXIiLCJwdWJsaXNoZXJBbnN3ZXIiLCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJhdWRpb0xldmVsQ2hhbmdlZCIsImljZVRyaWNrbGUiLCJjaGFuZ2VQdWJsaXNoUXVhbGl0eSIsInBhcnRpY2lwYW50Sm9pbmVkIiwicGFydGljaXBhbnRMZWZ0IiwiZG9taW5hbnRTcGVha2VyQ2hhbmdlZCIsImpvaW5SZXNwb25zZSIsImhlYWx0aENoZWNrUmVzcG9uc2UiLCJ0cmFja1B1Ymxpc2hlZCIsInRyYWNrVW5wdWJsaXNoZWQiLCJjYWxsR3JhbnRzVXBkYXRlZCIsImdvQXdheSIsInBpbnNVcGRhdGVkIiwiU2Z1RXZlbnQiLCJQaW5zQ2hhbmdlZCRUeXBlIiwiSUNFUmVzdGFydCRUeXBlIiwiU2Z1UmVxdWVzdCRUeXBlIiwiSm9pblJlcXVlc3QiLCJIZWFsdGhDaGVja1JlcXVlc3QiLCJyZXF1ZXN0UGF5bG9hZCIsImpvaW5SZXF1ZXN0IiwiaGVhbHRoQ2hlY2tSZXF1ZXN0IiwiU2Z1UmVxdWVzdCIsIkhlYWx0aENoZWNrUmVxdWVzdCRUeXBlIiwiSGVhbHRoQ2hlY2tSZXNwb25zZSRUeXBlIiwiVHJhY2tQdWJsaXNoZWQkVHlwZSIsInBhcnRpY2lwYW50IiwiVHJhY2tVbnB1Ymxpc2hlZCRUeXBlIiwiY2F1c2UiLCJKb2luUmVxdWVzdCRUeXBlIiwiTWlncmF0aW9uIiwidG9rZW4iLCJzdWJzY3JpYmVyU2RwIiwiZmFzdFJlY29ubmVjdCIsImNsaWVudERldGFpbHMiLCJtaWdyYXRpb24iLCJNaWdyYXRpb24kVHlwZSIsImZyb21TZnVJZCIsImFubm91bmNlZFRyYWNrcyIsInN1YnNjcmlwdGlvbnMiLCJKb2luUmVzcG9uc2UkVHlwZSIsInJlY29ubmVjdGVkIiwiY2FsbFN0YXRlIiwiUGFydGljaXBhbnRKb2luZWQkVHlwZSIsImNhbGxDaWQiLCJQYXJ0aWNpcGFudExlZnQkVHlwZSIsIlN1YnNjcmliZXJPZmZlciRUeXBlIiwiUHVibGlzaGVyQW5zd2VyJFR5cGUiLCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQkVHlwZSIsIkNvbm5lY3Rpb25RdWFsaXR5SW5mbyIsImNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlcyIsIkNvbm5lY3Rpb25RdWFsaXR5SW5mbyRUeXBlIiwiRG9taW5hbnRTcGVha2VyQ2hhbmdlZCRUeXBlIiwiQXVkaW9MZXZlbCRUeXBlIiwibGV2ZWwiLCJBdWRpb0xldmVsIiwiQXVkaW9MZXZlbENoYW5nZWQkVHlwZSIsImF1ZGlvTGV2ZWxzIiwiQXVkaW9NZWRpYVJlcXVlc3QkVHlwZSIsImNoYW5uZWxDb3VudCIsIkF1ZGlvTWVkaWFSZXF1ZXN0IiwiQXVkaW9TZW5kZXIkVHlwZSIsIm1lZGlhUmVxdWVzdCIsImNvZGVjIiwiQXVkaW9TZW5kZXIiLCJWaWRlb01lZGlhUmVxdWVzdCRUeXBlIiwiaWRlYWxIZWlnaHQiLCJpZGVhbFdpZHRoIiwiaWRlYWxGcmFtZVJhdGUiLCJWaWRlb01lZGlhUmVxdWVzdCIsIlZpZGVvTGF5ZXJTZXR0aW5nJFR5cGUiLCJhY3RpdmUiLCJtYXhCaXRyYXRlIiwic2NhbGVSZXNvbHV0aW9uRG93bkJ5IiwicHJpb3JpdHkiLCJtYXhGcmFtZXJhdGUiLCJWaWRlb0xheWVyU2V0dGluZyIsIlZpZGVvU2VuZGVyJFR5cGUiLCJWaWRlb1NlbmRlciIsIkNoYW5nZVB1Ymxpc2hRdWFsaXR5JFR5cGUiLCJhdWRpb1NlbmRlcnMiLCJ2aWRlb1NlbmRlcnMiLCJDYWxsR3JhbnRzVXBkYXRlZCRUeXBlIiwiY3VycmVudEdyYW50cyIsIkdvQXdheSRUeXBlIiwicmVhc29uIiwiZXZlbnRzIiwiVmlzaWJpbGl0eVN0YXRlIiwiRGVib3VuY2VUeXBlIiwiU2lnbmFsU2VydmVyQ2xpZW50IiwiX3RyYW5zcG9ydCIsIm1ldGhvZHMiLCJzZXRQdWJsaXNoZXIiLCJpbnB1dCIsIm1ldGhvZCIsIm9wdCIsIm1lcmdlT3B0aW9ucyIsInNlbmRBbnN3ZXIiLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwidXBkYXRlTXV0ZVN0YXRlcyIsImRlZmF1bHRPcHRpb25zIiwiYmFzZVVybCIsInNlbmRKc29uIiwidGltZW91dCIsImpzb25PcHRpb25zIiwiaWdub3JlVW5rbm93bkZpZWxkcyIsIndpdGhIZWFkZXJzIiwiaGVhZGVycyIsImludGVyY2VwdFVuYXJ5IiwibmV4dCIsIm1ldGEiLCJjcmVhdGVTaWduYWxDbGllbnQiLCJ0cmFuc3BvcnQiLCJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsInRvTG93ZXJDYXNlIiwibG9nTGV2ZWxzIiwidHJhY2UiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwibG9nZ2VyJDQiLCJsb2dUb0NvbnNvbGUiLCJsb2dMZXZlbCIsImFyZ3MiLCJsb2dNZXRob2QiLCJjb25zb2xlIiwibG9nIiwic2V0TG9nZ2VyIiwibCIsImx2bCIsInNldExvZ0xldmVsIiwiZ2V0TG9nZ2VyIiwid2l0aFRhZ3MiLCJsb2dnZXJNZXRob2QiLCJ0YWdzIiwicmVzdWx0IiwiZ2V0UHJlZmVycmVkQ29kZWNzIiwicHJlZmVycmVkQ29kZWMiLCJjb2RlY1RvUmVtb3ZlIiwibG9nZ2VyIiwiUlRDUnRwU2VuZGVyIiwiY2FwIiwiZ2V0Q2FwYWJpbGl0aWVzIiwibWF0Y2hlZCIsInBhcnRpYWxNYXRjaGVkIiwidW5tYXRjaGVkIiwiY29kZWNzIiwiZm9yRWFjaCIsImMiLCJtaW1lVHlwZSIsInNob3VsZFJlbW92ZUNvZGVjIiwibWF0Y2hlc0NvZGVjIiwic2RwRm10cExpbmUiLCJpbmNsdWRlcyIsImdldEdlbmVyaWNTZHAiLCJkaXJlY3Rpb24iLCJ0ZW1wUGMiLCJSVENQZWVyQ29ubmVjdGlvbiIsImFkZFRyYW5zY2VpdmVyIiwib2ZmZXIiLCJjcmVhdGVPZmZlciIsImdldFRyYW5zY2VpdmVycyIsInQiLCJzdG9wIiwiY2xvc2UiLCJzZnVFdmVudEtpbmRzIiwiaXNTZnVFdmVudCIsImV2ZW50TmFtZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkRpc3BhdGNoZXIiLCJzdWJzY3JpYmVycyIsImRpc3BhdGNoIiwiZXZlbnRLaW5kIiwicGF5bG9hZCIsImxpc3RlbmVycyIsImZuIiwib24iLCJfYSIsIm9mZiIsIm9mZkFsbCIsIkljZVRyaWNrbGVCdWZmZXIiLCJzdWJzY3JpYmVyQ2FuZGlkYXRlcyIsInB1Ymxpc2hlckNhbmRpZGF0ZXMiLCJTVUJTQ1JJQkVSIiwiUFVCTElTSEVSX1VOU1BFQ0lGSUVEIiwiZ2V0SWNlQ2FuZGlkYXRlIiwiY2FuZGlkYXRlIiwidXNlcm5hbWVGcmFnbWVudCIsInNwbGl0dGVkQ2FuZGlkYXRlIiwic3BsaXQiLCJ1ZnJhZ0luZGV4IiwiZmluZEluZGV4IiwicyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b0pTT04iLCJzZGtJbmZvIiwib3NJbmZvIiwiZGV2aWNlSW5mbyIsInNldFNka0luZm8iLCJnZXRTZGtJbmZvIiwic2V0T1NJbmZvIiwiZ2V0T1NJbmZvIiwic2V0RGV2aWNlSW5mbyIsImdldERldmljZUluZm8iLCJnZXRDbGllbnREZXRhaWxzIiwidXNlckFnZW50IiwiY3B1IiwiZ2V0UmVzdWx0IiwidmVuZG9yIiwibW9kZWwiLCJERUZBVUxUX0JJVFJBVEUiLCJkZWZhdWx0VGFyZ2V0UmVzb2x1dGlvbiIsImZpbmRPcHRpbWFsVmlkZW9MYXllcnMiLCJ2aWRlb1RyYWNrIiwidGFyZ2V0UmVzb2x1dGlvbiIsIm9wdGltYWxWaWRlb0xheWVycyIsInNldHRpbmdzIiwiZ2V0U2V0dGluZ3MiLCJ3IiwiaCIsImlzUk5Jb3MiLCJnZXRDb21wdXRlZE1heEJpdHJhdGUiLCJkb3duc2NhbGVGYWN0b3IiLCJ1bnNoaWZ0Iiwicm91bmQiLCJxIiwid2l0aFNpbXVsY2FzdENvbnN0cmFpbnRzIiwiY3VycmVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwiY3VycmVudFBpeGVscyIsInRhcmdldFBpeGVscyIsInJlZHVjdGlvbkZhY3RvciIsInNpemUiLCJtYXgiLCJsYXllciIsInJpZE1hcHBpbmciLCJpbmRleCIsImZpbmRPcHRpbWFsU2NyZWVuU2hhcmluZ0xheWVycyIsInByZWZlcmVuY2VzIiwidHJhY2tUeXBlVG9QYXJ0aWNpcGFudFN0cmVhbUtleSIsIlNDUkVFTl9TSEFSRSIsIlNDUkVFTl9TSEFSRV9BVURJTyIsIlZJREVPIiwiQVVESU8iLCJVTlNQRUNJRklFRCIsImV4aGF1c3RpdmVUcmFja1R5cGVDaGVjayIsIm11dGVUeXBlVG9UcmFja1R5cGUiLCJtdXRlVHlwZSIsImV4aGF1c3RpdmVNdXRlVHlwZUNoZWNrIiwiaXNGdW5jdGlvblBhdGNoIiwidXBkYXRlIiwiZ2V0Q3VycmVudFZhbHVlIiwib2JzZXJ2YWJsZSQiLCJlcnIiLCJzdWJzY3JpYmUiLCJ1bnN1YnNjcmliZSIsInNldEN1cnJlbnRWYWx1ZSIsInN1YmplY3QiLCJjcmVhdGVTdWJzY3JpcHRpb24iLCJvYnNlcnZhYmxlIiwiaGFuZGxlciIsInN1YnNjcmlwdGlvbiIsInJ4VXRpbHMiLCJjb21iaW5lQ29tcGFyYXRvcnMiLCJjb21wYXJhdG9ycyIsImEiLCJiIiwiY29tcGFyYXRvciIsImRlc2NlbmRpbmciLCJjb25kaXRpb25hbCIsInByZWRpY2F0ZSIsIm5vb3BDb21wYXJhdG9yIiwiZG9taW5hbnRTcGVha2VyIiwic3BlYWtpbmciLCJzY3JlZW5TaGFyaW5nIiwiaGFzU2NyZWVuU2hhcmUiLCJwdWJsaXNoaW5nVmlkZW8iLCJoYXNWaWRlbyIsInB1Ymxpc2hpbmdBdWRpbyIsImhhc0F1ZGlvIiwicGlubmVkIiwicGluIiwiaXNMb2NhbFBpbiIsInBpbm5lZEF0IiwicmVhY3Rpb25UeXBlIiwicmVhY3Rpb24iLCJyb2xlIiwiaGFzQW55Um9sZSIsInAiLCJzb21lIiwiciIsImlmSW52aXNpYmxlQnkiLCJ2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZSIsIklOVklTSUJMRSIsImlmSW52aXNpYmxlT3JVbmtub3duQnkiLCJVTktOT1dOIiwiZGVmYXVsdFNvcnRQcmVzZXQiLCJzcGVha2VyTGF5b3V0U29ydFByZXNldCIsInBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQiLCJsaXZlc3RyZWFtT3JBdWRpb1Jvb21Tb3J0UHJlc2V0IiwiQ2FsbGluZ1N0YXRlIiwiYmFja3N0YWdlU3ViamVjdCIsImJsb2NrZWRVc2VySWRzU3ViamVjdCIsImNyZWF0ZWRBdFN1YmplY3QiLCJlbmRlZEF0U3ViamVjdCIsInN0YXJ0c0F0U3ViamVjdCIsInVwZGF0ZWRBdFN1YmplY3QiLCJjcmVhdGVkQnlTdWJqZWN0IiwiY3VzdG9tU3ViamVjdCIsImVncmVzc1N1YmplY3QiLCJpbmdyZXNzU3ViamVjdCIsInJlY29yZGluZ1N1YmplY3QiLCJzZXNzaW9uU3ViamVjdCIsInNldHRpbmdzU3ViamVjdCIsInRyYW5zY3JpYmluZ1N1YmplY3QiLCJlbmRlZEJ5U3ViamVjdCIsInRodW1ibmFpbHNTdWJqZWN0IiwibWVtYmVyc1N1YmplY3QiLCJvd25DYXBhYmlsaXRpZXNTdWJqZWN0IiwiY2FsbGluZ1N0YXRlU3ViamVjdCIsInN0YXJ0ZWRBdFN1YmplY3QiLCJwYXJ0aWNpcGFudENvdW50U3ViamVjdCIsImFub255bW91c1BhcnRpY2lwYW50Q291bnRTdWJqZWN0IiwicGFydGljaXBhbnRzU3ViamVjdCIsImNhbGxTdGF0c1JlcG9ydFN1YmplY3QiLCJzb3J0UGFydGljaXBhbnRzQnkiLCJzZXRTb3J0UGFydGljaXBhbnRzQnkiLCJwcyIsInNldFBhcnRpY2lwYW50Q291bnQiLCJjb3VudCIsInNldFN0YXJ0ZWRBdCIsInNldEFub255bW91c1BhcnRpY2lwYW50Q291bnQiLCJzZXRQYXJ0aWNpcGFudHMiLCJzZXRDYWxsaW5nU3RhdGUiLCJzdGF0ZSIsInNldENhbGxTdGF0c1JlcG9ydCIsInJlcG9ydCIsInNldE1lbWJlcnMiLCJtZW1iZXJzIiwic2V0T3duQ2FwYWJpbGl0aWVzIiwiY2FwYWJpbGl0aWVzIiwiZmluZFBhcnRpY2lwYW50QnlTZXNzaW9uSWQiLCJnZXRQYXJ0aWNpcGFudExvb2t1cEJ5U2Vzc2lvbklkIiwicmVkdWNlIiwibG9va3VwVGFibGUiLCJ1cGRhdGVQYXJ0aWNpcGFudCIsInRoZVBhdGNoIiwidXBkYXRlZFBhcnRpY2lwYW50IiwidXBkYXRlT3JBZGRQYXJ0aWNpcGFudCIsInVwZGF0ZVBhcnRpY2lwYW50cyIsInVwZGF0ZUZyb21FdmVudCIsImV2ZW50IiwiZXZlbnRIYW5kbGVycyIsInNldFNlcnZlclNpZGVQaW5zIiwicGluc0xvb2t1cCIsImxvb2t1cCIsInNlcnZlclNpZGVQaW5uZWRBdCIsInVwZGF0ZUZyb21DYWxsUmVzcG9uc2UiLCJiYWNrc3RhZ2UiLCJibG9ja2VkX3VzZXJfaWRzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJzdGFydHNfYXQiLCJlbmRlZF9hdCIsImNyZWF0ZWRfYnkiLCJlZ3Jlc3MiLCJpbmdyZXNzIiwicmVjb3JkaW5nIiwic2Vzc2lvbiIsInRyYW5zY3JpYmluZyIsInRodW1ibmFpbHMiLCJ1cGRhdGVGcm9tTWVtYmVyUmVtb3ZlZCIsIm0iLCJpbmRleE9mIiwidXNlcl9pZCIsInVwZGF0ZUZyb21NZW1iZXJBZGRlZCIsInVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdG9wcGVkIiwiYnJvYWRjYXN0aW5nIiwidXBkYXRlRnJvbUhMU0Jyb2FkY2FzdGluZ0ZhaWxlZCIsInVwZGF0ZUZyb21ITFNCcm9hZGNhc3RTdGFydGVkIiwiaGxzIiwicGxheWxpc3RfdXJsIiwiaGxzX3BsYXlsaXN0X3VybCIsInVwZGF0ZUZyb21TZXNzaW9uUGFydGljaXBhbnRMZWZ0IiwicGFydGljaXBhbnRzX2NvdW50X2J5X3JvbGUiLCJ1c2VyIiwidXNlcl9zZXNzaW9uX2lkIiwidXBkYXRlRnJvbVNlc3Npb25QYXJ0aWNpcGFudEpvaW5lZCIsInNob3VsZEluc2VydFBhcnRpY2lwYW50IiwidXBkYXRlZFBhcnRpY2lwYW50cyIsImluY3JlbWVudCIsInVwZGF0ZU1lbWJlcnMiLCJtZW1iZXIiLCJtZW1iZXJVcGRhdGUiLCJ1cGRhdGVQYXJ0aWNpcGFudFJlYWN0aW9uIiwiZW1vamlfY29kZSIsInVuYmxvY2tVc2VyIiwiY3VycmVudCIsImJsb2NrVXNlciIsInVwZGF0ZU93bkNhcGFiaWxpdGllcyIsImxvY2FsUGFydGljaXBhbnQiLCJvd25fY2FwYWJpbGl0aWVzIiwicGFydGljaXBhbnRzJCIsImFzT2JzZXJ2YWJsZSIsInBpcGUiLCJzb3J0IiwiYnVmZmVyU2l6ZSIsInJlZkNvdW50IiwibG9jYWxQYXJ0aWNpcGFudCQiLCJpc0xvY2FsUGFydGljaXBhbnQiLCJyZW1vdGVQYXJ0aWNpcGFudHMkIiwicGlubmVkUGFydGljaXBhbnRzJCIsImRvbWluYW50U3BlYWtlciQiLCJoYXNPbmdvaW5nU2NyZWVuU2hhcmUkIiwic3RhcnRlZEF0JCIsInBhcnRpY2lwYW50Q291bnQkIiwiYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQiLCJjYWxsU3RhdHNSZXBvcnQkIiwibWVtYmVycyQiLCJvd25DYXBhYmlsaXRpZXMkIiwiY2FsbGluZ1N0YXRlJCIsImJhY2tzdGFnZSQiLCJibG9ja2VkVXNlcklkcyQiLCJjcmVhdGVkQXQkIiwiZW5kZWRBdCQiLCJzdGFydHNBdCQiLCJ1cGRhdGVkQXQkIiwiY3JlYXRlZEJ5JCIsImN1c3RvbSQiLCJlZ3Jlc3MkIiwiaW5ncmVzcyQiLCJyZWNvcmRpbmckIiwic2Vzc2lvbiQiLCJzZXR0aW5ncyQiLCJ0cmFuc2NyaWJpbmckIiwiZW5kZWRCeSQiLCJ0aHVtYm5haWxzJCIsImFub255bW91c1BhcnRpY2lwYW50Q291bnQiLCJyZW1vdGVQYXJ0aWNpcGFudHMiLCJwaW5uZWRQYXJ0aWNpcGFudHMiLCJoYXNPbmdvaW5nU2NyZWVuU2hhcmUiLCJjYWxsaW5nU3RhdGUiLCJjYWxsU3RhdHNSZXBvcnQiLCJvd25DYXBhYmlsaXRpZXMiLCJibG9ja2VkVXNlcklkcyIsImVuZGVkQXQiLCJzdGFydHNBdCIsImNyZWF0ZWRCeSIsImVuZGVkQnkiLCJTdHJlYW1WaWRlb1dyaXRlYWJsZVN0YXRlU3RvcmUiLCJjb25uZWN0ZWRVc2VyU3ViamVjdCIsImNhbGxzU3ViamVjdCIsInNldENvbm5lY3RlZFVzZXIiLCJzZXRDYWxscyIsImNhbGxzIiwicmVnaXN0ZXJDYWxsIiwiY2lkIiwidW5yZWdpc3RlckNhbGwiLCJmaW5kQ2FsbCIsIkxFRlQiLCJsZWF2ZSIsImNhdGNoIiwiY29ubmVjdGVkVXNlciIsIlN0cmVhbVZpZGVvUmVhZE9ubHlTdGF0ZVN0b3JlIiwic3RvcmUiLCJjb25uZWN0ZWRVc2VyJCIsImNhbGxzJCIsImdldFJ0cE1hcCIsImxpbmUiLCJydHBSZWdleCIsInJ0cE1hdGNoIiwiZXhlYyIsIm9yaWdpbmFsIiwiZ2V0Rm10cCIsImZtdHBSZWdleCIsImZtdHBNYXRjaCIsImNvbmZpZyIsImdldE1lZGlhIiwibWVkaWFUeXBlIiwicmVnZXgiLCJSZWdFeHAiLCJtZWRpYVdpdGhQb3J0cyIsImNvZGVjT3JkZXIiLCJnZXRNZWRpYVNlY3Rpb24iLCJtZWRpYSIsInJ0cE1hcCIsImZtdHAiLCJpc1RoZVJlcXVpcmVkTWVkaWFTZWN0aW9uIiwiaXNWYWxpZExpbmUiLCJ0ZXN0IiwiX21lZGlhIiwicnRwTWFwTGluZSIsImdldE9wdXNGbXRwIiwic2VjdGlvbiIsImNvZGVjSWQiLCJ0b2dnbGVEdHgiLCJlbmFibGUiLCJvcHVzRm10cCIsIm1hdGNoRHR4IiwicmVxdWlyZWREdHhDb25maWciLCJuZXdGbXRwIiwiZW5hYmxlSGlnaFF1YWxpdHlBdWRpbyIsInRyYWNrTWlkIiwibWluIiwicGFyc2VkU2RwIiwiYXVkaW9NZWRpYSIsIlN0cmluZyIsIm9wdXNSdHAiLCJydHAiLCJ3cml0ZSIsImxvZ2dlciQzIiwiUHVibGlzaGVyIiwiY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24iLCJwYyIsImdldENvbmZpZ3VyYXRpb24iLCJfY29ubmVjdGlvbkNvbmZpZ3VyYXRpb24iLCJjb25uZWN0aW9uQ29uZmlnIiwic2Z1Q2xpZW50IiwiZGlzcGF0Y2hlciIsImlzRHR4RW5hYmxlZCIsImlzUmVkRW5hYmxlZCIsImljZVJlc3RhcnREZWxheSIsInRyYW5zY2VpdmVyUmVnaXN0cnkiLCJwdWJsaXNoT3B0aW9uc1BlclRyYWNrVHlwZSIsIk1hcCIsInRyYW5zY2VpdmVySW5pdE9yZGVyIiwidHJhY2tLaW5kTWFwcGluZyIsInRyYWNrTGF5ZXJzQ2FjaGUiLCJpc0ljZVJlc3RhcnRpbmciLCJjcmVhdGVQZWVyQ29ubmVjdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbkljZUNhbmRpZGF0ZSIsIm9uTmVnb3RpYXRpb25OZWVkZWQiLCJvbkljZUNhbmRpZGF0ZUVycm9yIiwib25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJvbkljZUdhdGhlcmluZ1N0YXRlQ2hhbmdlIiwib25TaWduYWxpbmdTdGF0ZUNoYW5nZSIsInN0b3BUcmFja3MiLCJzdG9wUHVibGlzaGluZyIsImNsZWFyVGltZW91dCIsImljZVJlc3RhcnRUaW1lb3V0IiwidW5zdWJzY3JpYmVPbkljZVJlc3RhcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicHVibGlzaFN0cmVhbSIsIm1lZGlhU3RyZWFtIiwidHJhY2siLCJvcHRzIiwicmVhZHlTdGF0ZSIsInRyYW5zY2VpdmVyIiwic2VuZGVyIiwiaGFuZGxlVHJhY2tFbmRlZCIsIm5vdGlmeVRyYWNrTXV0ZVN0YXRlQ2hhbmdlZCIsInZpZGVvIiwidGFyZ2V0X3Jlc29sdXRpb24iLCJ2aWRlb0VuY29kaW5ncyIsInNjcmVlblNoYXJlU2V0dGluZ3MiLCJvc05hbWUiLCJjb2RlY1ByZWZlcmVuY2VzIiwiZ2V0Q29kZWNQcmVmZXJlbmNlcyIsImVuYWJsZWQiLCJzdHJlYW1zIiwic2VuZEVuY29kaW5ncyIsInNldCIsInNldENvZGVjUHJlZmVyZW5jZXMiLCJwcmV2aW91c1RyYWNrIiwicmVwbGFjZVRyYWNrIiwidW5wdWJsaXNoU3RyZWFtIiwic3RvcFRyYWNrIiwiaXNQdWJsaXNoaW5nIiwidHJhbnNjZWl2ZXJGb3JUcmFja1R5cGUiLCJpc0xpdmUiLCJpc011dGVkIiwidXBkYXRlTXV0ZVN0YXRlIiwiYXVkaW9PclZpZGVvT3JTY3JlZW5TaGFyZVN0cmVhbSIsImdldFNlbmRlcnMiLCJzaWduYWxpbmdTdGF0ZSIsInJlbW92ZVRyYWNrIiwidXBkYXRlVmlkZW9QdWJsaXNoUXVhbGl0eSIsImVuYWJsZWRMYXllcnMiLCJ2aWRlb1NlbmRlciIsInBhcmFtcyIsImdldFBhcmFtZXRlcnMiLCJlbmNvZGluZ3MiLCJjaGFuZ2VkIiwiZW5hYmxlZFJpZHMiLCJseSIsImVuYyIsInNob3VsZEVuYWJsZSIsInZscyIsImFjdGl2ZUxheWVycyIsInNldFBhcmFtZXRlcnMiLCJnZXRTdGF0cyIsInNlbGVjdG9yIiwiZGVmYXVsdEF1ZGlvQ29kZWMiLCJzZXRTZnVDbGllbnQiLCJtaWdyYXRlVG8iLCJzZXRDb25maWd1cmF0aW9uIiwic2hvdWxkUmVzdGFydEljZSIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIm5lZ290aWF0ZSIsInJlc3RhcnRJY2UiLCJtdW5nZUNvZGVjcyIsImV4dHJhY3RNaWQiLCJ0cmFja0luZm9zIiwiZ2V0Q3VycmVudFRyYWNrSW5mb3MiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwicmVzcG9uc2UiLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsImljZVRyaWNrbGVCdWZmZXIiLCJhZGRJY2VDYW5kaWRhdGUiLCJtc2lkIiwiaGV1cmlzdGljTWlkIiwibG9jYWxEZXNjcmlwdGlvbiIsIm9wdGltYWxMYXllcnMiLCJwdWJsaXNoT3B0cyIsImdldCIsIm9wdGltYWxMYXllciIsInJpZFRvVmlkZW9RdWFsaXR5IiwiaXNBdWRpb1RyYWNrIiwidHJhY2tTZXR0aW5ncyIsImlzU3RlcmVvIiwiZXJyb3JNZXNzYWdlIiwiUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50IiwiZXJyb3JDb2RlIiwiZXJyb3JUZXh0IiwiaGFzTmV0d29ya0Nvbm5lY3Rpb24iLCJPRkZMSU5FIiwic2V0VGltZW91dCIsImljZUdhdGhlcmluZ1N0YXRlIiwiTE9XX1VOU1BFQ0lGSUVEIiwiTUlEIiwiSElHSCIsImxvZ2dlciQyIiwiU3Vic2NyaWJlciIsImhhbmRsZU9uVHJhY2siLCJ1bnJlZ2lzdGVyT25TdWJzY3JpYmVyT2ZmZXIiLCJ1bnJlZ2lzdGVyT25JY2VSZXN0YXJ0IiwicHJldmlvdXNQQyIsInRyYWNrSWRzVG9NaWdyYXRlIiwiU2V0IiwiZ2V0UmVjZWl2ZXJzIiwiYWRkIiwibWlncmF0aW9uVGltZW91dElkIiwiY2xlYW51cE1pZ3JhdGlvbiIsImhhbmRsZVRyYWNrTWlncmF0aW9uIiwiZGVsZXRlIiwiaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwiY29ubmVjdGlvblN0YXRlIiwicHJldmlvdXNJc0ljZVJlc3RhcnRpbmciLCJwcmltYXJ5U3RyZWFtIiwicGFydGljaXBhbnRUb1VwZGF0ZSIsInN0cmVhbUtpbmRQcm9wIiwiVFJBQ0tfVFlQRV9BVURJTyIsIlRSQUNLX1RZUEVfVklERU8iLCJUUkFDS19UWVBFX1NDUkVFTl9TSEFSRSIsIlRSQUNLX1RZUEVfU0NSRUVOX1NIQVJFX0FVRElPIiwicHJldmlvdXNTdHJlYW0iLCJnZXRUcmFja3MiLCJhbnN3ZXIiLCJjcmVhdGVBbnN3ZXIiLCJjcmVhdGVXZWJTb2NrZXRTaWduYWxDaGFubmVsIiwiZW5kcG9pbnQiLCJvbk1lc3NhZ2UiLCJ3cyIsImJpbmFyeVR5cGUiLCJkYXRhIiwiQXJyYXlCdWZmZXIiLCJmcm9tQmluYXJ5IiwiVWludDhBcnJheSIsImZyb21Kc29uU3RyaW5nIiwic2xlZXAiLCJQcm9taXNlIiwiaXNGdW5jdGlvbiIsIkZ1bmN0aW9uIiwiS25vd25Db2RlcyIsIlRPS0VOX0VYUElSRUQiLCJXU19DTE9TRURfU1VDQ0VTUyIsIldTX0NMT1NFRF9BQlJVUFRMWSIsIldTX1BPTElDWV9WSU9MQVRJT04iLCJyZXRyeUludGVydmFsIiwibnVtYmVyT2ZGYWlsdXJlcyIsInJhbmRvbSIsInJhbmRvbUlkIiwiZ2VuZXJhdGVVVUlEdjQiLCJoZXgiLCJieXRlcyIsInBhZFN0YXJ0IiwiZ2V0UmFuZG9tQnl0ZXMiLCJzdWJhcnJheSIsImdldFJhbmRvbVZhbHVlc1dpdGhNYXRoUmFuZG9tIiwicG93IiwiYnl0ZUxlbmd0aCIsImdldFJhbmRvbVZhbHVlcyIsImNyeXB0byIsImJpbmQiLCJtc0NyeXB0byIsImNvbnZlcnRFcnJvclRvSnNvbiIsImpzb25PYmoiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiXyIsImlzT25saW5lIiwibmF2Iiwid2luZG93Iiwib25MaW5lIiwiYWRkQ29ubmVjdGlvbkV2ZW50TGlzdGVuZXJzIiwiY2IiLCJyZW1vdmVDb25uZWN0aW9uRXZlbnRMaXN0ZW5lcnMiLCJTdHJlYW1TZnVDbGllbnQiLCJzZnVTZXJ2ZXIiLCJpc01pZ3JhdGluZ0F3YXkiLCJpc0Zhc3RSZWNvbm5lY3RpbmciLCJwaW5nSW50ZXJ2YWxJbk1zIiwidW5oZWFsdGh5VGltZW91dEluTXMiLCJOT1JNQUxfQ0xPU1VSRSIsInNpZ25hbFdzIiwiQ0xPU0VEIiwidW5zdWJzY3JpYmVJY2VUcmlja2xlIiwiY2xlYXJJbnRlcnZhbCIsImtlZXBBbGl2ZUludGVydmFsIiwiY29ubmVjdGlvbkNoZWNrVGltZW91dCIsInJldHJ5YWJsZSIsInJwYyIsInNlbmQiLCJzaWduYWxSZWFkeSIsInRoZW4iLCJzaWduYWwiLCJPUEVOIiwiZWRnZU5hbWUiLCJ0b0JpbmFyeSIsImtlZXBBbGl2ZSIsInNldEludGVydmFsIiwic2NoZWR1bGVDb25uZWN0aW9uQ2hlY2siLCJsYXN0TWVzc2FnZVRpbWVzdGFtcCIsInRpbWVTaW5jZUxhc3RNZXNzYWdlIiwiRVJST1JfQ09OTkVDVElPTl9VTkhFQUxUSFkiLCJlZGdlX25hbWUiLCJsb2dJbnRlcmNlcHRvciIsInVybCIsImludGVyY2VwdG9ycyIsIkF1dGhvcml6YXRpb24iLCJ3c19lbmRwb2ludCIsInJlc29sdmUiLCJvbk9wZW4iLCJFUlJPUl9DT05ORUNUSU9OX0JST0tFTiIsIk1BWF9SRVRSSUVTIiwicmV0cnlBdHRlbXB0IiwicnBjQ2FsbFJlc3VsdCIsIndhdGNoQ2FsbEFjY2VwdGVkIiwib25DYWxsQWNjZXB0ZWQiLCJjdXJyZW50VXNlcklkIiwiUklOR0lORyIsIndhdGNoQ2FsbFJlamVjdGVkIiwib25DYWxsUmVqZWN0ZWQiLCJldmVudENhbGwiLCJjYWxsU2Vzc2lvbiIsInJlamVjdGVkQnkiLCJyZWplY3RlZF9ieSIsImlzQ3JlYXRlZEJ5TWUiLCJldmVyeW9uZUVsc2VSZWplY3RlZCIsImV2ZXJ5Iiwid2F0Y2hDYWxsRW5kZWQiLCJvbkNhbGxFbmRlZCIsIkpPSU5FRCIsIkpPSU5JTkciLCJ3YXRjaENhbGxHcmFudHNVcGRhdGVkIiwib25DYWxsR3JhbnRzVXBkYXRlZCIsIm5leHRDYXBhYmlsaXRpZXMiLCJjYXBhYmlsaXR5IiwibG9nZ2VyJDEiLCJ3YXRjaENoYW5nZVB1Ymxpc2hRdWFsaXR5IiwidXBkYXRlUHVibGlzaFF1YWxpdHkiLCJ3YXRjaENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCIsInBhdGNoZXMiLCJ3YXRjaFBhcnRpY2lwYW50Q291bnRDaGFuZ2VkIiwid2F0Y2hMaXZlRW5kZWQiLCJMSVZFX0VOREVEIiwicGVybWlzc2lvbnNDb250ZXh0IiwiaGFzUGVybWlzc2lvbiIsIndhdGNoU2Z1RXJyb3JSZXBvcnRzIiwid2F0Y2hQaW5zVXBkYXRlZCIsIm9uUGluc1VwZGF0ZWQiLCJoYW5kbGVSZW1vdGVTb2Z0TXV0ZSIsIk1PREVSQVRJT04iLCJjYW1lcmEiLCJkaXNhYmxlIiwibWljcm9waG9uZSIsInB1Ymxpc2hlciIsInN0b3BQdWJsaXNoIiwid2F0Y2hQYXJ0aWNpcGFudEpvaW5lZCIsIm9uUGFydGljaXBhbnRKb2luZWQiLCJhc3NpZ24iLCJzY3JlZW5TaGFyZVRyYWNrIiwid2F0Y2hQYXJ0aWNpcGFudExlZnQiLCJvblBhcnRpY2lwYW50TGVmdCIsIndhdGNoVHJhY2tQdWJsaXNoZWQiLCJvblRyYWNrUHVibGlzaGVkIiwidW5pcXVlIiwid2F0Y2hUcmFja1VucHVibGlzaGVkIiwib25UcmFja1VucHVibGlzaGVkIiwiYXJyIiwid2F0Y2hEb21pbmFudFNwZWFrZXJDaGFuZ2VkIiwid2F0Y2hBdWRpb0xldmVsQ2hhbmdlZCIsInJlZ2lzdGVyRXZlbnRIYW5kbGVycyIsInJpbmdpbmciLCJyZWdpc3RlclJpbmdpbmdDYWxsRXZlbnRIYW5kbGVycyIsImNvb3JkaW5hdG9yUmluZ0V2ZW50cyIsImh0dHBDbGllbnQiLCJqb2luQ2FsbFJlc3BvbnNlIiwiZG9Kb2luIiwiY3JlZGVudGlhbHMiLCJ0b1J0Y0NvbmZpZ3VyYXRpb24iLCJpY2Vfc2VydmVycyIsInNlcnZlciIsIm1ldGFkYXRhIiwibG9jYXRpb24iLCJnZXRMb2NhdGlvbkhpbnQiLCJyZXF1ZXN0IiwicG9zdCIsInJ0Y0NvbmZpZyIsImljZVNlcnZlcnMiLCJpY2UiLCJ1cmxzIiwidXNlcm5hbWUiLCJjcmVkZW50aWFsIiwicGFzc3dvcmQiLCJjcmVhdGVTdGF0c1JlcG9ydGVyIiwic3Vic2NyaWJlciIsInBvbGxpbmdJbnRlcnZhbEluTXMiLCJnZXRSYXdTdGF0c0ZvclRyYWNrIiwiZ2V0U3RhdHNGb3JTdHJlYW0iLCJzdGF0c0ZvclN0cmVhbSIsInN0YXRzIiwidHJhbnNmb3JtIiwidHJhY2tLaW5kIiwic3RhcnRSZXBvcnRpbmdTdGF0c0ZvciIsInNlc3Npb25JZHNUb1RyYWNrIiwicnVuIiwic3RvcFJlcG9ydGluZ1N0YXRzRm9yIiwicGFydGljaXBhbnRTdGF0cyIsInNlc3Npb25JZHMiLCJoYXMiLCJtZXJnZWRTdHJlYW0iLCJNZWRpYVN0cmVhbSIsInZpZGVvU3RyZWFtIiwiZ2V0VmlkZW9UcmFja3MiLCJhdWRpb1N0cmVhbSIsImdldEF1ZGlvVHJhY2tzIiwic3Vic2NyaWJlclN0YXRzIiwicHVibGlzaGVyU3RhdHMiLCJhbGwiLCJhZ2dyZWdhdGUiLCJzdWJzY3JpYmVyUmF3U3RhdHMiLCJwdWJsaXNoZXJSYXdTdGF0cyIsImRhdGFjZW50ZXIiLCJ0aW1lc3RhbXAiLCJ0aW1lb3V0SWQiLCJsb29wIiwiZmxhdHRlbiQxIiwic3RhdCIsInJ0Y1N0cmVhbVN0YXRzIiwidHJhbnNwb3J0SWQiLCJyb3VuZFRyaXBUaW1lIiwiZHRsc1N0YXRlIiwiY2FuZGlkYXRlUGFpciIsInNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkIiwiY3VycmVudFJvdW5kVHJpcFRpbWUiLCJieXRlc1NlbnQiLCJieXRlc1JlY2VpdmVkIiwiZnJhbWVIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZnJhbWVzUGVyU2Vjb25kIiwiaml0dGVyIiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb24iLCJzc3JjIiwicmF3U3RhdHMiLCJhZ2dyZWdhdGVkU3RhdHMiLCJyYXdSZXBvcnQiLCJ0b3RhbEJ5dGVzU2VudCIsInRvdGFsQnl0ZXNSZWNlaXZlZCIsImF2ZXJhZ2VKaXR0ZXJJbk1zIiwiYXZlcmFnZVJvdW5kVHJpcFRpbWVJbk1zIiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb25zIiwiaGlnaGVzdEZyYW1lV2lkdGgiLCJoaWdoZXN0RnJhbWVIZWlnaHQiLCJoaWdoZXN0RnJhbWVzUGVyU2Vjb25kIiwibWF4QXJlYSIsImFyZWEiLCJhY2MiLCJzdHJlYW0iLCJzdHJlYW1BcmVhIiwiQm9vbGVhbiIsIkRFRkFVTFRfVEhSRVNIT0xEIiwiVmlld3BvcnRUcmFja2VyIiwiZWxlbWVudEhhbmRsZXJNYXAiLCJvYnNlcnZlciIsInF1ZXVlU2V0Iiwic2V0Vmlld3BvcnQiLCJ2aWV3cG9ydEVsZW1lbnQiLCJjbGVhbnVwIiwiZGlzY29ubmVjdCIsImNsZWFyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyeSIsInJvb3QiLCJ0aHJlc2hvbGQiLCJxdWV1ZUVsZW1lbnQiLCJxdWV1ZUhhbmRsZXIiLCJjb250YWlucyIsIm9ic2VydmUiLCJlbGVtZW50IiwicXVldWVJdGVtIiwidW5vYnNlcnZlIiwiaXNTYWZhcmkiLCJpc0ZpcmVmb3giLCJpc0Nocm9tZSIsImJyb3dzZXJzIiwiREVGQVVMVF9WSUVXUE9SVF9WSVNJQklMSVRZX1NUQVRFIiwiRHluYXNjYWxlTWFuYWdlciIsInZpZXdwb3J0VHJhY2tlciIsInRyYWNrRWxlbWVudFZpc2liaWxpdHkiLCJwcmV2aW91c1Zpc2liaWxpdHlTdGF0ZSIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiZG9jdW1lbnQiLCJmdWxsc2NyZWVuRWxlbWVudCIsIlZJU0lCTEUiLCJiaW5kVmlkZW9FbGVtZW50IiwidmlkZW9FbGVtZW50IiwiYm91bmRQYXJ0aWNpcGFudCIsInJlcXVlc3RUcmFja1dpdGhEaW1lbnNpb25zIiwiZGVib3VuY2VUeXBlIiwidXBkYXRlU3Vic2NyaXB0aW9uc1BhcnRpYWwiLCJwYXJ0aWNpcGFudCQiLCJ2aWV3cG9ydFZpc2liaWxpdHlTdGF0ZVN1YnNjcmlwdGlvbiIsIm5leHRWaWV3cG9ydFZpc2liaWxpdHlTdGF0ZSIsIk1FRElVTSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwibGFzdERpbWVuc2lvbnMiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiY3VycmVudERpbWVuc2lvbnMiLCJTTE9XIiwicHVibGlzaGVkVHJhY2tzU3Vic2NyaXB0aW9uIiwiRkFTVCIsImF1dG9wbGF5IiwicGxheXNJbmxpbmUiLCJzdHJlYW1TdWJzY3JpcHRpb24iLCJzb3VyY2UiLCJzY3JlZW5TaGFyZVN0cmVhbSIsInNyY09iamVjdCIsInBsYXkiLCJiaW5kQXVkaW9FbGVtZW50IiwiYXVkaW9FbGVtZW50IiwidXBkYXRlTWVkaWFTdHJlYW1TdWJzY3JpcHRpb24iLCJzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtIiwic2VsZWN0ZWREZXZpY2UiLCJzcGVha2VyIiwic2V0U2lua0lkIiwic2lua0lkU3Vic2NyaXB0aW9uIiwic2VsZWN0ZWREZXZpY2UkIiwiZGV2aWNlSWQiLCJ2b2x1bWVTdWJzY3JpcHRpb24iLCJ2b2x1bWUkIiwidm9sdW1lIiwiUGVybWlzc2lvbnNDb250ZXh0IiwicGVybWlzc2lvbnMiLCJzZXRQZXJtaXNzaW9ucyIsInNldENhbGxTZXR0aW5ncyIsInBlcm1pc3Npb24iLCJjYW5SZXF1ZXN0IiwiYXVkaW8iLCJzY3JlZW5zaGFyaW5nIiwiYWNjZXNzX3JlcXVlc3RfZW5hYmxlZCIsIkNhbGxUeXBlIiwiQ2FsbFR5cGVzUmVnaXN0cnkiLCJjYWxsVHlwZXMiLCJyZWdpc3RlciIsImNhbGxUeXBlIiwidW5yZWdpc3RlciIsIkNhbGxUeXBlcyIsImdldERldmljZXMiLCJjb25zdHJhaW50cyIsImVudW1lcmF0ZSIsImRldmljZXMiLCJtZWRpYURldmljZXMiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmVlZHNHZXRVc2VyTWVkaWEiLCJsYWJlbCIsImdldFVzZXJNZWRpYSIsImRpc3Bvc2VPZk1lZGlhU3RyZWFtIiwiY29tcGxldGUiLCJjaGVja0lmQXVkaW9PdXRwdXRDaGFuZ2VTdXBwb3J0ZWQiLCJjcmVhdGVFbGVtZW50IiwiYXVkaW9EZXZpY2VDb25zdHJhaW50cyIsImF1dG9HYWluQ29udHJvbCIsIm5vaXNlU3VwcHJlc3Npb24iLCJlY2hvQ2FuY2VsbGF0aW9uIiwidmlkZW9EZXZpY2VDb25zdHJhaW50cyIsIm1lbW9pemVkT2JzZXJ2YWJsZSIsIm1lbW9pemVkIiwiZ2V0RGV2aWNlQ2hhbmdlT2JzZXJ2ZXIiLCJub3RpZnkiLCJnZXRBdWRpb0RldmljZXNPYnNlcnZlciIsImdldEF1ZGlvT3V0cHV0RGV2aWNlc09ic2VydmVyIiwiZ2V0VmlkZW9EZXZpY2VzT2JzZXJ2ZXIiLCJnZXRBdWRpb0RldmljZXMiLCJnZXRWaWRlb0RldmljZXMiLCJnZXRBdWRpb091dHB1dERldmljZXMiLCJnZXRTdHJlYW0iLCJnZXRBdWRpb1N0cmVhbSIsInRyYWNrQ29uc3RyYWludHMiLCJnZXRWaWRlb1N0cmVhbSIsImdldFNjcmVlblNoYXJlU3RyZWFtIiwiZ2V0RGlzcGxheU1lZGlhIiwiaWRlYWwiLCJzeXN0ZW1BdWRpbyIsImRldmljZUlkcyQiLCJyZWxlYXNlIiwiSW5wdXRNZWRpYURldmljZU1hbmFnZXIiLCJzdG9wT25MZWF2ZSIsImlzVHJhY2tTdG9wcGVkRHVlVG9UcmFja0VuZCIsInJlbW92ZVN1YnNjcmlwdGlvbnMiLCJoYW5kbGVEaXNjb25uZWN0ZWRPclJlcGxhY2VkRGV2aWNlcyIsImxpc3REZXZpY2VzIiwic3RhdHVzIiwiZW5hYmxlUHJvbWlzZSIsInVubXV0ZVN0cmVhbSIsInNldFN0YXR1cyIsImZvcmNlU3RvcCIsInByZXZTdGF0dXMiLCJkaXNhYmxlTW9kZSIsImRpc2FibGVQcm9taXNlIiwibXV0ZVN0cmVhbSIsInJlc3VtZSIsInRvZ2dsZSIsInNldERlZmF1bHRDb25zdHJhaW50cyIsInNlbGVjdCIsInNldERldmljZSIsImFwcGx5U2V0dGluZ3NUb1N0cmVhbSIsInN0b3BQdWJsaXNoU3RyZWFtIiwibXV0ZUxvY2FsU3RyZWFtIiwiYWxsRW5kZWQiLCJzZXRNZWRpYVN0cmVhbSIsIm11dGVUcmFja3MiLCJ1bm11dGVUcmFja3MiLCJkZWZhdWx0Q29uc3RyYWludHMiLCJtZWRpYURldmljZUtpbmQiLCJwcmV2RGV2aWNlcyIsImN1cnJlbnREZXZpY2VzIiwiaXNEZXZpY2VEaXNjb25uZWN0ZWQiLCJpc0RldmljZVJlcGxhY2VkIiwiY3VycmVudERldmljZSIsImZpbmREZXZpY2VJbkxpc3QiLCJwcmV2RGV2aWNlIiwiZ3JvdXBJZCIsIklucHV0TWVkaWFEZXZpY2VNYW5hZ2VyU3RhdGUiLCJwZXJtaXNzaW9uTmFtZSIsInN0YXR1c1N1YmplY3QiLCJtZWRpYVN0cmVhbVN1YmplY3QiLCJzZWxlY3RlZERldmljZVN1YmplY3QiLCJkZWZhdWx0Q29uc3RyYWludHNTdWJqZWN0IiwibWVkaWFTdHJlYW0kIiwic3RhdHVzJCIsImRlZmF1bHRDb25zdHJhaW50cyQiLCJoYXNCcm93c2VyUGVybWlzc2lvbiQiLCJub3RpZnlHcmFudGVkIiwicGVybWlzc2lvbnNBUElBdmFpbGFibGUiLCJxdWVyeSIsInBlcm1pc3Npb25TdGF0ZSIsInBlcm1pc3Npb25TdGF0dXMiLCJnZXREZXZpY2VJZEZyb21TdHJlYW0iLCJDYW1lcmFNYW5hZ2VyU3RhdGUiLCJkaXJlY3Rpb25TdWJqZWN0IiwiZGlyZWN0aW9uJCIsInNldERpcmVjdGlvbiIsImZhY2luZ01vZGUiLCJDYW1lcmFNYW5hZ2VyIiwic2VsZWN0RGlyZWN0aW9uIiwiZmxpcCIsIm5ld0RpcmVjdGlvbiIsInNlbGVjdFRhcmdldFJlc29sdXRpb24iLCJyZXNvbHV0aW9uIiwic2V0UHJlZmVycmVkQ29kZWMiLCJwdWJsaXNoVmlkZW9TdHJlYW0iLCJNaWNyb3Bob25lTWFuYWdlclN0YXRlIiwic3BlYWtpbmdXaGlsZU11dGVkU3ViamVjdCIsInNwZWFraW5nV2hpbGVNdXRlZCQiLCJzcGVha2luZ1doaWxlTXV0ZWQiLCJzZXRTcGVha2luZ1doaWxlTXV0ZWQiLCJERVRFQ1RJT05fRlJFUVVFTkNZX0lOX01TIiwiQVVESU9fTEVWRUxfVEhSRVNIT0xEJDEiLCJGRlRfU0laRSIsImNyZWF0ZVNvdW5kRGV0ZWN0b3IiLCJvblNvdW5kRGV0ZWN0ZWRTdGF0ZUNoYW5nZWQiLCJkZXRlY3Rpb25GcmVxdWVuY3lJbk1zIiwiYXVkaW9MZXZlbFRocmVzaG9sZCIsImZmdFNpemUiLCJkZXN0cm95U3RyZWFtT25TdG9wIiwiYXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0IiwiYW5hbHlzZXIiLCJjcmVhdGVBbmFseXNlciIsImNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIiwiY29ubmVjdCIsImludGVydmFsSWQiLCJmcmVxdWVuY3lCaW5Db3VudCIsImdldEJ5dGVGcmVxdWVuY3lEYXRhIiwiaXNTb3VuZERldGVjdGVkIiwiYXZlcmFnZWREYXRhVmFsdWUiLCJwdiIsImN2IiwicGVyY2VudGFnZSIsImZsYXR0ZW4iLCJBVURJT19MRVZFTF9USFJFU0hPTEQiLCJSTlNwZWVjaERldGVjdG9yIiwicGMxIiwicGMyIiwic3RhcnQiLCJhZGRUcmFjayIsImF1ZGlvVHJhY2tzIiwib25TcGVha2luZ0RldGVjdGVkU3RhdGVDaGFuZ2UiLCJhdWRpb01lZGlhU291cmNlU3RhdHMiLCJNaWNyb3Bob25lTWFuYWdlciIsInN0b3BTcGVha2luZ1doaWxlTXV0ZWREZXRlY3Rpb24iLCJzdGFydFNwZWFraW5nV2hpbGVNdXRlZERldGVjdGlvbiIsInB1Ymxpc2hBdWRpb1N0cmVhbSIsInJuU3BlZWNoRGV0ZWN0b3IiLCJzb3VuZERldGVjdG9yQ2xlYW51cCIsIlNjcmVlblNoYXJlU3RhdGUiLCJhcmd1bWVudHMiLCJhdWRpb0VuYWJsZWRTdWJqZWN0IiwiYXVkaW9FbmFibGVkJCIsImF1ZGlvRW5hYmxlZCIsInNldEF1ZGlvRW5hYmxlZCIsImlzRW5hYmxlZCIsInNldFNldHRpbmdzIiwiU2NyZWVuU2hhcmVNYW5hZ2VyIiwiZW5hYmxlU2NyZWVuU2hhcmVBdWRpbyIsImRpc2FibGVTY3JlZW5TaGFyZUF1ZGlvIiwicHVibGlzaFNjcmVlblNoYXJlU3RyZWFtIiwiU3BlYWtlclN0YXRlIiwidm9sdW1lU3ViamVjdCIsImlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkIiwic2V0Vm9sdW1lIiwiU3BlYWtlck1hbmFnZXIiLCJzdHJlYW1DbGllbnQiLCJjbGllbnRTdG9yZSIsIndhdGNoaW5nIiwiZHluYXNjYWxlTWFuYWdlciIsInRyYWNrU3Vic2NyaXB0aW9uc1N1YmplY3QiLCJyZWNvbm5lY3RBdHRlbXB0cyIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwibGVhdmVDYWxsSG9va3MiLCJzdHJlYW1DbGllbnRFdmVudEhhbmRsZXJzIiwib2ZmSGFuZGxlciIsImNhbGxfY2lkIiwicmVnaXN0ZXJlZE9mZkhhbmRsZXIiLCJyZWplY3QiLCJhc3NlcnRDYWxsSm9pbmVkIiwiaGFzT3RoZXJQYXJ0aWNpcGFudHMiLCJzdGF0c1JlcG9ydGVyIiwiaG9vayIsInNjcmVlblNoYXJlIiwic3RvcE9uTGVhdmVQcm9taXNlcyIsInN0cmVhbUNsaWVudEJhc2VQYXRoIiwicmluZyIsInJpbmdpbmdTdWJqZWN0IiwiX2hhc0Nvbm5lY3Rpb25JRCIsImFwcGx5RGV2aWNlQ29uZmlnIiwiZ2V0T3JDcmVhdGUiLCJhY2NlcHQiLCJpc01pZ3JhdGluZyIsIk1JR1JBVElORyIsImlzUmVjb25uZWN0aW5nIiwiUkVDT05ORUNUSU5HIiwic2Z1VG9rZW4iLCJwcmV2aW91c1NmdUNsaWVudCIsInJlY29ubmVjdCIsInN0cmF0ZWd5IiwiY3VycmVudFN0YXRlIiwibWlncmF0aW5nX2Zyb20iLCJ1bnJlZ2lzdGVyR29Bd2F5IiwiUkVDT05ORUNUSU5HX0ZBSUxFRCIsInVuc3Vic2NyaWJlT25saW5lRXZlbnQiLCJvbmxpbmUiLCJjdXJyZW50Q2FsbGluZ1N0YXRlIiwic2hvdWxkUmVjb25uZWN0IiwiaXNGaXJzdFJlY29ubmVjdEF0dGVtcHQiLCJ1bnN1YnNjcmliZU9mZmxpbmVFdmVudCIsImF1ZGlvU2V0dGluZ3MiLCJvcHVzX2R0eF9lbmFibGVkIiwicmVkdW5kYW50X2NvZGluZ19lbmFibGVkIiwid2FpdEZvckpvaW5SZXNwb25zZSIsImN1cnJlbnRQYXJ0aWNpcGFudHMiLCJwYXJ0aWNpcGFudExvb2t1cCIsImV4aXN0aW5nUGFydGljaXBhbnQiLCJpbml0Q2FtZXJhIiwiaW5pdE1pYyIsImF1ZGlvVHJhY2siLCJzY3JlZW5TaGFyZUF1ZGlvVHJhY2siLCJjaGFuZ2VzIiwiY2hhbmdlIiwicHJvcCIsInNjcmVlblNoYXJlRGltZW5zaW9uIiwicmVzZXRSZWFjdGlvbiIsImNyaXRlcmlhIiwic2VuZFJlYWN0aW9uIiwibXV0ZVNlbGYiLCJteVVzZXJJZCIsIm11dGVVc2VyIiwibXV0ZU90aGVycyIsInVzZXJJZHNUb011dGUiLCJ1c2VyX2lkcyIsIm11dGVBbGxVc2VycyIsIm11dGVfYWxsX3VzZXJzIiwic3RhcnRSZWNvcmRpbmciLCJzdG9wUmVjb3JkaW5nIiwicmVxdWVzdFBlcm1pc3Npb25zIiwiY2FuUmVxdWVzdFBlcm1pc3Npb25zIiwiZ3JhbnRQZXJtaXNzaW9ucyIsInVwZGF0ZVVzZXJQZXJtaXNzaW9ucyIsImdyYW50X3Blcm1pc3Npb25zIiwicmV2b2tlUGVybWlzc2lvbnMiLCJyZXZva2VfcGVybWlzc2lvbnMiLCJnb0xpdmUiLCJzdG9wTGl2ZSIsInN0YXJ0SExTIiwic3RvcEhMUyIsInVwZGF0ZXMiLCJlbmRDYWxsIiwidW5waW4iLCJwaW5Gb3JFdmVyeW9uZSIsInVucGluRm9yRXZlcnlvbmUiLCJxdWVyeU1lbWJlcnMiLCJ1cGRhdGVDYWxsTWVtYmVycyIsInNjaGVkdWxlQXV0b0Ryb3AiLCJkcm9wVGltZW91dCIsInRpbWVvdXRJbk1zIiwiYXV0b19jYW5jZWxfdGltZW91dF9tcyIsInF1ZXJ5UmVjb3JkaW5ncyIsImNhbGxTZXNzaW9uSWQiLCJzZW5kQ3VzdG9tRXZlbnQiLCJ1bmJpbmQiLCJiaW5kQ2FsbFRodW1ibmFpbEVsZW1lbnQiLCJpbWFnZUVsZW1lbnQiLCJoYW5kbGVFcnJvciIsInNyYyIsImZhbGxiYWNrSW1hZ2VTb3VyY2UiLCJ0aHVtYm5haWxVcmwiLCJVUkwiLCJpbWFnZV91cmwiLCJzZWFyY2hQYXJhbXMiLCJjYWxsVHlwZUNvbmZpZyIsInBhcnRpY2lwYW50U29ydGVyIiwiSURMRSIsInJlZ2lzdGVyRWZmZWN0cyIsInBlcm1pc3Npb25Ub1RyYWNrVHlwZSIsImlzUmluZ2luZyIsImRlZmF1bHREaXJlY3Rpb24iLCJiYWNrZW5kU2V0dGluZyIsImNhbWVyYV9mYWNpbmciLCJjYW1lcmFfZGVmYXVsdF9vbiIsIm1pY19kZWZhdWx0X29uIiwiSW5zaWdodE1ldHJpY3MiLCJjb25uZWN0aW9uU3RhcnRUaW1lc3RhbXAiLCJ3c1RvdGFsRmFpbHVyZXMiLCJ3c0NvbnNlY3V0aXZlRmFpbHVyZXMiLCJpbnN0YW5jZUNsaWVudElkIiwicG9zdEluc2lnaHRzIiwiaW5zaWdodFR5cGUiLCJpbnNpZ2h0cyIsIm1heEF0dGVtcHRzIiwiYnVpbGRXc0ZhdGFsSW5zaWdodCIsImNvbm5lY3Rpb24iLCJidWlsZFdzQmFzZUluc2lnaHQiLCJjbGllbnQiLCJyZWFkeV9zdGF0ZSIsIl9idWlsZFVybCIsImFwaV9rZXkiLCJzdGFydF90cyIsImluc2lnaHRNZXRyaWNzIiwiZW5kX3RzIiwiYXV0aF90eXBlIiwiZ2V0QXV0aFR5cGUiLCJ0b2tlbk1hbmFnZXIiLCJ1c2VySUQiLCJ1c2VyX2RldGFpbHMiLCJfdXNlciIsImNsaWVudF9pZCIsImNvbm5lY3Rpb25JRCIsIndzX2RldGFpbHMiLCJ3c19jb25zZWN1dGl2ZV9mYWlsdXJlcyIsIndzX3RvdGFsX2ZhaWx1cmVzIiwicmVxdWVzdF9pZCIsInJlcXVlc3RJRCIsInVzZXJfYWdlbnQiLCJpbnN0YW5jZV9jbGllbnRfaWQiLCJidWlsZFdzU3VjY2Vzc0FmdGVyRmFpbHVyZUluc2lnaHQiLCJpc0Nsb3NlRXZlbnQiLCJyZXMiLCJpc0Vycm9yRXZlbnQiLCJTdGFibGVXU0Nvbm5lY3Rpb24iLCJfbG9nIiwiZXh0cmEiLCJzZXRDbGllbnQiLCJVUkxTZWFyY2hQYXJhbXMiLCJnZXRVc2VyQWdlbnQiLCJ3c0Jhc2VVUkwiLCJvbmxpbmVTdGF0dXNDaGFuZ2VkIiwiX3NldEhlYWx0aCIsImlzSGVhbHRoeSIsIl9yZWNvbm5lY3QiLCJpbnRlcnZhbCIsIm9ub3BlbiIsIndzSUQiLCJfZ2V0VG9rZW4iLCJhdXRoTWVzc2FnZSIsImF1dGhlbnRpY2F0aW9uU2VudCIsIm9ubWVzc2FnZSIsImlzUmVzb2x2ZWQiLCJyZWplY3RQcm9taXNlIiwiX2Vycm9yRnJvbVdTRXZlbnQiLCJsYXN0RXZlbnQiLCJzY2hlZHVsZU5leHRQaW5nIiwicmVzb2x2ZVByb21pc2UiLCJpc0Nvbm5lY3RpbmciLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiaXNTdGF0aWMiLCJjb25uZWN0aW9uQ2hlY2tUaW1lb3V0UmVmIiwicmVmcmVzaFRva2VuIiwiZGlzcGF0Y2hFdmVudCIsIm9uY2xvc2UiLCJ3YXNDbGVhbiIsInRvdGFsRmFpbHVyZXMiLCJvbmVycm9yIiwiaGVhbHRoeSIsImRpc3BhdGNoSW1tZWRpYXRlbHkiLCJpc1dTRmFpbHVyZSIsInN0YXR1c0NvZGUiLCJTdGF0dXNDb2RlIiwiX3NldHVwQ29ubmVjdGlvblByb21pc2UiLCJjb25uZWN0aW9uT3BlbiIsImhlYWx0aENoZWNrVGltZW91dFJlZiIsImNsaWVudElEIiwicGluZ0ludGVydmFsIiwiaXNEaXNjb25uZWN0ZWQiLCJoZWFsdGhDaGVjayIsIl9jb25uZWN0IiwiX3dhaXRGb3JIZWFsdGh5IiwicmFjZSIsInJlbW92ZUFsbExpc3RlbmVycyIsImlzQ2xvc2VkUHJvbWlzZSIsImVuYWJsZVdTRmFsbGJhY2siLCJpc1Rva2VuUmVhZHkiLCJ0b2tlblJlYWR5IiwibG9hZFRva2VuIiwid3NVUkwiLCJjb25uZWN0aW9uX2lkIiwicmVzb2x2ZUNvbm5lY3Rpb25JZCIsImVuYWJsZUluc2lnaHRzIiwicmVqZWN0Q29ubmVjdGlvbklkIiwiX2Rlc3Ryb3lDdXJyZW50V1NDb25uZWN0aW9uIiwiaXNTdHJpbmciLCJhcnJheU9yU3RyaW5nIiwiaXNNYXBTdHJpbmdDYWxsYmFjayIsImNhbGxiYWNrIiwiY2hhckF0Iiwia1ZhbHVlIiwibWFwcGVkVmFsdWUiLCJlbmNvZGVCYXNlNjQiLCJjaGFyIiwiY2hhckNvZGVBdCIsImRlY29kZUJhc2U2NCIsImZyb21DaGFyQ29kZSIsIkwiLCJ4IiwiQSIsIkpXVFVzZXJUb2tlbiIsImFwaVNlY3JldCIsImV4dHJhRGF0YSIsImp3dE9wdGlvbnMiLCJUeXBlRXJyb3IiLCJzaWduIiwiYWxnb3JpdGhtIiwibm9UaW1lc3RhbXAiLCJpYXQiLCJKV1RTZXJ2ZXJUb2tlbiIsIlVzZXJGcm9tVG9rZW4iLCJmcmFnbWVudHMiLCJiNjRQYXlsb2FkIiwiRGV2VG9rZW4iLCJUb2tlbk1hbmFnZXIiLCJzZWNyZXQiLCJzZXRUb2tlbk9yUHJvdmlkZXIiLCJ0b2tlbk9yUHJvdmlkZXIiLCJpc0Fub255bW91cyIsInZhbGlkYXRlVG9rZW4iLCJ0b2tlblByb3ZpZGVyIiwicmVzZXQiLCJsb2FkVG9rZW5Qcm9taXNlIiwidG9rZW5Vc2VySWQiLCJnZXRUb2tlbiIsIkFQSUVycm9yQ29kZXMiLCJpc0FQSUVycm9yIiwiaXNFcnJvclJldHJ5YWJsZSIsImlzQ29ubmVjdGlvbklERXJyb3IiLCJpc0Vycm9yUmVzcG9uc2UiLCJDb25uZWN0aW9uU3RhdGUiLCJXU0Nvbm5lY3Rpb25GYWxsYmFjayIsIl9vbmxpbmVTdGF0dXNDaGFuZ2VkIiwiX3NldFN0YXRlIiwiQ2xvc2VkIiwiY2FuY2VsVG9rZW4iLCJjYW5jZWwiLCJfcmVxIiwicmV0cnkiLCJDYW5jZWxUb2tlbiIsImRvQXhpb3NSZXF1ZXN0IiwiYmFzZVVSTCIsInB1YmxpY0VuZHBvaW50IiwiX3BvbGwiLCJDb25uZWN0ZWQiLCJpc0NhbmNlbCIsIkRpc2Nvbm5lY3RlZCIsIkNvbm5lY3RpbmciLCJfYnVpbGRXU1BheWxvYWQiLCJJbml0IiwiSElOVF9VUkwiLCJoaW50VXJsIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnQiLCJmZXRjaCIsImF3c1BvcCIsIlN0cmVhbUNsaWVudCIsIm5leHRSZXF1ZXN0QWJvcnRDb250cm9sbGVyIiwiZGV2VG9rZW4iLCJzZXRCYXNlVVJMIiwiaGludCIsImxvY2F0aW9uSGludCIsImxvY2F0aW9uSGludFVybCIsImxvY2F0aW9uSGludFRpbWVvdXQiLCJfZ2V0Q29ubmVjdGlvbklEIiwid3NDb25uZWN0aW9uIiwid3NGYWxsYmFjayIsImNvbm5lY3RVc2VyIiwidXNlclRva2VuT3JQcm92aWRlciIsInNldFVzZXJQcm9taXNlIiwiX2lzVXNpbmdTZXJ2ZXJBdXRoIiwibm9kZSIsImFsbG93U2VydmVyU2lkZUNvbm5lY3QiLCJzZXRUb2tlblByb21pc2UiLCJfc2V0VG9rZW4iLCJfc2V0VXNlciIsIndzUHJvbWlzZSIsIm9wZW5Db25uZWN0aW9uIiwicGVyc2lzdFVzZXJPbkNvbm5lY3Rpb25GYWlsdXJlIiwiY2xvc2VDb25uZWN0aW9uIiwiZGlzY29ubmVjdFVzZXIiLCJjbGVhbmluZ0ludGVydmFsUmVmIiwiY29ubmVjdGlvbklkUHJvbWlzZSIsIl9ub3JtYWxpemVEYXRlIiwiYmVmb3JlIiwiY29ubmVjdEd1ZXN0VXNlciIsImd1ZXN0VXNlckNyZWF0ZVByb21pc2UiLCJmaW5hbGx5IiwiYWNjZXNzX3Rva2VuIiwiY29ubmVjdEFub255bW91c1VzZXIiLCJfbG9nQXBpUmVxdWVzdCIsIl9sb2dBcGlSZXNwb25zZSIsIl9sb2dBcGlFcnJvciIsInJlcXVlc3RDb25maWciLCJfZW5yaWNoQXhpb3NPcHRpb25zIiwiYXhpb3NJbnN0YW5jZSIsInB1dCIsImhhbmRsZVJlc3BvbnNlIiwiY2xpZW50X3JlcXVlc3RfaWQiLCJlcnJvckZyb21SZXNwb25zZSIsInJlY2VpdmVkX2F0IiwibGlzdGVuZXIiLCJ3YXJtVXAiLCJfc2F5SGkiLCJkZWZhdWx0V1NUaW1lb3V0V2l0aEZhbGxiYWNrIiwiZGVmYXVsdFdTVGltZW91dCIsIm1vZGUiLCJzZXRVc2VyQWdlbnQiLCJhdXRob3JpemF0aW9uIiwiYXhpb3NSZXF1ZXN0Q29uZmlnIiwiY3JlYXRlQWJvcnRDb250cm9sbGVyRm9yTmV4dFJlcXVlc3QiLCJjcmVhdGVUb2tlbiIsImV4cCIsImNhbGxfY2lkcyIsImlucHV0T3B0aW9ucyIsIndpdGhDcmVkZW50aWFscyIsImh0dHBzQWdlbnQiLCJBZ2VudCIsImtlZXBBbGl2ZU1zZWNzIiwicHJvY2VzcyIsImVudiIsIlNUUkVBTV9MT0NBTF9URVNUX1JVTiIsIlNUUkVBTV9MT0NBTF9URVNUX0hPU1QiLCJTdHJlYW1WaWRlb0NsaWVudCIsImFwaUtleU9yQXJncyIsImV2ZW50SGFuZGxlcnNUb1VucmVnaXN0ZXIiLCJjb25uZWN0aW9uUHJvbWlzZSIsImRpc2Nvbm5lY3Rpb25Qcm9taXNlIiwid3JpdGVhYmxlU3RhdGVTdG9yZSIsImNyZWF0ZUd1ZXN0VXNlciIsInF1ZXJ5Q2FsbHMiLCJ3YXRjaCIsImVkZ2VzIiwiYWRkRGV2aWNlIiwicHVzaF9wcm92aWRlciIsInB1c2hfcHJvdmlkZXJfbmFtZSIsInZvaXBfdG9rZW4iLCJyZW1vdmVEZXZpY2UiLCJvblJpbmdpbmdDYWxsIiwicmVhZE9ubHlTdGF0ZVN0b3JlIiwiY2FsbElkIiwiYXBpS2V5IiwiY29ubmVjdFVzZXJSZXNwb25zZSIsIm1lIiwiY2FsbHNUb1JlV2F0Y2giLCJmaWx0ZXJfY29uZGl0aW9ucyIsIiRpbiIsImZpZWxkIiwibmV3Q2FsbCIsInByZXZDYWxsIiwidGhlQ2FsbCIsImFkZFZvaXBEZXZpY2UiLCJTdHJlYW1WaWRlb1NlcnZlckNsaWVudCIsImdldENhbGxUeXBlcyIsImdldENhbGxUeXBlIiwiY3JlYXRlQ2FsbFR5cGUiLCJkZWxldGVDYWxsVHlwZSIsInVwZGF0ZUNhbGxUeXBlIiwibGlzdEV4dGVybmFsU3RvcmFnZSIsImNyZWF0ZUV4dGVybmFsU3RvcmFnZSIsImRlbGV0ZUV4dGVybmFsU3RvcmFnZSIsInVwZGF0ZUV4dGVybmFsU3RvcmFnZSIsImNoZWNrRXh0ZXJuYWxTdG9yYWdlIiwiQnJvd3NlcnMiLCJSeFV0aWxzIiwiU2Z1RXZlbnRzIiwiU2Z1TW9kZWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-bindings/dist/index.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_LANGUAGE: () => (/* binding */ DEFAULT_LANGUAGE),\n/* harmony export */   DEFAULT_NAMESPACE: () => (/* binding */ DEFAULT_NAMESPACE),\n/* harmony export */   Restricted: () => (/* binding */ Restricted),\n/* harmony export */   StreamCallProvider: () => (/* binding */ StreamCallProvider),\n/* harmony export */   StreamI18n: () => (/* binding */ StreamI18n),\n/* harmony export */   StreamI18nProvider: () => (/* binding */ StreamI18nProvider),\n/* harmony export */   StreamVideoProvider: () => (/* binding */ StreamVideoProvider),\n/* harmony export */   defaultTranslationFunction: () => (/* binding */ defaultTranslationFunction),\n/* harmony export */   mapToRegistry: () => (/* binding */ mapToRegistry),\n/* harmony export */   useCall: () => (/* binding */ useCall),\n/* harmony export */   useCallStateHooks: () => (/* binding */ useCallStateHooks),\n/* harmony export */   useCalls: () => (/* binding */ useCalls),\n/* harmony export */   useConnectedUser: () => (/* binding */ useConnectedUser),\n/* harmony export */   useCreateI18n: () => (/* binding */ useCreateI18n),\n/* harmony export */   useI18n: () => (/* binding */ useI18n),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStreamVideoClient: () => (/* binding */ useStreamVideoClient)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! i18next */ \"(ssr)/./node_modules/i18next/dist/esm/i18next.js\");\n/* harmony import */ var _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stream-io/video-client */ \"(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\");\n\n\n\n\n\nconst StreamCallContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * A provider for the call object.\n */\nconst StreamCallProvider = (props) => {\n    const { call, children } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamCallContext.Provider, { value: call, children: children }));\n};\n/**\n * A hook to get the call object from the closest provider.\n */\nconst useCall = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamCallContext);\n};\n\nconst mapToRegistry = (translationsMap, namespace) => Object.entries(translationsMap).reduce((acc, [lng, translations]) => {\n    acc[lng] = { [namespace]: translations };\n    return acc;\n}, {});\n\nconst DEFAULT_LANGUAGE = 'en';\nconst DEFAULT_NAMESPACE = 'stream-video';\nconst DEFAULT_CONFIG = {\n    debug: false,\n    currentLanguage: DEFAULT_LANGUAGE,\n    fallbackLanguage: false,\n};\nconst DEFAULT_TRANSLATIONS_REGISTRY = mapToRegistry({}, DEFAULT_NAMESPACE);\nconst defaultTranslationFunction = (key) => key;\nclass StreamI18n {\n    /** Simple logger function */\n    constructor(options = {}) {\n        /** Translator function that converts the provided string into its equivalent in the current language. */\n        this.t = defaultTranslationFunction;\n        this.init = async () => {\n            try {\n                this.t = await this.i18nInstance.init();\n            }\n            catch (e) {\n                console.error(`Failed to initialize translations: ${JSON.stringify(e)}`);\n            }\n            return this;\n        };\n        this.changeLanguage = async (language, onChange) => {\n            if (!this._checkIsInitialized())\n                return;\n            // i18next detects the language, if none provided, but it is better\n            // to show this detection here explicitly\n            const browserLanguage = typeof window !== 'undefined' && window.navigator\n                ? window.navigator.language\n                : undefined;\n            await this.i18nInstance.changeLanguage(language || browserLanguage);\n            onChange?.(this.currentLanguage);\n        };\n        this.registerTranslationsForLanguage = ({ lng, translations, }) => {\n            if (!this._checkIsInitialized())\n                return;\n            this.i18nInstance.addResourceBundle(lng, DEFAULT_NAMESPACE, translations, true, true);\n        };\n        this._checkIsInitialized = () => {\n            if (!this.i18nInstance.isInitialized) {\n                console.warn('I18n instance is not initialized. Call yourStreamI18nInstance.init().');\n            }\n            return this.i18nInstance.isInitialized;\n        };\n        const { debug = DEFAULT_CONFIG.debug, currentLanguage = DEFAULT_CONFIG.currentLanguage, fallbackLanguage = DEFAULT_CONFIG.fallbackLanguage, translationsOverrides, } = options;\n        this.i18nInstance = i18next__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createInstance({\n            debug,\n            defaultNS: DEFAULT_NAMESPACE,\n            fallbackLng: fallbackLanguage,\n            interpolation: { escapeValue: false },\n            keySeparator: false,\n            lng: currentLanguage,\n            nsSeparator: false,\n            parseMissingKeyHandler: (key) => {\n                return key;\n            },\n            resources: DEFAULT_TRANSLATIONS_REGISTRY,\n        });\n        if (translationsOverrides) {\n            this.i18nInstance.on('initialized', () => {\n                Object.entries(translationsOverrides).forEach(([lng, translations]) => {\n                    this.registerTranslationsForLanguage({ lng, translations });\n                });\n            });\n        }\n    }\n    get currentLanguage() {\n        this._checkIsInitialized();\n        return this.i18nInstance.language;\n    }\n    get isInitialized() {\n        return this.i18nInstance.isInitialized;\n    }\n}\n\nconst StreamI18nContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    t: defaultTranslationFunction,\n});\nconst StreamI18nProvider = ({ children, ...createI18nParams }) => {\n    const { i18n, t } = useCreateI18n(createI18nParams);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamI18nContext.Provider, { value: { t, i18n }, children: children }));\n};\nconst useCreateI18n = ({ i18nInstance, language, fallbackLanguage, translationsOverrides, }) => {\n    const [i18n] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => i18nInstance ||\n        new StreamI18n({\n            currentLanguage: language,\n            fallbackLanguage,\n            translationsOverrides,\n        }));\n    const [t, setTranslationFn] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => defaultTranslationFunction);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const { isInitialized } = i18n;\n        if (!isInitialized) {\n            i18n.init().then((_i18n) => setTranslationFn(() => _i18n.i18nInstance.t));\n            return;\n        }\n        if (language && i18n?.currentLanguage !== language) {\n            i18n.changeLanguage(language).catch((err) => {\n                console.log('Error while changing language', err);\n            });\n        }\n    }, [i18n, i18nInstance, language, translationsOverrides]);\n    return { i18n, t };\n};\nconst useI18n = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamI18nContext);\n\nconst StreamVideoContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * StreamVideo is a provider component which should be used to wrap the entire application.\n * It provides the client object to all children components and initializes the i18n instance.\n *  @param PropsWithChildren<StreamVideoProps>\n *  @category Client State\n */\nconst StreamVideoProvider = ({ children, client, i18nInstance, language, translationsOverrides, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamVideoContext.Provider, { value: client, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StreamI18nProvider, { i18nInstance: i18nInstance, language: language, translationsOverrides: translationsOverrides, children: children }) }));\n};\n/**\n *\n * @returns\n *\n * @category Client State\n */\nconst useStreamVideoClient = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StreamVideoContext);\n};\n\n/**\n * Utility hook which provides the current value of the given observable.\n * @internal\n */\nconst useObservableValue = (observable$) => {\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(() => _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__.RxUtils.getCurrentValue(observable$));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        const subscription = observable$.subscribe(setValue);\n        return () => {\n            subscription.unsubscribe();\n        };\n    }, [observable$]);\n    return value;\n};\n\n/**\n * Utility hook, which provides the current call's state.\n *\n * @category Call State\n */\nconst useCallState = () => {\n    const call = useCall();\n    // return an empty and unlinked CallState object if there is no call in the provider\n    // this ensures that the hooks always return a value and many null checks can be avoided\n    if (!call) {\n        const message = 'You are using useCallState() outside a Call context. ' +\n            'Please wrap your component in <StreamCall /> and provide a \"call\" instance.';\n        console.warn(message);\n        return new _stream_io_video_client__WEBPACK_IMPORTED_MODULE_3__.CallState();\n    }\n    return call.state;\n};\n/**\n * Utility hook which provides information whether the current call is being recorded. It will return `true` if the call is being recorded.\n *\n * @category Call State\n */\nconst useIsCallRecordingInProgress = () => {\n    const { recording$ } = useCallState();\n    return useObservableValue(recording$);\n};\n/**\n * Utility hook which provides information whether the current call is broadcasting.\n *\n * @category Call State\n */\nconst useIsCallHLSBroadcastingInProgress = () => {\n    const { egress$ } = useCallState();\n    const egress = useObservableValue(egress$);\n    if (!egress)\n        return false;\n    return egress.broadcasting;\n};\n/**\n * Utility hook which provides information whether the current call is live.\n *\n * @category Call State\n */\nconst useIsCallLive = () => {\n    const { backstage$ } = useCallState();\n    const isBackstageOn = useObservableValue(backstage$);\n    return !isBackstageOn;\n};\n/**\n * Returns the list of blocked users in the current call.\n */\nconst useCallBlockedUserIds = () => {\n    const { blockedUserIds$ } = useCallState();\n    return useObservableValue(blockedUserIds$);\n};\n/**\n * Returns the timestamp when this call was created.\n */\nconst useCallCreatedAt = () => {\n    const { createdAt$ } = useCallState();\n    return useObservableValue(createdAt$);\n};\n/**\n * Returns the timestamp when this call was ended.\n */\nconst useCallEndedAt = () => {\n    const { endedAt$ } = useCallState();\n    return useObservableValue(endedAt$);\n};\n/**\n * Returns the timestamp telling when the call is scheduled to start.\n */\nconst useCallStartsAt = () => {\n    const { startsAt$ } = useCallState();\n    return useObservableValue(startsAt$);\n};\n/**\n * Returns the timestamp when this call was updated.\n */\nconst useCallUpdatedAt = () => {\n    const { updatedAt$ } = useCallState();\n    return useObservableValue(updatedAt$);\n};\n/**\n * Returns the information about the call's creator.\n */\nconst useCallCreatedBy = () => {\n    const { createdBy$ } = useCallState();\n    return useObservableValue(createdBy$);\n};\n/**\n * Returns the call's custom data.\n */\nconst useCallCustomData = () => {\n    const { custom$ } = useCallState();\n    return useObservableValue(custom$);\n};\n/**\n * Returns the call's Egress information.\n */\nconst useCallEgress = () => {\n    const { egress$ } = useCallState();\n    return useObservableValue(egress$);\n};\n/**\n * Returns the call's Ingress information.\n */\nconst useCallIngress = () => {\n    const { ingress$ } = useCallState();\n    return useObservableValue(ingress$);\n};\n/**\n * Returns the data for the current call session.\n */\nconst useCallSession = () => {\n    const { session$ } = useCallState();\n    return useObservableValue(session$);\n};\n/**\n * Returns the call's settings.\n */\nconst useCallSettings = () => {\n    const { settings$ } = useCallState();\n    return useObservableValue(settings$);\n};\n/**\n * Returns whether the call has transcribing enabled.\n */\nconst useIsCallTranscribingInProgress = () => {\n    const { transcribing$ } = useCallState();\n    return useObservableValue(transcribing$);\n};\n/**\n * Returns information about the user who has marked this call as ended.\n */\nconst useCallEndedBy = () => {\n    const { endedBy$ } = useCallState();\n    return useObservableValue(endedBy$);\n};\n/**\n * Utility hook which provides a boolean indicating whether there is\n * a participant in the current call which shares their screen.\n *\n * @category Call State\n */\nconst useHasOngoingScreenShare = () => {\n    const { hasOngoingScreenShare$ } = useCallState();\n    return useObservableValue(hasOngoingScreenShare$);\n};\n/**\n * Utility hook which provides the latest stats report of the current call.\n *\n * The latest stats report of the current call.\n * When stats gathering is enabled, this observable will emit a new value\n * at a regular (configurable) interval.\n *\n * Consumers of this observable can implement their own batching logic\n * in case they want to show historical stats data.\n *\n * @category Call State\n */\nconst useCallStatsReport = () => {\n    const { callStatsReport$ } = useCallState();\n    return useObservableValue(callStatsReport$);\n};\n/**\n * Utility hook which provides the dominant speaker of the current call.\n *\n * @category Call State\n */\nconst useDominantSpeaker = () => {\n    const { dominantSpeaker$ } = useCallState();\n    return useObservableValue(dominantSpeaker$);\n};\n/**\n * Utility hook which provides a list of call members.\n *\n * @category Call State\n */\nconst useCallMembers = () => {\n    const { members$ } = useCallState();\n    return useObservableValue(members$);\n};\n/**\n * Utility hook providing the current calling state of the call. For example, `RINGING` or `JOINED`.\n *\n * @category Call State\n */\nconst useCallCallingState = () => {\n    const { callingState$ } = useCallState();\n    return useObservableValue(callingState$);\n};\n/**\n * Utility hook providing the actual start time of the current session.\n * Useful for calculating the call duration.\n *\n * @category Call State\n */\nconst useCallStartedAt = () => {\n    const { startedAt$ } = useCallState();\n    return useObservableValue(startedAt$);\n};\n/**\n * A hook which provides a list of all participants that have joined an active call.\n *\n * @category Call State\n *\n * @param options.sortBy - A comparator function to sort the participants by.\n * Make sure to memoize output of the `combineComparators` function\n * (or keep it out of component's scope if possible) before passing it down to this property.\n */\nconst useParticipants = ({ sortBy, } = {}) => {\n    const { participants$ } = useCallState();\n    const participants = useObservableValue(participants$);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        if (sortBy) {\n            return [...participants].sort(sortBy);\n        }\n        return participants;\n    }, [participants, sortBy]);\n};\n/**\n * A hook which provides a StreamVideoLocalParticipant object.\n * It signals that I have joined a call.\n *\n * @category Call State\n */\nconst useLocalParticipant = () => {\n    const { localParticipant$ } = useCallState();\n    return useObservableValue(localParticipant$);\n};\n/**\n * A hook which provides a list of all other participants than me that have joined an active call.\n *\n * @category Call State\n */\nconst useRemoteParticipants = () => {\n    const { remoteParticipants$ } = useCallState();\n    return useObservableValue(remoteParticipants$);\n};\n/**\n * Returns the approximate participant count of the active call.\n * This includes the anonymous users as well, and it is computed on the server.\n *\n * @category Call State\n */\nconst useParticipantCount = () => {\n    const { participantCount$ } = useCallState();\n    return useObservableValue(participantCount$);\n};\n/**\n * Returns the approximate anonymous participant count of the active call.\n * The regular participants are not included in this count. It is computed on the server.\n *\n * @category Call State\n */\nconst useAnonymousParticipantCount = () => {\n    const { anonymousParticipantCount$ } = useCallState();\n    return useObservableValue(anonymousParticipantCount$);\n};\n/**\n * Returns the generated thumbnail of the current call, if enabled in settings.\n */\nconst useCallThumbnail = () => {\n    const { thumbnails$ } = useCallState();\n    return useObservableValue(thumbnails$);\n};\n/**\n * A hook which returns the local participant's own capabilities.\n */\nconst useOwnCapabilities = () => {\n    const { ownCapabilities$ } = useCallState();\n    return useObservableValue(ownCapabilities$);\n};\n/**\n * Hook that returns true if the local participant has all the given permissions.\n *\n * @param permissions the permissions to check.\n */\nconst useHasPermissions = (...permissions) => {\n    const capabilities = useOwnCapabilities();\n    return permissions.every((permission) => capabilities?.includes(permission));\n};\n/**\n * Returns the camera state of the current call.\n *\n * @category Camera Manager State\n *\n */\nconst useCameraState = () => {\n    const call = useCall();\n    const { camera } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => camera.listDevices(), [camera]);\n    const { state } = camera;\n    const status = useObservableValue(state.status$);\n    const direction = useObservableValue(state.direction$);\n    const mediaStream = useObservableValue(state.mediaStream$);\n    const selectedDevice = useObservableValue(state.selectedDevice$);\n    const devices = useObservableValue(devices$);\n    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);\n    const isMute = status !== 'enabled';\n    return {\n        camera,\n        status,\n        isEnabled: status === 'enabled',\n        direction,\n        mediaStream,\n        devices,\n        hasBrowserPermission,\n        selectedDevice,\n        isMute,\n    };\n};\n/**\n * Returns the microphone state of the current call.\n *\n * @category Microphone Manager State\n */\nconst useMicrophoneState = () => {\n    const call = useCall();\n    const { microphone } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => microphone.listDevices(), [microphone]);\n    const { state } = microphone;\n    const status = useObservableValue(state.status$);\n    const mediaStream = useObservableValue(state.mediaStream$);\n    const selectedDevice = useObservableValue(state.selectedDevice$);\n    const devices = useObservableValue(devices$);\n    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);\n    const isSpeakingWhileMuted = useObservableValue(state.speakingWhileMuted$);\n    const isMute = status !== 'enabled';\n    return {\n        microphone,\n        status,\n        isEnabled: status === 'enabled',\n        mediaStream,\n        devices,\n        selectedDevice,\n        hasBrowserPermission,\n        isSpeakingWhileMuted,\n        isMute,\n    };\n};\n/**\n * Returns the speaker state of the current call.\n */\nconst useSpeakerState = () => {\n    const call = useCall();\n    const { speaker } = call;\n    const devices$ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => speaker.listDevices(), [speaker]);\n    const devices = useObservableValue(devices$);\n    const selectedDevice = useObservableValue(speaker.state.selectedDevice$);\n    return {\n        speaker,\n        devices,\n        selectedDevice,\n        isDeviceSelectionSupported: speaker.state.isDeviceSelectionSupported,\n    };\n};\n/**\n * Returns the Screen Share state of the current call.\n */\nconst useScreenShareState = () => {\n    const call = useCall();\n    const { screenShare } = call;\n    const status = useObservableValue(screenShare.state.status$);\n    const mediaStream = useObservableValue(screenShare.state.mediaStream$);\n    const isMute = status !== 'enabled';\n    return {\n        screenShare,\n        mediaStream,\n        status,\n        isMute,\n    };\n};\n\nvar CallStateHooks = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    useAnonymousParticipantCount: useAnonymousParticipantCount,\n    useCallBlockedUserIds: useCallBlockedUserIds,\n    useCallCallingState: useCallCallingState,\n    useCallCreatedAt: useCallCreatedAt,\n    useCallCreatedBy: useCallCreatedBy,\n    useCallCustomData: useCallCustomData,\n    useCallEgress: useCallEgress,\n    useCallEndedAt: useCallEndedAt,\n    useCallEndedBy: useCallEndedBy,\n    useCallIngress: useCallIngress,\n    useCallMembers: useCallMembers,\n    useCallSession: useCallSession,\n    useCallSettings: useCallSettings,\n    useCallStartedAt: useCallStartedAt,\n    useCallStartsAt: useCallStartsAt,\n    useCallState: useCallState,\n    useCallStatsReport: useCallStatsReport,\n    useCallThumbnail: useCallThumbnail,\n    useCallUpdatedAt: useCallUpdatedAt,\n    useCameraState: useCameraState,\n    useDominantSpeaker: useDominantSpeaker,\n    useHasOngoingScreenShare: useHasOngoingScreenShare,\n    useHasPermissions: useHasPermissions,\n    useIsCallHLSBroadcastingInProgress: useIsCallHLSBroadcastingInProgress,\n    useIsCallLive: useIsCallLive,\n    useIsCallRecordingInProgress: useIsCallRecordingInProgress,\n    useIsCallTranscribingInProgress: useIsCallTranscribingInProgress,\n    useLocalParticipant: useLocalParticipant,\n    useMicrophoneState: useMicrophoneState,\n    useOwnCapabilities: useOwnCapabilities,\n    useParticipantCount: useParticipantCount,\n    useParticipants: useParticipants,\n    useRemoteParticipants: useRemoteParticipants,\n    useScreenShareState: useScreenShareState,\n    useSpeakerState: useSpeakerState\n});\n\n/**\n * Utility hook which provides access to client's state store.\n */\nconst useStore = () => {\n    const client = useStreamVideoClient();\n    if (!client) {\n        throw new Error(`StreamVideoClient isn't initialized or this hook is called outside of <StreamVideo> context.`);\n    }\n    return client.readOnlyStateStore;\n};\n/**\n * Utility hook which provides a list of all notifications about created calls.\n * In the ring call settings, these calls can be outgoing (I have called somebody)\n * or incoming (somebody has called me).\n *\n * @category Client State\n */\nconst useCalls = () => {\n    const { calls$ } = useStore();\n    return useObservableValue(calls$);\n};\n/**\n * Returns the current connected user.\n *\n * @category Client State\n */\nconst useConnectedUser = () => {\n    const { connectedUser$ } = useStore();\n    return useObservableValue(connectedUser$);\n};\n\n/**\n * A hook-alike function that exposes all call state hooks.\n *\n * @category Call State\n */\nconst useCallStateHooks = () => CallStateHooks;\n\nconst Restricted = ({ canRequestOnly, hasPermissionsOnly, requiredGrants, requireAll = true, children, }) => {\n    const call = useCall();\n    const { useCallSettings, useOwnCapabilities } = useCallStateHooks();\n    const ownCapabilities = useOwnCapabilities();\n    const settings = useCallSettings();\n    const hasPermissions = requiredGrants[requireAll ? 'every' : 'some']((capability) => ownCapabilities?.includes(capability));\n    if (hasPermissionsOnly)\n        return hasPermissions ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }) : null;\n    const canRequest = requiredGrants.some((capability) => call?.permissionsContext.canRequest(capability, settings));\n    if (canRequestOnly)\n        return canRequest ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children }) : null;\n    if (hasPermissions || canRequest)\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: children });\n    return null;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1iaW5kaW5ncy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtEO0FBQzhCO0FBQ2xEO0FBQytCOztBQUU3RCwwQkFBMEIsb0RBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZLHNEQUFHLCtCQUErQixpQ0FBaUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQVU7QUFDckI7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGtCQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2SkFBNko7QUFDN0ssNEJBQTRCLDhEQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQjtBQUM5RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixvREFBYTtBQUN2QztBQUNBLENBQUM7QUFDRCw4QkFBOEIsK0JBQStCO0FBQzdELFlBQVks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aW5nLy4vbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vdmlkZW8tcmVhY3QtYmluZGluZ3MvZGlzdC9pbmRleC5lcy5qcz8yNzg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGkxOG5leHQgZnJvbSAnaTE4bmV4dCc7XG5pbXBvcnQgeyBSeFV0aWxzLCBDYWxsU3RhdGUgfSBmcm9tICdAc3RyZWFtLWlvL3ZpZGVvLWNsaWVudCc7XG5cbmNvbnN0IFN0cmVhbUNhbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqXG4gKiBBIHByb3ZpZGVyIGZvciB0aGUgY2FsbCBvYmplY3QuXG4gKi9cbmNvbnN0IFN0cmVhbUNhbGxQcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2FsbCwgY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KFN0cmVhbUNhbGxDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjYWxsLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbi8qKlxuICogQSBob29rIHRvIGdldCB0aGUgY2FsbCBvYmplY3QgZnJvbSB0aGUgY2xvc2VzdCBwcm92aWRlci5cbiAqL1xuY29uc3QgdXNlQ2FsbCA9ICgpID0+IHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChTdHJlYW1DYWxsQ29udGV4dCk7XG59O1xuXG5jb25zdCBtYXBUb1JlZ2lzdHJ5ID0gKHRyYW5zbGF0aW9uc01hcCwgbmFtZXNwYWNlKSA9PiBPYmplY3QuZW50cmllcyh0cmFuc2xhdGlvbnNNYXApLnJlZHVjZSgoYWNjLCBbbG5nLCB0cmFuc2xhdGlvbnNdKSA9PiB7XG4gICAgYWNjW2xuZ10gPSB7IFtuYW1lc3BhY2VdOiB0cmFuc2xhdGlvbnMgfTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuXG5jb25zdCBERUZBVUxUX0xBTkdVQUdFID0gJ2VuJztcbmNvbnN0IERFRkFVTFRfTkFNRVNQQUNFID0gJ3N0cmVhbS12aWRlbyc7XG5jb25zdCBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgY3VycmVudExhbmd1YWdlOiBERUZBVUxUX0xBTkdVQUdFLFxuICAgIGZhbGxiYWNrTGFuZ3VhZ2U6IGZhbHNlLFxufTtcbmNvbnN0IERFRkFVTFRfVFJBTlNMQVRJT05TX1JFR0lTVFJZID0gbWFwVG9SZWdpc3RyeSh7fSwgREVGQVVMVF9OQU1FU1BBQ0UpO1xuY29uc3QgZGVmYXVsdFRyYW5zbGF0aW9uRnVuY3Rpb24gPSAoa2V5KSA9PiBrZXk7XG5jbGFzcyBTdHJlYW1JMThuIHtcbiAgICAvKiogU2ltcGxlIGxvZ2dlciBmdW5jdGlvbiAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvKiogVHJhbnNsYXRvciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHRoZSBwcm92aWRlZCBzdHJpbmcgaW50byBpdHMgZXF1aXZhbGVudCBpbiB0aGUgY3VycmVudCBsYW5ndWFnZS4gKi9cbiAgICAgICAgdGhpcy50ID0gZGVmYXVsdFRyYW5zbGF0aW9uRnVuY3Rpb247XG4gICAgICAgIHRoaXMuaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gYXdhaXQgdGhpcy5pMThuSW5zdGFuY2UuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSB0cmFuc2xhdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGFuZ2VMYW5ndWFnZSA9IGFzeW5jIChsYW5ndWFnZSwgb25DaGFuZ2UpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tJc0luaXRpYWxpemVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gaTE4bmV4dCBkZXRlY3RzIHRoZSBsYW5ndWFnZSwgaWYgbm9uZSBwcm92aWRlZCwgYnV0IGl0IGlzIGJldHRlclxuICAgICAgICAgICAgLy8gdG8gc2hvdyB0aGlzIGRldGVjdGlvbiBoZXJlIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXJMYW5ndWFnZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3JcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaTE4bkluc3RhbmNlLmNoYW5nZUxhbmd1YWdlKGxhbmd1YWdlIHx8IGJyb3dzZXJMYW5ndWFnZSk7XG4gICAgICAgICAgICBvbkNoYW5nZT8uKHRoaXMuY3VycmVudExhbmd1YWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclRyYW5zbGF0aW9uc0Zvckxhbmd1YWdlID0gKHsgbG5nLCB0cmFuc2xhdGlvbnMsIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tJc0luaXRpYWxpemVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pMThuSW5zdGFuY2UuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBERUZBVUxUX05BTUVTUEFDRSwgdHJhbnNsYXRpb25zLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2hlY2tJc0luaXRpYWxpemVkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmkxOG5JbnN0YW5jZS5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJMThuIGluc3RhbmNlIGlzIG5vdCBpbml0aWFsaXplZC4gQ2FsbCB5b3VyU3RyZWFtSTE4bkluc3RhbmNlLmluaXQoKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmkxOG5JbnN0YW5jZS5pc0luaXRpYWxpemVkO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGRlYnVnID0gREVGQVVMVF9DT05GSUcuZGVidWcsIGN1cnJlbnRMYW5ndWFnZSA9IERFRkFVTFRfQ09ORklHLmN1cnJlbnRMYW5ndWFnZSwgZmFsbGJhY2tMYW5ndWFnZSA9IERFRkFVTFRfQ09ORklHLmZhbGxiYWNrTGFuZ3VhZ2UsIHRyYW5zbGF0aW9uc092ZXJyaWRlcywgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaTE4bkluc3RhbmNlID0gaTE4bmV4dC5jcmVhdGVJbnN0YW5jZSh7XG4gICAgICAgICAgICBkZWJ1ZyxcbiAgICAgICAgICAgIGRlZmF1bHROUzogREVGQVVMVF9OQU1FU1BBQ0UsXG4gICAgICAgICAgICBmYWxsYmFja0xuZzogZmFsbGJhY2tMYW5ndWFnZSxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IHsgZXNjYXBlVmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICBrZXlTZXBhcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgbG5nOiBjdXJyZW50TGFuZ3VhZ2UsXG4gICAgICAgICAgICBuc1NlcGFyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZU1pc3NpbmdLZXlIYW5kbGVyOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvdXJjZXM6IERFRkFVTFRfVFJBTlNMQVRJT05TX1JFR0lTVFJZLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uc092ZXJyaWRlcykge1xuICAgICAgICAgICAgdGhpcy5pMThuSW5zdGFuY2Uub24oJ2luaXRpYWxpemVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRyYW5zbGF0aW9uc092ZXJyaWRlcykuZm9yRWFjaCgoW2xuZywgdHJhbnNsYXRpb25zXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVHJhbnNsYXRpb25zRm9yTGFuZ3VhZ2UoeyBsbmcsIHRyYW5zbGF0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50TGFuZ3VhZ2UoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrSXNJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pMThuSW5zdGFuY2UubGFuZ3VhZ2U7XG4gICAgfVxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pMThuSW5zdGFuY2UuaXNJbml0aWFsaXplZDtcbiAgICB9XG59XG5cbmNvbnN0IFN0cmVhbUkxOG5Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgdDogZGVmYXVsdFRyYW5zbGF0aW9uRnVuY3Rpb24sXG59KTtcbmNvbnN0IFN0cmVhbUkxOG5Qcm92aWRlciA9ICh7IGNoaWxkcmVuLCAuLi5jcmVhdGVJMThuUGFyYW1zIH0pID0+IHtcbiAgICBjb25zdCB7IGkxOG4sIHQgfSA9IHVzZUNyZWF0ZUkxOG4oY3JlYXRlSTE4blBhcmFtcyk7XG4gICAgcmV0dXJuIChqc3goU3RyZWFtSTE4bkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgdCwgaTE4biB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbmNvbnN0IHVzZUNyZWF0ZUkxOG4gPSAoeyBpMThuSW5zdGFuY2UsIGxhbmd1YWdlLCBmYWxsYmFja0xhbmd1YWdlLCB0cmFuc2xhdGlvbnNPdmVycmlkZXMsIH0pID0+IHtcbiAgICBjb25zdCBbaTE4bl0gPSB1c2VTdGF0ZSgoKSA9PiBpMThuSW5zdGFuY2UgfHxcbiAgICAgICAgbmV3IFN0cmVhbUkxOG4oe1xuICAgICAgICAgICAgY3VycmVudExhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgICAgIGZhbGxiYWNrTGFuZ3VhZ2UsXG4gICAgICAgICAgICB0cmFuc2xhdGlvbnNPdmVycmlkZXMsXG4gICAgICAgIH0pKTtcbiAgICBjb25zdCBbdCwgc2V0VHJhbnNsYXRpb25Gbl0gPSB1c2VTdGF0ZSgoKSA9PiBkZWZhdWx0VHJhbnNsYXRpb25GdW5jdGlvbik7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBpc0luaXRpYWxpemVkIH0gPSBpMThuO1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGkxOG4uaW5pdCgpLnRoZW4oKF9pMThuKSA9PiBzZXRUcmFuc2xhdGlvbkZuKCgpID0+IF9pMThuLmkxOG5JbnN0YW5jZS50KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhbmd1YWdlICYmIGkxOG4/LmN1cnJlbnRMYW5ndWFnZSAhPT0gbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGkxOG4uY2hhbmdlTGFuZ3VhZ2UobGFuZ3VhZ2UpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igd2hpbGUgY2hhbmdpbmcgbGFuZ3VhZ2UnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbaTE4biwgaTE4bkluc3RhbmNlLCBsYW5ndWFnZSwgdHJhbnNsYXRpb25zT3ZlcnJpZGVzXSk7XG4gICAgcmV0dXJuIHsgaTE4biwgdCB9O1xufTtcbmNvbnN0IHVzZUkxOG4gPSAoKSA9PiB1c2VDb250ZXh0KFN0cmVhbUkxOG5Db250ZXh0KTtcblxuY29uc3QgU3RyZWFtVmlkZW9Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuLyoqXG4gKiBTdHJlYW1WaWRlbyBpcyBhIHByb3ZpZGVyIGNvbXBvbmVudCB3aGljaCBzaG91bGQgYmUgdXNlZCB0byB3cmFwIHRoZSBlbnRpcmUgYXBwbGljYXRpb24uXG4gKiBJdCBwcm92aWRlcyB0aGUgY2xpZW50IG9iamVjdCB0byBhbGwgY2hpbGRyZW4gY29tcG9uZW50cyBhbmQgaW5pdGlhbGl6ZXMgdGhlIGkxOG4gaW5zdGFuY2UuXG4gKiAgQHBhcmFtIFByb3BzV2l0aENoaWxkcmVuPFN0cmVhbVZpZGVvUHJvcHM+XG4gKiAgQGNhdGVnb3J5IENsaWVudCBTdGF0ZVxuICovXG5jb25zdCBTdHJlYW1WaWRlb1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGNsaWVudCwgaTE4bkluc3RhbmNlLCBsYW5ndWFnZSwgdHJhbnNsYXRpb25zT3ZlcnJpZGVzLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goU3RyZWFtVmlkZW9Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjbGllbnQsIGNoaWxkcmVuOiBqc3goU3RyZWFtSTE4blByb3ZpZGVyLCB7IGkxOG5JbnN0YW5jZTogaTE4bkluc3RhbmNlLCBsYW5ndWFnZTogbGFuZ3VhZ2UsIHRyYW5zbGF0aW9uc092ZXJyaWRlczogdHJhbnNsYXRpb25zT3ZlcnJpZGVzLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufTtcbi8qKlxuICpcbiAqIEByZXR1cm5zXG4gKlxuICogQGNhdGVnb3J5IENsaWVudCBTdGF0ZVxuICovXG5jb25zdCB1c2VTdHJlYW1WaWRlb0NsaWVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChTdHJlYW1WaWRlb0NvbnRleHQpO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGdpdmVuIG9ic2VydmFibGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgdXNlT2JzZXJ2YWJsZVZhbHVlID0gKG9ic2VydmFibGUkKSA9PiB7XG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBSeFV0aWxzLmdldEN1cnJlbnRWYWx1ZShvYnNlcnZhYmxlJCkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUkLnN1YnNjcmliZShzZXRWYWx1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbb2JzZXJ2YWJsZSRdKTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgaG9vaywgd2hpY2ggcHJvdmlkZXMgdGhlIGN1cnJlbnQgY2FsbCdzIHN0YXRlLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIC8vIHJldHVybiBhbiBlbXB0eSBhbmQgdW5saW5rZWQgQ2FsbFN0YXRlIG9iamVjdCBpZiB0aGVyZSBpcyBubyBjYWxsIGluIHRoZSBwcm92aWRlclxuICAgIC8vIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBob29rcyBhbHdheXMgcmV0dXJuIGEgdmFsdWUgYW5kIG1hbnkgbnVsbCBjaGVja3MgY2FuIGJlIGF2b2lkZWRcbiAgICBpZiAoIWNhbGwpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdZb3UgYXJlIHVzaW5nIHVzZUNhbGxTdGF0ZSgpIG91dHNpZGUgYSBDYWxsIGNvbnRleHQuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB3cmFwIHlvdXIgY29tcG9uZW50IGluIDxTdHJlYW1DYWxsIC8+IGFuZCBwcm92aWRlIGEgXCJjYWxsXCIgaW5zdGFuY2UuJztcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxTdGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbC5zdGF0ZTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBpbmZvcm1hdGlvbiB3aGV0aGVyIHRoZSBjdXJyZW50IGNhbGwgaXMgYmVpbmcgcmVjb3JkZWQuIEl0IHdpbGwgcmV0dXJuIGB0cnVlYCBpZiB0aGUgY2FsbCBpcyBiZWluZyByZWNvcmRlZC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VJc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVjb3JkaW5nJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShyZWNvcmRpbmckKTtcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBpbmZvcm1hdGlvbiB3aGV0aGVyIHRoZSBjdXJyZW50IGNhbGwgaXMgYnJvYWRjYXN0aW5nLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUlzQ2FsbEhMU0Jyb2FkY2FzdGluZ0luUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBlZ3Jlc3MkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICBjb25zdCBlZ3Jlc3MgPSB1c2VPYnNlcnZhYmxlVmFsdWUoZWdyZXNzJCk7XG4gICAgaWYgKCFlZ3Jlc3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZWdyZXNzLmJyb2FkY2FzdGluZztcbn07XG4vKipcbiAqIFV0aWxpdHkgaG9vayB3aGljaCBwcm92aWRlcyBpbmZvcm1hdGlvbiB3aGV0aGVyIHRoZSBjdXJyZW50IGNhbGwgaXMgbGl2ZS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VJc0NhbGxMaXZlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYmFja3N0YWdlJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgY29uc3QgaXNCYWNrc3RhZ2VPbiA9IHVzZU9ic2VydmFibGVWYWx1ZShiYWNrc3RhZ2UkKTtcbiAgICByZXR1cm4gIWlzQmFja3N0YWdlT247XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGJsb2NrZWQgdXNlcnMgaW4gdGhlIGN1cnJlbnQgY2FsbC5cbiAqL1xuY29uc3QgdXNlQ2FsbEJsb2NrZWRVc2VySWRzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYmxvY2tlZFVzZXJJZHMkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGJsb2NrZWRVc2VySWRzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgd2hlbiB0aGlzIGNhbGwgd2FzIGNyZWF0ZWQuXG4gKi9cbmNvbnN0IHVzZUNhbGxDcmVhdGVkQXQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjcmVhdGVkQXQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGNyZWF0ZWRBdCQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgdGltZXN0YW1wIHdoZW4gdGhpcyBjYWxsIHdhcyBlbmRlZC5cbiAqL1xuY29uc3QgdXNlQ2FsbEVuZGVkQXQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBlbmRlZEF0JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShlbmRlZEF0JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgdGVsbGluZyB3aGVuIHRoZSBjYWxsIGlzIHNjaGVkdWxlZCB0byBzdGFydC5cbiAqL1xuY29uc3QgdXNlQ2FsbFN0YXJ0c0F0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RhcnRzQXQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXJ0c0F0JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgd2hlbiB0aGlzIGNhbGwgd2FzIHVwZGF0ZWQuXG4gKi9cbmNvbnN0IHVzZUNhbGxVcGRhdGVkQXQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1cGRhdGVkQXQkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHVwZGF0ZWRBdCQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNhbGwncyBjcmVhdG9yLlxuICovXG5jb25zdCB1c2VDYWxsQ3JlYXRlZEJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgY3JlYXRlZEJ5JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShjcmVhdGVkQnkkKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGNhbGwncyBjdXN0b20gZGF0YS5cbiAqL1xuY29uc3QgdXNlQ2FsbEN1c3RvbURhdGEgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBjdXN0b20kIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGN1c3RvbSQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2FsbCdzIEVncmVzcyBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgdXNlQ2FsbEVncmVzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGVncmVzcyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoZWdyZXNzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYWxsJ3MgSW5ncmVzcyBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgdXNlQ2FsbEluZ3Jlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBpbmdyZXNzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShpbmdyZXNzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgY3VycmVudCBjYWxsIHNlc3Npb24uXG4gKi9cbmNvbnN0IHVzZUNhbGxTZXNzaW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc2Vzc2lvbiQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoc2Vzc2lvbiQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2FsbCdzIHNldHRpbmdzLlxuICovXG5jb25zdCB1c2VDYWxsU2V0dGluZ3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXR0aW5ncyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoc2V0dGluZ3MkKTtcbn07XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgY2FsbCBoYXMgdHJhbnNjcmliaW5nIGVuYWJsZWQuXG4gKi9cbmNvbnN0IHVzZUlzQ2FsbFRyYW5zY3JpYmluZ0luUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0cmFuc2NyaWJpbmckIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHRyYW5zY3JpYmluZyQpO1xufTtcbi8qKlxuICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdXNlciB3aG8gaGFzIG1hcmtlZCB0aGlzIGNhbGwgYXMgZW5kZWQuXG4gKi9cbmNvbnN0IHVzZUNhbGxFbmRlZEJ5ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZW5kZWRCeSQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoZW5kZWRCeSQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgaXNcbiAqIGEgcGFydGljaXBhbnQgaW4gdGhlIGN1cnJlbnQgY2FsbCB3aGljaCBzaGFyZXMgdGhlaXIgc2NyZWVuLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUhhc09uZ29pbmdTY3JlZW5TaGFyZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhhc09uZ29pbmdTY3JlZW5TaGFyZSQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoaGFzT25nb2luZ1NjcmVlblNoYXJlJCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgdGhlIGxhdGVzdCBzdGF0cyByZXBvcnQgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqXG4gKiBUaGUgbGF0ZXN0IHN0YXRzIHJlcG9ydCBvZiB0aGUgY3VycmVudCBjYWxsLlxuICogV2hlbiBzdGF0cyBnYXRoZXJpbmcgaXMgZW5hYmxlZCwgdGhpcyBvYnNlcnZhYmxlIHdpbGwgZW1pdCBhIG5ldyB2YWx1ZVxuICogYXQgYSByZWd1bGFyIChjb25maWd1cmFibGUpIGludGVydmFsLlxuICpcbiAqIENvbnN1bWVycyBvZiB0aGlzIG9ic2VydmFibGUgY2FuIGltcGxlbWVudCB0aGVpciBvd24gYmF0Y2hpbmcgbG9naWNcbiAqIGluIGNhc2UgdGhleSB3YW50IHRvIHNob3cgaGlzdG9yaWNhbCBzdGF0cyBkYXRhLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxTdGF0c1JlcG9ydCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNhbGxTdGF0c1JlcG9ydCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY2FsbFN0YXRzUmVwb3J0JCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgdGhlIGRvbWluYW50IHNwZWFrZXIgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VEb21pbmFudFNwZWFrZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBkb21pbmFudFNwZWFrZXIkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGRvbWluYW50U3BlYWtlciQpO1xufTtcbi8qKlxuICogVXRpbGl0eSBob29rIHdoaWNoIHByb3ZpZGVzIGEgbGlzdCBvZiBjYWxsIG1lbWJlcnMuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ2FsbE1lbWJlcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBtZW1iZXJzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShtZW1iZXJzJCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgcHJvdmlkaW5nIHRoZSBjdXJyZW50IGNhbGxpbmcgc3RhdGUgb2YgdGhlIGNhbGwuIEZvciBleGFtcGxlLCBgUklOR0lOR2Agb3IgYEpPSU5FRGAuXG4gKlxuICogQGNhdGVnb3J5IENhbGwgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ2FsbENhbGxpbmdTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNhbGxpbmdTdGF0ZSQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY2FsbGluZ1N0YXRlJCk7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgcHJvdmlkaW5nIHRoZSBhY3R1YWwgc3RhcnQgdGltZSBvZiB0aGUgY3VycmVudCBzZXNzaW9uLlxuICogVXNlZnVsIGZvciBjYWxjdWxhdGluZyB0aGUgY2FsbCBkdXJhdGlvbi5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxsU3RhcnRlZEF0ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RhcnRlZEF0JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShzdGFydGVkQXQkKTtcbn07XG4vKipcbiAqIEEgaG9vayB3aGljaCBwcm92aWRlcyBhIGxpc3Qgb2YgYWxsIHBhcnRpY2lwYW50cyB0aGF0IGhhdmUgam9pbmVkIGFuIGFjdGl2ZSBjYWxsLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKlxuICogQHBhcmFtIG9wdGlvbnMuc29ydEJ5IC0gQSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIHNvcnQgdGhlIHBhcnRpY2lwYW50cyBieS5cbiAqIE1ha2Ugc3VyZSB0byBtZW1vaXplIG91dHB1dCBvZiB0aGUgYGNvbWJpbmVDb21wYXJhdG9yc2AgZnVuY3Rpb25cbiAqIChvciBrZWVwIGl0IG91dCBvZiBjb21wb25lbnQncyBzY29wZSBpZiBwb3NzaWJsZSkgYmVmb3JlIHBhc3NpbmcgaXQgZG93biB0byB0aGlzIHByb3BlcnR5LlxuICovXG5jb25zdCB1c2VQYXJ0aWNpcGFudHMgPSAoeyBzb3J0QnksIH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnRzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHBhcnRpY2lwYW50cyQpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNvcnRCeSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5wYXJ0aWNpcGFudHNdLnNvcnQoc29ydEJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydGljaXBhbnRzO1xuICAgIH0sIFtwYXJ0aWNpcGFudHMsIHNvcnRCeV0pO1xufTtcbi8qKlxuICogQSBob29rIHdoaWNoIHByb3ZpZGVzIGEgU3RyZWFtVmlkZW9Mb2NhbFBhcnRpY2lwYW50IG9iamVjdC5cbiAqIEl0IHNpZ25hbHMgdGhhdCBJIGhhdmUgam9pbmVkIGEgY2FsbC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VMb2NhbFBhcnRpY2lwYW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgbG9jYWxQYXJ0aWNpcGFudCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUobG9jYWxQYXJ0aWNpcGFudCQpO1xufTtcbi8qKlxuICogQSBob29rIHdoaWNoIHByb3ZpZGVzIGEgbGlzdCBvZiBhbGwgb3RoZXIgcGFydGljaXBhbnRzIHRoYW4gbWUgdGhhdCBoYXZlIGpvaW5lZCBhbiBhY3RpdmUgY2FsbC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VSZW1vdGVQYXJ0aWNpcGFudHMgPSAoKSA9PiB7XG4gICAgY29uc3QgeyByZW1vdGVQYXJ0aWNpcGFudHMkIH0gPSB1c2VDYWxsU3RhdGUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKHJlbW90ZVBhcnRpY2lwYW50cyQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgcGFydGljaXBhbnQgY291bnQgb2YgdGhlIGFjdGl2ZSBjYWxsLlxuICogVGhpcyBpbmNsdWRlcyB0aGUgYW5vbnltb3VzIHVzZXJzIGFzIHdlbGwsIGFuZCBpdCBpcyBjb21wdXRlZCBvbiB0aGUgc2VydmVyLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZVBhcnRpY2lwYW50Q291bnQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBwYXJ0aWNpcGFudENvdW50JCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShwYXJ0aWNpcGFudENvdW50JCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcHByb3hpbWF0ZSBhbm9ueW1vdXMgcGFydGljaXBhbnQgY291bnQgb2YgdGhlIGFjdGl2ZSBjYWxsLlxuICogVGhlIHJlZ3VsYXIgcGFydGljaXBhbnRzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBjb3VudC4gSXQgaXMgY29tcHV0ZWQgb24gdGhlIHNlcnZlci5cbiAqXG4gKiBAY2F0ZWdvcnkgQ2FsbCBTdGF0ZVxuICovXG5jb25zdCB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCQpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIHRodW1ibmFpbCBvZiB0aGUgY3VycmVudCBjYWxsLCBpZiBlbmFibGVkIGluIHNldHRpbmdzLlxuICovXG5jb25zdCB1c2VDYWxsVGh1bWJuYWlsID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdGh1bWJuYWlscyQgfSA9IHVzZUNhbGxTdGF0ZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUodGh1bWJuYWlscyQpO1xufTtcbi8qKlxuICogQSBob29rIHdoaWNoIHJldHVybnMgdGhlIGxvY2FsIHBhcnRpY2lwYW50J3Mgb3duIGNhcGFiaWxpdGllcy5cbiAqL1xuY29uc3QgdXNlT3duQ2FwYWJpbGl0aWVzID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgb3duQ2FwYWJpbGl0aWVzJCB9ID0gdXNlQ2FsbFN0YXRlKCk7XG4gICAgcmV0dXJuIHVzZU9ic2VydmFibGVWYWx1ZShvd25DYXBhYmlsaXRpZXMkKTtcbn07XG4vKipcbiAqIEhvb2sgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGxvY2FsIHBhcnRpY2lwYW50IGhhcyBhbGwgdGhlIGdpdmVuIHBlcm1pc3Npb25zLlxuICpcbiAqIEBwYXJhbSBwZXJtaXNzaW9ucyB0aGUgcGVybWlzc2lvbnMgdG8gY2hlY2suXG4gKi9cbmNvbnN0IHVzZUhhc1Blcm1pc3Npb25zID0gKC4uLnBlcm1pc3Npb25zKSA9PiB7XG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdXNlT3duQ2FwYWJpbGl0aWVzKCk7XG4gICAgcmV0dXJuIHBlcm1pc3Npb25zLmV2ZXJ5KChwZXJtaXNzaW9uKSA9PiBjYXBhYmlsaXRpZXM/LmluY2x1ZGVzKHBlcm1pc3Npb24pKTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGNhbWVyYSBzdGF0ZSBvZiB0aGUgY3VycmVudCBjYWxsLlxuICpcbiAqIEBjYXRlZ29yeSBDYW1lcmEgTWFuYWdlciBTdGF0ZVxuICpcbiAqL1xuY29uc3QgdXNlQ2FtZXJhU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IGNhbWVyYSB9ID0gY2FsbDtcbiAgICBjb25zdCBkZXZpY2VzJCA9IHVzZU1lbW8oKCkgPT4gY2FtZXJhLmxpc3REZXZpY2VzKCksIFtjYW1lcmFdKTtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBjYW1lcmE7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLnN0YXR1cyQpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5kaXJlY3Rpb24kKTtcbiAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5tZWRpYVN0cmVhbSQpO1xuICAgIGNvbnN0IHNlbGVjdGVkRGV2aWNlID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLnNlbGVjdGVkRGV2aWNlJCk7XG4gICAgY29uc3QgZGV2aWNlcyA9IHVzZU9ic2VydmFibGVWYWx1ZShkZXZpY2VzJCk7XG4gICAgY29uc3QgaGFzQnJvd3NlclBlcm1pc3Npb24gPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuaGFzQnJvd3NlclBlcm1pc3Npb24kKTtcbiAgICBjb25zdCBpc011dGUgPSBzdGF0dXMgIT09ICdlbmFibGVkJztcbiAgICByZXR1cm4ge1xuICAgICAgICBjYW1lcmEsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgaXNFbmFibGVkOiBzdGF0dXMgPT09ICdlbmFibGVkJyxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBtZWRpYVN0cmVhbSxcbiAgICAgICAgZGV2aWNlcyxcbiAgICAgICAgaGFzQnJvd3NlclBlcm1pc3Npb24sXG4gICAgICAgIHNlbGVjdGVkRGV2aWNlLFxuICAgICAgICBpc011dGUsXG4gICAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIG1pY3JvcGhvbmUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqXG4gKiBAY2F0ZWdvcnkgTWljcm9waG9uZSBNYW5hZ2VyIFN0YXRlXG4gKi9cbmNvbnN0IHVzZU1pY3JvcGhvbmVTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgbWljcm9waG9uZSB9ID0gY2FsbDtcbiAgICBjb25zdCBkZXZpY2VzJCA9IHVzZU1lbW8oKCkgPT4gbWljcm9waG9uZS5saXN0RGV2aWNlcygpLCBbbWljcm9waG9uZV0pO1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IG1pY3JvcGhvbmU7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLnN0YXR1cyQpO1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLm1lZGlhU3RyZWFtJCk7XG4gICAgY29uc3Qgc2VsZWN0ZWREZXZpY2UgPSB1c2VPYnNlcnZhYmxlVmFsdWUoc3RhdGUuc2VsZWN0ZWREZXZpY2UkKTtcbiAgICBjb25zdCBkZXZpY2VzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKGRldmljZXMkKTtcbiAgICBjb25zdCBoYXNCcm93c2VyUGVybWlzc2lvbiA9IHVzZU9ic2VydmFibGVWYWx1ZShzdGF0ZS5oYXNCcm93c2VyUGVybWlzc2lvbiQpO1xuICAgIGNvbnN0IGlzU3BlYWtpbmdXaGlsZU11dGVkID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHN0YXRlLnNwZWFraW5nV2hpbGVNdXRlZCQpO1xuICAgIGNvbnN0IGlzTXV0ZSA9IHN0YXR1cyAhPT0gJ2VuYWJsZWQnO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pY3JvcGhvbmUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgaXNFbmFibGVkOiBzdGF0dXMgPT09ICdlbmFibGVkJyxcbiAgICAgICAgbWVkaWFTdHJlYW0sXG4gICAgICAgIGRldmljZXMsXG4gICAgICAgIHNlbGVjdGVkRGV2aWNlLFxuICAgICAgICBoYXNCcm93c2VyUGVybWlzc2lvbixcbiAgICAgICAgaXNTcGVha2luZ1doaWxlTXV0ZWQsXG4gICAgICAgIGlzTXV0ZSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3BlYWtlciBzdGF0ZSBvZiB0aGUgY3VycmVudCBjYWxsLlxuICovXG5jb25zdCB1c2VTcGVha2VyU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHNwZWFrZXIgfSA9IGNhbGw7XG4gICAgY29uc3QgZGV2aWNlcyQgPSB1c2VNZW1vKCgpID0+IHNwZWFrZXIubGlzdERldmljZXMoKSwgW3NwZWFrZXJdKTtcbiAgICBjb25zdCBkZXZpY2VzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKGRldmljZXMkKTtcbiAgICBjb25zdCBzZWxlY3RlZERldmljZSA9IHVzZU9ic2VydmFibGVWYWx1ZShzcGVha2VyLnN0YXRlLnNlbGVjdGVkRGV2aWNlJCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3BlYWtlcixcbiAgICAgICAgZGV2aWNlcyxcbiAgICAgICAgc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgIGlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkOiBzcGVha2VyLnN0YXRlLmlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkLFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBTY3JlZW4gU2hhcmUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgY2FsbC5cbiAqL1xuY29uc3QgdXNlU2NyZWVuU2hhcmVTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgc2NyZWVuU2hhcmUgfSA9IGNhbGw7XG4gICAgY29uc3Qgc3RhdHVzID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHNjcmVlblNoYXJlLnN0YXRlLnN0YXR1cyQpO1xuICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gdXNlT2JzZXJ2YWJsZVZhbHVlKHNjcmVlblNoYXJlLnN0YXRlLm1lZGlhU3RyZWFtJCk7XG4gICAgY29uc3QgaXNNdXRlID0gc3RhdHVzICE9PSAnZW5hYmxlZCc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuU2hhcmUsXG4gICAgICAgIG1lZGlhU3RyZWFtLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGlzTXV0ZSxcbiAgICB9O1xufTtcblxudmFyIENhbGxTdGF0ZUhvb2tzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50OiB1c2VBbm9ueW1vdXNQYXJ0aWNpcGFudENvdW50LFxuICAgIHVzZUNhbGxCbG9ja2VkVXNlcklkczogdXNlQ2FsbEJsb2NrZWRVc2VySWRzLFxuICAgIHVzZUNhbGxDYWxsaW5nU3RhdGU6IHVzZUNhbGxDYWxsaW5nU3RhdGUsXG4gICAgdXNlQ2FsbENyZWF0ZWRBdDogdXNlQ2FsbENyZWF0ZWRBdCxcbiAgICB1c2VDYWxsQ3JlYXRlZEJ5OiB1c2VDYWxsQ3JlYXRlZEJ5LFxuICAgIHVzZUNhbGxDdXN0b21EYXRhOiB1c2VDYWxsQ3VzdG9tRGF0YSxcbiAgICB1c2VDYWxsRWdyZXNzOiB1c2VDYWxsRWdyZXNzLFxuICAgIHVzZUNhbGxFbmRlZEF0OiB1c2VDYWxsRW5kZWRBdCxcbiAgICB1c2VDYWxsRW5kZWRCeTogdXNlQ2FsbEVuZGVkQnksXG4gICAgdXNlQ2FsbEluZ3Jlc3M6IHVzZUNhbGxJbmdyZXNzLFxuICAgIHVzZUNhbGxNZW1iZXJzOiB1c2VDYWxsTWVtYmVycyxcbiAgICB1c2VDYWxsU2Vzc2lvbjogdXNlQ2FsbFNlc3Npb24sXG4gICAgdXNlQ2FsbFNldHRpbmdzOiB1c2VDYWxsU2V0dGluZ3MsXG4gICAgdXNlQ2FsbFN0YXJ0ZWRBdDogdXNlQ2FsbFN0YXJ0ZWRBdCxcbiAgICB1c2VDYWxsU3RhcnRzQXQ6IHVzZUNhbGxTdGFydHNBdCxcbiAgICB1c2VDYWxsU3RhdGU6IHVzZUNhbGxTdGF0ZSxcbiAgICB1c2VDYWxsU3RhdHNSZXBvcnQ6IHVzZUNhbGxTdGF0c1JlcG9ydCxcbiAgICB1c2VDYWxsVGh1bWJuYWlsOiB1c2VDYWxsVGh1bWJuYWlsLFxuICAgIHVzZUNhbGxVcGRhdGVkQXQ6IHVzZUNhbGxVcGRhdGVkQXQsXG4gICAgdXNlQ2FtZXJhU3RhdGU6IHVzZUNhbWVyYVN0YXRlLFxuICAgIHVzZURvbWluYW50U3BlYWtlcjogdXNlRG9taW5hbnRTcGVha2VyLFxuICAgIHVzZUhhc09uZ29pbmdTY3JlZW5TaGFyZTogdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlLFxuICAgIHVzZUhhc1Blcm1pc3Npb25zOiB1c2VIYXNQZXJtaXNzaW9ucyxcbiAgICB1c2VJc0NhbGxITFNCcm9hZGNhc3RpbmdJblByb2dyZXNzOiB1c2VJc0NhbGxITFNCcm9hZGNhc3RpbmdJblByb2dyZXNzLFxuICAgIHVzZUlzQ2FsbExpdmU6IHVzZUlzQ2FsbExpdmUsXG4gICAgdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzczogdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyxcbiAgICB1c2VJc0NhbGxUcmFuc2NyaWJpbmdJblByb2dyZXNzOiB1c2VJc0NhbGxUcmFuc2NyaWJpbmdJblByb2dyZXNzLFxuICAgIHVzZUxvY2FsUGFydGljaXBhbnQ6IHVzZUxvY2FsUGFydGljaXBhbnQsXG4gICAgdXNlTWljcm9waG9uZVN0YXRlOiB1c2VNaWNyb3Bob25lU3RhdGUsXG4gICAgdXNlT3duQ2FwYWJpbGl0aWVzOiB1c2VPd25DYXBhYmlsaXRpZXMsXG4gICAgdXNlUGFydGljaXBhbnRDb3VudDogdXNlUGFydGljaXBhbnRDb3VudCxcbiAgICB1c2VQYXJ0aWNpcGFudHM6IHVzZVBhcnRpY2lwYW50cyxcbiAgICB1c2VSZW1vdGVQYXJ0aWNpcGFudHM6IHVzZVJlbW90ZVBhcnRpY2lwYW50cyxcbiAgICB1c2VTY3JlZW5TaGFyZVN0YXRlOiB1c2VTY3JlZW5TaGFyZVN0YXRlLFxuICAgIHVzZVNwZWFrZXJTdGF0ZTogdXNlU3BlYWtlclN0YXRlXG59KTtcblxuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgYWNjZXNzIHRvIGNsaWVudCdzIHN0YXRlIHN0b3JlLlxuICovXG5jb25zdCB1c2VTdG9yZSA9ICgpID0+IHtcbiAgICBjb25zdCBjbGllbnQgPSB1c2VTdHJlYW1WaWRlb0NsaWVudCgpO1xuICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyZWFtVmlkZW9DbGllbnQgaXNuJ3QgaW5pdGlhbGl6ZWQgb3IgdGhpcyBob29rIGlzIGNhbGxlZCBvdXRzaWRlIG9mIDxTdHJlYW1WaWRlbz4gY29udGV4dC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudC5yZWFkT25seVN0YXRlU3RvcmU7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGhvb2sgd2hpY2ggcHJvdmlkZXMgYSBsaXN0IG9mIGFsbCBub3RpZmljYXRpb25zIGFib3V0IGNyZWF0ZWQgY2FsbHMuXG4gKiBJbiB0aGUgcmluZyBjYWxsIHNldHRpbmdzLCB0aGVzZSBjYWxscyBjYW4gYmUgb3V0Z29pbmcgKEkgaGF2ZSBjYWxsZWQgc29tZWJvZHkpXG4gKiBvciBpbmNvbWluZyAoc29tZWJvZHkgaGFzIGNhbGxlZCBtZSkuXG4gKlxuICogQGNhdGVnb3J5IENsaWVudCBTdGF0ZVxuICovXG5jb25zdCB1c2VDYWxscyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNhbGxzJCB9ID0gdXNlU3RvcmUoKTtcbiAgICByZXR1cm4gdXNlT2JzZXJ2YWJsZVZhbHVlKGNhbGxzJCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3RlZCB1c2VyLlxuICpcbiAqIEBjYXRlZ29yeSBDbGllbnQgU3RhdGVcbiAqL1xuY29uc3QgdXNlQ29ubmVjdGVkVXNlciA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbm5lY3RlZFVzZXIkIH0gPSB1c2VTdG9yZSgpO1xuICAgIHJldHVybiB1c2VPYnNlcnZhYmxlVmFsdWUoY29ubmVjdGVkVXNlciQpO1xufTtcblxuLyoqXG4gKiBBIGhvb2stYWxpa2UgZnVuY3Rpb24gdGhhdCBleHBvc2VzIGFsbCBjYWxsIHN0YXRlIGhvb2tzLlxuICpcbiAqIEBjYXRlZ29yeSBDYWxsIFN0YXRlXG4gKi9cbmNvbnN0IHVzZUNhbGxTdGF0ZUhvb2tzID0gKCkgPT4gQ2FsbFN0YXRlSG9va3M7XG5cbmNvbnN0IFJlc3RyaWN0ZWQgPSAoeyBjYW5SZXF1ZXN0T25seSwgaGFzUGVybWlzc2lvbnNPbmx5LCByZXF1aXJlZEdyYW50cywgcmVxdWlyZUFsbCA9IHRydWUsIGNoaWxkcmVuLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxTZXR0aW5ncywgdXNlT3duQ2FwYWJpbGl0aWVzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IG93bkNhcGFiaWxpdGllcyA9IHVzZU93bkNhcGFiaWxpdGllcygpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gdXNlQ2FsbFNldHRpbmdzKCk7XG4gICAgY29uc3QgaGFzUGVybWlzc2lvbnMgPSByZXF1aXJlZEdyYW50c1tyZXF1aXJlQWxsID8gJ2V2ZXJ5JyA6ICdzb21lJ10oKGNhcGFiaWxpdHkpID0+IG93bkNhcGFiaWxpdGllcz8uaW5jbHVkZXMoY2FwYWJpbGl0eSkpO1xuICAgIGlmIChoYXNQZXJtaXNzaW9uc09ubHkpXG4gICAgICAgIHJldHVybiBoYXNQZXJtaXNzaW9ucyA/IGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgOiBudWxsO1xuICAgIGNvbnN0IGNhblJlcXVlc3QgPSByZXF1aXJlZEdyYW50cy5zb21lKChjYXBhYmlsaXR5KSA9PiBjYWxsPy5wZXJtaXNzaW9uc0NvbnRleHQuY2FuUmVxdWVzdChjYXBhYmlsaXR5LCBzZXR0aW5ncykpO1xuICAgIGlmIChjYW5SZXF1ZXN0T25seSlcbiAgICAgICAgcmV0dXJuIGNhblJlcXVlc3QgPyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIDogbnVsbDtcbiAgICBpZiAoaGFzUGVybWlzc2lvbnMgfHwgY2FuUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgeyBERUZBVUxUX0xBTkdVQUdFLCBERUZBVUxUX05BTUVTUEFDRSwgUmVzdHJpY3RlZCwgU3RyZWFtQ2FsbFByb3ZpZGVyLCBTdHJlYW1JMThuLCBTdHJlYW1JMThuUHJvdmlkZXIsIFN0cmVhbVZpZGVvUHJvdmlkZXIsIGRlZmF1bHRUcmFuc2xhdGlvbkZ1bmN0aW9uLCBtYXBUb1JlZ2lzdHJ5LCB1c2VDYWxsLCB1c2VDYWxsU3RhdGVIb29rcywgdXNlQ2FsbHMsIHVzZUNvbm5lY3RlZFVzZXIsIHVzZUNyZWF0ZUkxOG4sIHVzZUkxOG4sIHVzZVN0b3JlLCB1c2VTdHJlYW1WaWRlb0NsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stream-io/video-react-sdk/dist/index.es.js":
/*!******************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-sdk/dist/index.es.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AcceptCallButton: () => (/* binding */ AcceptCallButton),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AudioSettingsDefaultDeviceEnum),\n/* harmony export */   AudioSettingsRequestDefaultDeviceEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   Avatar: () => (/* binding */ Avatar),\n/* harmony export */   AvatarFallback: () => (/* binding */ AvatarFallback),\n/* harmony export */   AxiosError: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.AxiosError),\n/* harmony export */   BaseVideo: () => (/* binding */ BaseVideo),\n/* harmony export */   Browsers: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers),\n/* harmony export */   Call: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Call),\n/* harmony export */   CallControls: () => (/* binding */ CallControls),\n/* harmony export */   CallParticipantListing: () => (/* binding */ CallParticipantListing),\n/* harmony export */   CallParticipantListingItem: () => (/* binding */ CallParticipantListingItem),\n/* harmony export */   CallParticipantsList: () => (/* binding */ CallParticipantsList),\n/* harmony export */   CallPreview: () => (/* binding */ CallPreview),\n/* harmony export */   CallRecordingList: () => (/* binding */ CallRecordingList),\n/* harmony export */   CallRecordingListHeader: () => (/* binding */ CallRecordingListHeader),\n/* harmony export */   CallRecordingListItem: () => (/* binding */ CallRecordingListItem),\n/* harmony export */   CallState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallState),\n/* harmony export */   CallStats: () => (/* binding */ CallStats),\n/* harmony export */   CallStatsButton: () => (/* binding */ CallStatsButton),\n/* harmony export */   CallStatsLatencyChart: () => (/* binding */ CallStatsLatencyChart),\n/* harmony export */   CallType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallType),\n/* harmony export */   CallTypes: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallTypes),\n/* harmony export */   CallingState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState),\n/* harmony export */   CameraManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CameraManager),\n/* harmony export */   CameraManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CameraManagerState),\n/* harmony export */   CancelCallButton: () => (/* binding */ CancelCallButton),\n/* harmony export */   CancelCallConfirmButton: () => (/* binding */ CancelCallConfirmButton),\n/* harmony export */   CompositeButton: () => (/* binding */ CompositeButton),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CreateDeviceRequestPushProviderEnum),\n/* harmony export */   DEFAULT_LANGUAGE: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_LANGUAGE),\n/* harmony export */   DEFAULT_NAMESPACE: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_NAMESPACE),\n/* harmony export */   DebounceType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.DebounceType),\n/* harmony export */   DefaultParticipantViewUI: () => (/* binding */ DefaultParticipantViewUI),\n/* harmony export */   DefaultReactionsMenu: () => (/* binding */ DefaultReactionsMenu),\n/* harmony export */   DefaultScreenShareOverlay: () => (/* binding */ DefaultScreenShareOverlay),\n/* harmony export */   DefaultVideoPlaceholder: () => (/* binding */ DefaultVideoPlaceholder),\n/* harmony export */   DeviceSelector: () => (/* binding */ DeviceSelector),\n/* harmony export */   DeviceSelectorAudioInput: () => (/* binding */ DeviceSelectorAudioInput),\n/* harmony export */   DeviceSelectorAudioOutput: () => (/* binding */ DeviceSelectorAudioOutput),\n/* harmony export */   DeviceSelectorVideo: () => (/* binding */ DeviceSelectorVideo),\n/* harmony export */   DeviceSettings: () => (/* binding */ DeviceSettings),\n/* harmony export */   DropDownSelect: () => (/* binding */ DropDownSelect),\n/* harmony export */   DropDownSelectOption: () => (/* binding */ DropDownSelectOption),\n/* harmony export */   DynascaleManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.DynascaleManager),\n/* harmony export */   EmptyCallRecordingListing: () => (/* binding */ EmptyCallRecordingListing),\n/* harmony export */   ErrorFromResponse: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ErrorFromResponse),\n/* harmony export */   GenericMenu: () => (/* binding */ GenericMenu),\n/* harmony export */   GenericMenuButtonItem: () => (/* binding */ GenericMenuButtonItem),\n/* harmony export */   Icon: () => (/* binding */ Icon),\n/* harmony export */   IconButton: () => (/* binding */ IconButton),\n/* harmony export */   InputMediaDeviceManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.InputMediaDeviceManager),\n/* harmony export */   InputMediaDeviceManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.InputMediaDeviceManagerState),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.LayoutSettingsNameEnum),\n/* harmony export */   LayoutSettingsRequestNameEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.LayoutSettingsRequestNameEnum),\n/* harmony export */   LivestreamLayout: () => (/* binding */ LivestreamLayout),\n/* harmony export */   LoadingCallRecordingListing: () => (/* binding */ LoadingCallRecordingListing),\n/* harmony export */   LoadingIndicator: () => (/* binding */ LoadingIndicator),\n/* harmony export */   MenuToggle: () => (/* binding */ MenuToggle),\n/* harmony export */   MenuVisualType: () => (/* binding */ MenuVisualType),\n/* harmony export */   MicrophoneManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.MicrophoneManager),\n/* harmony export */   MicrophoneManagerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.MicrophoneManagerState),\n/* harmony export */   Notification: () => (/* binding */ Notification),\n/* harmony export */   OwnCapability: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability),\n/* harmony export */   PaginatedGridLayout: () => (/* binding */ PaginatedGridLayout),\n/* harmony export */   ParticipantActionsContextMenu: () => (/* binding */ ParticipantActionsContextMenu),\n/* harmony export */   ParticipantDetails: () => (/* binding */ ParticipantDetails),\n/* harmony export */   ParticipantView: () => (/* binding */ ParticipantView),\n/* harmony export */   ParticipantViewContext: () => (/* binding */ ParticipantViewContext),\n/* harmony export */   ParticipantsAudio: () => (/* binding */ ParticipantsAudio),\n/* harmony export */   PermissionNotification: () => (/* binding */ PermissionNotification),\n/* harmony export */   PermissionRequestList: () => (/* binding */ PermissionRequestList),\n/* harmony export */   PermissionRequests: () => (/* binding */ PermissionRequests),\n/* harmony export */   ReactionsButton: () => (/* binding */ ReactionsButton),\n/* harmony export */   RecordCallButton: () => (/* binding */ RecordCallButton),\n/* harmony export */   RecordCallConfirmationButton: () => (/* binding */ RecordCallConfirmationButton),\n/* harmony export */   RecordSettingsRequestModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RecordSettingsRequestModeEnum),\n/* harmony export */   RecordSettingsRequestQualityEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RecordSettingsRequestQualityEnum),\n/* harmony export */   RecordingInProgressNotification: () => (/* binding */ RecordingInProgressNotification),\n/* harmony export */   Restricted: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted),\n/* harmony export */   RingingCall: () => (/* binding */ RingingCall),\n/* harmony export */   RingingCallControls: () => (/* binding */ RingingCallControls),\n/* harmony export */   RxUtils: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.RxUtils),\n/* harmony export */   ScreenShareButton: () => (/* binding */ ScreenShareButton),\n/* harmony export */   ScreenShareManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ScreenShareManager),\n/* harmony export */   ScreenShareState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ScreenShareState),\n/* harmony export */   SearchInput: () => (/* binding */ SearchInput),\n/* harmony export */   SearchResults: () => (/* binding */ SearchResults),\n/* harmony export */   SfuEvents: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuEvents),\n/* harmony export */   SfuModels: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels),\n/* harmony export */   SpeakerLayout: () => (/* binding */ SpeakerLayout),\n/* harmony export */   SpeakerManager: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SpeakerManager),\n/* harmony export */   SpeakerState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SpeakerState),\n/* harmony export */   SpeakingWhileMutedNotification: () => (/* binding */ SpeakingWhileMutedNotification),\n/* harmony export */   SpeechIndicator: () => (/* binding */ SpeechIndicator),\n/* harmony export */   StatCard: () => (/* binding */ StatCard),\n/* harmony export */   StatCardExplanation: () => (/* binding */ StatCardExplanation),\n/* harmony export */   StatsTag: () => (/* binding */ StatsTag),\n/* harmony export */   Statuses: () => (/* binding */ Statuses),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamCallProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamCallProvider),\n/* harmony export */   StreamI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamI18n),\n/* harmony export */   StreamI18nProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamI18nProvider),\n/* harmony export */   StreamSfuClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamSfuClient),\n/* harmony export */   StreamTheme: () => (/* binding */ StreamTheme),\n/* harmony export */   StreamVideo: () => (/* binding */ StreamVideo),\n/* harmony export */   StreamVideoClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoClient),\n/* harmony export */   StreamVideoProvider: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamVideoProvider),\n/* harmony export */   StreamVideoReadOnlyStateStore: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoReadOnlyStateStore),\n/* harmony export */   StreamVideoServerClient: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoServerClient),\n/* harmony export */   StreamVideoWriteableStateStore: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.StreamVideoWriteableStateStore),\n/* harmony export */   TextButton: () => (/* binding */ TextButton),\n/* harmony export */   ToggleAudioOutputButton: () => (/* binding */ ToggleAudioOutputButton),\n/* harmony export */   ToggleAudioPreviewButton: () => (/* binding */ ToggleAudioPreviewButton),\n/* harmony export */   ToggleAudioPublishingButton: () => (/* binding */ ToggleAudioPublishingButton),\n/* harmony export */   ToggleVideoPreviewButton: () => (/* binding */ ToggleVideoPreviewButton),\n/* harmony export */   ToggleVideoPublishingButton: () => (/* binding */ ToggleVideoPublishingButton),\n/* harmony export */   Tooltip: () => (/* binding */ Tooltip),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.TranscriptionSettingsModeEnum),\n/* harmony export */   TranscriptionSettingsRequestModeEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.TranscriptionSettingsRequestModeEnum),\n/* harmony export */   Video: () => (/* binding */ Video$1),\n/* harmony export */   VideoPreview: () => (/* binding */ VideoPreview),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoSettingsRequestCameraFacingEnum: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VideoSettingsRequestCameraFacingEnum),\n/* harmony export */   ViewportTracker: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.ViewportTracker),\n/* harmony export */   VisibilityState: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VisibilityState),\n/* harmony export */   WithTooltip: () => (/* binding */ WithTooltip),\n/* harmony export */   checkIfAudioOutputChangeSupported: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.checkIfAudioOutputChangeSupported),\n/* harmony export */   combineComparators: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.combineComparators),\n/* harmony export */   conditional: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.conditional),\n/* harmony export */   createSoundDetector: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.createSoundDetector),\n/* harmony export */   defaultReactions: () => (/* binding */ defaultReactions),\n/* harmony export */   defaultSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.defaultSortPreset),\n/* harmony export */   defaultTranslationFunction: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.defaultTranslationFunction),\n/* harmony export */   descending: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.descending),\n/* harmony export */   deviceIds$: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.deviceIds$),\n/* harmony export */   disposeOfMediaStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.disposeOfMediaStream),\n/* harmony export */   dominantSpeaker: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.dominantSpeaker),\n/* harmony export */   getAudioDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioDevices),\n/* harmony export */   getAudioOutputDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioOutputDevices),\n/* harmony export */   getAudioStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getAudioStream),\n/* harmony export */   getClientDetails: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getClientDetails),\n/* harmony export */   getDeviceInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getDeviceInfo),\n/* harmony export */   getLogger: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getLogger),\n/* harmony export */   getOSInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getOSInfo),\n/* harmony export */   getScreenShareStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getScreenShareStream),\n/* harmony export */   getSdkInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getSdkInfo),\n/* harmony export */   getVideoDevices: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getVideoDevices),\n/* harmony export */   getVideoStream: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.getVideoStream),\n/* harmony export */   livestreamOrAudioRoomSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.livestreamOrAudioRoomSortPreset),\n/* harmony export */   logLevels: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.logLevels),\n/* harmony export */   logToConsole: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.logToConsole),\n/* harmony export */   mapToRegistry: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.mapToRegistry),\n/* harmony export */   name: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.name),\n/* harmony export */   noopComparator: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.noopComparator),\n/* harmony export */   paginatedLayoutSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.paginatedLayoutSortPreset),\n/* harmony export */   pinned: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.pinned),\n/* harmony export */   publishingAudio: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.publishingAudio),\n/* harmony export */   publishingVideo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.publishingVideo),\n/* harmony export */   reactionType: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.reactionType),\n/* harmony export */   role: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.role),\n/* harmony export */   screenSharing: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.screenSharing),\n/* harmony export */   setDeviceInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setDeviceInfo),\n/* harmony export */   setLogLevel: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setLogLevel),\n/* harmony export */   setLogger: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setLogger),\n/* harmony export */   setOSInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setOSInfo),\n/* harmony export */   setSdkInfo: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setSdkInfo),\n/* harmony export */   speakerLayoutSortPreset: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speakerLayoutSortPreset),\n/* harmony export */   speaking: () => (/* reexport safe */ _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speaking),\n/* harmony export */   translations: () => (/* binding */ translations),\n/* harmony export */   useCall: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall),\n/* harmony export */   useCallStateHooks: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks),\n/* harmony export */   useCalls: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCalls),\n/* harmony export */   useConnectedUser: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser),\n/* harmony export */   useCreateI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCreateI18n),\n/* harmony export */   useHorizontalScrollPosition: () => (/* binding */ useHorizontalScrollPosition),\n/* harmony export */   useI18n: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n),\n/* harmony export */   useMenuContext: () => (/* binding */ useMenuContext),\n/* harmony export */   useParticipantViewContext: () => (/* binding */ useParticipantViewContext),\n/* harmony export */   usePersistedDevicePreferences: () => (/* binding */ usePersistedDevicePreferences),\n/* harmony export */   useRequestPermission: () => (/* binding */ useRequestPermission),\n/* harmony export */   useStore: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useStore),\n/* harmony export */   useStreamVideoClient: () => (/* reexport safe */ _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useStreamVideoClient),\n/* harmony export */   useTrackElementVisibility: () => (/* binding */ useTrackElementVisibility),\n/* harmony export */   useVerticalScrollPosition: () => (/* binding */ useVerticalScrollPosition)\n/* harmony export */ });\n/* harmony import */ var _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stream-io/video-client */ \"(ssr)/./node_modules/@stream-io/video-client/dist/index.es.js\");\n/* harmony import */ var _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stream-io/video-react-bindings */ \"(ssr)/./node_modules/@stream-io/video-react-bindings/dist/index.es.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! chart.js */ \"(ssr)/./node_modules/chart.js/dist/chart.js\");\n/* harmony import */ var react_chartjs_2__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-chartjs-2 */ \"(ssr)/./node_modules/react-chartjs-2/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst Audio = ({ participant, trackType = 'audioTrack', ...rest }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [audioElement, setAudioElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const { userId, sessionId } = participant;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !audioElement)\n            return;\n        const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);\n        return () => {\n            cleanup?.();\n        };\n    }, [call, sessionId, audioElement, trackType]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"audio\", { autoPlay: true, ...rest, ref: setAudioElement, \"data-user-id\": userId, \"data-session-id\": sessionId, \"data-track-type\": trackType }));\n};\n\nconst ParticipantsAudio = (props) => {\n    const { participants, audioProps } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: participants.map((participant) => {\n            if (participant.isLocalParticipant)\n                return null;\n            const { publishedTracks, audioStream, screenShareAudioStream, sessionId, } = participant;\n            const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n            const audioTrackElement = hasAudio && audioStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { ...audioProps, trackType: \"audioTrack\", participant: participant }));\n            const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n            const screenShareAudioTrackElement = hasScreenShareAudio &&\n                screenShareAudioStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { ...audioProps, trackType: \"screenShareAudioTrack\", participant: participant }));\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId));\n        }) }));\n};\n\nconst ParticipantViewContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(undefined);\nconst useParticipantViewContext = () => (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ParticipantViewContext);\n\nconst Avatar = ({ imageSrc, name, style, className, ...rest }) => {\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(!imageSrc || error) && name && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(AvatarFallback, { className: className, style: style, names: [name] })), imageSrc && !error && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { onError: () => setError(true), alt: \"avatar\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__avatar', className), src: imageSrc, style: style, ...rest }))] }));\n};\nconst AvatarFallback = ({ className, names, style, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__avatar--initials-fallback', className), style: style, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { children: [names[0][0], names[1]?.[0]] }) }));\n};\n\nconst useFloatingUIPreset = ({ placement, strategy, offset: offsetInPx = 10, }) => {\n    const { refs, x, y, update, elements: { domReference, floating }, } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useFloating)({\n        placement,\n        strategy,\n        middleware: [\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_6__.offset)(offsetInPx),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.shift)(),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.flip)(),\n            (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.size)({\n                padding: 10,\n                apply: ({ availableHeight, elements }) => {\n                    Object.assign(elements.floating.style, {\n                        maxHeight: `${availableHeight}px`,\n                    });\n                },\n            }),\n        ],\n    });\n    // handle window resizing\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!domReference || !floating)\n            return;\n        const cleanup = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.autoUpdate)(domReference, floating, update);\n        return () => cleanup();\n    }, [domReference, floating, update]);\n    return { refs, x, y, domReference, floating, strategy };\n};\n\n/**\n * This hook will persist the device settings to local storage.\n *\n * @param key the key to use for local storage.\n */\nconst usePersistDevicePreferences = (key) => {\n    const { useMicrophoneState, useCameraState, useSpeakerState, useCallSettings, } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const mic = useMicrophoneState();\n    const camera = useCameraState();\n    const speaker = useSpeakerState();\n    const settings = useCallSettings();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!settings)\n            return;\n        try {\n            const hasPreferences = !!window.localStorage.getItem(key);\n            const { audio, video } = settings;\n            const defaultDevice = 'default';\n            const preferences = {\n                mic: {\n                    selectedDeviceId: mic.selectedDevice || defaultDevice,\n                    muted: hasPreferences ? mic.isMute : !audio.mic_default_on,\n                },\n                camera: {\n                    selectedDeviceId: camera.selectedDevice || defaultDevice,\n                    muted: hasPreferences ? camera.isMute : !video.camera_default_on,\n                },\n                speaker: {\n                    selectedDeviceId: speaker.selectedDevice || defaultDevice,\n                    muted: false,\n                },\n            };\n            window.localStorage.setItem(key, JSON.stringify(preferences));\n        }\n        catch (err) {\n            console.warn('Failed to save device preferences', err);\n        }\n    }, [\n        camera.isMute,\n        camera.selectedDevice,\n        key,\n        mic.isMute,\n        mic.selectedDevice,\n        settings,\n        speaker.selectedDevice,\n    ]);\n};\n/**\n * This hook will apply the device settings from local storage.\n *\n * @param key the key to use for local storage.\n */\nconst useApplyDevicePreferences = (key) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const settings = useCallSettings();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !settings)\n            return;\n        const apply = async () => {\n            const initMic = async (setting) => {\n                await call.microphone.select(setting.selectedDeviceId);\n                if (setting.muted) {\n                    await call.microphone.disable();\n                }\n                else {\n                    await call.microphone.enable();\n                }\n            };\n            const initCamera = async (setting) => {\n                await call.camera.select(setting.selectedDeviceId);\n                if (setting.muted) {\n                    await call.camera.disable();\n                }\n                else {\n                    await call.camera.enable();\n                }\n            };\n            const initSpeaker = (setting) => {\n                call.speaker.select(setting.selectedDeviceId);\n            };\n            let preferences = null;\n            try {\n                preferences = JSON.parse(window.localStorage.getItem(key));\n            }\n            catch (err) {\n                console.warn('Failed to load device preferences', err);\n            }\n            if (preferences) {\n                await initMic(preferences.mic);\n                await initCamera(preferences.camera);\n                initSpeaker(preferences.speaker);\n            }\n            else {\n                const { audio, video } = settings;\n                if (audio.mic_default_on)\n                    await call.microphone.enable();\n                if (video.camera_default_on)\n                    await call.camera.enable();\n            }\n        };\n        apply().catch((err) => {\n            console.warn('Failed to apply device preferences', err);\n        });\n    }, [call, key, settings]);\n};\n/**\n * This hook will apply and persist the device preferences from local storage.\n *\n * @param key the key to use for local storage.\n */\nconst usePersistedDevicePreferences = (key = '@stream-io/device-preferences') => {\n    useApplyDevicePreferences(key);\n    usePersistDevicePreferences(key);\n};\n\nconst SCROLL_THRESHOLD = 10;\n/**\n * Hook which observes element's scroll position and returns text value based on the\n * position of the scrollbar (`top`, `bottom`, `between` and `null` if no scrollbar is available)\n */\nconst useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {\n    const [scrollPosition, setScrollPosition] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!scrollElement)\n            return;\n        const scrollHandler = () => {\n            const element = scrollElement;\n            const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;\n            if (!hasVerticalScrollbar)\n                return setScrollPosition(null);\n            const isAtTheTop = element.scrollTop <= threshold;\n            if (isAtTheTop)\n                return setScrollPosition('top');\n            const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;\n            if (isAtTheBottom)\n                return setScrollPosition('bottom');\n            setScrollPosition('between');\n        };\n        const resizeObserver = new ResizeObserver(scrollHandler);\n        resizeObserver.observe(scrollElement);\n        scrollElement.addEventListener('scroll', scrollHandler);\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollHandler);\n            resizeObserver.disconnect();\n        };\n    }, [scrollElement, threshold]);\n    return scrollPosition;\n};\nconst useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {\n    const [scrollPosition, setScrollPosition] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!scrollElement)\n            return;\n        const scrollHandler = () => {\n            const element = scrollElement;\n            const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;\n            if (!hasHorizontalScrollbar)\n                return setScrollPosition(null);\n            const isAtTheStart = element.scrollLeft <= threshold;\n            if (isAtTheStart)\n                return setScrollPosition('start');\n            const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;\n            if (isAtTheEnd)\n                return setScrollPosition('end');\n            setScrollPosition('between');\n        };\n        const resizeObserver = new ResizeObserver(scrollHandler);\n        resizeObserver.observe(scrollElement);\n        scrollElement.addEventListener('scroll', scrollHandler);\n        return () => {\n            scrollElement.removeEventListener('scroll', scrollHandler);\n            resizeObserver.disconnect();\n        };\n    }, [scrollElement, threshold]);\n    return scrollPosition;\n};\n\nconst useToggleCallRecording = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useIsCallRecordingInProgress } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isCallRecordingInProgress = useIsCallRecordingInProgress();\n    const [isAwaitingResponse, setIsAwaitingResponse] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    // TODO: add permissions\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // we wait until call.recording_started/stopped event to flips the\n        // `isCallRecordingInProgress` state variable.\n        // Once the flip happens, we remove the loading indicator\n        setIsAwaitingResponse((isAwaiting) => {\n            if (isAwaiting)\n                return false;\n            return isAwaiting;\n        });\n    }, [isCallRecordingInProgress]);\n    const toggleCallRecording = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n        try {\n            setIsAwaitingResponse(true);\n            if (isCallRecordingInProgress) {\n                await call?.stopRecording();\n            }\n            else {\n                await call?.startRecording();\n            }\n        }\n        catch (e) {\n            console.error(`Failed start recording`, e);\n        }\n    }, [call, isCallRecordingInProgress]);\n    return { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress };\n};\n\nconst useRequestPermission = (permission) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const hasPermission = useHasPermissions(permission);\n    const [isAwaitingPermission, setIsAwaitingPermission] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false); // TODO: load with possibly pending state\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        const reset = () => setIsAwaitingPermission(false);\n        if (hasPermission)\n            reset();\n    }, [hasPermission]);\n    const requestPermission = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async () => {\n        if (hasPermission)\n            return true;\n        const canRequestPermission = !!call?.permissionsContext.canRequest(permission);\n        if (isAwaitingPermission || !canRequestPermission)\n            return false;\n        setIsAwaitingPermission(true);\n        try {\n            await call?.requestPermissions({\n                permissions: [permission],\n            });\n        }\n        catch (error) {\n            setIsAwaitingPermission(false);\n            throw new Error(`requestPermission failed: ${error}`);\n        }\n        return false;\n    }, [call, hasPermission, isAwaitingPermission, permission]);\n    return {\n        requestPermission,\n        hasPermission,\n        canRequestPermission: !!call?.permissionsContext.canRequest(permission),\n        isAwaitingPermission,\n    };\n};\n\nvar MenuVisualType;\n(function (MenuVisualType) {\n    MenuVisualType[\"PORTAL\"] = \"portal\";\n    MenuVisualType[\"MENU\"] = \"menu\";\n})(MenuVisualType || (MenuVisualType = {}));\n/**\n * Used to provide utility APIs to the components rendered inside the portal.\n */\nconst MenuContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\n/**\n * Access to the closes MenuContext.\n */\nconst useMenuContext = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(MenuContext);\n};\nconst MenuPortal = ({ children, refs, }) => {\n    const portalId = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => `str-video-portal-${Math.random().toString(36).substring(2, 9)}`, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { id: portalId, className: \"str-video__portal\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.FloatingOverlay, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.FloatingPortal, { id: portalId, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__portal-content\", ref: refs.setFloating, children: children }) }) })] }));\n};\nconst MenuToggle = ({ ToggleButton, placement = 'top-start', strategy = 'absolute', offset, visualType = MenuVisualType.MENU, children, }) => {\n    const [menuShown, setMenuShown] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const { floating, domReference, refs, x, y } = useFloatingUIPreset({\n        placement,\n        strategy,\n        offset,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        const handleClick = (event) => {\n            if (!floating && domReference?.contains(event.target)) {\n                setMenuShown(true);\n            }\n            else if (floating && !floating?.contains(event.target)) {\n                setMenuShown(false);\n            }\n        };\n        const handleKeyDown = (event) => {\n            if (event.key.toLowerCase() === 'escape' &&\n                !event.altKey &&\n                !event.ctrlKey) {\n                setMenuShown(false);\n            }\n        };\n        document?.addEventListener('click', handleClick, { capture: true });\n        document?.addEventListener('keydown', handleKeyDown);\n        return () => {\n            document?.removeEventListener('click', handleClick, { capture: true });\n            document?.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [floating, domReference]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [menuShown && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuPortal, { refs: refs, children: children })) : visualType === MenuVisualType.MENU ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__menu-container\", ref: refs.setFloating, style: {\n                        position: strategy,\n                        top: y ?? 0,\n                        left: x ?? 0,\n                        overflowY: 'auto',\n                    }, children: children })) : null })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleButton, { menuShown: menuShown, ref: refs.setReference })] }));\n};\n\nconst GenericMenu = ({ children, onItemClick, }) => {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__generic-menu\", ref: ref, onClick: (e) => {\n            if (onItemClick &&\n                e.target !== ref.current &&\n                ref.current?.contains(e.target)) {\n                onItemClick(e);\n            }\n        }, children: children }));\n};\nconst GenericMenuButtonItem = ({ children, ...rest }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"li\", { className: \"str-video__generic-menu--item\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ...rest, children: children }) }));\n};\n\nconst Icon = ({ className, icon }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__icon', icon && `str-video__icon--${icon}`, className) }));\n\nconst IconButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function IconButton(props, ref) {\n    const { icon, enabled, variant, onClick, className, ...rest } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-controls__button', className, {\n            [`str-video__call-controls__button--variant-${variant}`]: variant,\n            'str-video__call-controls__button--enabled': enabled,\n        }), onClick: (e) => {\n            e.preventDefault();\n            onClick?.(e);\n        }, ref: ref, ...rest, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: icon }) }));\n});\n\nconst isComponentType = (elementOrComponent) => {\n    return elementOrComponent === null\n        ? false\n        : !(0,react__WEBPACK_IMPORTED_MODULE_3__.isValidElement)(elementOrComponent);\n};\n\nconst chunk = (array, size) => {\n    const chunkCount = Math.ceil(array.length / size);\n    return Array.from({ length: chunkCount }, (_, index) => array.slice(size * index, size * index + size));\n};\n\nconst applyElementToRef = (ref, element) => {\n    if (!ref)\n        return;\n    if (typeof ref === 'function')\n        return ref(element);\n    ref.current = element;\n};\n\nconst CompositeButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function CompositeButton({ caption, children, className, active, Menu, menuPlacement, menuOffset, title, ToggleMenuButton = DefaultToggleMenuButton, variant, onClick, ...restButtonProps }, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__composite-button', className, {\n            'str-video__composite-button--caption': caption,\n            'str-video__composite-button--menu': Menu,\n        }), title: title, ref: ref, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__composite-button__button-group', {\n                    'str-video__composite-button__button-group--active': active,\n                    'str-video__composite-button__button-group--active-primary': active && variant === 'primary',\n                    'str-video__composite-button__button-group--active-secondary': active && variant === 'secondary',\n                }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", className: \"str-video__composite-button__button\", onClick: (e) => {\n                            e.preventDefault();\n                            onClick?.(e);\n                        }, ...restButtonProps, children: children }), Menu && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton, children: isComponentType(Menu) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Menu, {}) : Menu }))] }), caption && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__composite-button__caption\", children: caption }))] }));\n});\nconst DefaultToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function DefaultToggleMenuButton({ menuShown }, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__menu-toggle-button', {\n            'str-video__menu-toggle-button--active': menuShown,\n        }), icon: menuShown ? 'caret-down' : 'caret-up', ref: ref }));\n});\n\nconst TextButton = ({ children, ...rest }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ...rest, className: \"str-video__text-button\", children: children }));\n};\n\nconst AcceptCallButton = ({ disabled, onAccept, onClick, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.join();\n            onAccept?.();\n        }\n    }, [onClick, onAccept, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: disabled, icon: \"call-accept\", variant: \"success\", \"data-testid\": \"accept-call-button\", onClick: handleClick }));\n};\n\nconst Notification = (props) => {\n    const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = 'top', iconClassName = 'str-video__notification__icon', close, } = props;\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement,\n        strategy: 'absolute',\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!isVisible || !visibilityTimeout || !resetIsVisible)\n            return;\n        const timeout = setTimeout(() => {\n            resetIsVisible();\n        }, visibilityTimeout);\n        return () => clearTimeout(timeout);\n    }, [isVisible, resetIsVisible, visibilityTimeout]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: refs.setReference, children: [isVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__notification\", ref: refs.setFloating, style: {\n                    position: strategy,\n                    top: y ?? 0,\n                    left: x ?? 0,\n                    overflowY: 'auto',\n                }, children: [iconClassName && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"i\", { className: iconClassName }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__notification__message\", children: message }), close ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"i\", { className: \"str-video__icon str-video__icon--close str-video__notification__close\", onClick: close })) : null] })), children] }));\n};\n\nconst PermissionNotification = (props) => {\n    const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children, } = props;\n    const { useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const hasPermission = useHasPermissions(permission);\n    const prevHasPermission = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(hasPermission);\n    const [showNotification, setShowNotification] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (hasPermission && !prevHasPermission.current) {\n            setShowNotification('granted');\n            prevHasPermission.current = true;\n        }\n        else if (!hasPermission && prevHasPermission.current) {\n            setShowNotification('revoked');\n            prevHasPermission.current = false;\n        }\n    }, [hasPermission]);\n    const resetIsVisible = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => setShowNotification(undefined), []);\n    if (isAwaitingApproval) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children: children }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: !!showNotification, visibilityTimeout: visibilityTimeout, resetIsVisible: resetIsVisible, message: showNotification === 'granted' ? messageApproved : messageRevoked, children: children }));\n};\n\nconst SpeakingWhileMutedNotification = ({ children, text, placement, }) => {\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { isSpeakingWhileMuted } = useMicrophoneState();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const message = text ?? t('You are muted. Unmute to speak.');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { message: message, isVisible: isSpeakingWhileMuted, placement: placement || 'top-start', children: children }));\n};\n\nconst RecordingInProgressNotification = ({ children, text, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { isCallRecordingInProgress } = useToggleCallRecording();\n    const [isVisible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const message = text ?? t('Recording in progress...');\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (isCallRecordingInProgress) {\n            setVisible(true);\n        }\n        else {\n            setVisible(false);\n        }\n    }, [isCallRecordingInProgress]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { message: message, iconClassName: \"str-video__icon str-video__icon--recording-on\", isVisible: isVisible, placement: \"top-start\", close: () => setVisible(false), children: children }));\n};\n\nconst LoadingIndicator = ({ className, type = 'spinner', text, tooltip, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__loading-indicator', className), title: tooltip, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__loading-indicator__icon', type) }), text && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__loading-indicator-text\", children: text })] }));\n};\n\nconst RecordEndConfirmation = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();\n    const { close } = useMenuContext();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__confirmation\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-on\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"h2\", { className: \"str-video__end-recording__heading\", children: t('End recording') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__end-recording__description\", children: t('Are you sure you want end the recording?') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-recording__actions\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { variant: \"secondary\", onClick: close, children: t('Cancel') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { variant: \"primary\", onClick: toggleCallRecording, children: isAwaitingResponse ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, {}) : t('End recording') })] })] }));\n};\nconst ToggleEndRecordingMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleEndRecordingMenuButton(props, ref) {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: true, variant: \"secondary\", \"data-testid\": \"recording-stop-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-off\" }) }));\n});\nconst RecordCallConfirmationButton = ({ caption, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();\n    if (isCallRecordingInProgress) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n                _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n                _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n            ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RecordEndConfirmation, {}) }) }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n        ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption: caption, title: caption || t('Record call'), variant: \"secondary\", \"data-testid\": \"recording-start-button\", onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, { tooltip: t('Waiting for recording to start...') })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"recording-off\" })) }) }));\n};\nconst RecordCallButton = ({ caption }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();\n    let title = caption || t('Record call');\n    if (isAwaitingResponse) {\n        title = isCallRecordingInProgress\n            ? t('Waiting for recording to stop...')\n            : t('Waiting for recording to start...');\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.START_RECORD_CALL,\n            _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.STOP_RECORD_CALL,\n        ], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption: caption, variant: \"secondary\", \"data-testid\": isCallRecordingInProgress\n                ? 'recording-stop-button'\n                : 'recording-start-button', title: title, onClick: isAwaitingResponse ? undefined : toggleCallRecording, children: isAwaitingResponse ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, {})) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isCallRecordingInProgress ? 'recording-on' : 'recording-off' })) }) }));\n};\n\nconst defaultEmojiReactionMap = {\n    ':like:': '👍',\n    ':raise-hand:': '✋',\n    ':fireworks:': '🎉',\n    ':dislike:': '👎',\n    ':heart:': '❤️',\n    ':smile:': '😀',\n};\nconst Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !reaction)\n            return;\n        const timeoutId = setTimeout(() => {\n            call.resetReaction(sessionId);\n        }, hideAfterTimeoutInMs);\n        return () => {\n            clearTimeout(timeoutId);\n        };\n    }, [call, hideAfterTimeoutInMs, reaction, sessionId]);\n    if (!reaction)\n        return null;\n    const { emoji_code: emojiCode } = reaction;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__reaction\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__reaction__emoji\", children: emojiCode && emojiReactionMap[emojiCode] }) }));\n};\n\nconst defaultReactions = [\n    {\n        type: 'reaction',\n        emoji_code: ':like:',\n    },\n    {\n        // TODO OL: use `prompt` type?\n        type: 'raised-hand',\n        emoji_code: ':raise-hand:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':fireworks:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':dislike:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':heart:',\n    },\n    {\n        type: 'reaction',\n        emoji_code: ':smile:',\n    },\n];\nconst ReactionsButton = ({ reactions = defaultReactions, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.CREATE_REACTION], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top\", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultReactionsMenu, { reactions: reactions }) }) }));\n};\nconst ToggleReactionsMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleReactionsMenuButton({ menuShown }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: menuShown, variant: \"primary\", title: t('Reactions'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"reactions\" }) }));\n});\nconst DefaultReactionsMenu = ({ reactions, layout = 'horizontal', }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__reactions-menu', {\n            'str-video__reactions-menu--horizontal': layout === 'horizontal',\n            'str-video__reactions-menu--vertical': layout === 'vertical',\n        }), children: reactions.map((reaction) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", className: \"str-video__reactions-menu__button\", onClick: () => {\n                call?.sendReaction(reaction);\n            }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code))) }));\n};\n\nconst ScreenShareButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption } = props;\n    const { useHasOngoingScreenShare, useScreenShareState, useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isSomeoneScreenSharing = useHasOngoingScreenShare();\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE);\n    const callSettings = useCallSettings();\n    const isScreenSharingAllowed = callSettings?.screensharing.enabled;\n    const { screenShare, isMute: amIScreenSharing } = useScreenShareState();\n    const disableScreenShareButton = amIScreenSharing\n        ? isSomeoneScreenSharing || isScreenSharingAllowed === false\n        : false;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your screen.'), messageAwaitingApproval: t('Awaiting for an approval to share screen.'), messageRevoked: t('You can no longer share your screen.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { active: isSomeoneScreenSharing, caption: caption, title: caption || t('Share screen'), variant: \"primary\", \"data-testid\": isSomeoneScreenSharing\n                    ? 'screen-share-stop-button'\n                    : 'screen-share-start-button', disabled: disableScreenShareButton, onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await screenShare.toggle();\n                    }\n                }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isSomeoneScreenSharing ? 'screen-share-on' : 'screen-share-off' }) }) }) }));\n};\n\nconst SelectContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nconst Select = (props) => {\n    const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp, } = props;\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [activeIndex, setActiveIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [selectedIndex, setSelectedIndex] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultSelectedIndex);\n    const [selectedLabel, setSelectedLabel] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultSelectedLabel);\n    const { refs, context } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useFloating)({\n        placement: 'bottom-start',\n        open: isOpen,\n        onOpenChange: setIsOpen,\n        whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.autoUpdate,\n        middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_7__.flip)()],\n    });\n    const elementsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    const labelsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    const handleSelect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index) => {\n        setSelectedIndex(index);\n        handleSelectProp(index || 0);\n        setIsOpen(false);\n        if (index !== null) {\n            setSelectedLabel(labelsRef.current[index]);\n        }\n    }, [handleSelectProp]);\n    const handleTypeaheadMatch = (index) => {\n        if (isOpen) {\n            setActiveIndex(index);\n        }\n        else {\n            handleSelect(index);\n        }\n    };\n    const listNav = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useListNavigation)(context, {\n        listRef: elementsRef,\n        activeIndex,\n        selectedIndex,\n        onNavigate: setActiveIndex,\n    });\n    const typeahead = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useTypeahead)(context, {\n        listRef: labelsRef,\n        activeIndex,\n        selectedIndex,\n        onMatch: handleTypeaheadMatch,\n    });\n    const click = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useClick)(context);\n    const dismiss = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useDismiss)(context);\n    const role = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useRole)(context, { role: 'listbox' });\n    const { getReferenceProps, getFloatingProps, getItemProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useInteractions)([listNav, typeahead, click, dismiss, role]);\n    const selectContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        activeIndex,\n        selectedIndex,\n        getItemProps,\n        handleSelect,\n    }), [activeIndex, selectedIndex, getItemProps, handleSelect]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__dropdown\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__dropdown-selected\", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", { className: \"str-video__dropdown-selected__label\", children: [icon && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-selected__icon\", icon: icon })), selectedLabel] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-selected__chevron\", icon: isOpen ? 'chevron-up' : 'chevron-down' })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SelectContext.Provider, { value: selectContext, children: isOpen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.FloatingFocusManager, { context: context, modal: false, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__dropdown-list\", ref: refs.setFloating, ...getFloatingProps(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.FloatingList, { elementsRef: elementsRef, labelsRef: labelsRef, children: children }) }) })) })] }));\n};\nconst DropDownSelectOption = (props) => {\n    const { selected, label, icon } = props;\n    const { getItemProps, handleSelect } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectContext);\n    const { ref, index } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useListItem)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__dropdown-option', {\n            'str-video__dropdown-option--selected': selected,\n        }), ref: ref, ...getItemProps({\n            onClick: () => handleSelect(index),\n        }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__dropdown-icon\", icon: icon }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__dropdown-label\", children: label })] }));\n};\nconst DropDownSelect = (props) => {\n    const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex, } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Select, { icon: icon, handleSelect: handleSelect, defaultSelectedIndex: defaultSelectedIndex, defaultSelectedLabel: defaultSelectedLabel, children: children }));\n};\n\nconst DeviceSelectorOption = ({ disabled, id, label, onChange, name, selected, defaultChecked, value, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"label\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__device-settings__option', {\n            'str-video__device-settings__option--selected': selected,\n            'str-video__device-settings__option--disabled': disabled,\n        }), htmlFor: id, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { type: \"radio\", name: name, onChange: onChange, value: value, id: id, checked: selected, defaultChecked: defaultChecked, disabled: disabled }), label] }));\n};\nconst DeviceSelectorList = (props) => {\n    const { devices = [], selectedDeviceId: selectedDeviceFromProps, title, type, onChange, } = props;\n    // sometimes the browser (Chrome) will report the system-default device\n    // with an id of 'default'. In case when it doesn't, we'll select the first\n    // available device.\n    let selectedDeviceId = selectedDeviceFromProps;\n    if (devices.length > 0 &&\n        !devices.find((d) => d.deviceId === selectedDeviceId)) {\n        selectedDeviceId = devices[0].deviceId;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings__device-kind\", children: [title && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__device-settings__device-selector-title\", children: title })), !devices.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorOption, { id: `${type}--default`, label: \"Default\", name: type, defaultChecked: true, value: \"default\" })) : (devices.map((device) => {\n                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e) => {\n                        onChange?.(e.target.value);\n                    }, name: type, selected: device.deviceId === selectedDeviceId || devices.length === 1 }, device.deviceId));\n            }))] }));\n};\nconst DeviceSelectorDropdown = (props) => {\n    const { devices = [], selectedDeviceId: selectedDeviceFromProps, title, onChange, icon, } = props;\n    // sometimes the browser (Chrome) will report the system-default device\n    // with an id of 'default'. In case when it doesn't, we'll select the first\n    // available device.\n    let selectedDeviceId = selectedDeviceFromProps;\n    if (devices.length > 0 &&\n        !devices.find((d) => d.deviceId === selectedDeviceId)) {\n        selectedDeviceId = devices[0].deviceId;\n    }\n    const selectedIndex = devices.findIndex((d) => d.deviceId === selectedDeviceId);\n    const handleSelect = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((index) => {\n        onChange?.(devices[index].deviceId);\n    }, [devices, onChange]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings__device-kind\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__device-settings__device-selector-title\", children: title }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropDownSelect, { icon: icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: devices[selectedIndex]?.label, handleSelect: handleSelect, children: devices.map((device) => {\n                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DropDownSelectOption, { icon: icon, label: device.label, selected: device.deviceId === selectedDeviceId || devices.length === 1 }, device.deviceId));\n                }) })] }));\n};\nconst DeviceSelector = (props) => {\n    const { visualType = 'list', icon, placeholder, ...rest } = props;\n    if (visualType === 'list') {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorList, { ...rest });\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorDropdown, { ...rest, icon: icon, placeholder: placeholder }));\n};\n\nconst DeviceSelectorAudioInput = ({ title, visualType, }) => {\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, selectedDevice, devices } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: \"audioinput\", onChange: async (deviceId) => {\n            await microphone.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"mic\" }));\n};\nconst DeviceSelectorAudioOutput = ({ title, visualType, }) => {\n    const { useSpeakerState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState();\n    if (!isDeviceSelectionSupported)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices, type: \"audiooutput\", selectedDeviceId: selectedDevice, onChange: (deviceId) => {\n            speaker.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"speaker\" }));\n};\n\nconst DeviceSelectorVideo = ({ title, visualType, }) => {\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, devices, selectedDevice } = useCameraState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelector, { devices: devices || [], type: \"videoinput\", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {\n            await camera.select(deviceId);\n        }, title: title, visualType: visualType, icon: \"camera\" }));\n};\n\nconst DeviceSettings = ({ visualType = MenuVisualType.MENU, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleDeviceSettingsMenuButton, visualType: visualType, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Menu, {}) }));\n};\nconst Menu = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__device-settings\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorVideo, { title: t('Select a Camera') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioInput, { title: t('Select a Mic') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioOutput, { title: t('Select Speakers') })] }));\n};\nconst ToggleDeviceSettingsMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleDeviceSettingsMenuButton({ menuShown }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__device-settings__button', {\n            'str-video__device-settings__button--active': menuShown,\n        }), title: t('Toggle device menu'), icon: \"device-settings\", ref: ref }));\n});\n\nconst ToggleAudioPreviewButton = (props) => {\n    const { caption, Menu, menuPlacement, ...restCompositeButtonProps } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, isMute, hasBrowserPermission } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!hasBrowserPermission && 'str-video__device-unavailable'), variant: \"secondary\", title: !hasBrowserPermission\n            ? t('Check your browser audio permissions')\n            : caption || t('Mic'), disabled: !hasBrowserPermission, \"data-testid\": isMute ? 'preview-audio-unmute-button' : 'preview-audio-mute-button', onClick: () => microphone.toggle(), Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: !isMute ? 'mic' : 'mic-off' }), !hasBrowserPermission && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", title: t('Check your browser audio permissions'), children: \"!\" }))] }));\n};\nconst ToggleAudioPublishingButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorAudioInput, { visualType: \"list\" }), menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO);\n    const { useMicrophoneState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { microphone, isMute, hasBrowserPermission } = useMicrophoneState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now speak.'), messageAwaitingApproval: t('Awaiting for an approval to speak.'), messageRevoked: t('You can no longer speak.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, title: !hasPermission\n                    ? t('You have no permission to share your audio')\n                    : !hasBrowserPermission\n                        ? t('Check your browser mic permissions')\n                        : caption || t('Mic'), variant: \"secondary\", disabled: !hasBrowserPermission || !hasPermission, \"data-testid\": isMute ? 'audio-unmute-button' : 'audio-mute-button', onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await microphone.toggle();\n                    }\n                }, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isMute ? 'mic-off' : 'mic' }), (!hasBrowserPermission || !hasPermission) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", children: \"!\" }))] }) }) }));\n};\n\nconst ToggleVideoPreviewButton = (props) => {\n    const { caption, Menu = DeviceSelectorVideo, menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, isMute, hasBrowserPermission } = useCameraState();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!hasBrowserPermission && 'str-video__device-unavailable'), title: !hasBrowserPermission\n            ? t('Check your browser video permissions')\n            : caption || t('Video'), variant: \"secondary\", \"data-testid\": isMute ? 'preview-video-unmute-button' : 'preview-video-mute-button', onClick: () => camera.toggle(), disabled: !hasBrowserPermission, Menu: Menu, menuPlacement: menuPlacement, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: !isMute ? 'camera' : 'camera-off' }), !hasBrowserPermission && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", title: t('Check your browser video permissions'), children: \"!\" }))] }));\n};\nconst ToggleVideoPublishingButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DeviceSelectorVideo, { visualType: \"list\" }), menuPlacement = 'top', ...restCompositeButtonProps } = props;\n    const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO);\n    const { useCameraState, useCallSettings } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { camera, isMute, hasBrowserPermission } = useCameraState();\n    const callSettings = useCallSettings();\n    const isPublishingVideoAllowed = callSettings?.video.enabled;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionNotification, { permission: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t('You can now share your video.'), messageAwaitingApproval: t('Awaiting for an approval to share your video.'), messageRevoked: t('You can no longer share your video.'), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(CompositeButton, { active: isMute, caption: caption, variant: \"secondary\", title: !hasPermission\n                    ? t('You have no permission to share your video')\n                    : !hasBrowserPermission\n                        ? t('Check your browser video permissions')\n                        : !isPublishingVideoAllowed\n                            ? t('Video publishing is disabled by the system')\n                            : caption || t('Video'), disabled: !hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed, \"data-testid\": isMute ? 'video-unmute-button' : 'video-mute-button', onClick: async () => {\n                    if (!hasPermission) {\n                        await requestPermission();\n                    }\n                    else {\n                        await camera.toggle();\n                    }\n                }, Menu: Menu, menuPlacement: menuPlacement, menuOffset: 16, ...restCompositeButtonProps, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: isMute ? 'camera-off' : 'camera' }), (!hasBrowserPermission ||\n                        !hasPermission ||\n                        !isPublishingVideoAllowed) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__no-media-permission\", children: \"!\" }))] }) }) }));\n};\n\nconst EndCallMenu = (props) => {\n    const { onLeave, onEnd } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__end-call__confirmation\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { className: \"str-video__button str-video__end-call__leave\", type: \"button\", \"data-testid\": \"leave-call-button\", onClick: onLeave, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__button__icon str-video__end-call__leave-icon\", icon: \"logout\" }), t('Leave call')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.END_CALL], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { className: \"str-video__button str-video__end-call__end\", type: \"button\", \"data-testid\": \"end-call-for-all-button\", onClick: onEnd, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__button__icon str-video__end-call__end-icon\", icon: \"call-end\" }), t('End call for all')] }) })] }));\n};\nconst CancelCallToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function CancelCallToggleMenuButton(props, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"call-end\", variant: \"danger\", title: t('Leave call'), \"data-testid\": \"leave-call-button\", ref: ref }));\n});\nconst CancelCallConfirmButton = ({ onClick, onLeave, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const handleLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.leave();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    const handleEndCall = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.endCall();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top-start\", ToggleButton: CancelCallToggleMenuButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) }));\n};\nconst CancelCallButton = ({ disabled, onClick, onLeave, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(async (e) => {\n        if (onClick) {\n            onClick(e);\n        }\n        else if (call) {\n            await call.leave();\n            onLeave?.();\n        }\n    }, [onClick, onLeave, call]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: disabled, icon: \"call-end\", variant: \"danger\", title: t('Leave call'), \"data-testid\": \"cancel-call-button\", onClick: handleClick }));\n};\n\nconst CallControls = ({ onLeave }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-controls\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RecordCallButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ReactionsButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ScreenShareButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SpeakingWhileMutedNotification, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleAudioPublishingButton, {}) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ToggleVideoPublishingButton, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { onLeave: onLeave })] }));\n\nchart_js__WEBPACK_IMPORTED_MODULE_8__.Chart.register(chart_js__WEBPACK_IMPORTED_MODULE_8__.CategoryScale, chart_js__WEBPACK_IMPORTED_MODULE_8__.LinearScale, chart_js__WEBPACK_IMPORTED_MODULE_8__.LineElement, chart_js__WEBPACK_IMPORTED_MODULE_8__.PointElement);\nconst CallStatsLatencyChart = (props) => {\n    const { values } = props;\n    let max = 0;\n    const data = {\n        labels: values.map((point) => {\n            const date = new Date(point.x * 1000);\n            return `${date.getHours()}:${date.getMinutes()}`;\n        }),\n        datasets: [\n            {\n                data: values.map((point) => {\n                    const { y } = point;\n                    max = Math.max(max, y);\n                    return point;\n                }),\n                borderColor: '#00e2a1',\n                backgroundColor: '#00e2a1',\n            },\n        ],\n    };\n    const options = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n        return {\n            maintainAspectRatio: false,\n            animation: {\n                duration: 0,\n            },\n            elements: {\n                line: {\n                    borderWidth: 1,\n                },\n                point: {\n                    radius: 2,\n                },\n            },\n            scales: {\n                y: {\n                    position: 'right',\n                    stacked: true,\n                    min: 0,\n                    max: Math.max(180, Math.ceil((max + 10) / 10) * 10),\n                    grid: {\n                        display: true,\n                        color: '#979ca0',\n                    },\n                    ticks: {\n                        stepSize: 30,\n                    },\n                },\n                x: {\n                    grid: {\n                        display: false,\n                    },\n                    ticks: {\n                        display: false,\n                    },\n                },\n            },\n        };\n    }, [max]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats-line-chart-container\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_chartjs_2__WEBPACK_IMPORTED_MODULE_9__.Line, { options: options, data: data, className: \"str-video__call-stats__latencychart\" }) }));\n};\n\nvar Statuses;\n(function (Statuses) {\n    Statuses[\"GOOD\"] = \"Good\";\n    Statuses[\"OK\"] = \"Ok\";\n    Statuses[\"BAD\"] = \"Bad\";\n})(Statuses || (Statuses = {}));\nconst statsStatus = ({ value, lowBound, highBound, }) => {\n    if (value <= lowBound) {\n        return Statuses.GOOD;\n    }\n    if (value >= lowBound && value <= highBound) {\n        return Statuses.OK;\n    }\n    if (value >= highBound) {\n        return Statuses.BAD;\n    }\n    return Statuses.GOOD;\n};\nconst CallStats = (props) => {\n    const { latencyLowBound = 75, latencyHighBound = 400 } = props;\n    const [latencyBuffer, setLatencyBuffer] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n        const now = Date.now();\n        return Array.from({ length: 20 }, (_, i) => ({ x: now + i, y: 0 }));\n    });\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const [publishBitrate, setPublishBitrate] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');\n    const [subscribeBitrate, setSubscribeBitrate] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('-');\n    const previousStats = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    const { useCallStatsReport } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callStatsReport = useCallStatsReport();\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!callStatsReport)\n            return;\n        if (!previousStats.current) {\n            previousStats.current = callStatsReport;\n            return;\n        }\n        const previousCallStatsReport = previousStats.current;\n        setPublishBitrate(() => {\n            return calculatePublishBitrate(previousCallStatsReport, callStatsReport);\n        });\n        setSubscribeBitrate(() => {\n            return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);\n        });\n        setLatencyBuffer((latencyBuf) => {\n            const newLatencyBuffer = latencyBuf.slice(-19);\n            newLatencyBuffer.push({\n                x: callStatsReport.timestamp,\n                y: callStatsReport.publisherStats.averageRoundTripTimeInMs,\n            });\n            return newLatencyBuffer;\n        });\n        previousStats.current = callStatsReport;\n    }, [callStatsReport]);\n    const latencyComparison = {\n        lowBound: latencyLowBound,\n        highBound: latencyHighBound,\n        value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0,\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats\", children: callStatsReport && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h3\", { className: \"str-video__call-stats__heading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-stats__icon\", icon: \"call-latency\" }), t('Call Latency')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-stats__description\", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__latencychart\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallStatsLatencyChart, { values: latencyBuffer }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h3\", { className: \"str-video__call-stats__heading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-stats__icon\", icon: \"network-quality\" }), t('Call performance')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-stats__description\", children: t('Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.') })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-container\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Region\", value: callStatsReport.datacenter }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Latency\", value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receive jitter\", value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {\n                                ...latencyComparison,\n                                value: callStatsReport.subscriberStats.averageJitterInMs,\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish jitter\", value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {\n                                ...latencyComparison,\n                                value: callStatsReport.publisherStats.averageJitterInMs,\n                            } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish resolution\", value: toFrameSize(callStatsReport.publisherStats) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish quality drop reason\", value: callStatsReport.publisherStats.qualityLimitationReasons }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receiving resolution\", value: toFrameSize(callStatsReport.subscriberStats) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receive quality drop reason\", value: callStatsReport.subscriberStats.qualityLimitationReasons }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Publish bitrate\", value: publishBitrate }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCard, { label: \"Receiving bitrate\", value: subscribeBitrate })] })] })) }));\n};\nconst StatCardExplanation = (props) => {\n    const { description } = props;\n    const [isOpen, setIsOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const { refs, floatingStyles, context } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useFloating)({\n        open: isOpen,\n        onOpenChange: setIsOpen,\n    });\n    const hover = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useHover)(context);\n    const { getReferenceProps, getFloatingProps } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_5__.useInteractions)([hover]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-explanation\", ref: refs.setReference, ...getReferenceProps(), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { className: \"str-video__call-explanation__icon\", icon: \"info\" }) }), isOpen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-explanation__description\", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description }))] }));\n};\nconst StatsTag = ({ children, status = Statuses.GOOD, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-stats__tag', {\n            'str-video__call-stats__tag--good': status === Statuses.GOOD,\n            'str-video__call-stats__tag--ok': status === Statuses.OK,\n            'str-video__call-stats__tag--bad': status === Statuses.BAD,\n        }), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__tag__text\", children: children }) }));\n};\nconst StatCard = (props) => {\n    const { label, value, description, comparison } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const status = comparison ? statsStatus(comparison) : undefined;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-content\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-stats__card-label\", children: [label, description && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatCardExplanation, { description: description })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-stats__card-value\", children: value })] }), comparison && status && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StatsTag, { status: status, children: t(status) })] }));\n};\nconst toFrameSize = (stats) => {\n    const { highestFrameWidth: w, highestFrameHeight: h, highestFramesPerSecond: fps, } = stats;\n    let size = `-`;\n    if (w && h) {\n        size = `${w}x${h}`;\n        if (fps) {\n            size += `@${fps}fps.`;\n        }\n    }\n    return size;\n};\nconst calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {\n    const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp, }, } = previousCallStatsReport;\n    const { publisherStats: { totalBytesSent, timestamp }, } = callStatsReport;\n    const bytesSent = totalBytesSent - previousTotalBytesSent;\n    const timeElapsed = timestamp - previousTimestamp;\n    return `${((bytesSent * 8) / timeElapsed).toFixed(2)} kbps`;\n};\nconst calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {\n    const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp, }, } = previousCallStatsReport;\n    const { subscriberStats: { totalBytesReceived, timestamp }, } = callStatsReport;\n    const bytesReceived = totalBytesReceived - previousTotalBytesReceived;\n    const timeElapsed = timestamp - previousTimestamp;\n    return `${((bytesReceived * 8) / timeElapsed).toFixed(2)} kbps`;\n};\n\nconst CallStatsButton = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"top-end\", ToggleButton: ToggleMenuButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallStats, {}) }));\nconst ToggleMenuButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleMenuButton(props, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, menuShown } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { ref: ref, active: menuShown, caption: caption, title: caption || t('Statistics'), \"data-testid\": \"stats-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"stats\" }) }));\n});\n\nconst ToggleAudioOutputButton = (props) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { caption, Menu = DeviceSelectorAudioOutput, menuPlacement = 'top', } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CompositeButton, { Menu: Menu, menuPlacement: menuPlacement, caption: caption, title: caption || t('Speakers'), \"data-testid\": \"audio-output-button\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"speaker\" }) }));\n};\n\nconst BlockedUserListing = ({ data }) => {\n    if (!data.length)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing\", children: data.map((userId) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlockedUserListingItem, { userId: userId }, userId))) }) }));\n};\nconst BlockedUserListingItem = ({ userId }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const unblockUserClickHandler = () => {\n        if (userId)\n            call?.unblockUser(userId);\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing-item__display-name\", children: userId }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.BLOCK_USERS], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(TextButton, { onClick: unblockUserClickHandler, children: \"Unblock\" }) })] }));\n};\n\nconst CallParticipantListHeader = ({ onClose, }) => {\n    const { useParticipants, useAnonymousParticipantCount } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants();\n    const anonymousParticipantCount = useAnonymousParticipantCount();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list-header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list-header__title\", children: [t('Participants'), ' ', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__participant-list-header__title-count\", children: [\"[\", participants.length, \"]\"] }), anonymousParticipantCount > 0 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-list-header__title-anonymous\", children: t('Anonymous', { count: anonymousParticipantCount }) }))] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: onClose, className: \"str-video__participant-list-header__close-button\", icon: \"close\" })] }));\n};\n\nconst Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = 'top', visible = false, }) => {\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement: tooltipPlacement,\n        strategy: 'absolute',\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        refs.setReference(referenceElement);\n    }, [referenceElement, refs]);\n    if (!visible)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__tooltip', tooltipClassName), ref: refs.setFloating, style: {\n            position: strategy,\n            top: y ?? 0,\n            left: x ?? 0,\n            overflowY: 'auto',\n        }, children: children }));\n};\n\nconst useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave, } = {}) => {\n    const [tooltipVisible, setTooltipVisible] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const handleMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((e) => {\n        setTooltipVisible(true);\n        onMouseEnter?.(e);\n    }, [onMouseEnter]);\n    const handleMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((e) => {\n        setTooltipVisible(false);\n        onMouseLeave?.(e);\n    }, [onMouseLeave]);\n    return { handleMouseEnter, handleMouseLeave, tooltipVisible };\n};\n\n// todo: duplicate of CallParticipantList.tsx#MediaIndicator - refactor to a single component\nconst WithTooltip = ({ title, tooltipClassName, tooltipPlacement, ...props }) => {\n    const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();\n    const [tooltipAnchor, setTooltipAnchor] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipVisible, tooltipClassName: tooltipClassName, tooltipPlacement: tooltipPlacement, children: title || '' }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] }));\n};\n\nconst CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName, }) => {\n    const isAudioOn = participant.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const isVideoOn = participant.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const isPinned = !!participant.pin;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Avatar, { name: participant.name, imageSrc: participant.image }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DisplayName, { participant: participant }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-listing-item__media-indicator-group\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: isAudioOn ? t('Microphone on') : t('Microphone off'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isAudioOn ? 'mic' : 'mic-off'}`) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: isVideoOn ? t('Camera on') : t('Camera off'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', `str-video__participant-listing-item__icon-${isVideoOn ? 'camera' : 'camera-off'}`) }), isPinned && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaIndicator, { title: t('Pinned'), className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-listing-item__icon', 'str-video__participant-listing-item__icon-pinned') })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleButton$2, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantViewContext.Provider, { value: { participant, trackType: 'none' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantActionsContextMenu, {}) }) })] })] }));\n};\nconst MediaIndicator = (props) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(WithTooltip, { ...props }));\nconst DefaultDisplayName = ({ participant }) => {\n    const connectedUser = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const meFlag = participant.userId === connectedUser?.id ? t('Me') : '';\n    const nameOrId = participant.name || participant.userId || t('Unknown');\n    let displayName;\n    if (!participant.name) {\n        displayName = meFlag || nameOrId || t('Unknown');\n    }\n    else if (meFlag) {\n        displayName = `${nameOrId} (${meFlag})`;\n    }\n    else {\n        displayName = nameOrId;\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(WithTooltip, { className: \"str-video__participant-listing-item__display-name\", title: displayName, children: displayName }));\n};\nconst ToggleButton$2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"ellipsis\", ref: ref });\n});\n\nconst CallParticipantListing = ({ data, }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-listing\", children: data.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListingItem, { participant: participant }, participant.sessionId))) }));\n\nconst EmptyParticipantSearchList = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-list--empty\", children: t('No participants found') }));\n};\n\nconst SearchInput = ({ exitSearch, isActive, ...rest }) => {\n    const [inputElement, setInputElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!inputElement)\n            return;\n        const handleKeyDown = (e) => {\n            if (e.key.toLowerCase() === 'escape')\n                exitSearch();\n        };\n        inputElement.addEventListener('keydown', handleKeyDown);\n        return () => {\n            inputElement.removeEventListener('keydown', handleKeyDown);\n        };\n    }, [exitSearch, inputElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__search-input__container', {\n            'str-video__search-input__container--active': isActive,\n        }), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { placeholder: \"Search\", ...rest, ref: setInputElement }), isActive ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: \"str-video__search-input__clear-btn\", onClick: exitSearch, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__search-input__icon--active\" }) })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__search-input__icon\" }))] }));\n};\n\nconst SearchResults = ({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList, }) => {\n    if (searchQueryInProgress) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__search-results--loading\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator$1, {}) }));\n    }\n    if (!searchResults.length) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EmptySearchResultComponent, {});\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResultList, { data: searchResults });\n};\n\nconst useSearch = ({ debounceInterval, searchFn, searchQuery = '', }) => {\n    const [searchResults, setSearchResults] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const [searchQueryInProgress, setSearchQueryInProgress] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!searchQuery.length) {\n            setSearchQueryInProgress(false);\n            setSearchResults([]);\n            return;\n        }\n        setSearchQueryInProgress(true);\n        const timeout = setTimeout(async () => {\n            try {\n                const results = await searchFn(searchQuery);\n                setSearchResults(results);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            finally {\n                setSearchQueryInProgress(false);\n            }\n        }, debounceInterval);\n        return () => {\n            clearTimeout(timeout);\n        };\n    }, [debounceInterval, searchFn, searchQuery]);\n    return {\n        searchQueryInProgress,\n        searchResults,\n    };\n};\n\nconst UserListTypes = {\n    active: 'Active users',\n    blocked: 'Blocked users',\n};\nconst DEFAULT_DEBOUNCE_SEARCH_INTERVAL = 200;\nconst CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval, }) => {\n    const [searchQuery, setSearchQuery] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('');\n    const [userListType, setUserListType] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)('active');\n    const exitSearch = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => setSearchQuery(''), []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListHeader, { onClose: onClose }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch: exitSearch, isActive: !!searchQuery }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallParticipantListContentHeader, { userListType: userListType, setUserListType: setUserListType }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list__content\", children: [userListType === 'active' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ActiveUsersSearchResults, { searchQuery: searchQuery, activeUsersSearchFn: activeUsersSearchFn, debounceSearchInterval: debounceSearchInterval })), userListType === 'blocked' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BlockedUsersSearchResults, { searchQuery: searchQuery, blockedUsersSearchFn: blockedUsersSearchFn, debounceSearchInterval: debounceSearchInterval }))] })] }));\n};\nconst CallParticipantListContentHeader = ({ userListType, setUserListType, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const muteAll = () => {\n        call?.muteAllUsers('audio');\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__participant-list__content-header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-list__content-header-title\", children: userListType === 'active' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(TextButton, { onClick: muteAll, children: \"Mute all\" }) })) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { placement: \"bottom-end\", ToggleButton: ToggleButton$1, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenu, { children: Object.keys(UserListTypes).map((lt) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { \"aria-selected\": lt === userListType, onClick: () => setUserListType(lt), children: UserListTypes[lt] }, lt))) }) })] }));\n};\nconst ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, }) => {\n    const { useParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants({ sortBy: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.name });\n    const activeUsersSearchFn = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((queryString) => {\n        const queryRegExp = new RegExp(queryString, 'i');\n        return Promise.resolve(participants.filter((participant) => {\n            return participant.name.match(queryRegExp);\n        }));\n    }, [participants]);\n    const { searchQueryInProgress, searchResults } = useSearch({\n        searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,\n        debounceInterval: debounceSearchInterval,\n        searchQuery,\n    });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing }));\n};\nconst BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval = DEFAULT_DEBOUNCE_SEARCH_INTERVAL, searchQuery, }) => {\n    const { useCallBlockedUserIds } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const blockedUsers = useCallBlockedUserIds();\n    const blockedUsersSearchFn = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((queryString) => {\n        const queryRegExp = new RegExp(queryString, 'i');\n        return Promise.resolve(blockedUsers.filter((blockedUser) => {\n            return blockedUser.match(queryRegExp);\n        }));\n    }, [blockedUsers]);\n    const { searchQueryInProgress, searchResults } = useSearch({\n        searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,\n        debounceInterval: debounceSearchInterval,\n        searchQuery,\n    });\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator: LoadingIndicator, searchQueryInProgress: searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing }));\n};\nconst ToggleButton$1 = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"filter\", ref: ref });\n});\n\nconst CallPreview = (props) => {\n    const { className, style } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallThumbnail } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const thumbnail = useCallThumbnail();\n    const [imageRef, setImageRef] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!imageRef || !call)\n            return;\n        const cleanup = call.bindCallThumbnailElement(imageRef);\n        return () => cleanup();\n    }, [imageRef, call]);\n    if (!thumbnail)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-preview', className), style: style, alt: \"Call Preview Thumbnail\", ref: setImageRef }));\n};\n\nconst CallRecordingListHeader = ({ callRecordings, onRefresh, }) => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__header\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__title\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { children: t('Call Recordings') }), callRecordings.length ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { children: [\"(\", callRecordings.length, \")\"] }) : null] }), onRefresh && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"refresh\", title: t('Refresh'), onClick: onRefresh }))] }));\n};\n\nconst dateFormat = (date) => {\n    const format = new Date(date);\n    return format.toTimeString().split(' ')[0];\n};\nconst CallRecordingListItem = ({ recording, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"li\", { className: \"str-video__call-recording-list__item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__filename\", children: recording.filename }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__time\", children: dateFormat(recording.start_time) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__time\", children: dateFormat(recording.end_time) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__table-cell str-video__call-recording-list__download\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__call-recording-list-item__action-button', 'str-video__call-recording-list-item__action-button--download'), role: \"button\", href: recording.url, download: recording.filename, title: \"Download the recording\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"download\" }) }) })] }));\n};\n\nconst EmptyCallRecordingListing = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list__listing str-video__call-recording-list__listing--empty\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__listing--icon-empty\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", { className: \"str-video__call-recording-list__listing--text-empty\", children: \"No recordings available\" })] }));\n};\n\nconst LoadingCallRecordingListing = ({ callRecordings, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [callRecordings.map((recording) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListItem, { recording: recording }, recording.filename))), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingIndicator, { text: \"Recording getting ready\" })] }));\n};\n\nconst CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-recording-list\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListHeader$1, { callRecordings: callRecordings, onRefresh: onRefresh }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__listing\", children: loading ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LoadingCallRecordingList, { callRecordings: callRecordings })) : callRecordings.length ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__call-recording-list__list\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"li\", { className: \"str-video__call-recording-list__item\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__filename\", children: \"Name\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__time\", children: \"Start time\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__time\", children: \"End time\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-recording-list__download\" })] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"ul\", { className: \"str-video__call-recording-list__list\", children: callRecordings.map((recording) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CallRecordingListItem$1, { recording: recording }, recording.filename))) })] })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(EmptyCallRecordingList, {})) })] }));\n};\n\nconst RingingCallControls = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useCallCallingState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callCallingState = useCallCallingState();\n    if (!call)\n        return null;\n    const buttonsDisabled = callCallingState !== _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__pending-call-controls\", children: call.isCreatedByMe ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { disabled: buttonsDisabled })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(AcceptCallButton, { disabled: buttonsDisabled }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(CancelCallButton, { onClick: () => call.leave({ reject: true }), disabled: buttonsDisabled })] })) }));\n};\n\nconst CALLING_STATE_TO_LABEL = {\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINING]: 'Joining',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING]: 'Ringing',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.MIGRATING]: 'Migrating',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RECONNECTING]: 'Re-connecting',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RECONNECTING_FAILED]: 'Failed',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.OFFLINE]: 'No internet connection',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.IDLE]: '',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.UNKNOWN]: '',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINED]: 'Joined',\n    [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.LEFT]: 'Left call',\n};\nconst RingingCall = (props) => {\n    const { includeSelf = false, totalMembersToShow = 3 } = props;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { useCallCallingState, useCallMembers } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const callingState = useCallCallingState();\n    const members = useCallMembers();\n    const connectedUser = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useConnectedUser)();\n    if (!call)\n        return null;\n    // take the first N members to show their avatars\n    const membersToShow = (members || [])\n        .slice(0, totalMembersToShow)\n        .map(({ user }) => user)\n        .filter((user) => user.id !== connectedUser?.id || includeSelf);\n    if (includeSelf &&\n        !membersToShow.find((user) => user.id === connectedUser?.id)) {\n        // if the current user is not in the initial batch of members,\n        // replace the first item in membersToShow array with the current user\n        const self = members.find(({ user }) => user.id === connectedUser?.id);\n        if (self) {\n            membersToShow.splice(0, 1, self.user);\n        }\n    }\n    const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-panel str-video__call-panel--ringing\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-panel__members-list\", children: membersToShow.map((user) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__call-panel__member-box\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Avatar, { name: user.name, imageSrc: user.image }), user.name && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__member_details\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__member_name\", children: user.name }) }))] }, user.id))) }), callingStateLabel && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__call-panel__calling-state-label\", children: t(callingStateLabel) })), [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.RINGING, _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallingState.JOINING].includes(callingState) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RingingCallControls, {}))] }));\n};\n\nconst byNameOrId = (a, b) => {\n    if (a.name && b.name && a.name < b.name)\n        return -1;\n    if (a.name && b.name && a.name > b.name)\n        return 1;\n    if (a.id < b.id)\n        return -1;\n    if (a.id > b.id)\n        return 1;\n    return 0;\n};\nconst PermissionRequests = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useLocalParticipant, useHasPermissions } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const localParticipant = useLocalParticipant();\n    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [permissionRequests, setPermissionRequests] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    const canUpdateCallPermissions = useHasPermissions(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.UPDATE_CALL_PERMISSIONS);\n    const localUserId = localParticipant?.userId;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call || !canUpdateCallPermissions)\n            return;\n        return call.on('call.permission_request', (event) => {\n            if (event.user.id !== localUserId) {\n                setPermissionRequests((requests) => [...requests, event].sort((a, b) => byNameOrId(a.user, b.user)));\n            }\n        });\n    }, [call, canUpdateCallPermissions, localUserId]);\n    const handleUpdatePermission = (request, type) => {\n        return async () => {\n            const { user, permissions } = request;\n            switch (type) {\n                case 'grant':\n                    await call?.grantPermissions(user.id, permissions);\n                    break;\n                case 'revoke':\n                    await call?.revokePermissions(user.id, permissions);\n                    break;\n            }\n            setPermissionRequests((requests) => requests.filter((r) => r !== request));\n        };\n    };\n    const { refs, x, y, strategy } = useFloatingUIPreset({\n        placement: 'bottom',\n        strategy: 'absolute',\n    });\n    // don't render anything if there are no permission requests\n    if (permissionRequests.length === 0)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-requests\", ref: refs.setReference, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-requests__notification\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__permission-requests__notification__message\", children: [permissionRequests.length, \" pending permission requests\"] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { type: \"button\", onClick: () => {\n                            setExpanded((e) => !e);\n                        }, children: expanded ? 'Hide requests' : 'Show requests' })] }), expanded && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PermissionRequestList, { ref: refs.setFloating, style: {\n                    position: strategy,\n                    top: y ?? 0,\n                    left: x ?? 0,\n                    overflowY: 'auto',\n                }, permissionRequests: permissionRequests, handleUpdatePermission: handleUpdatePermission }))] }));\n};\nconst PermissionRequestList = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function PermissionRequestList(props, ref) {\n    const { permissionRequests, handleUpdatePermission, ...rest } = props;\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__permission-requests-list\", ref: ref, ...rest, children: permissionRequests.map((request, reqIndex) => {\n            const { user, permissions } = request;\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, { children: permissions.map((permission) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__permission-request\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__permission-request__message\", children: messageForPermission(user.name || user.id, permission, t) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--allow\", type: \"button\", onClick: handleUpdatePermission(request, 'grant'), children: t('Allow') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--reject\", type: \"button\", onClick: handleUpdatePermission(request, 'revoke'), children: t('Revoke') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Button, { className: \"str-video__permission-request__button--reject\", type: \"button\", onClick: handleUpdatePermission(request, 'dismiss'), children: t('Dismiss') })] }, permission))) }, `${user.id}/${reqIndex}`));\n        }) }));\n});\nconst Button = (props) => {\n    const { className, ...rest } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__permission-request__button', className), ...rest }));\n};\nconst messageForPermission = (userName, permission, t) => {\n    switch (permission) {\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO:\n            return t('{{ userName }} is requesting to speak', { userName });\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO:\n            return t('{{ userName }} is requesting to share their camera', {\n                userName,\n            });\n        case _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE:\n            return t('{{ userName }} is requesting to present their screen', {\n                userName,\n            });\n        default:\n            return t('{{ userName }} is requesting permission: {{ permission }}', {\n                userName,\n                permission,\n            });\n    }\n};\n\nconst StreamTheme = ({ as: Component = 'div', className, children, ...props }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Component, { ...props, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video', className), children: children }));\n};\n\nconst DefaultVideoPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function DefaultVideoPlaceholder({ participant, style }, ref) {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const name = participant.name || participant.userId;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__video-placeholder\", style: style, ref: ref, children: [(!participant.image || error) &&\n                (name ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(InitialsFallback, { name: name })) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__video-placeholder__no-video-label\", children: t('Video is disabled') }))), participant.image && !error && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", { onError: () => setError(true), alt: \"video-placeholder\", className: \"str-video__video-placeholder__avatar\", src: participant.image }))] }));\n});\nconst InitialsFallback = (props) => {\n    const { name } = props;\n    const initials = name\n        .split(' ')\n        .slice(0, 2)\n        .map((n) => n[0])\n        .join('');\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__video-placeholder__initials-fallback\", children: initials }));\n};\n\nconst Video$1 = ({ trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder, refs, ...rest }) => {\n    const { sessionId, videoStream, screenShareStream, publishedTracks, viewportVisibilityState, isLocalParticipant, userId, } = participant;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [videoElement, setVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // start with true, will flip once the video starts playing\n    const [isVideoPaused, setIsVideoPaused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const [isWideMode, setIsWideMode] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true);\n    const stream = trackType === 'videoTrack'\n        ? videoStream\n        : trackType === 'screenShareTrack'\n            ? screenShareStream\n            : undefined;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect)(() => {\n        if (!call || !videoElement || trackType === 'none')\n            return;\n        const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);\n        return () => {\n            cleanup?.();\n        };\n    }, [call, trackType, sessionId, videoElement]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!stream || !videoElement)\n            return;\n        const [track] = stream.getVideoTracks();\n        if (!track)\n            return;\n        const handlePlayPause = () => {\n            setIsVideoPaused(videoElement.paused);\n            const { width = 0, height = 0 } = track.getSettings();\n            setIsWideMode(width >= height);\n        };\n        // playback may have started before we had a chance to\n        // attach the 'play/pause' event listener, so we set the state\n        // here to make sure it's in sync\n        setIsVideoPaused(videoElement.paused);\n        videoElement.addEventListener('play', handlePlayPause);\n        videoElement.addEventListener('pause', handlePlayPause);\n        track.addEventListener('unmute', handlePlayPause);\n        return () => {\n            videoElement.removeEventListener('play', handlePlayPause);\n            videoElement.removeEventListener('pause', handlePlayPause);\n            track.removeEventListener('unmute', handlePlayPause);\n            // reset the 'pause' state once we unmount the video element\n            setIsVideoPaused(true);\n        };\n    }, [stream, videoElement]);\n    if (!call)\n        return null;\n    const isPublishingTrack = trackType === 'videoTrack'\n        ? publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO)\n        : trackType === 'screenShareTrack'\n            ? publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE)\n            : false;\n    const isInvisible = trackType === 'none' ||\n        viewportVisibilityState?.[trackType] === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.VisibilityState.INVISIBLE;\n    const hasNoVideoOrInvisible = !isPublishingTrack || isInvisible;\n    const mirrorVideo = isLocalParticipant && trackType === 'videoTrack';\n    const isScreenShareTrack = trackType === 'screenShareTrack';\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [!hasNoVideoOrInvisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { ...rest, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video', className, {\n                    'str-video__video--not-playing': isVideoPaused,\n                    'str-video__video--tall': !isWideMode,\n                    'str-video__video--mirror': mirrorVideo,\n                    'str-video__video--screen-share': isScreenShareTrack,\n                }), \"data-user-id\": userId, \"data-session-id\": sessionId, ref: (element) => {\n                    setVideoElement(element);\n                    refs?.setVideoElement?.(element);\n                } })), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VideoPlaceholder, { style: { position: 'absolute' }, participant: participant, ref: refs?.setVideoPlaceholderElement }))] }));\n};\n\n/**\n * @description Extends video element with `stream` property\n * (`srcObject`) to reactively handle stream changes\n */\nconst BaseVideo = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function BaseVideo({ stream, ...rest }, ref) {\n    const [videoElement, setVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoElement || !stream)\n            return;\n        if (stream === videoElement.srcObject)\n            return;\n        videoElement.srcObject = stream;\n        if (_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers.isSafari() || _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.Browsers.isFirefox()) {\n            // Firefox and Safari have some timing issue\n            setTimeout(() => {\n                videoElement.srcObject = stream;\n                videoElement.play().catch((e) => {\n                    console.error(`Failed to play stream`, e);\n                });\n            }, 0);\n        }\n        return () => {\n            videoElement.pause();\n            videoElement.srcObject = null;\n        };\n    }, [stream, videoElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"video\", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {\n            applyElementToRef(ref, element);\n            setVideoElement(element);\n        } }));\n});\n\nconst DefaultDisabledVideoPreview = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str_video__video-preview__disabled-video-preview\", children: t('Video is disabled') }));\n};\nconst DefaultNoCameraPreview = () => {\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str_video__video-preview__no-camera-preview\", children: t('No camera found') }));\n};\nconst VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator, }) => {\n    const { useCameraState } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const { devices, status, isMute, mediaStream } = useCameraState();\n    let contents;\n    if (isMute && devices?.length === 0) {\n        contents = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(NoCameraPreview, {});\n    }\n    else if (status === 'enabled') {\n        const loading = !mediaStream;\n        contents = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [mediaStream && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(BaseVideo, { stream: mediaStream, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video-preview', {\n                        'str-video__video-preview--mirror': mirror,\n                        'str-video__video-preview--loading': loading,\n                    }) })), loading && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(StartingCameraPreview, {})] }));\n    }\n    else {\n        contents = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DisabledVideoPreview, {});\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__video-preview-container', className), children: contents }));\n};\n\nconst ParticipantActionsContextMenu = () => {\n    const { participant, participantViewElement, videoElement } = useParticipantViewContext();\n    const [fullscreenModeOn, setFullscreenModeOn] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!!document.fullscreenElement);\n    const [pictureInPictureElement, setPictureInPictureElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(document.pictureInPictureElement);\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const { pin, publishedTracks, sessionId, userId } = participant;\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const hasScreenShare = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n    const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n    const blockUser = () => call?.blockUser(userId);\n    const muteAudio = () => call?.muteUser(userId, 'audio');\n    const muteVideo = () => call?.muteUser(userId, 'video');\n    const muteScreenShare = () => call?.muteUser(userId, 'screenshare');\n    const muteScreenShareAudio = () => call?.muteUser(userId, 'screenshare_audio');\n    const grantPermission = (permission) => () => {\n        call?.updateUserPermissions({\n            user_id: userId,\n            grant_permissions: [permission],\n        });\n    };\n    const revokePermission = (permission) => () => {\n        call?.updateUserPermissions({\n            user_id: userId,\n            revoke_permissions: [permission],\n        });\n    };\n    const toggleParticipantPin = () => {\n        if (pin) {\n            call?.unpin(sessionId);\n        }\n        else {\n            call?.pin(sessionId);\n        }\n    };\n    const pinForEveryone = () => {\n        call\n            ?.pinForEveryone({\n            user_id: userId,\n            session_id: sessionId,\n        })\n            .catch((err) => {\n            console.error(`Failed to pin participant ${userId}`, err);\n        });\n    };\n    const unpinForEveryone = () => {\n        call\n            ?.unpinForEveryone({\n            user_id: userId,\n            session_id: sessionId,\n        })\n            .catch((err) => {\n            console.error(`Failed to unpin participant ${userId}`, err);\n        });\n    };\n    const toggleFullscreenMode = () => {\n        if (!fullscreenModeOn) {\n            return participantViewElement?.requestFullscreen().catch(console.error);\n        }\n        return document.exitFullscreen().catch(console.error);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        // handles the case when fullscreen mode is toggled externally,\n        // e.g., by pressing ESC key or some other keyboard shortcut\n        const handleFullscreenChange = () => {\n            setFullscreenModeOn(!!document.fullscreenElement);\n        };\n        document.addEventListener('fullscreenchange', handleFullscreenChange);\n        return () => {\n            document.removeEventListener('fullscreenchange', handleFullscreenChange);\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!videoElement)\n            return;\n        const handlePiP = () => {\n            setPictureInPictureElement(document.pictureInPictureElement);\n        };\n        videoElement.addEventListener('enterpictureinpicture', handlePiP);\n        videoElement.addEventListener('leavepictureinpicture', handlePiP);\n        return () => {\n            videoElement.removeEventListener('enterpictureinpicture', handlePiP);\n            videoElement.removeEventListener('leavepictureinpicture', handlePiP);\n        };\n    }, [videoElement]);\n    const togglePictureInPicture = () => {\n        if (videoElement && pictureInPictureElement !== videoElement) {\n            return videoElement\n                .requestPictureInPicture()\n                .catch(console.error);\n        }\n        return document.exitPictureInPicture().catch(console.error);\n    };\n    const { close } = useMenuContext() || {};\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenu, { onItemClick: close, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), pin ? t('Unpin') : t('Pin')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.PIN_FOR_EVERYONE], children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), t('Pin for everyone')] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"pin\" }), t('Unpin for everyone')] })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.BLOCK_USERS], children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: blockUser, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"not-allowed\" }), t('Block')] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.MUTE_USERS], children: [hasVideo && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteVideo, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"camera-off-outline\" }), t('Turn off video')] })), hasScreenShare && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShare, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"screen-share-off\" }), t('Turn off screen share')] })), hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteAudio, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"no-audio\" }), t('Mute audio')] })), hasScreenShareAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"no-audio\" }), t('Mute screen share audio')] }))] }), participantViewElement && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t('{{ direction }} fullscreen', {\n                    direction: fullscreenModeOn ? t('Leave') : t('Enter'),\n                }) })), videoElement && document.pictureInPictureEnabled && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t('{{ direction }} picture-in-picture', {\n                    direction: pictureInPictureElement === videoElement\n                        ? t('Leave')\n                        : t('Enter'),\n                }) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.Restricted, { requiredGrants: [_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.UPDATE_CALL_PERMISSIONS], children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO), children: t('Allow audio') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO), children: t('Allow video') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: grantPermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE), children: t('Allow screen sharing') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_AUDIO), children: t('Disable audio') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SEND_VIDEO), children: t('Disable video') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(GenericMenuButtonItem, { onClick: revokePermission(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.OwnCapability.SCREENSHARE), children: t('Disable screen sharing') })] })] }));\n};\n\nconst useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const manager = propsDynascaleManager ?? call?.dynascaleManager;\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!trackedElement || !manager || !call || trackType === 'none')\n            return;\n        const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);\n        return () => {\n            unobserve();\n        };\n    }, [trackedElement, manager, call, sessionId, trackType]);\n};\n\nconst ToggleButton = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ToggleButton(props, ref) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { enabled: props.menuShown, icon: \"ellipsis\", ref: ref });\n});\nconst DefaultScreenShareOverlay = () => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const stopScreenShare = () => {\n        call?.screenShare.disable();\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__screen-share-overlay\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"screen-share-off\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__screen-share-overlay__title\", children: t('You are presenting your screen') }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { onClick: stopScreenShare, className: \"str-video__screen-share-overlay__button\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Icon, { icon: \"close\" }), \" \", t('Stop Screen Sharing')] })] }));\n};\nconst DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = 'bottom-start', showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu, }) => {\n    const { participant, trackType } = useParticipantViewContext();\n    const { publishedTracks } = participant;\n    const hasScreenShare = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n    if (participant.isLocalParticipant &&\n        hasScreenShare &&\n        trackType === 'screenShareTrack') {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultScreenShareOverlay, {}), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [showMenuButton && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MenuToggle, { strategy: \"fixed\", placement: menuPlacement, ToggleButton: ToggleButton, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantActionsContextMenu$1, {}) })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Reaction, { participant: participant }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantDetails, { indicatorsVisible: indicatorsVisible })] }));\n};\nconst ParticipantDetails = ({ indicatorsVisible = true, }) => {\n    const { participant } = useParticipantViewContext();\n    const { isLocalParticipant, connectionQuality, publishedTracks, pin, sessionId, name, userId, } = participant;\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    const connectionQualityAsString = !!connectionQuality &&\n        _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.ConnectionQuality[connectionQuality].toLowerCase();\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const canUnpin = !!pin && pin.isLocalPin;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__participant-details\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: \"str-video__participant-details__name\", children: [name || userId, indicatorsVisible && !hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-details__name--audio-muted\" })), indicatorsVisible && !hasVideo && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__participant-details__name--video-muted\" })), indicatorsVisible && canUnpin && (\n                        // TODO: remove this monstrosity once we have a proper design\n                        (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { title: t('Unpin'), onClick: () => call?.unpin(sessionId), className: \"str-video__participant-details__name--pinned\" })), indicatorsVisible && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SpeechIndicator, {})] }) }), indicatorsVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Notification, { isVisible: isLocalParticipant &&\n                    connectionQuality === _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.ConnectionQuality.POOR, message: t('Poor connection quality'), children: connectionQualityAsString && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-details__connection-quality', `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString })) }))] }));\n};\nconst SpeechIndicator = () => {\n    const { participant } = useParticipantViewContext();\n    const { isSpeaking, isDominantSpeaker } = participant;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"span\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__speech-indicator', isSpeaking && 'str-video__speech-indicator--speaking', isDominantSpeaker && 'str-video__speech-indicator--dominant'), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__speech-indicator__bar\" })] }));\n};\n\nconst ParticipantView = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function ParticipantView({ participant, trackType = 'videoTrack', muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }, ref) {\n    const { isLocalParticipant, isSpeaking, isDominantSpeaker, publishedTracks, sessionId, } = participant;\n    const hasAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.AUDIO);\n    const hasVideo = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.VIDEO);\n    const hasScreenShareAudio = publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE_AUDIO);\n    const [trackedElement, setTrackedElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [contextVideoElement, setContextVideoElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    // TODO: allow to pass custom ViewportTracker instance from props\n    useTrackElementVisibility({\n        sessionId,\n        trackedElement,\n        trackType,\n    });\n    const participantViewContextValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        participant,\n        participantViewElement: trackedElement,\n        videoElement: contextVideoElement,\n        videoPlaceholderElement: contextVideoPlaceholderElement,\n        trackType,\n    }), [\n        contextVideoElement,\n        contextVideoPlaceholderElement,\n        participant,\n        trackedElement,\n        trackType,\n    ]);\n    const videoRefs = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => ({\n        setVideoElement: (element) => {\n            setVideoElement?.(element);\n            setContextVideoElement(element);\n        },\n        setVideoPlaceholderElement: (element) => {\n            setVideoPlaceholderElement?.(element);\n            setContextVideoPlaceholderElement(element);\n        },\n    }), [setVideoElement, setVideoPlaceholderElement]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { \"data-testid\": \"participant-view\", ref: (element) => {\n            applyElementToRef(ref, element);\n            setTrackedElement(element);\n        }, className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__participant-view', isDominantSpeaker && 'str-video__participant-view--dominant-speaker', isSpeaking && 'str-video__participant-view--speaking', !hasVideo && 'str-video__participant-view--no-video', !hasAudio && 'str-video__participant-view--no-audio', className), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [hasAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { participant: participant, trackType: \"audioTrack\" })), hasScreenShareAudio && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Audio, { participant: participant, trackType: \"screenShareAudioTrack\" }))] })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Video$1, { VideoPlaceholder: VideoPlaceholder, participant: participant, trackType: trackType, refs: videoRefs, autoPlay: true }), isComponentType(ParticipantViewUI) ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantViewUI, {})) : (ParticipantViewUI)] }) }));\n});\n\n// re-exporting the StreamCallProvider as StreamCall\nconst StreamCall = _stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamCallProvider;\n\nvar Joining = \"Joining\";\nvar Mic = \"Mic\";\nvar Ringing = \"Ringing\";\nvar Speakers = \"Speakers\";\nvar Video = \"Video\";\nvar Live = \"Live\";\nvar Reactions = \"Reactions\";\nvar Statistics = \"Statistics\";\nvar Invite = \"Invite\";\nvar Join = \"Join\";\nvar You = \"You\";\nvar Me = \"Me\";\nvar Unknown = \"Unknown\";\nvar Refresh = \"Refresh\";\nvar Allow = \"Allow\";\nvar Revoke = \"Revoke\";\nvar Dismiss = \"Dismiss\";\nvar Pinned = \"Pinned\";\nvar Unpin = \"Unpin\";\nvar Pin = \"Pin\";\nvar Block = \"Block\";\nvar Enter = \"Enter\";\nvar Leave = \"Leave\";\nvar Participants = \"Participants\";\nvar Anonymous = \", and ({{ count }}) anonymous\";\nvar en = {\n\tJoining: Joining,\n\tMic: Mic,\n\t\"No internet connection\": \"No internet connection\",\n\t\"Re-connecting\": \"Re-connecting\",\n\tRinging: Ringing,\n\t\"Screen Share\": \"Screen Share\",\n\t\"Select a Camera\": \"Select a Camera\",\n\t\"Select a Mic\": \"Select a Mic\",\n\t\"Select Speakers\": \"Select Speakers\",\n\tSpeakers: Speakers,\n\tVideo: Video,\n\t\"You are muted. Unmute to speak.\": \"You are muted. Unmute to speak.\",\n\tLive: Live,\n\t\"You can now speak.\": \"You can now speak.\",\n\t\"Awaiting for an approval to speak.\": \"Awaiting for an approval to speak.\",\n\t\"You can no longer speak.\": \"You can no longer speak.\",\n\t\"You can now share your video.\": \"You can now share your video.\",\n\t\"Awaiting for an approval to share your video.\": \"Awaiting for an approval to share your video.\",\n\t\"You can no longer share your video.\": \"You can no longer share your video.\",\n\t\"Waiting for recording to stop...\": \"Waiting for recording to stop...\",\n\t\"Waiting for recording to start...\": \"Waiting for recording to start...\",\n\t\"Record call\": \"Record call\",\n\tReactions: Reactions,\n\tStatistics: Statistics,\n\t\"You can now share your screen.\": \"You can now share your screen.\",\n\t\"Awaiting for an approval to share screen.\": \"Awaiting for an approval to share screen.\",\n\t\"You can no longer share your screen.\": \"You can no longer share your screen.\",\n\t\"Share screen\": \"Share screen\",\n\t\"Incoming Call...\": \"Incoming Call...\",\n\t\"Calling...\": \"Calling...\",\n\t\"Mute All\": \"Mute All\",\n\tInvite: Invite,\n\tJoin: Join,\n\tYou: You,\n\tMe: Me,\n\tUnknown: Unknown,\n\t\"Toggle device menu\": \"Toggle device menu\",\n\t\"Call Recordings\": \"Call Recordings\",\n\tRefresh: Refresh,\n\t\"Check your browser video permissions\": \"Check your browser video permissions\",\n\t\"Video publishing is disabled by the system\": \"Video publishing is disabled by the system\",\n\t\"You have no permission to share your video\": \"You have no permission to share your video\",\n\t\"You have no permission to share your audio\": \"You have no permission to share your audio\",\n\t\"You are presenting your screen\": \"You are presenting your screen\",\n\t\"Stop Screen Sharing\": \"Stop Screen Sharing\",\n\tAllow: Allow,\n\tRevoke: Revoke,\n\tDismiss: Dismiss,\n\t\"Microphone on\": \"Microphone on\",\n\t\"Microphone off\": \"Microphone off\",\n\t\"Camera on\": \"Camera on\",\n\t\"Camera off\": \"Camera off\",\n\t\"No camera found\": \"No camera found\",\n\t\"Video is disabled\": \"Video is disabled\",\n\tPinned: Pinned,\n\tUnpin: Unpin,\n\tPin: Pin,\n\t\"Pin for everyone\": \"Pin for everyone\",\n\t\"Unpin for everyone\": \"Unpin for everyone\",\n\tBlock: Block,\n\t\"Turn off video\": \"Turn off video\",\n\t\"Turn off screen share\": \"Turn off screen share\",\n\t\"Mute audio\": \"Mute audio\",\n\t\"Mute screen share audio\": \"Mute screen share audio\",\n\t\"Allow audio\": \"Allow audio\",\n\t\"Allow video\": \"Allow video\",\n\t\"Allow screen sharing\": \"Allow screen sharing\",\n\t\"Disable audio\": \"Disable audio\",\n\t\"Disable video\": \"Disable video\",\n\t\"Disable screen sharing\": \"Disable screen sharing\",\n\tEnter: Enter,\n\tLeave: Leave,\n\t\"Leave call\": \"Leave call\",\n\t\"End call for all\": \"End call for all\",\n\t\"{{ direction }} fullscreen\": \"{{ direction }} fullscreen\",\n\t\"{{ direction }} picture-in-picture\": \"{{ direction }} picture-in-picture\",\n\t\"Dominant Speaker\": \"Dominant Speaker\",\n\t\"Poor connection quality\": \"Poor connection quality. Please check your internet connection.\",\n\tParticipants: Participants,\n\tAnonymous: Anonymous,\n\t\"No participants found\": \"No participants found\",\n\t\"Participants ({{ numberOfParticipants }})\": \"Participants ({{ numberOfParticipants }})\",\n\t\"{{ userName }} is sharing their screen\": \"{{ userName }} is sharing their screen\",\n\t\"{{ userName }} is requesting to speak\": \"{{ userName }} is requesting to speak\",\n\t\"{{ userName }} is requesting to share their camera\": \"{{ userName }} is requesting to share their camera\",\n\t\"{{ userName }} is requesting to present their screen\": \"{{ userName }} is requesting to present their screen\",\n\t\"{{ userName }} is requesting permission: {{ permission }}\": \"{{ userName }} is requesting permission: {{ permission }}\"\n};\n\nconst translations = { en };\n\nconst StreamVideo = (props) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.StreamVideoProvider, { translationsOverrides: translations, ...props }));\n};\n\nconst usePaginatedLayoutSortPreset = (call) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call)\n            return;\n        call.setSortParticipantsBy(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.paginatedLayoutSortPreset);\n        return () => {\n            resetSortPreset(call);\n        };\n    }, [call]);\n};\nconst useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!call)\n            return;\n        // always show the remote participant in the spotlight\n        if (isOneOnOneCall) {\n            call.setSortParticipantsBy((0,_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.combineComparators)(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.screenSharing, loggedIn));\n        }\n        else {\n            call.setSortParticipantsBy(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.speakerLayoutSortPreset);\n        }\n        return () => {\n            resetSortPreset(call);\n        };\n    }, [call, isOneOnOneCall]);\n};\nconst resetSortPreset = (call) => {\n    // reset the sorting to the default for the call type\n    const callConfig = _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.CallTypes.get(call.type);\n    call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.defaultSortPreset);\n};\nconst loggedIn = (a, b) => {\n    if (a.isLocalParticipant)\n        return 1;\n    if (b.isLocalParticipant)\n        return -1;\n    return 0;\n};\n\nconst LivestreamLayout = (props) => {\n    const { useParticipants, useRemoteParticipants, useHasOngoingScreenShare } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const [currentSpeaker, ...otherParticipants] = useParticipants();\n    const remoteParticipants = useRemoteParticipants();\n    const hasOngoingScreenShare = useHasOngoingScreenShare();\n    const presenter = hasOngoingScreenShare\n        ? hasScreenShare$1(currentSpeaker) && currentSpeaker\n        : otherParticipants.find(hasScreenShare$1);\n    usePaginatedLayoutSortPreset(call);\n    const Overlay = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showSpeakerName: props.showSpeakerName }));\n    const { floatingParticipantProps } = props;\n    const FloatingParticipantOverlay = hasOngoingScreenShare && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantOverlay\n    // these elements aren't needed for the video feed\n    , { \n        // these elements aren't needed for the video feed\n        showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false, showDuration: floatingParticipantProps?.showDuration ?? false, showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false, showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true }));\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__livestream-layout__wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { className: \"str-video__livestream-layout__screen-share\", participant: presenter, ParticipantViewUI: Overlay, trackType: \"screenShareTrack\", muteAudio // audio is rendered by ParticipantsAudio\n                : true })), currentSpeaker && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(hasOngoingScreenShare &&\n                    (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__livestream-layout__floating-participant', `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? 'top-right'}`)), participant: currentSpeaker, ParticipantViewUI: FloatingParticipantOverlay || Overlay, muteAudio // audio is rendered by ParticipantsAudio\n                : true }))] }));\n};\nconst hasScreenShare$1 = (p) => !!p?.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\nconst ParticipantOverlay = (props) => {\n    const { enableFullScreen = true, showParticipantCount = true, showDuration = true, showLiveBadge = true, showSpeakerName = false, } = props;\n    const { participant } = useParticipantViewContext();\n    const { useParticipantCount } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participantCount = useParticipantCount();\n    const duration = useUpdateCallDuration();\n    const toggleFullScreen = useToggleFullScreen();\n    const { t } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useI18n)();\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__livestream-layout__overlay\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__livestream-layout__overlay__bar\", children: [showLiveBadge && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__live-badge\", children: t('Live') })), showParticipantCount && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__viewers-count\", children: participantCount })), showSpeakerName && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__speaker-name\", title: participant.name || participant.userId || '', children: participant.name || participant.userId || '' })), showDuration && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__duration\", children: formatDuration(duration) })), enableFullScreen && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", { className: \"str-video__livestream-layout__go-fullscreen\", onClick: toggleFullScreen }))] }) }));\n};\nconst useUpdateCallDuration = () => {\n    const { useIsCallLive, useCallSession } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const isCallLive = useIsCallLive();\n    const session = useCallSession();\n    const [duration, setDuration] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n        if (!session || !session.live_started_at)\n            return 0;\n        const liveStartTime = new Date(session.live_started_at);\n        const now = new Date();\n        return Math.floor((now.getTime() - liveStartTime.getTime()) / 1000);\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!isCallLive)\n            return;\n        const interval = setInterval(() => {\n            setDuration((d) => d + 1);\n        }, 1000);\n        return () => {\n            clearInterval(interval);\n        };\n    }, [isCallLive]);\n    return duration;\n};\nconst useToggleFullScreen = () => {\n    const { participantViewElement } = useParticipantViewContext();\n    const [isFullscreen, setIsFullscreen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n        if (isFullscreen) {\n            document.exitFullscreen().then(() => {\n                setIsFullscreen(false);\n            });\n        }\n        else {\n            participantViewElement?.requestFullscreen().then(() => {\n                setIsFullscreen(true);\n            });\n        }\n    }, [isFullscreen, participantViewElement]);\n};\nconst formatDuration = (durationInMs) => {\n    const days = Math.floor(durationInMs / 86400);\n    const hours = Math.floor(durationInMs / 3600);\n    const minutes = Math.floor((durationInMs % 3600) / 60);\n    const seconds = durationInMs % 60;\n    return `${days ? days + ' ' : ''}${hours ? hours + ':' : ''}${minutes < 10 ? '0' : ''}${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n};\n\nconst GROUP_SIZE = 16;\nconst PaginatedGridLayoutGroup = ({ group, VideoPlaceholder, ParticipantViewUI, }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__paginated-grid-layout__group', {\n            'str-video__paginated-grid-layout--one': group.length === 1,\n            'str-video__paginated-grid-layout--two-four': group.length >= 2 && group.length <= 4,\n            'str-video__paginated-grid-layout--five-nine': group.length >= 5 && group.length <= 9,\n        }), children: group.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participant, muteAudio: true, VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI }, participant.sessionId))) }));\n};\nconst PaginatedGridLayout = ({ groupSize = GROUP_SIZE, excludeLocalParticipant = false, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, }) => {\n    const [page, setPage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(0);\n    const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement,] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useParticipants, useRemoteParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const participants = useParticipants();\n    // used to render audio elements\n    const remoteParticipants = useRemoteParticipants();\n    usePaginatedLayoutSortPreset(call);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!paginatedGridLayoutWrapperElement || !call)\n            return;\n        const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);\n        return () => cleanup();\n    }, [paginatedGridLayoutWrapperElement, call]);\n    // only used to render video elements\n    const participantGroups = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => chunk(excludeLocalParticipant ? remoteParticipants : participants, groupSize), [excludeLocalParticipant, remoteParticipants, participants, groupSize]);\n    const pageCount = participantGroups.length;\n    // update page when page count is reduced and selected page no longer exists\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (page > pageCount - 1) {\n            setPage(Math.max(0, pageCount - 1));\n        }\n    }, [page, pageCount]);\n    const selectedGroup = participantGroups[page];\n    if (!call)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__paginated-grid-layout__wrapper\", ref: setPaginatedGridLayoutWrapperElement, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__paginated-grid-layout\", children: [pageArrowsVisible && pageCount > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { icon: \"caret-left\", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) })), selectedGroup && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PaginatedGridLayoutGroup, { group: participantGroups[page], VideoPlaceholder: VideoPlaceholder, ParticipantViewUI: ParticipantViewUI })), pageArrowsVisible && pageCount > 1 && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { disabled: page === pageCount - 1, icon: \"caret-right\", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) }))] })] }));\n};\n\nconst useCalculateHardLimit = (\n/**\n * Element that stretches to 100% of the whole layout component\n */\nwrapperElement, \n/**\n * Element that directly hosts individual `ParticipantView` (or wrapper) elements\n */\nhostElement, limit) => {\n    const [calculatedLimit, setCalculatedLimit] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        vertical: typeof limit === 'number' ? limit : null,\n        horizontal: typeof limit === 'number' ? limit : null,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!hostElement ||\n            !wrapperElement ||\n            typeof limit === 'number' ||\n            typeof limit === 'undefined')\n            return;\n        let childWidth = null;\n        let childHeight = null;\n        const resizeObserver = new ResizeObserver((entries, observer) => {\n            // this part should ideally run as little times as possible\n            // get child measurements and disconnect\n            // does not consider dynamically sized children\n            // this hook is for SpeakerLayout use only, where children in the bar are fixed size\n            if (entries.length > 1) {\n                const child = hostElement.firstChild;\n                if (child) {\n                    childHeight = child.clientHeight;\n                    childWidth = child.clientWidth;\n                    observer.unobserve(hostElement);\n                }\n            }\n            // keep the state at { vertical: 1, horizontal: 1 }\n            // until we get the proper child measurements\n            if (childHeight === null || childWidth === null)\n                return;\n            const vertical = Math.floor(wrapperElement.clientHeight / childHeight);\n            const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);\n            setCalculatedLimit((pv) => {\n                if (pv.vertical !== vertical || pv.horizontal !== horizontal)\n                    return { vertical, horizontal };\n                return pv;\n            });\n        });\n        resizeObserver.observe(wrapperElement);\n        resizeObserver.observe(hostElement);\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, [hostElement, limit, wrapperElement]);\n    return calculatedLimit;\n};\n\nconst DefaultParticipantViewUIBar = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultParticipantViewUI, { menuPlacement: \"top-end\" }));\nconst DefaultParticipantViewUISpotlight = () => (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(DefaultParticipantViewUI, {});\nconst SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUISpotlight, VideoPlaceholder, participantsBarPosition = 'bottom', participantsBarLimit, }) => {\n    const call = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCall)();\n    const { useParticipants, useRemoteParticipants } = (0,_stream_io_video_react_bindings__WEBPACK_IMPORTED_MODULE_1__.useCallStateHooks)();\n    const [participantInSpotlight, ...otherParticipants] = useParticipants();\n    const remoteParticipants = useRemoteParticipants();\n    const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [participantsBarElement, setParticipantsBarElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [buttonsWrapperElement, setButtonsWrapperElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const isSpeakerScreenSharing = hasScreenShare(participantInSpotlight);\n    const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);\n    const isVertical = participantsBarPosition === 'left' || participantsBarPosition === 'right';\n    const isHorizontal = participantsBarPosition === 'top' || participantsBarPosition === 'bottom';\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n        if (!participantsBarWrapperElement || !call)\n            return;\n        const cleanup = call.setViewport(participantsBarWrapperElement);\n        return () => cleanup();\n    }, [participantsBarWrapperElement, call]);\n    const isOneOnOneCall = otherParticipants.length === 1;\n    useSpeakerLayoutSortPreset(call, isOneOnOneCall);\n    let participantsWithAppliedLimit = otherParticipants;\n    const hardLimitToApply = isVertical\n        ? hardLimit.vertical\n        : hardLimit.horizontal;\n    if (typeof participantsBarLimit !== 'undefined' &&\n        hardLimitToApply !== null) {\n        participantsWithAppliedLimit = otherParticipants.slice(0, \n        // subtract 1 if speaker is sharing screen as\n        // that one is rendered independently from otherParticipants array\n        hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0));\n    }\n    if (!call)\n        return null;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: \"str-video__speaker-layout__wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_4__[\"default\"])('str-video__speaker-layout', participantsBarPosition &&\n                    `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__spotlight\", children: participantInSpotlight && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participantInSpotlight, muteAudio: true, trackType: isSpeakerScreenSharing ? 'screenShareTrack' : 'videoTrack', ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder: VideoPlaceholder })) }), participantsWithAppliedLimit.length > 0 && participantsBarPosition && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: setButtonsWrapperElement, className: \"str-video__speaker-layout__participants-bar-buttons-wrapper\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participants-bar-wrapper\", ref: setParticipantsBarWrapperElement, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: setParticipantsBarElement, className: \"str-video__speaker-layout__participants-bar\", children: [isSpeakerScreenSharing && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participant-tile\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, muteAudio: true }) }, participantInSpotlight.sessionId)), participantsWithAppliedLimit.map((participant) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { className: \"str-video__speaker-layout__participant-tile\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ParticipantView, { participant: participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder: VideoPlaceholder, muteAudio: true }) }, participant.sessionId)))] }) }), isVertical && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement })), isHorizontal && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement }))] }))] })] }));\n};\nconst HorizontalScrollButtons = ({ scrollWrapper, }) => {\n    const scrollPosition = useHorizontalScrollPosition(scrollWrapper);\n    const scrollStartClickHandler = () => {\n        scrollWrapper?.scrollBy({ left: -150, behavior: 'smooth' });\n    };\n    const scrollEndClickHandler = () => {\n        scrollWrapper?.scrollBy({ left: 150, behavior: 'smooth' });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [scrollPosition && scrollPosition !== 'start' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollStartClickHandler, icon: \"caret-left\", className: \"str-video__speaker-layout__participants-bar--button-left\" })), scrollPosition && scrollPosition !== 'end' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollEndClickHandler, icon: \"caret-right\", className: \"str-video__speaker-layout__participants-bar--button-right\" }))] }));\n};\nconst VerticalScrollButtons = ({ scrollWrapper, }) => {\n    const scrollPosition = useVerticalScrollPosition(scrollWrapper);\n    const scrollTopClickHandler = () => {\n        scrollWrapper?.scrollBy({ top: -150, behavior: 'smooth' });\n    };\n    const scrollBottomClickHandler = () => {\n        scrollWrapper?.scrollBy({ top: 150, behavior: 'smooth' });\n    };\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [scrollPosition && scrollPosition !== 'top' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollTopClickHandler, icon: \"caret-up\", className: \"str-video__speaker-layout__participants-bar--button-top\" })), scrollPosition && scrollPosition !== 'bottom' && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(IconButton, { onClick: scrollBottomClickHandler, icon: \"caret-down\", className: \"str-video__speaker-layout__participants-bar--button-bottom\" }))] }));\n};\nconst hasScreenShare = (p) => !!p?.publishedTracks.includes(_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.TrackType.SCREEN_SHARE);\n\nconst [major, minor, patch] = (\"0.5.1\" ).split('.');\n(0,_stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.setSdkInfo)({\n    type: _stream_io_video_client__WEBPACK_IMPORTED_MODULE_0__.SfuModels.SdkType.REACT,\n    major,\n    minor,\n    patch,\n});\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbVA7QUFDM007QUFDcUg7QUFDN0c7QUFDUTtBQUNrSDtBQUNsSjtBQUM2TztBQUM3SztBQUNqRDs7QUFFdkMsaUJBQWlCLGdEQUFnRDtBQUNqRSxpQkFBaUIsd0VBQU87QUFDeEIsNENBQTRDLCtDQUFRO0FBQ3BELFlBQVksb0JBQW9CO0FBQ2hDLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxzREFBRyxZQUFZLG1JQUFtSTtBQUM5Sjs7QUFFQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDLFlBQVksc0RBQUcsQ0FBQyx1REFBUSxJQUFJO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1FO0FBQ3ZGLHNEQUFzRCw4REFBUztBQUMvRCxrRUFBa0Usc0RBQUcsVUFBVSxrRUFBa0U7QUFDakosaUVBQWlFLDhEQUFTO0FBQzFFO0FBQ0EsMkNBQTJDLHNEQUFHLFVBQVUsNkVBQTZFO0FBQ3JJLG9CQUFvQix1REFBSSxDQUFDLDJDQUFVLElBQUksNkRBQTZEO0FBQ3BHLFNBQVMsR0FBRztBQUNaOztBQUVBLCtCQUErQixvREFBYTtBQUM1Qyx3Q0FBd0MsaURBQVU7O0FBRWxELGtCQUFrQiwyQ0FBMkM7QUFDN0QsOEJBQThCLCtDQUFRO0FBQ3RDLFlBQVksdURBQUksQ0FBQyx1REFBUSxJQUFJLDRDQUE0Qyxz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aUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQSxrQ0FBa0MsK0JBQStCO0FBQ2pFO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0EsWUFBWSx1REFBSSxDQUFDLHVEQUFRLElBQUksMERBQTBELHNEQUFHLGVBQWUsd0hBQXdILHNEQUFzRCxzREFBRyxlQUFlLGdJQUFnSSxLQUFLO0FBQzlhO0FBQ0EsNERBQTRELDhEQUFTOztBQUVyRTtBQUNBLG1FQUFVO0FBQ1YsVUFBVSw4REFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUyckQ7QUFDNXJEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWFnbGVzLXJpbmcvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9pbmRleC5lcy5qcz9hYTViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNmdU1vZGVscywgT3duQ2FwYWJpbGl0eSwgbmFtZSwgQ2FsbGluZ1N0YXRlLCBWaXNpYmlsaXR5U3RhdGUsIEJyb3dzZXJzLCBwYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0LCBjb21iaW5lQ29tcGFyYXRvcnMsIHNjcmVlblNoYXJpbmcsIHNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0LCBDYWxsVHlwZXMsIGRlZmF1bHRTb3J0UHJlc2V0LCBzZXRTZGtJbmZvIH0gZnJvbSAnQHN0cmVhbS1pby92aWRlby1jbGllbnQnO1xuZXhwb3J0ICogZnJvbSAnQHN0cmVhbS1pby92aWRlby1jbGllbnQnO1xuaW1wb3J0IHsgdXNlQ2FsbCwgdXNlQ2FsbFN0YXRlSG9va3MsIHVzZUkxOG4sIFJlc3RyaWN0ZWQsIHVzZUNvbm5lY3RlZFVzZXIsIFN0cmVhbUNhbGxQcm92aWRlciwgU3RyZWFtVmlkZW9Qcm92aWRlciB9IGZyb20gJ0BzdHJlYW0taW8vdmlkZW8tcmVhY3QtYmluZGluZ3MnO1xuZXhwb3J0ICogZnJvbSAnQHN0cmVhbS1pby92aWRlby1yZWFjdC1iaW5kaW5ncyc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50LCBqc3hzIH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgRnJhZ21lbnQgYXMgRnJhZ21lbnQkMSwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiwgZm9yd2FyZFJlZiwgaXNWYWxpZEVsZW1lbnQsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgdXNlRmxvYXRpbmcsIG9mZnNldCwgc2hpZnQsIGZsaXAsIHNpemUsIGF1dG9VcGRhdGUsIEZsb2F0aW5nT3ZlcmxheSwgRmxvYXRpbmdQb3J0YWwsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlVHlwZWFoZWFkLCB1c2VDbGljaywgdXNlRGlzbWlzcywgdXNlUm9sZSwgdXNlSW50ZXJhY3Rpb25zLCBGbG9hdGluZ0ZvY3VzTWFuYWdlciwgRmxvYXRpbmdMaXN0LCB1c2VIb3ZlciB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdCc7XG5pbXBvcnQgeyBDaGFydCwgQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIExpbmVFbGVtZW50LCBQb2ludEVsZW1lbnQgfSBmcm9tICdjaGFydC5qcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAncmVhY3QtY2hhcnRqcy0yJztcblxuY29uc3QgQXVkaW8gPSAoeyBwYXJ0aWNpcGFudCwgdHJhY2tUeXBlID0gJ2F1ZGlvVHJhY2snLCAuLi5yZXN0IH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IFthdWRpb0VsZW1lbnQsIHNldEF1ZGlvRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCB7IHVzZXJJZCwgc2Vzc2lvbklkIH0gPSBwYXJ0aWNpcGFudDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwgfHwgIWF1ZGlvRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuYmluZEF1ZGlvRWxlbWVudChhdWRpb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXA/LigpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxsLCBzZXNzaW9uSWQsIGF1ZGlvRWxlbWVudCwgdHJhY2tUeXBlXSk7XG4gICAgcmV0dXJuIChqc3goXCJhdWRpb1wiLCB7IGF1dG9QbGF5OiB0cnVlLCAuLi5yZXN0LCByZWY6IHNldEF1ZGlvRWxlbWVudCwgXCJkYXRhLXVzZXItaWRcIjogdXNlcklkLCBcImRhdGEtc2Vzc2lvbi1pZFwiOiBzZXNzaW9uSWQsIFwiZGF0YS10cmFjay10eXBlXCI6IHRyYWNrVHlwZSB9KSk7XG59O1xuXG5jb25zdCBQYXJ0aWNpcGFudHNBdWRpbyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnRzLCBhdWRpb1Byb3BzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogcGFydGljaXBhbnRzLm1hcCgocGFydGljaXBhbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGFudC5pc0xvY2FsUGFydGljaXBhbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHB1Ymxpc2hlZFRyYWNrcywgYXVkaW9TdHJlYW0sIHNjcmVlblNoYXJlQXVkaW9TdHJlYW0sIHNlc3Npb25JZCwgfSA9IHBhcnRpY2lwYW50O1xuICAgICAgICAgICAgY29uc3QgaGFzQXVkaW8gPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5BVURJTyk7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrRWxlbWVudCA9IGhhc0F1ZGlvICYmIGF1ZGlvU3RyZWFtICYmIChqc3goQXVkaW8sIHsgLi4uYXVkaW9Qcm9wcywgdHJhY2tUeXBlOiBcImF1ZGlvVHJhY2tcIiwgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50IH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NjcmVlblNoYXJlQXVkaW8gPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5TQ1JFRU5fU0hBUkVfQVVESU8pO1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuU2hhcmVBdWRpb1RyYWNrRWxlbWVudCA9IGhhc1NjcmVlblNoYXJlQXVkaW8gJiZcbiAgICAgICAgICAgICAgICBzY3JlZW5TaGFyZUF1ZGlvU3RyZWFtICYmIChqc3goQXVkaW8sIHsgLi4uYXVkaW9Qcm9wcywgdHJhY2tUeXBlOiBcInNjcmVlblNoYXJlQXVkaW9UcmFja1wiLCBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIChqc3hzKEZyYWdtZW50JDEsIHsgY2hpbGRyZW46IFthdWRpb1RyYWNrRWxlbWVudCwgc2NyZWVuU2hhcmVBdWRpb1RyYWNrRWxlbWVudF0gfSwgc2Vzc2lvbklkKSk7XG4gICAgICAgIH0pIH0pKTtcbn07XG5cbmNvbnN0IFBhcnRpY2lwYW50Vmlld0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCB1c2VQYXJ0aWNpcGFudFZpZXdDb250ZXh0ID0gKCkgPT4gdXNlQ29udGV4dChQYXJ0aWNpcGFudFZpZXdDb250ZXh0KTtcblxuY29uc3QgQXZhdGFyID0gKHsgaW1hZ2VTcmMsIG5hbWUsIHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3QgfSkgPT4ge1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogWyghaW1hZ2VTcmMgfHwgZXJyb3IpICYmIG5hbWUgJiYgKGpzeChBdmF0YXJGYWxsYmFjaywgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlLCBuYW1lczogW25hbWVdIH0pKSwgaW1hZ2VTcmMgJiYgIWVycm9yICYmIChqc3goXCJpbWdcIiwgeyBvbkVycm9yOiAoKSA9PiBzZXRFcnJvcih0cnVlKSwgYWx0OiBcImF2YXRhclwiLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fYXZhdGFyJywgY2xhc3NOYW1lKSwgc3JjOiBpbWFnZVNyYywgc3R5bGU6IHN0eWxlLCAuLi5yZXN0IH0pKV0gfSkpO1xufTtcbmNvbnN0IEF2YXRhckZhbGxiYWNrID0gKHsgY2xhc3NOYW1lLCBuYW1lcywgc3R5bGUsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19hdmF0YXItLWluaXRpYWxzLWZhbGxiYWNrJywgY2xhc3NOYW1lKSwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjoganN4cyhcImRpdlwiLCB7IGNoaWxkcmVuOiBbbmFtZXNbMF1bMF0sIG5hbWVzWzFdPy5bMF1dIH0pIH0pKTtcbn07XG5cbmNvbnN0IHVzZUZsb2F0aW5nVUlQcmVzZXQgPSAoeyBwbGFjZW1lbnQsIHN0cmF0ZWd5LCBvZmZzZXQ6IG9mZnNldEluUHggPSAxMCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgcmVmcywgeCwgeSwgdXBkYXRlLCBlbGVtZW50czogeyBkb21SZWZlcmVuY2UsIGZsb2F0aW5nIH0sIH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgICAgIG9mZnNldChvZmZzZXRJblB4KSxcbiAgICAgICAgICAgIHNoaWZ0KCksXG4gICAgICAgICAgICBmbGlwKCksXG4gICAgICAgICAgICBzaXplKHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgICAgICAgICBhcHBseTogKHsgYXZhaWxhYmxlSGVpZ2h0LCBlbGVtZW50cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudHMuZmxvYXRpbmcuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogYCR7YXZhaWxhYmxlSGVpZ2h0fXB4YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgIH0pO1xuICAgIC8vIGhhbmRsZSB3aW5kb3cgcmVzaXppbmdcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWRvbVJlZmVyZW5jZSB8fCAhZmxvYXRpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBhdXRvVXBkYXRlKGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhbnVwKCk7XG4gICAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIHVwZGF0ZV0pO1xuICAgIHJldHVybiB7IHJlZnMsIHgsIHksIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIHN0cmF0ZWd5IH07XG59O1xuXG4vKipcbiAqIFRoaXMgaG9vayB3aWxsIHBlcnNpc3QgdGhlIGRldmljZSBzZXR0aW5ncyB0byBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UgZm9yIGxvY2FsIHN0b3JhZ2UuXG4gKi9cbmNvbnN0IHVzZVBlcnNpc3REZXZpY2VQcmVmZXJlbmNlcyA9IChrZXkpID0+IHtcbiAgICBjb25zdCB7IHVzZU1pY3JvcGhvbmVTdGF0ZSwgdXNlQ2FtZXJhU3RhdGUsIHVzZVNwZWFrZXJTdGF0ZSwgdXNlQ2FsbFNldHRpbmdzLCB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBtaWMgPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICBjb25zdCBjYW1lcmEgPSB1c2VDYW1lcmFTdGF0ZSgpO1xuICAgIGNvbnN0IHNwZWFrZXIgPSB1c2VTcGVha2VyU3RhdGUoKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHVzZUNhbGxTZXR0aW5ncygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYXNQcmVmZXJlbmNlcyA9ICEhd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBjb25zdCB7IGF1ZGlvLCB2aWRlbyB9ID0gc2V0dGluZ3M7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0RGV2aWNlID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgY29uc3QgcHJlZmVyZW5jZXMgPSB7XG4gICAgICAgICAgICAgICAgbWljOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRGV2aWNlSWQ6IG1pYy5zZWxlY3RlZERldmljZSB8fCBkZWZhdWx0RGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBtdXRlZDogaGFzUHJlZmVyZW5jZXMgPyBtaWMuaXNNdXRlIDogIWF1ZGlvLm1pY19kZWZhdWx0X29uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FtZXJhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRGV2aWNlSWQ6IGNhbWVyYS5zZWxlY3RlZERldmljZSB8fCBkZWZhdWx0RGV2aWNlLFxuICAgICAgICAgICAgICAgICAgICBtdXRlZDogaGFzUHJlZmVyZW5jZXMgPyBjYW1lcmEuaXNNdXRlIDogIXZpZGVvLmNhbWVyYV9kZWZhdWx0X29uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3BlYWtlcjoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZERldmljZUlkOiBzcGVha2VyLnNlbGVjdGVkRGV2aWNlIHx8IGRlZmF1bHREZXZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG11dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHByZWZlcmVuY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSBkZXZpY2UgcHJlZmVyZW5jZXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBjYW1lcmEuaXNNdXRlLFxuICAgICAgICBjYW1lcmEuc2VsZWN0ZWREZXZpY2UsXG4gICAgICAgIGtleSxcbiAgICAgICAgbWljLmlzTXV0ZSxcbiAgICAgICAgbWljLnNlbGVjdGVkRGV2aWNlLFxuICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgc3BlYWtlci5zZWxlY3RlZERldmljZSxcbiAgICBdKTtcbn07XG4vKipcbiAqIFRoaXMgaG9vayB3aWxsIGFwcGx5IHRoZSBkZXZpY2Ugc2V0dGluZ3MgZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UgZm9yIGxvY2FsIHN0b3JhZ2UuXG4gKi9cbmNvbnN0IHVzZUFwcGx5RGV2aWNlUHJlZmVyZW5jZXMgPSAoa2V5KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZUNhbGxTZXR0aW5ncyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHVzZUNhbGxTZXR0aW5ncygpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhc2V0dGluZ3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGFwcGx5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5pdE1pYyA9IGFzeW5jIChzZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbC5taWNyb3Bob25lLnNlbGVjdChzZXR0aW5nLnNlbGVjdGVkRGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsLm1pY3JvcGhvbmUuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRDYW1lcmEgPSBhc3luYyAoc2V0dGluZykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLnNlbGVjdChzZXR0aW5nLnNlbGVjdGVkRGV2aWNlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nLm11dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpbml0U3BlYWtlciA9IChzZXR0aW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbC5zcGVha2VyLnNlbGVjdChzZXR0aW5nLnNlbGVjdGVkRGV2aWNlSWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwcmVmZXJlbmNlcyA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzID0gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gbG9hZCBkZXZpY2UgcHJlZmVyZW5jZXMnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaW5pdE1pYyhwcmVmZXJlbmNlcy5taWMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGluaXRDYW1lcmEocHJlZmVyZW5jZXMuY2FtZXJhKTtcbiAgICAgICAgICAgICAgICBpbml0U3BlYWtlcihwcmVmZXJlbmNlcy5zcGVha2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXVkaW8sIHZpZGVvIH0gPSBzZXR0aW5ncztcbiAgICAgICAgICAgICAgICBpZiAoYXVkaW8ubWljX2RlZmF1bHRfb24pXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwubWljcm9waG9uZS5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8uY2FtZXJhX2RlZmF1bHRfb24pXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhbGwuY2FtZXJhLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhcHBseSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGFwcGx5IGRldmljZSBwcmVmZXJlbmNlcycsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIFtjYWxsLCBrZXksIHNldHRpbmdzXSk7XG59O1xuLyoqXG4gKiBUaGlzIGhvb2sgd2lsbCBhcHBseSBhbmQgcGVyc2lzdCB0aGUgZGV2aWNlIHByZWZlcmVuY2VzIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGZvciBsb2NhbCBzdG9yYWdlLlxuICovXG5jb25zdCB1c2VQZXJzaXN0ZWREZXZpY2VQcmVmZXJlbmNlcyA9IChrZXkgPSAnQHN0cmVhbS1pby9kZXZpY2UtcHJlZmVyZW5jZXMnKSA9PiB7XG4gICAgdXNlQXBwbHlEZXZpY2VQcmVmZXJlbmNlcyhrZXkpO1xuICAgIHVzZVBlcnNpc3REZXZpY2VQcmVmZXJlbmNlcyhrZXkpO1xufTtcblxuY29uc3QgU0NST0xMX1RIUkVTSE9MRCA9IDEwO1xuLyoqXG4gKiBIb29rIHdoaWNoIG9ic2VydmVzIGVsZW1lbnQncyBzY3JvbGwgcG9zaXRpb24gYW5kIHJldHVybnMgdGV4dCB2YWx1ZSBiYXNlZCBvbiB0aGVcbiAqIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGxiYXIgKGB0b3BgLCBgYm90dG9tYCwgYGJldHdlZW5gIGFuZCBgbnVsbGAgaWYgbm8gc2Nyb2xsYmFyIGlzIGF2YWlsYWJsZSlcbiAqL1xuY29uc3QgdXNlVmVydGljYWxTY3JvbGxQb3NpdGlvbiA9IChzY3JvbGxFbGVtZW50LCB0aHJlc2hvbGQgPSBTQ1JPTExfVEhSRVNIT0xEKSA9PiB7XG4gICAgY29uc3QgW3Njcm9sbFBvc2l0aW9uLCBzZXRTY3JvbGxQb3NpdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNjcm9sbEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGhhc1ZlcnRpY2FsU2Nyb2xsYmFyID0gZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIGlmICghaGFzVmVydGljYWxTY3JvbGxiYXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFNjcm9sbFBvc2l0aW9uKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgaXNBdFRoZVRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wIDw9IHRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmIChpc0F0VGhlVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbigndG9wJyk7XG4gICAgICAgICAgICBjb25zdCBpc0F0VGhlQm90dG9tID0gTWF0aC5hYnMoZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBlbGVtZW50LnNjcm9sbFRvcCAtIGVsZW1lbnQuY2xpZW50SGVpZ2h0KSA8PSB0aHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoaXNBdFRoZUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0U2Nyb2xsUG9zaXRpb24oJ2JvdHRvbScpO1xuICAgICAgICAgICAgc2V0U2Nyb2xsUG9zaXRpb24oJ2JldHdlZW4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoc2Nyb2xsRWxlbWVudCk7XG4gICAgICAgIHNjcm9sbEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsSGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzY3JvbGxFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtzY3JvbGxFbGVtZW50LCB0aHJlc2hvbGRdKTtcbiAgICByZXR1cm4gc2Nyb2xsUG9zaXRpb247XG59O1xuY29uc3QgdXNlSG9yaXpvbnRhbFNjcm9sbFBvc2l0aW9uID0gKHNjcm9sbEVsZW1lbnQsIHRocmVzaG9sZCA9IFNDUk9MTF9USFJFU0hPTEQpID0+IHtcbiAgICBjb25zdCBbc2Nyb2xsUG9zaXRpb24sIHNldFNjcm9sbFBvc2l0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc2Nyb2xsRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgaGFzSG9yaXpvbnRhbFNjcm9sbGJhciA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKCFoYXNIb3Jpem9udGFsU2Nyb2xsYmFyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbihudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXRUaGVTdGFydCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCA8PSB0aHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAoaXNBdFRoZVN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRTY3JvbGxQb3NpdGlvbignc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXRUaGVFbmQgPSBNYXRoLmFicyhlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5zY3JvbGxMZWZ0IC0gZWxlbWVudC5jbGllbnRXaWR0aCkgPD0gdGhyZXNob2xkO1xuICAgICAgICAgICAgaWYgKGlzQXRUaGVFbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFNjcm9sbFBvc2l0aW9uKCdlbmQnKTtcbiAgICAgICAgICAgIHNldFNjcm9sbFBvc2l0aW9uKCdiZXR3ZWVuJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHNjcm9sbEVsZW1lbnQpO1xuICAgICAgICBzY3JvbGxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbEhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2Nyb2xsRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbc2Nyb2xsRWxlbWVudCwgdGhyZXNob2xkXSk7XG4gICAgcmV0dXJuIHNjcm9sbFBvc2l0aW9uO1xufTtcblxuY29uc3QgdXNlVG9nZ2xlQ2FsbFJlY29yZGluZyA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzID0gdXNlSXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcygpO1xuICAgIGNvbnN0IFtpc0F3YWl0aW5nUmVzcG9uc2UsIHNldElzQXdhaXRpbmdSZXNwb25zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gVE9ETzogYWRkIHBlcm1pc3Npb25zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gd2Ugd2FpdCB1bnRpbCBjYWxsLnJlY29yZGluZ19zdGFydGVkL3N0b3BwZWQgZXZlbnQgdG8gZmxpcHMgdGhlXG4gICAgICAgIC8vIGBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzYCBzdGF0ZSB2YXJpYWJsZS5cbiAgICAgICAgLy8gT25jZSB0aGUgZmxpcCBoYXBwZW5zLCB3ZSByZW1vdmUgdGhlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgIHNldElzQXdhaXRpbmdSZXNwb25zZSgoaXNBd2FpdGluZykgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQXdhaXRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGlzQXdhaXRpbmc7XG4gICAgICAgIH0pO1xuICAgIH0sIFtpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXSk7XG4gICAgY29uc3QgdG9nZ2xlQ2FsbFJlY29yZGluZyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldElzQXdhaXRpbmdSZXNwb25zZSh0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8uc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8uc3RhcnRSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHN0YXJ0IHJlY29yZGluZ2AsIGUpO1xuICAgICAgICB9XG4gICAgfSwgW2NhbGwsIGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3NdKTtcbiAgICByZXR1cm4geyB0b2dnbGVDYWxsUmVjb3JkaW5nLCBpc0F3YWl0aW5nUmVzcG9uc2UsIGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgfTtcbn07XG5cbmNvbnN0IHVzZVJlcXVlc3RQZXJtaXNzaW9uID0gKHBlcm1pc3Npb24pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlSGFzUGVybWlzc2lvbnMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgaGFzUGVybWlzc2lvbiA9IHVzZUhhc1Blcm1pc3Npb25zKHBlcm1pc3Npb24pO1xuICAgIGNvbnN0IFtpc0F3YWl0aW5nUGVybWlzc2lvbiwgc2V0SXNBd2FpdGluZ1Blcm1pc3Npb25dID0gdXNlU3RhdGUoZmFsc2UpOyAvLyBUT0RPOiBsb2FkIHdpdGggcG9zc2libHkgcGVuZGluZyBzdGF0ZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4gc2V0SXNBd2FpdGluZ1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICBpZiAoaGFzUGVybWlzc2lvbilcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgfSwgW2hhc1Blcm1pc3Npb25dKTtcbiAgICBjb25zdCByZXF1ZXN0UGVybWlzc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGhhc1Blcm1pc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2FuUmVxdWVzdFBlcm1pc3Npb24gPSAhIWNhbGw/LnBlcm1pc3Npb25zQ29udGV4dC5jYW5SZXF1ZXN0KHBlcm1pc3Npb24pO1xuICAgICAgICBpZiAoaXNBd2FpdGluZ1Blcm1pc3Npb24gfHwgIWNhblJlcXVlc3RQZXJtaXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzZXRJc0F3YWl0aW5nUGVybWlzc2lvbih0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGw/LnJlcXVlc3RQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IFtwZXJtaXNzaW9uXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgc2V0SXNBd2FpdGluZ1Blcm1pc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXF1ZXN0UGVybWlzc2lvbiBmYWlsZWQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtjYWxsLCBoYXNQZXJtaXNzaW9uLCBpc0F3YWl0aW5nUGVybWlzc2lvbiwgcGVybWlzc2lvbl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uLFxuICAgICAgICBoYXNQZXJtaXNzaW9uLFxuICAgICAgICBjYW5SZXF1ZXN0UGVybWlzc2lvbjogISFjYWxsPy5wZXJtaXNzaW9uc0NvbnRleHQuY2FuUmVxdWVzdChwZXJtaXNzaW9uKSxcbiAgICAgICAgaXNBd2FpdGluZ1Blcm1pc3Npb24sXG4gICAgfTtcbn07XG5cbnZhciBNZW51VmlzdWFsVHlwZTtcbihmdW5jdGlvbiAoTWVudVZpc3VhbFR5cGUpIHtcbiAgICBNZW51VmlzdWFsVHlwZVtcIlBPUlRBTFwiXSA9IFwicG9ydGFsXCI7XG4gICAgTWVudVZpc3VhbFR5cGVbXCJNRU5VXCJdID0gXCJtZW51XCI7XG59KShNZW51VmlzdWFsVHlwZSB8fCAoTWVudVZpc3VhbFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBVc2VkIHRvIHByb3ZpZGUgdXRpbGl0eSBBUElzIHRvIHRoZSBjb21wb25lbnRzIHJlbmRlcmVkIGluc2lkZSB0aGUgcG9ydGFsLlxuICovXG5jb25zdCBNZW51Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuLyoqXG4gKiBBY2Nlc3MgdG8gdGhlIGNsb3NlcyBNZW51Q29udGV4dC5cbiAqL1xuY29uc3QgdXNlTWVudUNvbnRleHQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoTWVudUNvbnRleHQpO1xufTtcbmNvbnN0IE1lbnVQb3J0YWwgPSAoeyBjaGlsZHJlbiwgcmVmcywgfSkgPT4ge1xuICAgIGNvbnN0IHBvcnRhbElkID0gdXNlTWVtbygoKSA9PiBgc3RyLXZpZGVvLXBvcnRhbC0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gLCBbXSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgaWQ6IHBvcnRhbElkLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wb3J0YWxcIiB9KSwganN4KEZsb2F0aW5nT3ZlcmxheSwgeyBjaGlsZHJlbjoganN4KEZsb2F0aW5nUG9ydGFsLCB7IGlkOiBwb3J0YWxJZCwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BvcnRhbC1jb250ZW50XCIsIHJlZjogcmVmcy5zZXRGbG9hdGluZywgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pIH0pXSB9KSk7XG59O1xuY29uc3QgTWVudVRvZ2dsZSA9ICh7IFRvZ2dsZUJ1dHRvbiwgcGxhY2VtZW50ID0gJ3RvcC1zdGFydCcsIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJywgb2Zmc2V0LCB2aXN1YWxUeXBlID0gTWVudVZpc3VhbFR5cGUuTUVOVSwgY2hpbGRyZW4sIH0pID0+IHtcbiAgICBjb25zdCBbbWVudVNob3duLCBzZXRNZW51U2hvd25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgZmxvYXRpbmcsIGRvbVJlZmVyZW5jZSwgcmVmcywgeCwgeSB9ID0gdXNlRmxvYXRpbmdVSVByZXNldCh7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgIG9mZnNldCxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmbG9hdGluZyAmJiBkb21SZWZlcmVuY2U/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBzZXRNZW51U2hvd24odHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmbG9hdGluZyAmJiAhZmxvYXRpbmc/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBzZXRNZW51U2hvd24oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdlc2NhcGUnICYmXG4gICAgICAgICAgICAgICAgIWV2ZW50LmFsdEtleSAmJlxuICAgICAgICAgICAgICAgICFldmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgc2V0TWVudVNob3duKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xuICAgICAgICB9O1xuICAgIH0sIFtmbG9hdGluZywgZG9tUmVmZXJlbmNlXSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbbWVudVNob3duICYmIChqc3goTWVudUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgY2xvc2U6ICgpID0+IHNldE1lbnVTaG93bihmYWxzZSkgfSwgY2hpbGRyZW46IHZpc3VhbFR5cGUgPT09IE1lbnVWaXN1YWxUeXBlLlBPUlRBTCA/IChqc3goTWVudVBvcnRhbCwgeyByZWZzOiByZWZzLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpIDogdmlzdWFsVHlwZSA9PT0gTWVudVZpc3VhbFR5cGUuTUVOVSA/IChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19tZW51LWNvbnRhaW5lclwiLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHkgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpIDogbnVsbCB9KSksIGpzeChUb2dnbGVCdXR0b24sIHsgbWVudVNob3duOiBtZW51U2hvd24sIHJlZjogcmVmcy5zZXRSZWZlcmVuY2UgfSldIH0pKTtcbn07XG5cbmNvbnN0IEdlbmVyaWNNZW51ID0gKHsgY2hpbGRyZW4sIG9uSXRlbUNsaWNrLCB9KSA9PiB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHJldHVybiAoanN4KFwidWxcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19nZW5lcmljLW1lbnVcIiwgcmVmOiByZWYsIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAob25JdGVtQ2xpY2sgJiZcbiAgICAgICAgICAgICAgICBlLnRhcmdldCAhPT0gcmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudD8uY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgb25JdGVtQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuY29uc3QgR2VuZXJpY01lbnVCdXR0b25JdGVtID0gKHsgY2hpbGRyZW4sIC4uLnJlc3QgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwibGlcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19nZW5lcmljLW1lbnUtLWl0ZW1cIiwgY2hpbGRyZW46IGpzeChcImJ1dHRvblwiLCB7IC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59O1xuXG5jb25zdCBJY29uID0gKHsgY2xhc3NOYW1lLCBpY29uIH0pID0+IChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2ljb24nLCBpY29uICYmIGBzdHItdmlkZW9fX2ljb24tLSR7aWNvbn1gLCBjbGFzc05hbWUpIH0pKTtcblxuY29uc3QgSWNvbkJ1dHRvbiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbkJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBpY29uLCBlbmFibGVkLCB2YXJpYW50LCBvbkNsaWNrLCBjbGFzc05hbWUsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2NhbGwtY29udHJvbHNfX2J1dHRvbicsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgW2BzdHItdmlkZW9fX2NhbGwtY29udHJvbHNfX2J1dHRvbi0tdmFyaWFudC0ke3ZhcmlhbnR9YF06IHZhcmlhbnQsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jYWxsLWNvbnRyb2xzX19idXR0b24tLWVuYWJsZWQnOiBlbmFibGVkLFxuICAgICAgICB9KSwgb25DbGljazogKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uQ2xpY2s/LihlKTtcbiAgICAgICAgfSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBpY29uIH0pIH0pKTtcbn0pO1xuXG5jb25zdCBpc0NvbXBvbmVudFR5cGUgPSAoZWxlbWVudE9yQ29tcG9uZW50KSA9PiB7XG4gICAgcmV0dXJuIGVsZW1lbnRPckNvbXBvbmVudCA9PT0gbnVsbFxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogIWlzVmFsaWRFbGVtZW50KGVsZW1lbnRPckNvbXBvbmVudCk7XG59O1xuXG5jb25zdCBjaHVuayA9IChhcnJheSwgc2l6ZSkgPT4ge1xuICAgIGNvbnN0IGNodW5rQ291bnQgPSBNYXRoLmNlaWwoYXJyYXkubGVuZ3RoIC8gc2l6ZSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNodW5rQ291bnQgfSwgKF8sIGluZGV4KSA9PiBhcnJheS5zbGljZShzaXplICogaW5kZXgsIHNpemUgKiBpbmRleCArIHNpemUpKTtcbn07XG5cbmNvbnN0IGFwcGx5RWxlbWVudFRvUmVmID0gKHJlZiwgZWxlbWVudCkgPT4ge1xuICAgIGlmICghcmVmKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiByZWYoZWxlbWVudCk7XG4gICAgcmVmLmN1cnJlbnQgPSBlbGVtZW50O1xufTtcblxuY29uc3QgQ29tcG9zaXRlQnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGVCdXR0b24oeyBjYXB0aW9uLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBhY3RpdmUsIE1lbnUsIG1lbnVQbGFjZW1lbnQsIG1lbnVPZmZzZXQsIHRpdGxlLCBUb2dnbGVNZW51QnV0dG9uID0gRGVmYXVsdFRvZ2dsZU1lbnVCdXR0b24sIHZhcmlhbnQsIG9uQ2xpY2ssIC4uLnJlc3RCdXR0b25Qcm9wcyB9LCByZWYpIHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbicsIGNsYXNzTmFtZSwge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbi0tY2FwdGlvbic6IGNhcHRpb24sXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uLS1tZW51JzogTWVudSxcbiAgICAgICAgfSksIHRpdGxlOiB0aXRsZSwgcmVmOiByZWYsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19idXR0b24tZ3JvdXAnLCB7XG4gICAgICAgICAgICAgICAgICAgICdzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2J1dHRvbi1ncm91cC0tYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAnc3RyLXZpZGVvX19jb21wb3NpdGUtYnV0dG9uX19idXR0b24tZ3JvdXAtLWFjdGl2ZS1wcmltYXJ5JzogYWN0aXZlICYmIHZhcmlhbnQgPT09ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fY29tcG9zaXRlLWJ1dHRvbl9fYnV0dG9uLWdyb3VwLS1hY3RpdmUtc2Vjb25kYXJ5JzogYWN0aXZlICYmIHZhcmlhbnQgPT09ICdzZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgIH0pLCBjaGlsZHJlbjogW2pzeChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2J1dHRvblwiLCBvbkNsaWNrOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPy4oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAuLi5yZXN0QnV0dG9uUHJvcHMsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSwgTWVudSAmJiAoanN4KE1lbnVUb2dnbGUsIHsgb2Zmc2V0OiBtZW51T2Zmc2V0LCBwbGFjZW1lbnQ6IG1lbnVQbGFjZW1lbnQsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlTWVudUJ1dHRvbiwgY2hpbGRyZW46IGlzQ29tcG9uZW50VHlwZShNZW51KSA/IGpzeChNZW51LCB7fSkgOiBNZW51IH0pKV0gfSksIGNhcHRpb24gJiYgKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NvbXBvc2l0ZS1idXR0b25fX2NhcHRpb25cIiwgY2hpbGRyZW46IGNhcHRpb24gfSkpXSB9KSk7XG59KTtcbmNvbnN0IERlZmF1bHRUb2dnbGVNZW51QnV0dG9uID0gZm9yd2FyZFJlZihmdW5jdGlvbiBEZWZhdWx0VG9nZ2xlTWVudUJ1dHRvbih7IG1lbnVTaG93biB9LCByZWYpIHtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19tZW51LXRvZ2dsZS1idXR0b24nLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19tZW51LXRvZ2dsZS1idXR0b24tLWFjdGl2ZSc6IG1lbnVTaG93bixcbiAgICAgICAgfSksIGljb246IG1lbnVTaG93biA/ICdjYXJldC1kb3duJyA6ICdjYXJldC11cCcsIHJlZjogcmVmIH0pKTtcbn0pO1xuXG5jb25zdCBUZXh0QnV0dG9uID0gKHsgY2hpbGRyZW4sIC4uLnJlc3QgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwiYnV0dG9uXCIsIHsgLi4ucmVzdCwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fdGV4dC1idXR0b25cIiwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IEFjY2VwdENhbGxCdXR0b24gPSAoeyBkaXNhYmxlZCwgb25BY2NlcHQsIG9uQ2xpY2ssIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbCkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5qb2luKCk7XG4gICAgICAgICAgICBvbkFjY2VwdD8uKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGljaywgb25BY2NlcHQsIGNhbGxdKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGRpc2FibGVkOiBkaXNhYmxlZCwgaWNvbjogXCJjYWxsLWFjY2VwdFwiLCB2YXJpYW50OiBcInN1Y2Nlc3NcIiwgXCJkYXRhLXRlc3RpZFwiOiBcImFjY2VwdC1jYWxsLWJ1dHRvblwiLCBvbkNsaWNrOiBoYW5kbGVDbGljayB9KSk7XG59O1xuXG5jb25zdCBOb3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGlzVmlzaWJsZSwgbWVzc2FnZSwgY2hpbGRyZW4sIHZpc2liaWxpdHlUaW1lb3V0LCByZXNldElzVmlzaWJsZSwgcGxhY2VtZW50ID0gJ3RvcCcsIGljb25DbGFzc05hbWUgPSAnc3RyLXZpZGVvX19ub3RpZmljYXRpb25fX2ljb24nLCBjbG9zZSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgcmVmcywgeCwgeSwgc3RyYXRlZ3kgfSA9IHVzZUZsb2F0aW5nVUlQcmVzZXQoe1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICF2aXNpYmlsaXR5VGltZW91dCB8fCAhcmVzZXRJc1Zpc2libGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc2V0SXNWaXNpYmxlKCk7XG4gICAgICAgIH0sIHZpc2liaWxpdHlUaW1lb3V0KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9LCBbaXNWaXNpYmxlLCByZXNldElzVmlzaWJsZSwgdmlzaWJpbGl0eVRpbWVvdXRdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyByZWY6IHJlZnMuc2V0UmVmZXJlbmNlLCBjaGlsZHJlbjogW2lzVmlzaWJsZSAmJiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vdGlmaWNhdGlvblwiLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB5ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtpY29uQ2xhc3NOYW1lICYmIGpzeChcImlcIiwgeyBjbGFzc05hbWU6IGljb25DbGFzc05hbWUgfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19ub3RpZmljYXRpb25fX21lc3NhZ2VcIiwgY2hpbGRyZW46IG1lc3NhZ2UgfSksIGNsb3NlID8gKGpzeChcImlcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19pY29uIHN0ci12aWRlb19faWNvbi0tY2xvc2Ugc3RyLXZpZGVvX19ub3RpZmljYXRpb25fX2Nsb3NlXCIsIG9uQ2xpY2s6IGNsb3NlIH0pKSA6IG51bGxdIH0pKSwgY2hpbGRyZW5dIH0pKTtcbn07XG5cbmNvbnN0IFBlcm1pc3Npb25Ob3RpZmljYXRpb24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHBlcm1pc3Npb24sIGlzQXdhaXRpbmdBcHByb3ZhbCwgbWVzc2FnZUFwcHJvdmVkLCBtZXNzYWdlQXdhaXRpbmdBcHByb3ZhbCwgbWVzc2FnZVJldm9rZWQsIHZpc2liaWxpdHlUaW1lb3V0ID0gMzUwMCwgY2hpbGRyZW4sIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHVzZUhhc1Blcm1pc3Npb25zIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGhhc1Blcm1pc3Npb24gPSB1c2VIYXNQZXJtaXNzaW9ucyhwZXJtaXNzaW9uKTtcbiAgICBjb25zdCBwcmV2SGFzUGVybWlzc2lvbiA9IHVzZVJlZihoYXNQZXJtaXNzaW9uKTtcbiAgICBjb25zdCBbc2hvd05vdGlmaWNhdGlvbiwgc2V0U2hvd05vdGlmaWNhdGlvbl0gPSB1c2VTdGF0ZSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChoYXNQZXJtaXNzaW9uICYmICFwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTaG93Tm90aWZpY2F0aW9uKCdncmFudGVkJyk7XG4gICAgICAgICAgICBwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaGFzUGVybWlzc2lvbiAmJiBwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRTaG93Tm90aWZpY2F0aW9uKCdyZXZva2VkJyk7XG4gICAgICAgICAgICBwcmV2SGFzUGVybWlzc2lvbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCBbaGFzUGVybWlzc2lvbl0pO1xuICAgIGNvbnN0IHJlc2V0SXNWaXNpYmxlID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0U2hvd05vdGlmaWNhdGlvbih1bmRlZmluZWQpLCBbXSk7XG4gICAgaWYgKGlzQXdhaXRpbmdBcHByb3ZhbCkge1xuICAgICAgICByZXR1cm4gKGpzeChOb3RpZmljYXRpb24sIHsgaXNWaXNpYmxlOiBpc0F3YWl0aW5nQXBwcm92YWwgJiYgIWhhc1Blcm1pc3Npb24sIG1lc3NhZ2U6IG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOb3RpZmljYXRpb24sIHsgaXNWaXNpYmxlOiAhIXNob3dOb3RpZmljYXRpb24sIHZpc2liaWxpdHlUaW1lb3V0OiB2aXNpYmlsaXR5VGltZW91dCwgcmVzZXRJc1Zpc2libGU6IHJlc2V0SXNWaXNpYmxlLCBtZXNzYWdlOiBzaG93Tm90aWZpY2F0aW9uID09PSAnZ3JhbnRlZCcgPyBtZXNzYWdlQXBwcm92ZWQgOiBtZXNzYWdlUmV2b2tlZCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IFNwZWFraW5nV2hpbGVNdXRlZE5vdGlmaWNhdGlvbiA9ICh7IGNoaWxkcmVuLCB0ZXh0LCBwbGFjZW1lbnQsIH0pID0+IHtcbiAgICBjb25zdCB7IHVzZU1pY3JvcGhvbmVTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGlzU3BlYWtpbmdXaGlsZU11dGVkIH0gPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGV4dCA/PyB0KCdZb3UgYXJlIG11dGVkLiBVbm11dGUgdG8gc3BlYWsuJyk7XG4gICAgcmV0dXJuIChqc3goTm90aWZpY2F0aW9uLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGlzVmlzaWJsZTogaXNTcGVha2luZ1doaWxlTXV0ZWQsIHBsYWNlbWVudDogcGxhY2VtZW50IHx8ICd0b3Atc3RhcnQnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgUmVjb3JkaW5nSW5Qcm9ncmVzc05vdGlmaWNhdGlvbiA9ICh7IGNoaWxkcmVuLCB0ZXh0LCB9KSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgY29uc3QgW2lzVmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRleHQgPz8gdCgnUmVjb3JkaW5nIGluIHByb2dyZXNzLi4uJyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXSk7XG4gICAgcmV0dXJuIChqc3goTm90aWZpY2F0aW9uLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGljb25DbGFzc05hbWU6IFwic3RyLXZpZGVvX19pY29uIHN0ci12aWRlb19faWNvbi0tcmVjb3JkaW5nLW9uXCIsIGlzVmlzaWJsZTogaXNWaXNpYmxlLCBwbGFjZW1lbnQ6IFwidG9wLXN0YXJ0XCIsIGNsb3NlOiAoKSA9PiBzZXRWaXNpYmxlKGZhbHNlKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSAoeyBjbGFzc05hbWUsIHR5cGUgPSAnc3Bpbm5lcicsIHRleHQsIHRvb2x0aXAsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fbG9hZGluZy1pbmRpY2F0b3InLCBjbGFzc05hbWUpLCB0aXRsZTogdG9vbHRpcCwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fbG9hZGluZy1pbmRpY2F0b3JfX2ljb24nLCB0eXBlKSB9KSwgdGV4dCAmJiBqc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbG9hZGluZy1pbmRpY2F0b3ItdGV4dFwiLCBjaGlsZHJlbjogdGV4dCB9KV0gfSkpO1xufTtcblxuY29uc3QgUmVjb3JkRW5kQ29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdG9nZ2xlQ2FsbFJlY29yZGluZywgaXNBd2FpdGluZ1Jlc3BvbnNlIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgY29uc3QgeyBjbG9zZSB9ID0gdXNlTWVudUNvbnRleHQoKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19lbmQtcmVjb3JkaW5nX19jb25maXJtYXRpb25cIiwgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLXJlY29yZGluZ19faGVhZGVyXCIsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJyZWNvcmRpbmctb25cIiB9KSwganN4KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19lbmQtcmVjb3JkaW5nX19oZWFkaW5nXCIsIGNoaWxkcmVuOiB0KCdFbmQgcmVjb3JkaW5nJykgfSldIH0pLCBqc3goXCJwXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLXJlY29yZGluZ19fZGVzY3JpcHRpb25cIiwgY2hpbGRyZW46IHQoJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCBlbmQgdGhlIHJlY29yZGluZz8nKSB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2VuZC1yZWNvcmRpbmdfX2FjdGlvbnNcIiwgY2hpbGRyZW46IFtqc3goQ29tcG9zaXRlQnV0dG9uLCB7IHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIG9uQ2xpY2s6IGNsb3NlLCBjaGlsZHJlbjogdCgnQ2FuY2VsJykgfSksIGpzeChDb21wb3NpdGVCdXR0b24sIHsgdmFyaWFudDogXCJwcmltYXJ5XCIsIG9uQ2xpY2s6IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGNoaWxkcmVuOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyBqc3goTG9hZGluZ0luZGljYXRvciwge30pIDogdCgnRW5kIHJlY29yZGluZycpIH0pXSB9KV0gfSkpO1xufTtcbmNvbnN0IFRvZ2dsZUVuZFJlY29yZGluZ01lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZUVuZFJlY29yZGluZ01lbnVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIHJldHVybiAoanN4KENvbXBvc2l0ZUJ1dHRvbiwgeyByZWY6IHJlZiwgYWN0aXZlOiB0cnVlLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCBcImRhdGEtdGVzdGlkXCI6IFwicmVjb3JkaW5nLXN0b3AtYnV0dG9uXCIsIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBcInJlY29yZGluZy1vZmZcIiB9KSB9KSk7XG59KTtcbmNvbnN0IFJlY29yZENhbGxDb25maXJtYXRpb25CdXR0b24gPSAoeyBjYXB0aW9uLCB9KSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyB0b2dnbGVDYWxsUmVjb3JkaW5nLCBpc0F3YWl0aW5nUmVzcG9uc2UsIGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MgfSA9IHVzZVRvZ2dsZUNhbGxSZWNvcmRpbmcoKTtcbiAgICBpZiAoaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbXG4gICAgICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVEFSVF9SRUNPUkRfQ0FMTCxcbiAgICAgICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUT1BfUkVDT1JEX0NBTEwsXG4gICAgICAgICAgICBdLCBjaGlsZHJlbjoganN4KE1lbnVUb2dnbGUsIHsgVG9nZ2xlQnV0dG9uOiBUb2dnbGVFbmRSZWNvcmRpbmdNZW51QnV0dG9uLCB2aXN1YWxUeXBlOiBNZW51VmlzdWFsVHlwZS5QT1JUQUwsIGNoaWxkcmVuOiBqc3goUmVjb3JkRW5kQ29uZmlybWF0aW9uLCB7fSkgfSkgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbXG4gICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUQVJUX1JFQ09SRF9DQUxMLFxuICAgICAgICAgICAgT3duQ2FwYWJpbGl0eS5TVE9QX1JFQ09SRF9DQUxMLFxuICAgICAgICBdLCBjaGlsZHJlbjoganN4KENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzQ2FsbFJlY29yZGluZ0luUHJvZ3Jlc3MsIGNhcHRpb246IGNhcHRpb24sIHRpdGxlOiBjYXB0aW9uIHx8IHQoJ1JlY29yZCBjYWxsJyksIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIFwiZGF0YS10ZXN0aWRcIjogXCJyZWNvcmRpbmctc3RhcnQtYnV0dG9uXCIsIG9uQ2xpY2s6IGlzQXdhaXRpbmdSZXNwb25zZSA/IHVuZGVmaW5lZCA6IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGNoaWxkcmVuOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyAoanN4KExvYWRpbmdJbmRpY2F0b3IsIHsgdG9vbHRpcDogdCgnV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0YXJ0Li4uJykgfSkpIDogKGpzeChJY29uLCB7IGljb246IFwicmVjb3JkaW5nLW9mZlwiIH0pKSB9KSB9KSk7XG59O1xuY29uc3QgUmVjb3JkQ2FsbEJ1dHRvbiA9ICh7IGNhcHRpb24gfSkgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdG9nZ2xlQ2FsbFJlY29yZGluZywgaXNBd2FpdGluZ1Jlc3BvbnNlLCBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzIH0gPSB1c2VUb2dnbGVDYWxsUmVjb3JkaW5nKCk7XG4gICAgbGV0IHRpdGxlID0gY2FwdGlvbiB8fCB0KCdSZWNvcmQgY2FsbCcpO1xuICAgIGlmIChpc0F3YWl0aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgdGl0bGUgPSBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXG4gICAgICAgICAgICA/IHQoJ1dhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdG9wLi4uJylcbiAgICAgICAgICAgIDogdCgnV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0YXJ0Li4uJyk7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtcbiAgICAgICAgICAgIE93bkNhcGFiaWxpdHkuU1RBUlRfUkVDT1JEX0NBTEwsXG4gICAgICAgICAgICBPd25DYXBhYmlsaXR5LlNUT1BfUkVDT1JEX0NBTEwsXG4gICAgICAgIF0sIGNoaWxkcmVuOiBqc3goQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcywgY2FwdGlvbjogY2FwdGlvbiwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgXCJkYXRhLXRlc3RpZFwiOiBpc0NhbGxSZWNvcmRpbmdJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgPyAncmVjb3JkaW5nLXN0b3AtYnV0dG9uJ1xuICAgICAgICAgICAgICAgIDogJ3JlY29yZGluZy1zdGFydC1idXR0b24nLCB0aXRsZTogdGl0bGUsIG9uQ2xpY2s6IGlzQXdhaXRpbmdSZXNwb25zZSA/IHVuZGVmaW5lZCA6IHRvZ2dsZUNhbGxSZWNvcmRpbmcsIGNoaWxkcmVuOiBpc0F3YWl0aW5nUmVzcG9uc2UgPyAoanN4KExvYWRpbmdJbmRpY2F0b3IsIHt9KSkgOiAoanN4KEljb24sIHsgaWNvbjogaXNDYWxsUmVjb3JkaW5nSW5Qcm9ncmVzcyA/ICdyZWNvcmRpbmctb24nIDogJ3JlY29yZGluZy1vZmYnIH0pKSB9KSB9KSk7XG59O1xuXG5jb25zdCBkZWZhdWx0RW1vamlSZWFjdGlvbk1hcCA9IHtcbiAgICAnOmxpa2U6JzogJ/CfkY0nLFxuICAgICc6cmFpc2UtaGFuZDonOiAn4pyLJyxcbiAgICAnOmZpcmV3b3JrczonOiAn8J+OiScsXG4gICAgJzpkaXNsaWtlOic6ICfwn5GOJyxcbiAgICAnOmhlYXJ0Oic6ICfinaTvuI8nLFxuICAgICc6c21pbGU6JzogJ/CfmIAnLFxufTtcbmNvbnN0IFJlYWN0aW9uID0gKHsgcGFydGljaXBhbnQ6IHsgcmVhY3Rpb24sIHNlc3Npb25JZCB9LCBoaWRlQWZ0ZXJUaW1lb3V0SW5NcyA9IDU1MDAsIGVtb2ppUmVhY3Rpb25NYXAgPSBkZWZhdWx0RW1vamlSZWFjdGlvbk1hcCwgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsIHx8ICFyZWFjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjYWxsLnJlc2V0UmVhY3Rpb24oc2Vzc2lvbklkKTtcbiAgICAgICAgfSwgaGlkZUFmdGVyVGltZW91dEluTXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGwsIGhpZGVBZnRlclRpbWVvdXRJbk1zLCByZWFjdGlvbiwgc2Vzc2lvbklkXSk7XG4gICAgaWYgKCFyZWFjdGlvbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyBlbW9qaV9jb2RlOiBlbW9qaUNvZGUgfSA9IHJlYWN0aW9uO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcmVhY3Rpb25cIiwgY2hpbGRyZW46IGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19yZWFjdGlvbl9fZW1vamlcIiwgY2hpbGRyZW46IGVtb2ppQ29kZSAmJiBlbW9qaVJlYWN0aW9uTWFwW2Vtb2ppQ29kZV0gfSkgfSkpO1xufTtcblxuY29uc3QgZGVmYXVsdFJlYWN0aW9ucyA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6bGlrZTonLFxuICAgIH0sXG4gICAge1xuICAgICAgICAvLyBUT0RPIE9MOiB1c2UgYHByb21wdGAgdHlwZT9cbiAgICAgICAgdHlwZTogJ3JhaXNlZC1oYW5kJyxcbiAgICAgICAgZW1vamlfY29kZTogJzpyYWlzZS1oYW5kOicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6ZmlyZXdvcmtzOicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6ZGlzbGlrZTonLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiAncmVhY3Rpb24nLFxuICAgICAgICBlbW9qaV9jb2RlOiAnOmhlYXJ0OicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6ICdyZWFjdGlvbicsXG4gICAgICAgIGVtb2ppX2NvZGU6ICc6c21pbGU6JyxcbiAgICB9LFxuXTtcbmNvbnN0IFJlYWN0aW9uc0J1dHRvbiA9ICh7IHJlYWN0aW9ucyA9IGRlZmF1bHRSZWFjdGlvbnMsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5DUkVBVEVfUkVBQ1RJT05dLCBjaGlsZHJlbjoganN4KE1lbnVUb2dnbGUsIHsgcGxhY2VtZW50OiBcInRvcFwiLCBUb2dnbGVCdXR0b246IFRvZ2dsZVJlYWN0aW9uc01lbnVCdXR0b24sIHZpc3VhbFR5cGU6IE1lbnVWaXN1YWxUeXBlLk1FTlUsIGNoaWxkcmVuOiBqc3goRGVmYXVsdFJlYWN0aW9uc01lbnUsIHsgcmVhY3Rpb25zOiByZWFjdGlvbnMgfSkgfSkgfSkpO1xufTtcbmNvbnN0IFRvZ2dsZVJlYWN0aW9uc01lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZVJlYWN0aW9uc01lbnVCdXR0b24oeyBtZW51U2hvd24gfSwgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goQ29tcG9zaXRlQnV0dG9uLCB7IHJlZjogcmVmLCBhY3RpdmU6IG1lbnVTaG93biwgdmFyaWFudDogXCJwcmltYXJ5XCIsIHRpdGxlOiB0KCdSZWFjdGlvbnMnKSwgY2hpbGRyZW46IGpzeChJY29uLCB7IGljb246IFwicmVhY3Rpb25zXCIgfSkgfSkpO1xufSk7XG5jb25zdCBEZWZhdWx0UmVhY3Rpb25zTWVudSA9ICh7IHJlYWN0aW9ucywgbGF5b3V0ID0gJ2hvcml6b250YWwnLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudScsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX3JlYWN0aW9ucy1tZW51LS1ob3Jpem9udGFsJzogbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgICAnc3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudS0tdmVydGljYWwnOiBsYXlvdXQgPT09ICd2ZXJ0aWNhbCcsXG4gICAgICAgIH0pLCBjaGlsZHJlbjogcmVhY3Rpb25zLm1hcCgocmVhY3Rpb24pID0+IChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19yZWFjdGlvbnMtbWVudV9fYnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsPy5zZW5kUmVhY3Rpb24ocmVhY3Rpb24pO1xuICAgICAgICAgICAgfSwgY2hpbGRyZW46IHJlYWN0aW9uLmVtb2ppX2NvZGUgJiYgZGVmYXVsdEVtb2ppUmVhY3Rpb25NYXBbcmVhY3Rpb24uZW1vamlfY29kZV0gfSwgcmVhY3Rpb24uZW1vamlfY29kZSkpKSB9KSk7XG59O1xuXG5jb25zdCBTY3JlZW5TaGFyZUJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgY2FwdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB1c2VIYXNPbmdvaW5nU2NyZWVuU2hhcmUsIHVzZVNjcmVlblNoYXJlU3RhdGUsIHVzZUNhbGxTZXR0aW5ncyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBpc1NvbWVvbmVTY3JlZW5TaGFyaW5nID0gdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlKCk7XG4gICAgY29uc3QgeyBoYXNQZXJtaXNzaW9uLCByZXF1ZXN0UGVybWlzc2lvbiwgaXNBd2FpdGluZ1Blcm1pc3Npb24gfSA9IHVzZVJlcXVlc3RQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkUpO1xuICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHVzZUNhbGxTZXR0aW5ncygpO1xuICAgIGNvbnN0IGlzU2NyZWVuU2hhcmluZ0FsbG93ZWQgPSBjYWxsU2V0dGluZ3M/LnNjcmVlbnNoYXJpbmcuZW5hYmxlZDtcbiAgICBjb25zdCB7IHNjcmVlblNoYXJlLCBpc011dGU6IGFtSVNjcmVlblNoYXJpbmcgfSA9IHVzZVNjcmVlblNoYXJlU3RhdGUoKTtcbiAgICBjb25zdCBkaXNhYmxlU2NyZWVuU2hhcmVCdXR0b24gPSBhbUlTY3JlZW5TaGFyaW5nXG4gICAgICAgID8gaXNTb21lb25lU2NyZWVuU2hhcmluZyB8fCBpc1NjcmVlblNoYXJpbmdBbGxvd2VkID09PSBmYWxzZVxuICAgICAgICA6IGZhbHNlO1xuICAgIHJldHVybiAoanN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFXSwgY2hpbGRyZW46IGpzeChQZXJtaXNzaW9uTm90aWZpY2F0aW9uLCB7IHBlcm1pc3Npb246IE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkUsIGlzQXdhaXRpbmdBcHByb3ZhbDogaXNBd2FpdGluZ1Blcm1pc3Npb24sIG1lc3NhZ2VBcHByb3ZlZDogdCgnWW91IGNhbiBub3cgc2hhcmUgeW91ciBzY3JlZW4uJyksIG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsOiB0KCdBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc2hhcmUgc2NyZWVuLicpLCBtZXNzYWdlUmV2b2tlZDogdCgnWW91IGNhbiBubyBsb25nZXIgc2hhcmUgeW91ciBzY3JlZW4uJyksIGNoaWxkcmVuOiBqc3goQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNTb21lb25lU2NyZWVuU2hhcmluZywgY2FwdGlvbjogY2FwdGlvbiwgdGl0bGU6IGNhcHRpb24gfHwgdCgnU2hhcmUgc2NyZWVuJyksIHZhcmlhbnQ6IFwicHJpbWFyeVwiLCBcImRhdGEtdGVzdGlkXCI6IGlzU29tZW9uZVNjcmVlblNoYXJpbmdcbiAgICAgICAgICAgICAgICAgICAgPyAnc2NyZWVuLXNoYXJlLXN0b3AtYnV0dG9uJ1xuICAgICAgICAgICAgICAgICAgICA6ICdzY3JlZW4tc2hhcmUtc3RhcnQtYnV0dG9uJywgZGlzYWJsZWQ6IGRpc2FibGVTY3JlZW5TaGFyZUJ1dHRvbiwgb25DbGljazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzY3JlZW5TaGFyZS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBqc3goSWNvbiwgeyBpY29uOiBpc1NvbWVvbmVTY3JlZW5TaGFyaW5nID8gJ3NjcmVlbi1zaGFyZS1vbicgOiAnc2NyZWVuLXNoYXJlLW9mZicgfSkgfSkgfSkgfSkpO1xufTtcblxuY29uc3QgU2VsZWN0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuY29uc3QgU2VsZWN0ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgaWNvbiwgZGVmYXVsdFNlbGVjdGVkTGFiZWwsIGRlZmF1bHRTZWxlY3RlZEluZGV4LCBoYW5kbGVTZWxlY3Q6IGhhbmRsZVNlbGVjdFByb3AsIH0gPSBwcm9wcztcbiAgICBjb25zdCBbaXNPcGVuLCBzZXRJc09wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFthY3RpdmVJbmRleCwgc2V0QWN0aXZlSW5kZXhdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGUoZGVmYXVsdFNlbGVjdGVkSW5kZXgpO1xuICAgIGNvbnN0IFtzZWxlY3RlZExhYmVsLCBzZXRTZWxlY3RlZExhYmVsXSA9IHVzZVN0YXRlKGRlZmF1bHRTZWxlY3RlZExhYmVsKTtcbiAgICBjb25zdCB7IHJlZnMsIGNvbnRleHQgfSA9IHVzZUZsb2F0aW5nKHtcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgb3BlbjogaXNPcGVuLFxuICAgICAgICBvbk9wZW5DaGFuZ2U6IHNldElzT3BlbixcbiAgICAgICAgd2hpbGVFbGVtZW50c01vdW50ZWQ6IGF1dG9VcGRhdGUsXG4gICAgICAgIG1pZGRsZXdhcmU6IFtmbGlwKCldLFxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRzUmVmID0gdXNlUmVmKFtdKTtcbiAgICBjb25zdCBsYWJlbHNSZWYgPSB1c2VSZWYoW10pO1xuICAgIGNvbnN0IGhhbmRsZVNlbGVjdCA9IHVzZUNhbGxiYWNrKChpbmRleCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KTtcbiAgICAgICAgaGFuZGxlU2VsZWN0UHJvcChpbmRleCB8fCAwKTtcbiAgICAgICAgc2V0SXNPcGVuKGZhbHNlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZExhYmVsKGxhYmVsc1JlZi5jdXJyZW50W2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9LCBbaGFuZGxlU2VsZWN0UHJvcF0pO1xuICAgIGNvbnN0IGhhbmRsZVR5cGVhaGVhZE1hdGNoID0gKGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVNlbGVjdChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3ROYXYgPSB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCB7XG4gICAgICAgIGxpc3RSZWY6IGVsZW1lbnRzUmVmLFxuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgb25OYXZpZ2F0ZTogc2V0QWN0aXZlSW5kZXgsXG4gICAgfSk7XG4gICAgY29uc3QgdHlwZWFoZWFkID0gdXNlVHlwZWFoZWFkKGNvbnRleHQsIHtcbiAgICAgICAgbGlzdFJlZjogbGFiZWxzUmVmLFxuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgb25NYXRjaDogaGFuZGxlVHlwZWFoZWFkTWF0Y2gsXG4gICAgfSk7XG4gICAgY29uc3QgY2xpY2sgPSB1c2VDbGljayhjb250ZXh0KTtcbiAgICBjb25zdCBkaXNtaXNzID0gdXNlRGlzbWlzcyhjb250ZXh0KTtcbiAgICBjb25zdCByb2xlID0gdXNlUm9sZShjb250ZXh0LCB7IHJvbGU6ICdsaXN0Ym94JyB9KTtcbiAgICBjb25zdCB7IGdldFJlZmVyZW5jZVByb3BzLCBnZXRGbG9hdGluZ1Byb3BzLCBnZXRJdGVtUHJvcHMgfSA9IHVzZUludGVyYWN0aW9ucyhbbGlzdE5hdiwgdHlwZWFoZWFkLCBjbGljaywgZGlzbWlzcywgcm9sZV0pO1xuICAgIGNvbnN0IHNlbGVjdENvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGFjdGl2ZUluZGV4LFxuICAgICAgICBzZWxlY3RlZEluZGV4LFxuICAgICAgICBnZXRJdGVtUHJvcHMsXG4gICAgICAgIGhhbmRsZVNlbGVjdCxcbiAgICB9KSwgW2FjdGl2ZUluZGV4LCBzZWxlY3RlZEluZGV4LCBnZXRJdGVtUHJvcHMsIGhhbmRsZVNlbGVjdF0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duXCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkXCIsIHJlZjogcmVmcy5zZXRSZWZlcmVuY2UsIHRhYkluZGV4OiAwLCAuLi5nZXRSZWZlcmVuY2VQcm9wcygpLCBjaGlsZHJlbjogW2pzeHMoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkX19sYWJlbFwiLCBjaGlsZHJlbjogW2ljb24gJiYgKGpzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLXNlbGVjdGVkX19pY29uXCIsIGljb246IGljb24gfSkpLCBzZWxlY3RlZExhYmVsXSB9KSwganN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZHJvcGRvd24tc2VsZWN0ZWRfX2NoZXZyb25cIiwgaWNvbjogaXNPcGVuID8gJ2NoZXZyb24tdXAnIDogJ2NoZXZyb24tZG93bicgfSldIH0pLCBqc3goU2VsZWN0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc2VsZWN0Q29udGV4dCwgY2hpbGRyZW46IGlzT3BlbiAmJiAoanN4KEZsb2F0aW5nRm9jdXNNYW5hZ2VyLCB7IGNvbnRleHQ6IGNvbnRleHQsIG1vZGFsOiBmYWxzZSwgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2Ryb3Bkb3duLWxpc3RcIiwgcmVmOiByZWZzLnNldEZsb2F0aW5nLCAuLi5nZXRGbG9hdGluZ1Byb3BzKCksIGNoaWxkcmVuOiBqc3goRmxvYXRpbmdMaXN0LCB7IGVsZW1lbnRzUmVmOiBlbGVtZW50c1JlZiwgbGFiZWxzUmVmOiBsYWJlbHNSZWYsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSB9KSkgfSldIH0pKTtcbn07XG5jb25zdCBEcm9wRG93blNlbGVjdE9wdGlvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0ZWQsIGxhYmVsLCBpY29uIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGdldEl0ZW1Qcm9wcywgaGFuZGxlU2VsZWN0IH0gPSB1c2VDb250ZXh0KFNlbGVjdENvbnRleHQpO1xuICAgIGNvbnN0IHsgcmVmLCBpbmRleCB9ID0gdXNlTGlzdEl0ZW0oKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fZHJvcGRvd24tb3B0aW9uJywge1xuICAgICAgICAgICAgJ3N0ci12aWRlb19fZHJvcGRvd24tb3B0aW9uLS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICB9KSwgcmVmOiByZWYsIC4uLmdldEl0ZW1Qcm9wcyh7XG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBoYW5kbGVTZWxlY3QoaW5kZXgpLFxuICAgICAgICB9KSwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1pY29uXCIsIGljb246IGljb24gfSksIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kcm9wZG93bi1sYWJlbFwiLCBjaGlsZHJlbjogbGFiZWwgfSldIH0pKTtcbn07XG5jb25zdCBEcm9wRG93blNlbGVjdCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGljb24sIGhhbmRsZVNlbGVjdCwgZGVmYXVsdFNlbGVjdGVkTGFiZWwsIGRlZmF1bHRTZWxlY3RlZEluZGV4LCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChqc3goU2VsZWN0LCB7IGljb246IGljb24sIGhhbmRsZVNlbGVjdDogaGFuZGxlU2VsZWN0LCBkZWZhdWx0U2VsZWN0ZWRJbmRleDogZGVmYXVsdFNlbGVjdGVkSW5kZXgsIGRlZmF1bHRTZWxlY3RlZExhYmVsOiBkZWZhdWx0U2VsZWN0ZWRMYWJlbCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IERldmljZVNlbGVjdG9yT3B0aW9uID0gKHsgZGlzYWJsZWQsIGlkLCBsYWJlbCwgb25DaGFuZ2UsIG5hbWUsIHNlbGVjdGVkLCBkZWZhdWx0Q2hlY2tlZCwgdmFsdWUsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX29wdGlvbicsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fb3B0aW9uLS1zZWxlY3RlZCc6IHNlbGVjdGVkLFxuICAgICAgICAgICAgJ3N0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19vcHRpb24tLWRpc2FibGVkJzogZGlzYWJsZWQsXG4gICAgICAgIH0pLCBodG1sRm9yOiBpZCwgY2hpbGRyZW46IFtqc3goXCJpbnB1dFwiLCB7IHR5cGU6IFwicmFkaW9cIiwgbmFtZTogbmFtZSwgb25DaGFuZ2U6IG9uQ2hhbmdlLCB2YWx1ZTogdmFsdWUsIGlkOiBpZCwgY2hlY2tlZDogc2VsZWN0ZWQsIGRlZmF1bHRDaGVja2VkOiBkZWZhdWx0Q2hlY2tlZCwgZGlzYWJsZWQ6IGRpc2FibGVkIH0pLCBsYWJlbF0gfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yTGlzdCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZGV2aWNlcyA9IFtdLCBzZWxlY3RlZERldmljZUlkOiBzZWxlY3RlZERldmljZUZyb21Qcm9wcywgdGl0bGUsIHR5cGUsIG9uQ2hhbmdlLCB9ID0gcHJvcHM7XG4gICAgLy8gc29tZXRpbWVzIHRoZSBicm93c2VyIChDaHJvbWUpIHdpbGwgcmVwb3J0IHRoZSBzeXN0ZW0tZGVmYXVsdCBkZXZpY2VcbiAgICAvLyB3aXRoIGFuIGlkIG9mICdkZWZhdWx0Jy4gSW4gY2FzZSB3aGVuIGl0IGRvZXNuJ3QsIHdlJ2xsIHNlbGVjdCB0aGUgZmlyc3RcbiAgICAvLyBhdmFpbGFibGUgZGV2aWNlLlxuICAgIGxldCBzZWxlY3RlZERldmljZUlkID0gc2VsZWN0ZWREZXZpY2VGcm9tUHJvcHM7XG4gICAgaWYgKGRldmljZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhZGV2aWNlcy5maW5kKChkKSA9PiBkLmRldmljZUlkID09PSBzZWxlY3RlZERldmljZUlkKSkge1xuICAgICAgICBzZWxlY3RlZERldmljZUlkID0gZGV2aWNlc1swXS5kZXZpY2VJZDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZGV2aWNlLXNldHRpbmdzX19kZXZpY2Uta2luZFwiLCBjaGlsZHJlbjogW3RpdGxlICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2RldmljZS1zZWxlY3Rvci10aXRsZVwiLCBjaGlsZHJlbjogdGl0bGUgfSkpLCAhZGV2aWNlcy5sZW5ndGggPyAoanN4KERldmljZVNlbGVjdG9yT3B0aW9uLCB7IGlkOiBgJHt0eXBlfS0tZGVmYXVsdGAsIGxhYmVsOiBcIkRlZmF1bHRcIiwgbmFtZTogdHlwZSwgZGVmYXVsdENoZWNrZWQ6IHRydWUsIHZhbHVlOiBcImRlZmF1bHRcIiB9KSkgOiAoZGV2aWNlcy5tYXAoKGRldmljZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoanN4KERldmljZVNlbGVjdG9yT3B0aW9uLCB7IGlkOiBgJHt0eXBlfS0tJHtkZXZpY2UuZGV2aWNlSWR9YCwgdmFsdWU6IGRldmljZS5kZXZpY2VJZCwgbGFiZWw6IGRldmljZS5sYWJlbCwgb25DaGFuZ2U6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT8uKGUudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbmFtZTogdHlwZSwgc2VsZWN0ZWQ6IGRldmljZS5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCB8fCBkZXZpY2VzLmxlbmd0aCA9PT0gMSB9LCBkZXZpY2UuZGV2aWNlSWQpKTtcbiAgICAgICAgICAgIH0pKV0gfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yRHJvcGRvd24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGRldmljZXMgPSBbXSwgc2VsZWN0ZWREZXZpY2VJZDogc2VsZWN0ZWREZXZpY2VGcm9tUHJvcHMsIHRpdGxlLCBvbkNoYW5nZSwgaWNvbiwgfSA9IHByb3BzO1xuICAgIC8vIHNvbWV0aW1lcyB0aGUgYnJvd3NlciAoQ2hyb21lKSB3aWxsIHJlcG9ydCB0aGUgc3lzdGVtLWRlZmF1bHQgZGV2aWNlXG4gICAgLy8gd2l0aCBhbiBpZCBvZiAnZGVmYXVsdCcuIEluIGNhc2Ugd2hlbiBpdCBkb2Vzbid0LCB3ZSdsbCBzZWxlY3QgdGhlIGZpcnN0XG4gICAgLy8gYXZhaWxhYmxlIGRldmljZS5cbiAgICBsZXQgc2VsZWN0ZWREZXZpY2VJZCA9IHNlbGVjdGVkRGV2aWNlRnJvbVByb3BzO1xuICAgIGlmIChkZXZpY2VzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIWRldmljZXMuZmluZCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCkpIHtcbiAgICAgICAgc2VsZWN0ZWREZXZpY2VJZCA9IGRldmljZXNbMF0uZGV2aWNlSWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBkZXZpY2VzLmZpbmRJbmRleCgoZCkgPT4gZC5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCk7XG4gICAgY29uc3QgaGFuZGxlU2VsZWN0ID0gdXNlQ2FsbGJhY2soKGluZGV4KSA9PiB7XG4gICAgICAgIG9uQ2hhbmdlPy4oZGV2aWNlc1tpbmRleF0uZGV2aWNlSWQpO1xuICAgIH0sIFtkZXZpY2VzLCBvbkNoYW5nZV0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fZGV2aWNlLWtpbmRcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2RldmljZS1zZWxlY3Rvci10aXRsZVwiLCBjaGlsZHJlbjogdGl0bGUgfSksIGpzeChEcm9wRG93blNlbGVjdCwgeyBpY29uOiBpY29uLCBkZWZhdWx0U2VsZWN0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCwgZGVmYXVsdFNlbGVjdGVkTGFiZWw6IGRldmljZXNbc2VsZWN0ZWRJbmRleF0/LmxhYmVsLCBoYW5kbGVTZWxlY3Q6IGhhbmRsZVNlbGVjdCwgY2hpbGRyZW46IGRldmljZXMubWFwKChkZXZpY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRHJvcERvd25TZWxlY3RPcHRpb24sIHsgaWNvbjogaWNvbiwgbGFiZWw6IGRldmljZS5sYWJlbCwgc2VsZWN0ZWQ6IGRldmljZS5kZXZpY2VJZCA9PT0gc2VsZWN0ZWREZXZpY2VJZCB8fCBkZXZpY2VzLmxlbmd0aCA9PT0gMSB9LCBkZXZpY2UuZGV2aWNlSWQpKTtcbiAgICAgICAgICAgICAgICB9KSB9KV0gfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB2aXN1YWxUeXBlID0gJ2xpc3QnLCBpY29uLCBwbGFjZWhvbGRlciwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgaWYgKHZpc3VhbFR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICByZXR1cm4ganN4KERldmljZVNlbGVjdG9yTGlzdCwgeyAuLi5yZXN0IH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChEZXZpY2VTZWxlY3RvckRyb3Bkb3duLCB7IC4uLnJlc3QsIGljb246IGljb24sIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciB9KSk7XG59O1xuXG5jb25zdCBEZXZpY2VTZWxlY3RvckF1ZGlvSW5wdXQgPSAoeyB0aXRsZSwgdmlzdWFsVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlTWljcm9waG9uZVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgbWljcm9waG9uZSwgc2VsZWN0ZWREZXZpY2UsIGRldmljZXMgfSA9IHVzZU1pY3JvcGhvbmVTdGF0ZSgpO1xuICAgIHJldHVybiAoanN4KERldmljZVNlbGVjdG9yLCB7IGRldmljZXM6IGRldmljZXMgfHwgW10sIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlLCB0eXBlOiBcImF1ZGlvaW5wdXRcIiwgb25DaGFuZ2U6IGFzeW5jIChkZXZpY2VJZCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgbWljcm9waG9uZS5zZWxlY3QoZGV2aWNlSWQpO1xuICAgICAgICB9LCB0aXRsZTogdGl0bGUsIHZpc3VhbFR5cGU6IHZpc3VhbFR5cGUsIGljb246IFwibWljXCIgfSkpO1xufTtcbmNvbnN0IERldmljZVNlbGVjdG9yQXVkaW9PdXRwdXQgPSAoeyB0aXRsZSwgdmlzdWFsVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgdXNlU3BlYWtlclN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgc3BlYWtlciwgc2VsZWN0ZWREZXZpY2UsIGRldmljZXMsIGlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkIH0gPSB1c2VTcGVha2VyU3RhdGUoKTtcbiAgICBpZiAoIWlzRGV2aWNlU2VsZWN0aW9uU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeChEZXZpY2VTZWxlY3RvciwgeyBkZXZpY2VzOiBkZXZpY2VzLCB0eXBlOiBcImF1ZGlvb3V0cHV0XCIsIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlLCBvbkNoYW5nZTogKGRldmljZUlkKSA9PiB7XG4gICAgICAgICAgICBzcGVha2VyLnNlbGVjdChkZXZpY2VJZCk7XG4gICAgICAgIH0sIHRpdGxlOiB0aXRsZSwgdmlzdWFsVHlwZTogdmlzdWFsVHlwZSwgaWNvbjogXCJzcGVha2VyXCIgfSkpO1xufTtcblxuY29uc3QgRGV2aWNlU2VsZWN0b3JWaWRlbyA9ICh7IHRpdGxlLCB2aXN1YWxUeXBlLCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VDYW1lcmFTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGNhbWVyYSwgZGV2aWNlcywgc2VsZWN0ZWREZXZpY2UgfSA9IHVzZUNhbWVyYVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3goRGV2aWNlU2VsZWN0b3IsIHsgZGV2aWNlczogZGV2aWNlcyB8fCBbXSwgdHlwZTogXCJ2aWRlb2lucHV0XCIsIHNlbGVjdGVkRGV2aWNlSWQ6IHNlbGVjdGVkRGV2aWNlLCBvbkNoYW5nZTogYXN5bmMgKGRldmljZUlkKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBjYW1lcmEuc2VsZWN0KGRldmljZUlkKTtcbiAgICAgICAgfSwgdGl0bGU6IHRpdGxlLCB2aXN1YWxUeXBlOiB2aXN1YWxUeXBlLCBpY29uOiBcImNhbWVyYVwiIH0pKTtcbn07XG5cbmNvbnN0IERldmljZVNldHRpbmdzID0gKHsgdmlzdWFsVHlwZSA9IE1lbnVWaXN1YWxUeXBlLk1FTlUsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChNZW51VG9nZ2xlLCB7IHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlRGV2aWNlU2V0dGluZ3NNZW51QnV0dG9uLCB2aXN1YWxUeXBlOiB2aXN1YWxUeXBlLCBjaGlsZHJlbjoganN4KE1lbnUsIHt9KSB9KSk7XG59O1xuY29uc3QgTWVudSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NcIiwgY2hpbGRyZW46IFtqc3goRGV2aWNlU2VsZWN0b3JWaWRlbywgeyB0aXRsZTogdCgnU2VsZWN0IGEgQ2FtZXJhJykgfSksIGpzeChEZXZpY2VTZWxlY3RvckF1ZGlvSW5wdXQsIHsgdGl0bGU6IHQoJ1NlbGVjdCBhIE1pYycpIH0pLCBqc3goRGV2aWNlU2VsZWN0b3JBdWRpb091dHB1dCwgeyB0aXRsZTogdCgnU2VsZWN0IFNwZWFrZXJzJykgfSldIH0pKTtcbn07XG5jb25zdCBUb2dnbGVEZXZpY2VTZXR0aW5nc01lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZURldmljZVNldHRpbmdzTWVudUJ1dHRvbih7IG1lbnVTaG93biB9LCByZWYpIHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19kZXZpY2Utc2V0dGluZ3NfX2J1dHRvbicsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2RldmljZS1zZXR0aW5nc19fYnV0dG9uLS1hY3RpdmUnOiBtZW51U2hvd24sXG4gICAgICAgIH0pLCB0aXRsZTogdCgnVG9nZ2xlIGRldmljZSBtZW51JyksIGljb246IFwiZGV2aWNlLXNldHRpbmdzXCIsIHJlZjogcmVmIH0pKTtcbn0pO1xuXG5jb25zdCBUb2dnbGVBdWRpb1ByZXZpZXdCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IGNhcHRpb24sIE1lbnUsIG1lbnVQbGFjZW1lbnQsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyB1c2VNaWNyb3Bob25lU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBtaWNyb3Bob25lLCBpc011dGUsIGhhc0Jyb3dzZXJQZXJtaXNzaW9uIH0gPSB1c2VNaWNyb3Bob25lU3RhdGUoKTtcbiAgICByZXR1cm4gKGpzeHMoQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNNdXRlLCBjYXB0aW9uOiBjYXB0aW9uLCBjbGFzc05hbWU6IGNsc3goIWhhc0Jyb3dzZXJQZXJtaXNzaW9uICYmICdzdHItdmlkZW9fX2RldmljZS11bmF2YWlsYWJsZScpLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCB0aXRsZTogIWhhc0Jyb3dzZXJQZXJtaXNzaW9uXG4gICAgICAgICAgICA/IHQoJ0NoZWNrIHlvdXIgYnJvd3NlciBhdWRpbyBwZXJtaXNzaW9ucycpXG4gICAgICAgICAgICA6IGNhcHRpb24gfHwgdCgnTWljJyksIGRpc2FibGVkOiAhaGFzQnJvd3NlclBlcm1pc3Npb24sIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ3ByZXZpZXctYXVkaW8tdW5tdXRlLWJ1dHRvbicgOiAncHJldmlldy1hdWRpby1tdXRlLWJ1dHRvbicsIG9uQ2xpY2s6ICgpID0+IG1pY3JvcGhvbmUudG9nZ2xlKCksIE1lbnU6IE1lbnUsIG1lbnVQbGFjZW1lbnQ6IG1lbnVQbGFjZW1lbnQsIC4uLnJlc3RDb21wb3NpdGVCdXR0b25Qcm9wcywgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiAhaXNNdXRlID8gJ21pYycgOiAnbWljLW9mZicgfSksICFoYXNCcm93c2VyUGVybWlzc2lvbiAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vLW1lZGlhLXBlcm1pc3Npb25cIiwgdGl0bGU6IHQoJ0NoZWNrIHlvdXIgYnJvd3NlciBhdWRpbyBwZXJtaXNzaW9ucycpLCBjaGlsZHJlbjogXCIhXCIgfSkpXSB9KSk7XG59O1xuY29uc3QgVG9nZ2xlQXVkaW9QdWJsaXNoaW5nQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBNZW51ID0ganN4KERldmljZVNlbGVjdG9yQXVkaW9JbnB1dCwgeyB2aXN1YWxUeXBlOiBcImxpc3RcIiB9KSwgbWVudVBsYWNlbWVudCA9ICd0b3AnLCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgaGFzUGVybWlzc2lvbiwgcmVxdWVzdFBlcm1pc3Npb24sIGlzQXdhaXRpbmdQZXJtaXNzaW9uIH0gPSB1c2VSZXF1ZXN0UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfQVVESU8pO1xuICAgIGNvbnN0IHsgdXNlTWljcm9waG9uZVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgbWljcm9waG9uZSwgaXNNdXRlLCBoYXNCcm93c2VyUGVybWlzc2lvbiB9ID0gdXNlTWljcm9waG9uZVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuU0VORF9BVURJT10sIGNoaWxkcmVuOiBqc3goUGVybWlzc2lvbk5vdGlmaWNhdGlvbiwgeyBwZXJtaXNzaW9uOiBPd25DYXBhYmlsaXR5LlNFTkRfQVVESU8sIGlzQXdhaXRpbmdBcHByb3ZhbDogaXNBd2FpdGluZ1Blcm1pc3Npb24sIG1lc3NhZ2VBcHByb3ZlZDogdCgnWW91IGNhbiBub3cgc3BlYWsuJyksIG1lc3NhZ2VBd2FpdGluZ0FwcHJvdmFsOiB0KCdBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc3BlYWsuJyksIG1lc3NhZ2VSZXZva2VkOiB0KCdZb3UgY2FuIG5vIGxvbmdlciBzcGVhay4nKSwgY2hpbGRyZW46IGpzeHMoQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNNdXRlLCBjYXB0aW9uOiBjYXB0aW9uLCB0aXRsZTogIWhhc1Blcm1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgPyB0KCdZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgYXVkaW8nKVxuICAgICAgICAgICAgICAgICAgICA6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgbWljIHBlcm1pc3Npb25zJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2FwdGlvbiB8fCB0KCdNaWMnKSwgdmFyaWFudDogXCJzZWNvbmRhcnlcIiwgZGlzYWJsZWQ6ICFoYXNCcm93c2VyUGVybWlzc2lvbiB8fCAhaGFzUGVybWlzc2lvbiwgXCJkYXRhLXRlc3RpZFwiOiBpc011dGUgPyAnYXVkaW8tdW5tdXRlLWJ1dHRvbicgOiAnYXVkaW8tbXV0ZS1idXR0b24nLCBvbkNsaWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzUGVybWlzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG1pY3JvcGhvbmUudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBNZW51OiBNZW51LCBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBtZW51T2Zmc2V0OiAxNiwgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IGlzTXV0ZSA/ICdtaWMtb2ZmJyA6ICdtaWMnIH0pLCAoIWhhc0Jyb3dzZXJQZXJtaXNzaW9uIHx8ICFoYXNQZXJtaXNzaW9uKSAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX25vLW1lZGlhLXBlcm1pc3Npb25cIiwgY2hpbGRyZW46IFwiIVwiIH0pKV0gfSkgfSkgfSkpO1xufTtcblxuY29uc3QgVG9nZ2xlVmlkZW9QcmV2aWV3QnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBNZW51ID0gRGV2aWNlU2VsZWN0b3JWaWRlbywgbWVudVBsYWNlbWVudCA9ICd0b3AnLCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdXNlQ2FtZXJhU3RhdGUgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgeyBjYW1lcmEsIGlzTXV0ZSwgaGFzQnJvd3NlclBlcm1pc3Npb24gfSA9IHVzZUNhbWVyYVN0YXRlKCk7XG4gICAgcmV0dXJuIChqc3hzKENvbXBvc2l0ZUJ1dHRvbiwgeyBhY3RpdmU6IGlzTXV0ZSwgY2FwdGlvbjogY2FwdGlvbiwgY2xhc3NOYW1lOiBjbHN4KCFoYXNCcm93c2VyUGVybWlzc2lvbiAmJiAnc3RyLXZpZGVvX19kZXZpY2UtdW5hdmFpbGFibGUnKSwgdGl0bGU6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnMnKVxuICAgICAgICAgICAgOiBjYXB0aW9uIHx8IHQoJ1ZpZGVvJyksIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ3ByZXZpZXctdmlkZW8tdW5tdXRlLWJ1dHRvbicgOiAncHJldmlldy12aWRlby1tdXRlLWJ1dHRvbicsIG9uQ2xpY2s6ICgpID0+IGNhbWVyYS50b2dnbGUoKSwgZGlzYWJsZWQ6ICFoYXNCcm93c2VyUGVybWlzc2lvbiwgTWVudTogTWVudSwgbWVudVBsYWNlbWVudDogbWVudVBsYWNlbWVudCwgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246ICFpc011dGUgPyAnY2FtZXJhJyA6ICdjYW1lcmEtb2ZmJyB9KSwgIWhhc0Jyb3dzZXJQZXJtaXNzaW9uICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbm8tbWVkaWEtcGVybWlzc2lvblwiLCB0aXRsZTogdCgnQ2hlY2sgeW91ciBicm93c2VyIHZpZGVvIHBlcm1pc3Npb25zJyksIGNoaWxkcmVuOiBcIiFcIiB9KSldIH0pKTtcbn07XG5jb25zdCBUb2dnbGVWaWRlb1B1Ymxpc2hpbmdCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCB7IGNhcHRpb24sIE1lbnUgPSBqc3goRGV2aWNlU2VsZWN0b3JWaWRlbywgeyB2aXN1YWxUeXBlOiBcImxpc3RcIiB9KSwgbWVudVBsYWNlbWVudCA9ICd0b3AnLCAuLi5yZXN0Q29tcG9zaXRlQnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgaGFzUGVybWlzc2lvbiwgcmVxdWVzdFBlcm1pc3Npb24sIGlzQXdhaXRpbmdQZXJtaXNzaW9uIH0gPSB1c2VSZXF1ZXN0UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfVklERU8pO1xuICAgIGNvbnN0IHsgdXNlQ2FtZXJhU3RhdGUsIHVzZUNhbGxTZXR0aW5ncyB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB7IGNhbWVyYSwgaXNNdXRlLCBoYXNCcm93c2VyUGVybWlzc2lvbiB9ID0gdXNlQ2FtZXJhU3RhdGUoKTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSB1c2VDYWxsU2V0dGluZ3MoKTtcbiAgICBjb25zdCBpc1B1Ymxpc2hpbmdWaWRlb0FsbG93ZWQgPSBjYWxsU2V0dGluZ3M/LnZpZGVvLmVuYWJsZWQ7XG4gICAgcmV0dXJuIChqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuU0VORF9WSURFT10sIGNoaWxkcmVuOiBqc3goUGVybWlzc2lvbk5vdGlmaWNhdGlvbiwgeyBwZXJtaXNzaW9uOiBPd25DYXBhYmlsaXR5LlNFTkRfVklERU8sIGlzQXdhaXRpbmdBcHByb3ZhbDogaXNBd2FpdGluZ1Blcm1pc3Npb24sIG1lc3NhZ2VBcHByb3ZlZDogdCgnWW91IGNhbiBub3cgc2hhcmUgeW91ciB2aWRlby4nKSwgbWVzc2FnZUF3YWl0aW5nQXBwcm92YWw6IHQoJ0F3YWl0aW5nIGZvciBhbiBhcHByb3ZhbCB0byBzaGFyZSB5b3VyIHZpZGVvLicpLCBtZXNzYWdlUmV2b2tlZDogdCgnWW91IGNhbiBubyBsb25nZXIgc2hhcmUgeW91ciB2aWRlby4nKSwgY2hpbGRyZW46IGpzeHMoQ29tcG9zaXRlQnV0dG9uLCB7IGFjdGl2ZTogaXNNdXRlLCBjYXB0aW9uOiBjYXB0aW9uLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCB0aXRsZTogIWhhc1Blcm1pc3Npb25cbiAgICAgICAgICAgICAgICAgICAgPyB0KCdZb3UgaGF2ZSBubyBwZXJtaXNzaW9uIHRvIHNoYXJlIHlvdXIgdmlkZW8nKVxuICAgICAgICAgICAgICAgICAgICA6ICFoYXNCcm93c2VyUGVybWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0KCdDaGVjayB5b3VyIGJyb3dzZXIgdmlkZW8gcGVybWlzc2lvbnMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhaXNQdWJsaXNoaW5nVmlkZW9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0KCdWaWRlbyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkIGJ5IHRoZSBzeXN0ZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FwdGlvbiB8fCB0KCdWaWRlbycpLCBkaXNhYmxlZDogIWhhc0Jyb3dzZXJQZXJtaXNzaW9uIHx8ICFoYXNQZXJtaXNzaW9uIHx8ICFpc1B1Ymxpc2hpbmdWaWRlb0FsbG93ZWQsIFwiZGF0YS10ZXN0aWRcIjogaXNNdXRlID8gJ3ZpZGVvLXVubXV0ZS1idXR0b24nIDogJ3ZpZGVvLW11dGUtYnV0dG9uJywgb25DbGljazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Blcm1pc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RQZXJtaXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYW1lcmEudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBNZW51OiBNZW51LCBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBtZW51T2Zmc2V0OiAxNiwgLi4ucmVzdENvbXBvc2l0ZUJ1dHRvblByb3BzLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IGlzTXV0ZSA/ICdjYW1lcmEtb2ZmJyA6ICdjYW1lcmEnIH0pLCAoIWhhc0Jyb3dzZXJQZXJtaXNzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhaGFzUGVybWlzc2lvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzUHVibGlzaGluZ1ZpZGVvQWxsb3dlZCkgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19uby1tZWRpYS1wZXJtaXNzaW9uXCIsIGNoaWxkcmVuOiBcIiFcIiB9KSldIH0pIH0pIH0pKTtcbn07XG5cbmNvbnN0IEVuZENhbGxNZW51ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBvbkxlYXZlLCBvbkVuZCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fZW5kLWNhbGxfX2NvbmZpcm1hdGlvblwiLCBjaGlsZHJlbjogW2pzeHMoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19idXR0b24gc3RyLXZpZGVvX19lbmQtY2FsbF9fbGVhdmVcIiwgdHlwZTogXCJidXR0b25cIiwgXCJkYXRhLXRlc3RpZFwiOiBcImxlYXZlLWNhbGwtYnV0dG9uXCIsIG9uQ2xpY2s6IG9uTGVhdmUsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fYnV0dG9uX19pY29uIHN0ci12aWRlb19fZW5kLWNhbGxfX2xlYXZlLWljb25cIiwgaWNvbjogXCJsb2dvdXRcIiB9KSwgdCgnTGVhdmUgY2FsbCcpXSB9KSwganN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LkVORF9DQUxMXSwgY2hpbGRyZW46IGpzeHMoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19idXR0b24gc3RyLXZpZGVvX19lbmQtY2FsbF9fZW5kXCIsIHR5cGU6IFwiYnV0dG9uXCIsIFwiZGF0YS10ZXN0aWRcIjogXCJlbmQtY2FsbC1mb3ItYWxsLWJ1dHRvblwiLCBvbkNsaWNrOiBvbkVuZCwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19idXR0b25fX2ljb24gc3RyLXZpZGVvX19lbmQtY2FsbF9fZW5kLWljb25cIiwgaWNvbjogXCJjYWxsLWVuZFwiIH0pLCB0KCdFbmQgY2FsbCBmb3IgYWxsJyldIH0pIH0pXSB9KSk7XG59O1xuY29uc3QgQ2FuY2VsQ2FsbFRvZ2dsZU1lbnVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIENhbmNlbENhbGxUb2dnbGVNZW51QnV0dG9uKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChJY29uQnV0dG9uLCB7IGljb246IFwiY2FsbC1lbmRcIiwgdmFyaWFudDogXCJkYW5nZXJcIiwgdGl0bGU6IHQoJ0xlYXZlIGNhbGwnKSwgXCJkYXRhLXRlc3RpZFwiOiBcImxlYXZlLWNhbGwtYnV0dG9uXCIsIHJlZjogcmVmIH0pKTtcbn0pO1xuY29uc3QgQ2FuY2VsQ2FsbENvbmZpcm1CdXR0b24gPSAoeyBvbkNsaWNrLCBvbkxlYXZlLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBoYW5kbGVMZWF2ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGwpIHtcbiAgICAgICAgICAgIGF3YWl0IGNhbGwubGVhdmUoKTtcbiAgICAgICAgICAgIG9uTGVhdmU/LigpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2ssIG9uTGVhdmUsIGNhbGxdKTtcbiAgICBjb25zdCBoYW5kbGVFbmRDYWxsID0gdXNlQ2FsbGJhY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbCkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5lbmRDYWxsKCk7XG4gICAgICAgICAgICBvbkxlYXZlPy4oKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrLCBvbkxlYXZlLCBjYWxsXSk7XG4gICAgcmV0dXJuIChqc3goTWVudVRvZ2dsZSwgeyBwbGFjZW1lbnQ6IFwidG9wLXN0YXJ0XCIsIFRvZ2dsZUJ1dHRvbjogQ2FuY2VsQ2FsbFRvZ2dsZU1lbnVCdXR0b24sIGNoaWxkcmVuOiBqc3goRW5kQ2FsbE1lbnUsIHsgb25FbmQ6IGhhbmRsZUVuZENhbGwsIG9uTGVhdmU6IGhhbmRsZUxlYXZlIH0pIH0pKTtcbn07XG5jb25zdCBDYW5jZWxDYWxsQnV0dG9uID0gKHsgZGlzYWJsZWQsIG9uQ2xpY2ssIG9uTGVhdmUsIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbCkge1xuICAgICAgICAgICAgYXdhaXQgY2FsbC5sZWF2ZSgpO1xuICAgICAgICAgICAgb25MZWF2ZT8uKCk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGljaywgb25MZWF2ZSwgY2FsbF0pO1xuICAgIHJldHVybiAoanN4KEljb25CdXR0b24sIHsgZGlzYWJsZWQ6IGRpc2FibGVkLCBpY29uOiBcImNhbGwtZW5kXCIsIHZhcmlhbnQ6IFwiZGFuZ2VyXCIsIHRpdGxlOiB0KCdMZWF2ZSBjYWxsJyksIFwiZGF0YS10ZXN0aWRcIjogXCJjYW5jZWwtY2FsbC1idXR0b25cIiwgb25DbGljazogaGFuZGxlQ2xpY2sgfSkpO1xufTtcblxuY29uc3QgQ2FsbENvbnRyb2xzID0gKHsgb25MZWF2ZSB9KSA9PiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtY29udHJvbHNcIiwgY2hpbGRyZW46IFtqc3goUmVjb3JkQ2FsbEJ1dHRvbiwge30pLCBqc3goUmVhY3Rpb25zQnV0dG9uLCB7fSksIGpzeChTY3JlZW5TaGFyZUJ1dHRvbiwge30pLCBqc3goU3BlYWtpbmdXaGlsZU11dGVkTm90aWZpY2F0aW9uLCB7IGNoaWxkcmVuOiBqc3goVG9nZ2xlQXVkaW9QdWJsaXNoaW5nQnV0dG9uLCB7fSkgfSksIGpzeChUb2dnbGVWaWRlb1B1Ymxpc2hpbmdCdXR0b24sIHt9KSwganN4KENhbmNlbENhbGxCdXR0b24sIHsgb25MZWF2ZTogb25MZWF2ZSB9KV0gfSkpO1xuXG5DaGFydC5yZWdpc3RlcihDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgTGluZUVsZW1lbnQsIFBvaW50RWxlbWVudCk7XG5jb25zdCBDYWxsU3RhdHNMYXRlbmN5Q2hhcnQgPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7IHZhbHVlcyB9ID0gcHJvcHM7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgbGFiZWxzOiB2YWx1ZXMubWFwKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHBvaW50LnggKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtkYXRlLmdldEhvdXJzKCl9OiR7ZGF0ZS5nZXRNaW51dGVzKCl9YDtcbiAgICAgICAgfSksXG4gICAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLm1hcCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB5IH0gPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnIzAwZTJhMScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwZTJhMScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH07XG4gICAgY29uc3Qgb3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICBzdGFja2VkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgIG1heDogTWF0aC5tYXgoMTgwLCBNYXRoLmNlaWwoKG1heCArIDEwKSAvIDEwKSAqIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnIzk3OWNhMCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwU2l6ZTogMzAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW21heF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0cy1saW5lLWNoYXJ0LWNvbnRhaW5lclwiLCBjaGlsZHJlbjoganN4KExpbmUsIHsgb3B0aW9uczogb3B0aW9ucywgZGF0YTogZGF0YSwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fbGF0ZW5jeWNoYXJ0XCIgfSkgfSkpO1xufTtcblxudmFyIFN0YXR1c2VzO1xuKGZ1bmN0aW9uIChTdGF0dXNlcykge1xuICAgIFN0YXR1c2VzW1wiR09PRFwiXSA9IFwiR29vZFwiO1xuICAgIFN0YXR1c2VzW1wiT0tcIl0gPSBcIk9rXCI7XG4gICAgU3RhdHVzZXNbXCJCQURcIl0gPSBcIkJhZFwiO1xufSkoU3RhdHVzZXMgfHwgKFN0YXR1c2VzID0ge30pKTtcbmNvbnN0IHN0YXRzU3RhdHVzID0gKHsgdmFsdWUsIGxvd0JvdW5kLCBoaWdoQm91bmQsIH0pID0+IHtcbiAgICBpZiAodmFsdWUgPD0gbG93Qm91bmQpIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c2VzLkdPT0Q7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+PSBsb3dCb3VuZCAmJiB2YWx1ZSA8PSBoaWdoQm91bmQpIHtcbiAgICAgICAgcmV0dXJuIFN0YXR1c2VzLk9LO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPj0gaGlnaEJvdW5kKSB7XG4gICAgICAgIHJldHVybiBTdGF0dXNlcy5CQUQ7XG4gICAgfVxuICAgIHJldHVybiBTdGF0dXNlcy5HT09EO1xufTtcbmNvbnN0IENhbGxTdGF0cyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbGF0ZW5jeUxvd0JvdW5kID0gNzUsIGxhdGVuY3lIaWdoQm91bmQgPSA0MDAgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtsYXRlbmN5QnVmZmVyLCBzZXRMYXRlbmN5QnVmZmVyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IDIwIH0sIChfLCBpKSA9PiAoeyB4OiBub3cgKyBpLCB5OiAwIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBbcHVibGlzaEJpdHJhdGUsIHNldFB1Ymxpc2hCaXRyYXRlXSA9IHVzZVN0YXRlKCctJyk7XG4gICAgY29uc3QgW3N1YnNjcmliZUJpdHJhdGUsIHNldFN1YnNjcmliZUJpdHJhdGVdID0gdXNlU3RhdGUoJy0nKTtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRzID0gdXNlUmVmKCk7XG4gICAgY29uc3QgeyB1c2VDYWxsU3RhdHNSZXBvcnQgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgY2FsbFN0YXRzUmVwb3J0ID0gdXNlQ2FsbFN0YXRzUmVwb3J0KCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjYWxsU3RhdHNSZXBvcnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghcHJldmlvdXNTdGF0cy5jdXJyZW50KSB7XG4gICAgICAgICAgICBwcmV2aW91c1N0YXRzLmN1cnJlbnQgPSBjYWxsU3RhdHNSZXBvcnQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNDYWxsU3RhdHNSZXBvcnQgPSBwcmV2aW91c1N0YXRzLmN1cnJlbnQ7XG4gICAgICAgIHNldFB1Ymxpc2hCaXRyYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVQdWJsaXNoQml0cmF0ZShwcmV2aW91c0NhbGxTdGF0c1JlcG9ydCwgY2FsbFN0YXRzUmVwb3J0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFN1YnNjcmliZUJpdHJhdGUoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZVN1YnNjcmliZUJpdHJhdGUocHJldmlvdXNDYWxsU3RhdHNSZXBvcnQsIGNhbGxTdGF0c1JlcG9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRMYXRlbmN5QnVmZmVyKChsYXRlbmN5QnVmKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdMYXRlbmN5QnVmZmVyID0gbGF0ZW5jeUJ1Zi5zbGljZSgtMTkpO1xuICAgICAgICAgICAgbmV3TGF0ZW5jeUJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBjYWxsU3RhdHNSZXBvcnQudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIHk6IGNhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdMYXRlbmN5QnVmZmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJldmlvdXNTdGF0cy5jdXJyZW50ID0gY2FsbFN0YXRzUmVwb3J0O1xuICAgIH0sIFtjYWxsU3RhdHNSZXBvcnRdKTtcbiAgICBjb25zdCBsYXRlbmN5Q29tcGFyaXNvbiA9IHtcbiAgICAgICAgbG93Qm91bmQ6IGxhdGVuY3lMb3dCb3VuZCxcbiAgICAgICAgaGlnaEJvdW5kOiBsYXRlbmN5SGlnaEJvdW5kLFxuICAgICAgICB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0Py5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXMgfHwgMCxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c1wiLCBjaGlsZHJlbjogY2FsbFN0YXRzUmVwb3J0ICYmIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2hlYWRlclwiLCBjaGlsZHJlbjogW2pzeHMoXCJoM1wiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2hlYWRpbmdcIiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19pY29uXCIsIGljb246IFwiY2FsbC1sYXRlbmN5XCIgfSksIHQoJ0NhbGwgTGF0ZW5jeScpXSB9KSwganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2Rlc2NyaXB0aW9uXCIsIGNoaWxkcmVuOiB0KCdWZXJ5IGhpZ2ggbGF0ZW5jeSB2YWx1ZXMgbWF5IHJlZHVjZSBjYWxsIHF1YWxpdHksIGNhdXNlIGxhZywgYW5kIG1ha2UgdGhlIGNhbGwgbGVzcyBlbmpveWFibGUuJykgfSldIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX19sYXRlbmN5Y2hhcnRcIiwgY2hpbGRyZW46IGpzeChDYWxsU3RhdHNMYXRlbmN5Q2hhcnQsIHsgdmFsdWVzOiBsYXRlbmN5QnVmZmVyIH0pIH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19faGVhZGVyXCIsIGNoaWxkcmVuOiBbanN4cyhcImgzXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19faGVhZGluZ1wiLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2ljb25cIiwgaWNvbjogXCJuZXR3b3JrLXF1YWxpdHlcIiB9KSwgdCgnQ2FsbCBwZXJmb3JtYW5jZScpXSB9KSwganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2Rlc2NyaXB0aW9uXCIsIGNoaWxkcmVuOiB0KCdWZXJ5IGhpZ2ggbGF0ZW5jeSB2YWx1ZXMgbWF5IHJlZHVjZSBjYWxsIHF1YWxpdHksIGNhdXNlIGxhZywgYW5kIG1ha2UgdGhlIGNhbGwgbGVzcyBlbmpveWFibGUuJykgfSldIH0pLCBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fY2FyZC1jb250YWluZXJcIiwgY2hpbGRyZW46IFtqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUmVnaW9uXCIsIHZhbHVlOiBjYWxsU3RhdHNSZXBvcnQuZGF0YWNlbnRlciB9KSwganN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIkxhdGVuY3lcIiwgdmFsdWU6IGAke2NhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5hdmVyYWdlUm91bmRUcmlwVGltZUluTXN9IG1zLmAsIGNvbXBhcmlzb246IGxhdGVuY3lDb21wYXJpc29uIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUmVjZWl2ZSBqaXR0ZXJcIiwgdmFsdWU6IGAke2NhbGxTdGF0c1JlcG9ydC5zdWJzY3JpYmVyU3RhdHMuYXZlcmFnZUppdHRlckluTXN9IG1zLmAsIGNvbXBhcmlzb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubGF0ZW5jeUNvbXBhcmlzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYWxsU3RhdHNSZXBvcnQuc3Vic2NyaWJlclN0YXRzLmF2ZXJhZ2VKaXR0ZXJJbk1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJQdWJsaXNoIGppdHRlclwiLCB2YWx1ZTogYCR7Y2FsbFN0YXRzUmVwb3J0LnB1Ymxpc2hlclN0YXRzLmF2ZXJhZ2VKaXR0ZXJJbk1zfSBtcy5gLCBjb21wYXJpc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmxhdGVuY3lDb21wYXJpc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2FsbFN0YXRzUmVwb3J0LnB1Ymxpc2hlclN0YXRzLmF2ZXJhZ2VKaXR0ZXJJbk1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJQdWJsaXNoIHJlc29sdXRpb25cIiwgdmFsdWU6IHRvRnJhbWVTaXplKGNhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cykgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJQdWJsaXNoIHF1YWxpdHkgZHJvcCByZWFzb25cIiwgdmFsdWU6IGNhbGxTdGF0c1JlcG9ydC5wdWJsaXNoZXJTdGF0cy5xdWFsaXR5TGltaXRhdGlvblJlYXNvbnMgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJSZWNlaXZpbmcgcmVzb2x1dGlvblwiLCB2YWx1ZTogdG9GcmFtZVNpemUoY2FsbFN0YXRzUmVwb3J0LnN1YnNjcmliZXJTdGF0cykgfSksIGpzeChTdGF0Q2FyZCwgeyBsYWJlbDogXCJSZWNlaXZlIHF1YWxpdHkgZHJvcCByZWFzb25cIiwgdmFsdWU6IGNhbGxTdGF0c1JlcG9ydC5zdWJzY3JpYmVyU3RhdHMucXVhbGl0eUxpbWl0YXRpb25SZWFzb25zIH0pLCBqc3goU3RhdENhcmQsIHsgbGFiZWw6IFwiUHVibGlzaCBiaXRyYXRlXCIsIHZhbHVlOiBwdWJsaXNoQml0cmF0ZSB9KSwganN4KFN0YXRDYXJkLCB7IGxhYmVsOiBcIlJlY2VpdmluZyBiaXRyYXRlXCIsIHZhbHVlOiBzdWJzY3JpYmVCaXRyYXRlIH0pXSB9KV0gfSkpIH0pKTtcbn07XG5jb25zdCBTdGF0Q2FyZEV4cGxhbmF0aW9uID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBkZXNjcmlwdGlvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2lzT3Blbiwgc2V0SXNPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB7IHJlZnMsIGZsb2F0aW5nU3R5bGVzLCBjb250ZXh0IH0gPSB1c2VGbG9hdGluZyh7XG4gICAgICAgIG9wZW46IGlzT3BlbixcbiAgICAgICAgb25PcGVuQ2hhbmdlOiBzZXRJc09wZW4sXG4gICAgfSk7XG4gICAgY29uc3QgaG92ZXIgPSB1c2VIb3Zlcihjb250ZXh0KTtcbiAgICBjb25zdCB7IGdldFJlZmVyZW5jZVByb3BzLCBnZXRGbG9hdGluZ1Byb3BzIH0gPSB1c2VJbnRlcmFjdGlvbnMoW2hvdmVyXSk7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1leHBsYW5hdGlvblwiLCByZWY6IHJlZnMuc2V0UmVmZXJlbmNlLCAuLi5nZXRSZWZlcmVuY2VQcm9wcygpLCBjaGlsZHJlbjoganN4KEljb24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1leHBsYW5hdGlvbl9faWNvblwiLCBpY29uOiBcImluZm9cIiB9KSB9KSwgaXNPcGVuICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLWV4cGxhbmF0aW9uX19kZXNjcmlwdGlvblwiLCByZWY6IHJlZnMuc2V0RmxvYXRpbmcsIHN0eWxlOiBmbG9hdGluZ1N0eWxlcywgLi4uZ2V0RmxvYXRpbmdQcm9wcygpLCBjaGlsZHJlbjogZGVzY3JpcHRpb24gfSkpXSB9KSk7XG59O1xuY29uc3QgU3RhdHNUYWcgPSAoeyBjaGlsZHJlbiwgc3RhdHVzID0gU3RhdHVzZXMuR09PRCwgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2NhbGwtc3RhdHNfX3RhZycsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2NhbGwtc3RhdHNfX3RhZy0tZ29vZCc6IHN0YXR1cyA9PT0gU3RhdHVzZXMuR09PRCxcbiAgICAgICAgICAgICdzdHItdmlkZW9fX2NhbGwtc3RhdHNfX3RhZy0tb2snOiBzdGF0dXMgPT09IFN0YXR1c2VzLk9LLFxuICAgICAgICAgICAgJ3N0ci12aWRlb19fY2FsbC1zdGF0c19fdGFnLS1iYWQnOiBzdGF0dXMgPT09IFN0YXR1c2VzLkJBRCxcbiAgICAgICAgfSksIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXN0YXRzX190YWdfX3RleHRcIiwgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn07XG5jb25zdCBTdGF0Q2FyZCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgbGFiZWwsIHZhbHVlLCBkZXNjcmlwdGlvbiwgY29tcGFyaXNvbiB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3Qgc3RhdHVzID0gY29tcGFyaXNvbiA/IHN0YXRzU3RhdHVzKGNvbXBhcmlzb24pIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmRcIiwgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fY2FyZC1jb250ZW50XCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtc3RhdHNfX2NhcmQtbGFiZWxcIiwgY2hpbGRyZW46IFtsYWJlbCwgZGVzY3JpcHRpb24gJiYganN4KFN0YXRDYXJkRXhwbGFuYXRpb24sIHsgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH0pXSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1zdGF0c19fY2FyZC12YWx1ZVwiLCBjaGlsZHJlbjogdmFsdWUgfSldIH0pLCBjb21wYXJpc29uICYmIHN0YXR1cyAmJiBqc3goU3RhdHNUYWcsIHsgc3RhdHVzOiBzdGF0dXMsIGNoaWxkcmVuOiB0KHN0YXR1cykgfSldIH0pKTtcbn07XG5jb25zdCB0b0ZyYW1lU2l6ZSA9IChzdGF0cykgPT4ge1xuICAgIGNvbnN0IHsgaGlnaGVzdEZyYW1lV2lkdGg6IHcsIGhpZ2hlc3RGcmFtZUhlaWdodDogaCwgaGlnaGVzdEZyYW1lc1BlclNlY29uZDogZnBzLCB9ID0gc3RhdHM7XG4gICAgbGV0IHNpemUgPSBgLWA7XG4gICAgaWYgKHcgJiYgaCkge1xuICAgICAgICBzaXplID0gYCR7d314JHtofWA7XG4gICAgICAgIGlmIChmcHMpIHtcbiAgICAgICAgICAgIHNpemUgKz0gYEAke2Zwc31mcHMuYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5jb25zdCBjYWxjdWxhdGVQdWJsaXNoQml0cmF0ZSA9IChwcmV2aW91c0NhbGxTdGF0c1JlcG9ydCwgY2FsbFN0YXRzUmVwb3J0KSA9PiB7XG4gICAgY29uc3QgeyBwdWJsaXNoZXJTdGF0czogeyB0b3RhbEJ5dGVzU2VudDogcHJldmlvdXNUb3RhbEJ5dGVzU2VudCwgdGltZXN0YW1wOiBwcmV2aW91c1RpbWVzdGFtcCwgfSwgfSA9IHByZXZpb3VzQ2FsbFN0YXRzUmVwb3J0O1xuICAgIGNvbnN0IHsgcHVibGlzaGVyU3RhdHM6IHsgdG90YWxCeXRlc1NlbnQsIHRpbWVzdGFtcCB9LCB9ID0gY2FsbFN0YXRzUmVwb3J0O1xuICAgIGNvbnN0IGJ5dGVzU2VudCA9IHRvdGFsQnl0ZXNTZW50IC0gcHJldmlvdXNUb3RhbEJ5dGVzU2VudDtcbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IHRpbWVzdGFtcCAtIHByZXZpb3VzVGltZXN0YW1wO1xuICAgIHJldHVybiBgJHsoKGJ5dGVzU2VudCAqIDgpIC8gdGltZUVsYXBzZWQpLnRvRml4ZWQoMil9IGticHNgO1xufTtcbmNvbnN0IGNhbGN1bGF0ZVN1YnNjcmliZUJpdHJhdGUgPSAocHJldmlvdXNDYWxsU3RhdHNSZXBvcnQsIGNhbGxTdGF0c1JlcG9ydCkgPT4ge1xuICAgIGNvbnN0IHsgc3Vic2NyaWJlclN0YXRzOiB7IHRvdGFsQnl0ZXNSZWNlaXZlZDogcHJldmlvdXNUb3RhbEJ5dGVzUmVjZWl2ZWQsIHRpbWVzdGFtcDogcHJldmlvdXNUaW1lc3RhbXAsIH0sIH0gPSBwcmV2aW91c0NhbGxTdGF0c1JlcG9ydDtcbiAgICBjb25zdCB7IHN1YnNjcmliZXJTdGF0czogeyB0b3RhbEJ5dGVzUmVjZWl2ZWQsIHRpbWVzdGFtcCB9LCB9ID0gY2FsbFN0YXRzUmVwb3J0O1xuICAgIGNvbnN0IGJ5dGVzUmVjZWl2ZWQgPSB0b3RhbEJ5dGVzUmVjZWl2ZWQgLSBwcmV2aW91c1RvdGFsQnl0ZXNSZWNlaXZlZDtcbiAgICBjb25zdCB0aW1lRWxhcHNlZCA9IHRpbWVzdGFtcCAtIHByZXZpb3VzVGltZXN0YW1wO1xuICAgIHJldHVybiBgJHsoKGJ5dGVzUmVjZWl2ZWQgKiA4KSAvIHRpbWVFbGFwc2VkKS50b0ZpeGVkKDIpfSBrYnBzYDtcbn07XG5cbmNvbnN0IENhbGxTdGF0c0J1dHRvbiA9ICgpID0+IChqc3goTWVudVRvZ2dsZSwgeyBwbGFjZW1lbnQ6IFwidG9wLWVuZFwiLCBUb2dnbGVCdXR0b246IFRvZ2dsZU1lbnVCdXR0b24sIGNoaWxkcmVuOiBqc3goQ2FsbFN0YXRzLCB7fSkgfSkpO1xuY29uc3QgVG9nZ2xlTWVudUJ1dHRvbiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gVG9nZ2xlTWVudUJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBjYXB0aW9uLCBtZW51U2hvd24gfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KENvbXBvc2l0ZUJ1dHRvbiwgeyByZWY6IHJlZiwgYWN0aXZlOiBtZW51U2hvd24sIGNhcHRpb246IGNhcHRpb24sIHRpdGxlOiBjYXB0aW9uIHx8IHQoJ1N0YXRpc3RpY3MnKSwgXCJkYXRhLXRlc3RpZFwiOiBcInN0YXRzLWJ1dHRvblwiLCBjaGlsZHJlbjoganN4KEljb24sIHsgaWNvbjogXCJzdGF0c1wiIH0pIH0pKTtcbn0pO1xuXG5jb25zdCBUb2dnbGVBdWRpb091dHB1dEJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgY2FwdGlvbiwgTWVudSA9IERldmljZVNlbGVjdG9yQXVkaW9PdXRwdXQsIG1lbnVQbGFjZW1lbnQgPSAndG9wJywgfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KENvbXBvc2l0ZUJ1dHRvbiwgeyBNZW51OiBNZW51LCBtZW51UGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBjYXB0aW9uOiBjYXB0aW9uLCB0aXRsZTogY2FwdGlvbiB8fCB0KCdTcGVha2VycycpLCBcImRhdGEtdGVzdGlkXCI6IFwiYXVkaW8tb3V0cHV0LWJ1dHRvblwiLCBjaGlsZHJlbjoganN4KEljb24sIHsgaWNvbjogXCJzcGVha2VyXCIgfSkgfSkpO1xufTtcblxuY29uc3QgQmxvY2tlZFVzZXJMaXN0aW5nID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmdcIiwgY2hpbGRyZW46IGRhdGEubWFwKCh1c2VySWQpID0+IChqc3goQmxvY2tlZFVzZXJMaXN0aW5nSXRlbSwgeyB1c2VySWQ6IHVzZXJJZCB9LCB1c2VySWQpKSkgfSkgfSkpO1xufTtcbmNvbnN0IEJsb2NrZWRVc2VyTGlzdGluZ0l0ZW0gPSAoeyB1c2VySWQgfSkgPT4ge1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgdW5ibG9ja1VzZXJDbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICh1c2VySWQpXG4gICAgICAgICAgICBjYWxsPy51bmJsb2NrVXNlcih1c2VySWQpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19kaXNwbGF5LW5hbWVcIiwgY2hpbGRyZW46IHVzZXJJZCB9KSwganN4KFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LkJMT0NLX1VTRVJTXSwgY2hpbGRyZW46IGpzeChUZXh0QnV0dG9uLCB7IG9uQ2xpY2s6IHVuYmxvY2tVc2VyQ2xpY2tIYW5kbGVyLCBjaGlsZHJlbjogXCJVbmJsb2NrXCIgfSkgfSldIH0pKTtcbn07XG5cbmNvbnN0IENhbGxQYXJ0aWNpcGFudExpc3RIZWFkZXIgPSAoeyBvbkNsb3NlLCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VQYXJ0aWNpcGFudHMsIHVzZUFub255bW91c1BhcnRpY2lwYW50Q291bnQgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gdXNlUGFydGljaXBhbnRzKCk7XG4gICAgY29uc3QgYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCA9IHVzZUFub255bW91c1BhcnRpY2lwYW50Q291bnQoKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LWhlYWRlclwiLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LWhlYWRlcl9fdGl0bGVcIiwgY2hpbGRyZW46IFt0KCdQYXJ0aWNpcGFudHMnKSwgJyAnLCBqc3hzKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3QtaGVhZGVyX190aXRsZS1jb3VudFwiLCBjaGlsZHJlbjogW1wiW1wiLCBwYXJ0aWNpcGFudHMubGVuZ3RoLCBcIl1cIl0gfSksIGFub255bW91c1BhcnRpY2lwYW50Q291bnQgPiAwICYmIChqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdC1oZWFkZXJfX3RpdGxlLWFub255bW91c1wiLCBjaGlsZHJlbjogdCgnQW5vbnltb3VzJywgeyBjb3VudDogYW5vbnltb3VzUGFydGljaXBhbnRDb3VudCB9KSB9KSldIH0pLCBqc3goSWNvbkJ1dHRvbiwgeyBvbkNsaWNrOiBvbkNsb3NlLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0LWhlYWRlcl9fY2xvc2UtYnV0dG9uXCIsIGljb246IFwiY2xvc2VcIiB9KV0gfSkpO1xufTtcblxuY29uc3QgVG9vbHRpcCA9ICh7IGNoaWxkcmVuLCByZWZlcmVuY2VFbGVtZW50LCB0b29sdGlwQ2xhc3NOYW1lLCB0b29sdGlwUGxhY2VtZW50ID0gJ3RvcCcsIHZpc2libGUgPSBmYWxzZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgcmVmcywgeCwgeSwgc3RyYXRlZ3kgfSA9IHVzZUZsb2F0aW5nVUlQcmVzZXQoe1xuICAgICAgICBwbGFjZW1lbnQ6IHRvb2x0aXBQbGFjZW1lbnQsXG4gICAgICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZnMuc2V0UmVmZXJlbmNlKHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgIH0sIFtyZWZlcmVuY2VFbGVtZW50LCByZWZzXSk7XG4gICAgaWYgKCF2aXNpYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX190b29sdGlwJywgdG9vbHRpcENsYXNzTmFtZSksIHJlZjogcmVmcy5zZXRGbG9hdGluZywgc3R5bGU6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgICAgICAgIHRvcDogeSA/PyAwLFxuICAgICAgICAgICAgbGVmdDogeCA/PyAwLFxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bycsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCB1c2VFbnRlckxlYXZlSGFuZGxlcnMgPSAoeyBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgW3Rvb2x0aXBWaXNpYmxlLCBzZXRUb29sdGlwVmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlTW91c2VFbnRlciA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIHNldFRvb2x0aXBWaXNpYmxlKHRydWUpO1xuICAgICAgICBvbk1vdXNlRW50ZXI/LihlKTtcbiAgICB9LCBbb25Nb3VzZUVudGVyXSk7XG4gICAgY29uc3QgaGFuZGxlTW91c2VMZWF2ZSA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIHNldFRvb2x0aXBWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgb25Nb3VzZUxlYXZlPy4oZSk7XG4gICAgfSwgW29uTW91c2VMZWF2ZV0pO1xuICAgIHJldHVybiB7IGhhbmRsZU1vdXNlRW50ZXIsIGhhbmRsZU1vdXNlTGVhdmUsIHRvb2x0aXBWaXNpYmxlIH07XG59O1xuXG4vLyB0b2RvOiBkdXBsaWNhdGUgb2YgQ2FsbFBhcnRpY2lwYW50TGlzdC50c3gjTWVkaWFJbmRpY2F0b3IgLSByZWZhY3RvciB0byBhIHNpbmdsZSBjb21wb25lbnRcbmNvbnN0IFdpdGhUb29sdGlwID0gKHsgdGl0bGUsIHRvb2x0aXBDbGFzc05hbWUsIHRvb2x0aXBQbGFjZW1lbnQsIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCB7IGhhbmRsZU1vdXNlRW50ZXIsIGhhbmRsZU1vdXNlTGVhdmUsIHRvb2x0aXBWaXNpYmxlIH0gPSB1c2VFbnRlckxlYXZlSGFuZGxlcnMoKTtcbiAgICBjb25zdCBbdG9vbHRpcEFuY2hvciwgc2V0VG9vbHRpcEFuY2hvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goVG9vbHRpcCwgeyByZWZlcmVuY2VFbGVtZW50OiB0b29sdGlwQW5jaG9yLCB2aXNpYmxlOiB0b29sdGlwVmlzaWJsZSwgdG9vbHRpcENsYXNzTmFtZTogdG9vbHRpcENsYXNzTmFtZSwgdG9vbHRpcFBsYWNlbWVudDogdG9vbHRpcFBsYWNlbWVudCwgY2hpbGRyZW46IHRpdGxlIHx8ICcnIH0pLCBqc3goXCJkaXZcIiwgeyByZWY6IHNldFRvb2x0aXBBbmNob3IsIG9uTW91c2VFbnRlcjogaGFuZGxlTW91c2VFbnRlciwgb25Nb3VzZUxlYXZlOiBoYW5kbGVNb3VzZUxlYXZlLCAuLi5wcm9wcyB9KV0gfSkpO1xufTtcblxuY29uc3QgQ2FsbFBhcnRpY2lwYW50TGlzdGluZ0l0ZW0gPSAoeyBwYXJ0aWNpcGFudCwgRGlzcGxheU5hbWUgPSBEZWZhdWx0RGlzcGxheU5hbWUsIH0pID0+IHtcbiAgICBjb25zdCBpc0F1ZGlvT24gPSBwYXJ0aWNpcGFudC5wdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5BVURJTyk7XG4gICAgY29uc3QgaXNWaWRlb09uID0gcGFydGljaXBhbnQucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuVklERU8pO1xuICAgIGNvbnN0IGlzUGlubmVkID0gISFwYXJ0aWNpcGFudC5waW47XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtXCIsIGNoaWxkcmVuOiBbanN4KEF2YXRhciwgeyBuYW1lOiBwYXJ0aWNpcGFudC5uYW1lLCBpbWFnZVNyYzogcGFydGljaXBhbnQuaW1hZ2UgfSksIGpzeChEaXNwbGF5TmFtZSwgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0aW5nLWl0ZW1fX21lZGlhLWluZGljYXRvci1ncm91cFwiLCBjaGlsZHJlbjogW2pzeChNZWRpYUluZGljYXRvciwgeyB0aXRsZTogaXNBdWRpb09uID8gdCgnTWljcm9waG9uZSBvbicpIDogdCgnTWljcm9waG9uZSBvZmYnKSwgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbicsIGBzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9faWNvbi0ke2lzQXVkaW9PbiA/ICdtaWMnIDogJ21pYy1vZmYnfWApIH0pLCBqc3goTWVkaWFJbmRpY2F0b3IsIHsgdGl0bGU6IGlzVmlkZW9PbiA/IHQoJ0NhbWVyYSBvbicpIDogdCgnQ2FtZXJhIG9mZicpLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19pY29uJywgYHN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19pY29uLSR7aXNWaWRlb09uID8gJ2NhbWVyYScgOiAnY2FtZXJhLW9mZid9YCkgfSksIGlzUGlubmVkICYmIChqc3goTWVkaWFJbmRpY2F0b3IsIHsgdGl0bGU6IHQoJ1Bpbm5lZCcpLCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19pY29uJywgJ3N0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZy1pdGVtX19pY29uLXBpbm5lZCcpIH0pKSwganN4KE1lbnVUb2dnbGUsIHsgcGxhY2VtZW50OiBcImJvdHRvbS1lbmRcIiwgVG9nZ2xlQnV0dG9uOiBUb2dnbGVCdXR0b24kMiwgY2hpbGRyZW46IGpzeChQYXJ0aWNpcGFudFZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IHBhcnRpY2lwYW50LCB0cmFja1R5cGU6ICdub25lJyB9LCBjaGlsZHJlbjoganN4KFBhcnRpY2lwYW50QWN0aW9uc0NvbnRleHRNZW51LCB7fSkgfSkgfSldIH0pXSB9KSk7XG59O1xuY29uc3QgTWVkaWFJbmRpY2F0b3IgPSAocHJvcHMpID0+IChqc3goV2l0aFRvb2x0aXAsIHsgLi4ucHJvcHMgfSkpO1xuY29uc3QgRGVmYXVsdERpc3BsYXlOYW1lID0gKHsgcGFydGljaXBhbnQgfSkgPT4ge1xuICAgIGNvbnN0IGNvbm5lY3RlZFVzZXIgPSB1c2VDb25uZWN0ZWRVc2VyKCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgbWVGbGFnID0gcGFydGljaXBhbnQudXNlcklkID09PSBjb25uZWN0ZWRVc2VyPy5pZCA/IHQoJ01lJykgOiAnJztcbiAgICBjb25zdCBuYW1lT3JJZCA9IHBhcnRpY2lwYW50Lm5hbWUgfHwgcGFydGljaXBhbnQudXNlcklkIHx8IHQoJ1Vua25vd24nKTtcbiAgICBsZXQgZGlzcGxheU5hbWU7XG4gICAgaWYgKCFwYXJ0aWNpcGFudC5uYW1lKSB7XG4gICAgICAgIGRpc3BsYXlOYW1lID0gbWVGbGFnIHx8IG5hbWVPcklkIHx8IHQoJ1Vua25vd24nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWVGbGFnKSB7XG4gICAgICAgIGRpc3BsYXlOYW1lID0gYCR7bmFtZU9ySWR9ICgke21lRmxhZ30pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRpc3BsYXlOYW1lID0gbmFtZU9ySWQ7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFdpdGhUb29sdGlwLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RpbmctaXRlbV9fZGlzcGxheS1uYW1lXCIsIHRpdGxlOiBkaXNwbGF5TmFtZSwgY2hpbGRyZW46IGRpc3BsYXlOYW1lIH0pKTtcbn07XG5jb25zdCBUb2dnbGVCdXR0b24kMiA9IGZvcndhcmRSZWYoZnVuY3Rpb24gVG9nZ2xlQnV0dG9uKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4ganN4KEljb25CdXR0b24sIHsgZW5hYmxlZDogcHJvcHMubWVudVNob3duLCBpY29uOiBcImVsbGlwc2lzXCIsIHJlZjogcmVmIH0pO1xufSk7XG5cbmNvbnN0IENhbGxQYXJ0aWNpcGFudExpc3RpbmcgPSAoeyBkYXRhLCB9KSA9PiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdGluZ1wiLCBjaGlsZHJlbjogZGF0YS5tYXAoKHBhcnRpY2lwYW50KSA9PiAoanN4KENhbGxQYXJ0aWNpcGFudExpc3RpbmdJdGVtLCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCB9LCBwYXJ0aWNpcGFudC5zZXNzaW9uSWQpKSkgfSkpO1xuXG5jb25zdCBFbXB0eVBhcnRpY2lwYW50U2VhcmNoTGlzdCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3QtLWVtcHR5XCIsIGNoaWxkcmVuOiB0KCdObyBwYXJ0aWNpcGFudHMgZm91bmQnKSB9KSk7XG59O1xuXG5jb25zdCBTZWFyY2hJbnB1dCA9ICh7IGV4aXRTZWFyY2gsIGlzQWN0aXZlLCAuLi5yZXN0IH0pID0+IHtcbiAgICBjb25zdCBbaW5wdXRFbGVtZW50LCBzZXRJbnB1dEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdlc2NhcGUnKVxuICAgICAgICAgICAgICAgIGV4aXRTZWFyY2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XG4gICAgICAgIH07XG4gICAgfSwgW2V4aXRTZWFyY2gsIGlucHV0RWxlbWVudF0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19zZWFyY2gtaW5wdXRfX2NvbnRhaW5lcicsIHtcbiAgICAgICAgICAgICdzdHItdmlkZW9fX3NlYXJjaC1pbnB1dF9fY29udGFpbmVyLS1hY3RpdmUnOiBpc0FjdGl2ZSxcbiAgICAgICAgfSksIGNoaWxkcmVuOiBbanN4KFwiaW5wdXRcIiwgeyBwbGFjZWhvbGRlcjogXCJTZWFyY2hcIiwgLi4ucmVzdCwgcmVmOiBzZXRJbnB1dEVsZW1lbnQgfSksIGlzQWN0aXZlID8gKGpzeChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NlYXJjaC1pbnB1dF9fY2xlYXItYnRuXCIsIG9uQ2xpY2s6IGV4aXRTZWFyY2gsIGNoaWxkcmVuOiBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc2VhcmNoLWlucHV0X19pY29uLS1hY3RpdmVcIiB9KSB9KSkgOiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NlYXJjaC1pbnB1dF9faWNvblwiIH0pKV0gfSkpO1xufTtcblxuY29uc3QgU2VhcmNoUmVzdWx0cyA9ICh7IEVtcHR5U2VhcmNoUmVzdWx0Q29tcG9uZW50LCBMb2FkaW5nSW5kaWNhdG9yOiBMb2FkaW5nSW5kaWNhdG9yJDEgPSBMb2FkaW5nSW5kaWNhdG9yLCBzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNlYXJjaFJlc3VsdHMsIFNlYXJjaFJlc3VsdExpc3QsIH0pID0+IHtcbiAgICBpZiAoc2VhcmNoUXVlcnlJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc2VhcmNoLXJlc3VsdHMtLWxvYWRpbmdcIiwgY2hpbGRyZW46IGpzeChMb2FkaW5nSW5kaWNhdG9yJDEsIHt9KSB9KSk7XG4gICAgfVxuICAgIGlmICghc2VhcmNoUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGpzeChFbXB0eVNlYXJjaFJlc3VsdENvbXBvbmVudCwge30pO1xuICAgIH1cbiAgICByZXR1cm4ganN4KFNlYXJjaFJlc3VsdExpc3QsIHsgZGF0YTogc2VhcmNoUmVzdWx0cyB9KTtcbn07XG5cbmNvbnN0IHVzZVNlYXJjaCA9ICh7IGRlYm91bmNlSW50ZXJ2YWwsIHNlYXJjaEZuLCBzZWFyY2hRdWVyeSA9ICcnLCB9KSA9PiB7XG4gICAgY29uc3QgW3NlYXJjaFJlc3VsdHMsIHNldFNlYXJjaFJlc3VsdHNdID0gdXNlU3RhdGUoW10pO1xuICAgIGNvbnN0IFtzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNldFNlYXJjaFF1ZXJ5SW5Qcm9ncmVzc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFzZWFyY2hRdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldFNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRTZWFyY2hSZXN1bHRzKFtdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWFyY2hRdWVyeUluUHJvZ3Jlc3ModHJ1ZSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHNlYXJjaEZuKHNlYXJjaFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBzZXRTZWFyY2hSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRTZWFyY2hRdWVyeUluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkZWJvdW5jZUludGVydmFsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICB9LCBbZGVib3VuY2VJbnRlcnZhbCwgc2VhcmNoRm4sIHNlYXJjaFF1ZXJ5XSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VhcmNoUXVlcnlJblByb2dyZXNzLFxuICAgICAgICBzZWFyY2hSZXN1bHRzLFxuICAgIH07XG59O1xuXG5jb25zdCBVc2VyTGlzdFR5cGVzID0ge1xuICAgIGFjdGl2ZTogJ0FjdGl2ZSB1c2VycycsXG4gICAgYmxvY2tlZDogJ0Jsb2NrZWQgdXNlcnMnLFxufTtcbmNvbnN0IERFRkFVTFRfREVCT1VOQ0VfU0VBUkNIX0lOVEVSVkFMID0gMjAwO1xuY29uc3QgQ2FsbFBhcnRpY2lwYW50c0xpc3QgPSAoeyBvbkNsb3NlLCBhY3RpdmVVc2Vyc1NlYXJjaEZuLCBibG9ja2VkVXNlcnNTZWFyY2hGbiwgZGVib3VuY2VTZWFyY2hJbnRlcnZhbCwgfSkgPT4ge1xuICAgIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGUoJycpO1xuICAgIGNvbnN0IFt1c2VyTGlzdFR5cGUsIHNldFVzZXJMaXN0VHlwZV0gPSB1c2VTdGF0ZSgnYWN0aXZlJyk7XG4gICAgY29uc3QgZXhpdFNlYXJjaCA9IHVzZUNhbGxiYWNrKCgpID0+IHNldFNlYXJjaFF1ZXJ5KCcnKSwgW10pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RcIiwgY2hpbGRyZW46IFtqc3goQ2FsbFBhcnRpY2lwYW50TGlzdEhlYWRlciwgeyBvbkNsb3NlOiBvbkNsb3NlIH0pLCBqc3goU2VhcmNoSW5wdXQsIHsgdmFsdWU6IHNlYXJjaFF1ZXJ5LCBvbkNoYW5nZTogKHsgY3VycmVudFRhcmdldCB9KSA9PiBzZXRTZWFyY2hRdWVyeShjdXJyZW50VGFyZ2V0LnZhbHVlKSwgZXhpdFNlYXJjaDogZXhpdFNlYXJjaCwgaXNBY3RpdmU6ICEhc2VhcmNoUXVlcnkgfSksIGpzeChDYWxsUGFydGljaXBhbnRMaXN0Q29udGVudEhlYWRlciwgeyB1c2VyTGlzdFR5cGU6IHVzZXJMaXN0VHlwZSwgc2V0VXNlckxpc3RUeXBlOiBzZXRVc2VyTGlzdFR5cGUgfSksIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1saXN0X19jb250ZW50XCIsIGNoaWxkcmVuOiBbdXNlckxpc3RUeXBlID09PSAnYWN0aXZlJyAmJiAoanN4KEFjdGl2ZVVzZXJzU2VhcmNoUmVzdWx0cywgeyBzZWFyY2hRdWVyeTogc2VhcmNoUXVlcnksIGFjdGl2ZVVzZXJzU2VhcmNoRm46IGFjdGl2ZVVzZXJzU2VhcmNoRm4sIGRlYm91bmNlU2VhcmNoSW50ZXJ2YWw6IGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwgfSkpLCB1c2VyTGlzdFR5cGUgPT09ICdibG9ja2VkJyAmJiAoanN4KEJsb2NrZWRVc2Vyc1NlYXJjaFJlc3VsdHMsIHsgc2VhcmNoUXVlcnk6IHNlYXJjaFF1ZXJ5LCBibG9ja2VkVXNlcnNTZWFyY2hGbjogYmxvY2tlZFVzZXJzU2VhcmNoRm4sIGRlYm91bmNlU2VhcmNoSW50ZXJ2YWw6IGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwgfSkpXSB9KV0gfSkpO1xufTtcbmNvbnN0IENhbGxQYXJ0aWNpcGFudExpc3RDb250ZW50SGVhZGVyID0gKHsgdXNlckxpc3RUeXBlLCBzZXRVc2VyTGlzdFR5cGUsIH0pID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IG11dGVBbGwgPSAoKSA9PiB7XG4gICAgICAgIGNhbGw/Lm11dGVBbGxVc2VycygnYXVkaW8nKTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWxpc3RfX2NvbnRlbnQtaGVhZGVyXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtbGlzdF9fY29udGVudC1oZWFkZXItdGl0bGVcIiwgY2hpbGRyZW46IHVzZXJMaXN0VHlwZSA9PT0gJ2FjdGl2ZScgJiYgKGpzeChSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5NVVRFX1VTRVJTXSwgaGFzUGVybWlzc2lvbnNPbmx5OiB0cnVlLCBjaGlsZHJlbjoganN4KFRleHRCdXR0b24sIHsgb25DbGljazogbXV0ZUFsbCwgY2hpbGRyZW46IFwiTXV0ZSBhbGxcIiB9KSB9KSkgfSksIGpzeChNZW51VG9nZ2xlLCB7IHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsIFRvZ2dsZUJ1dHRvbjogVG9nZ2xlQnV0dG9uJDEsIGNoaWxkcmVuOiBqc3goR2VuZXJpY01lbnUsIHsgY2hpbGRyZW46IE9iamVjdC5rZXlzKFVzZXJMaXN0VHlwZXMpLm1hcCgobHQpID0+IChqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IFwiYXJpYS1zZWxlY3RlZFwiOiBsdCA9PT0gdXNlckxpc3RUeXBlLCBvbkNsaWNrOiAoKSA9PiBzZXRVc2VyTGlzdFR5cGUobHQpLCBjaGlsZHJlbjogVXNlckxpc3RUeXBlc1tsdF0gfSwgbHQpKSkgfSkgfSldIH0pKTtcbn07XG5jb25zdCBBY3RpdmVVc2Vyc1NlYXJjaFJlc3VsdHMgPSAoeyBzZWFyY2hRdWVyeSwgYWN0aXZlVXNlcnNTZWFyY2hGbjogYWN0aXZlVXNlcnNTZWFyY2hGbkZyb21Qcm9wcywgZGVib3VuY2VTZWFyY2hJbnRlcnZhbCA9IERFRkFVTFRfREVCT1VOQ0VfU0VBUkNIX0lOVEVSVkFMLCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VQYXJ0aWNpcGFudHMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gdXNlUGFydGljaXBhbnRzKHsgc29ydEJ5OiBuYW1lIH0pO1xuICAgIGNvbnN0IGFjdGl2ZVVzZXJzU2VhcmNoRm4gPSB1c2VDYWxsYmFjaygocXVlcnlTdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnlSZWdFeHAgPSBuZXcgUmVnRXhwKHF1ZXJ5U3RyaW5nLCAnaScpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBhcnRpY2lwYW50cy5maWx0ZXIoKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcGFydGljaXBhbnQubmFtZS5tYXRjaChxdWVyeVJlZ0V4cCk7XG4gICAgICAgIH0pKTtcbiAgICB9LCBbcGFydGljaXBhbnRzXSk7XG4gICAgY29uc3QgeyBzZWFyY2hRdWVyeUluUHJvZ3Jlc3MsIHNlYXJjaFJlc3VsdHMgfSA9IHVzZVNlYXJjaCh7XG4gICAgICAgIHNlYXJjaEZuOiBhY3RpdmVVc2Vyc1NlYXJjaEZuRnJvbVByb3BzID8/IGFjdGl2ZVVzZXJzU2VhcmNoRm4sXG4gICAgICAgIGRlYm91bmNlSW50ZXJ2YWw6IGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwsXG4gICAgICAgIHNlYXJjaFF1ZXJ5LFxuICAgIH0pO1xuICAgIHJldHVybiAoanN4KFNlYXJjaFJlc3VsdHMsIHsgRW1wdHlTZWFyY2hSZXN1bHRDb21wb25lbnQ6IEVtcHR5UGFydGljaXBhbnRTZWFyY2hMaXN0LCBMb2FkaW5nSW5kaWNhdG9yOiBMb2FkaW5nSW5kaWNhdG9yLCBzZWFyY2hRdWVyeUluUHJvZ3Jlc3M6IHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcywgc2VhcmNoUmVzdWx0czogc2VhcmNoUXVlcnkgPyBzZWFyY2hSZXN1bHRzIDogcGFydGljaXBhbnRzLCBTZWFyY2hSZXN1bHRMaXN0OiBDYWxsUGFydGljaXBhbnRMaXN0aW5nIH0pKTtcbn07XG5jb25zdCBCbG9ja2VkVXNlcnNTZWFyY2hSZXN1bHRzID0gKHsgYmxvY2tlZFVzZXJzU2VhcmNoRm46IGJsb2NrZWRVc2Vyc1NlYXJjaEZuRnJvbVByb3BzLCBkZWJvdW5jZVNlYXJjaEludGVydmFsID0gREVGQVVMVF9ERUJPVU5DRV9TRUFSQ0hfSU5URVJWQUwsIHNlYXJjaFF1ZXJ5LCB9KSA9PiB7XG4gICAgY29uc3QgeyB1c2VDYWxsQmxvY2tlZFVzZXJJZHMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgYmxvY2tlZFVzZXJzID0gdXNlQ2FsbEJsb2NrZWRVc2VySWRzKCk7XG4gICAgY29uc3QgYmxvY2tlZFVzZXJzU2VhcmNoRm4gPSB1c2VDYWxsYmFjaygocXVlcnlTdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnlSZWdFeHAgPSBuZXcgUmVnRXhwKHF1ZXJ5U3RyaW5nLCAnaScpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJsb2NrZWRVc2Vycy5maWx0ZXIoKGJsb2NrZWRVc2VyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYmxvY2tlZFVzZXIubWF0Y2gocXVlcnlSZWdFeHApO1xuICAgICAgICB9KSk7XG4gICAgfSwgW2Jsb2NrZWRVc2Vyc10pO1xuICAgIGNvbnN0IHsgc2VhcmNoUXVlcnlJblByb2dyZXNzLCBzZWFyY2hSZXN1bHRzIH0gPSB1c2VTZWFyY2goe1xuICAgICAgICBzZWFyY2hGbjogYmxvY2tlZFVzZXJzU2VhcmNoRm5Gcm9tUHJvcHMgPz8gYmxvY2tlZFVzZXJzU2VhcmNoRm4sXG4gICAgICAgIGRlYm91bmNlSW50ZXJ2YWw6IGRlYm91bmNlU2VhcmNoSW50ZXJ2YWwsXG4gICAgICAgIHNlYXJjaFF1ZXJ5LFxuICAgIH0pO1xuICAgIHJldHVybiAoanN4KFNlYXJjaFJlc3VsdHMsIHsgRW1wdHlTZWFyY2hSZXN1bHRDb21wb25lbnQ6IEVtcHR5UGFydGljaXBhbnRTZWFyY2hMaXN0LCBMb2FkaW5nSW5kaWNhdG9yOiBMb2FkaW5nSW5kaWNhdG9yLCBzZWFyY2hRdWVyeUluUHJvZ3Jlc3M6IHNlYXJjaFF1ZXJ5SW5Qcm9ncmVzcywgc2VhcmNoUmVzdWx0czogc2VhcmNoUXVlcnkgPyBzZWFyY2hSZXN1bHRzIDogYmxvY2tlZFVzZXJzLCBTZWFyY2hSZXN1bHRMaXN0OiBCbG9ja2VkVXNlckxpc3RpbmcgfSkpO1xufTtcbmNvbnN0IFRvZ2dsZUJ1dHRvbiQxID0gZm9yd2FyZFJlZihmdW5jdGlvbiBUb2dnbGVCdXR0b24ocHJvcHMsIHJlZikge1xuICAgIHJldHVybiBqc3goSWNvbkJ1dHRvbiwgeyBlbmFibGVkOiBwcm9wcy5tZW51U2hvd24sIGljb246IFwiZmlsdGVyXCIsIHJlZjogcmVmIH0pO1xufSk7XG5cbmNvbnN0IENhbGxQcmV2aWV3ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlQ2FsbFRodW1ibmFpbCB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCB0aHVtYm5haWwgPSB1c2VDYWxsVGh1bWJuYWlsKCk7XG4gICAgY29uc3QgW2ltYWdlUmVmLCBzZXRJbWFnZVJlZl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWltYWdlUmVmIHx8ICFjYWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gY2FsbC5iaW5kQ2FsbFRodW1ibmFpbEVsZW1lbnQoaW1hZ2VSZWYpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYW51cCgpO1xuICAgIH0sIFtpbWFnZVJlZiwgY2FsbF0pO1xuICAgIGlmICghdGh1bWJuYWlsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeChcImltZ1wiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19jYWxsLXByZXZpZXcnLCBjbGFzc05hbWUpLCBzdHlsZTogc3R5bGUsIGFsdDogXCJDYWxsIFByZXZpZXcgVGh1bWJuYWlsXCIsIHJlZjogc2V0SW1hZ2VSZWYgfSkpO1xufTtcblxuY29uc3QgQ2FsbFJlY29yZGluZ0xpc3RIZWFkZXIgPSAoeyBjYWxsUmVjb3JkaW5ncywgb25SZWZyZXNoLCB9KSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9faGVhZGVyXCIsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RpdGxlXCIsIGNoaWxkcmVuOiBbanN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiB0KCdDYWxsIFJlY29yZGluZ3MnKSB9KSwgY2FsbFJlY29yZGluZ3MubGVuZ3RoID8ganN4cyhcInNwYW5cIiwgeyBjaGlsZHJlbjogW1wiKFwiLCBjYWxsUmVjb3JkaW5ncy5sZW5ndGgsIFwiKVwiXSB9KSA6IG51bGxdIH0pLCBvblJlZnJlc2ggJiYgKGpzeChJY29uQnV0dG9uLCB7IGljb246IFwicmVmcmVzaFwiLCB0aXRsZTogdCgnUmVmcmVzaCcpLCBvbkNsaWNrOiBvblJlZnJlc2ggfSkpXSB9KSk7XG59O1xuXG5jb25zdCBkYXRlRm9ybWF0ID0gKGRhdGUpID0+IHtcbiAgICBjb25zdCBmb3JtYXQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICByZXR1cm4gZm9ybWF0LnRvVGltZVN0cmluZygpLnNwbGl0KCcgJylbMF07XG59O1xuY29uc3QgQ2FsbFJlY29yZGluZ0xpc3RJdGVtID0gKHsgcmVjb3JkaW5nLCB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3hzKFwibGlcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19pdGVtXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGFibGUtY2VsbCBzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2ZpbGVuYW1lXCIsIGNoaWxkcmVuOiByZWNvcmRpbmcuZmlsZW5hbWUgfSksIGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RhYmxlLWNlbGwgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190aW1lXCIsIGNoaWxkcmVuOiBkYXRlRm9ybWF0KHJlY29yZGluZy5zdGFydF90aW1lKSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGFibGUtY2VsbCBzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX3RpbWVcIiwgY2hpbGRyZW46IGRhdGVGb3JtYXQocmVjb3JkaW5nLmVuZF90aW1lKSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGFibGUtY2VsbCBzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2Rvd25sb2FkXCIsIGNoaWxkcmVuOiBqc3goXCJhXCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3QtaXRlbV9fYWN0aW9uLWJ1dHRvbicsICdzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3QtaXRlbV9fYWN0aW9uLWJ1dHRvbi0tZG93bmxvYWQnKSwgcm9sZTogXCJidXR0b25cIiwgaHJlZjogcmVjb3JkaW5nLnVybCwgZG93bmxvYWQ6IHJlY29yZGluZy5maWxlbmFtZSwgdGl0bGU6IFwiRG93bmxvYWQgdGhlIHJlY29yZGluZ1wiLCBjaGlsZHJlbjoganN4KEljb24sIHsgaWNvbjogXCJkb3dubG9hZFwiIH0pIH0pIH0pXSB9KSk7XG59O1xuXG5jb25zdCBFbXB0eUNhbGxSZWNvcmRpbmdMaXN0aW5nID0gKCkgPT4ge1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2xpc3Rpbmcgc3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nLS1lbXB0eVwiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2xpc3RpbmctLWljb24tZW1wdHlcIiB9KSwganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RfX2xpc3RpbmctLXRleHQtZW1wdHlcIiwgY2hpbGRyZW46IFwiTm8gcmVjb3JkaW5ncyBhdmFpbGFibGVcIiB9KV0gfSkpO1xufTtcblxuY29uc3QgTG9hZGluZ0NhbGxSZWNvcmRpbmdMaXN0aW5nID0gKHsgY2FsbFJlY29yZGluZ3MsIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtjYWxsUmVjb3JkaW5ncy5tYXAoKHJlY29yZGluZykgPT4gKGpzeChDYWxsUmVjb3JkaW5nTGlzdEl0ZW0sIHsgcmVjb3JkaW5nOiByZWNvcmRpbmcgfSwgcmVjb3JkaW5nLmZpbGVuYW1lKSkpLCBqc3goTG9hZGluZ0luZGljYXRvciwgeyB0ZXh0OiBcIlJlY29yZGluZyBnZXR0aW5nIHJlYWR5XCIgfSldIH0pKTtcbn07XG5cbmNvbnN0IENhbGxSZWNvcmRpbmdMaXN0ID0gKHsgY2FsbFJlY29yZGluZ3MsIENhbGxSZWNvcmRpbmdMaXN0SGVhZGVyOiBDYWxsUmVjb3JkaW5nTGlzdEhlYWRlciQxID0gQ2FsbFJlY29yZGluZ0xpc3RIZWFkZXIsIENhbGxSZWNvcmRpbmdMaXN0SXRlbTogQ2FsbFJlY29yZGluZ0xpc3RJdGVtJDEgPSBDYWxsUmVjb3JkaW5nTGlzdEl0ZW0sIEVtcHR5Q2FsbFJlY29yZGluZ0xpc3QgPSBFbXB0eUNhbGxSZWNvcmRpbmdMaXN0aW5nLCBsb2FkaW5nLCBMb2FkaW5nQ2FsbFJlY29yZGluZ0xpc3QgPSBMb2FkaW5nQ2FsbFJlY29yZGluZ0xpc3RpbmcsIG9uUmVmcmVzaCwgfSkgPT4ge1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcmVjb3JkaW5nLWxpc3RcIiwgY2hpbGRyZW46IFtqc3goQ2FsbFJlY29yZGluZ0xpc3RIZWFkZXIkMSwgeyBjYWxsUmVjb3JkaW5nczogY2FsbFJlY29yZGluZ3MsIG9uUmVmcmVzaDogb25SZWZyZXNoIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0aW5nXCIsIGNoaWxkcmVuOiBsb2FkaW5nID8gKGpzeChMb2FkaW5nQ2FsbFJlY29yZGluZ0xpc3QsIHsgY2FsbFJlY29yZGluZ3M6IGNhbGxSZWNvcmRpbmdzIH0pKSA6IGNhbGxSZWNvcmRpbmdzLmxlbmd0aCA/IChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwidWxcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0XCIsIGNoaWxkcmVuOiBqc3hzKFwibGlcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19pdGVtXCIsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fZmlsZW5hbWVcIiwgY2hpbGRyZW46IFwiTmFtZVwiIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X190aW1lXCIsIGNoaWxkcmVuOiBcIlN0YXJ0IHRpbWVcIiB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1yZWNvcmRpbmctbGlzdF9fdGltZVwiLCBjaGlsZHJlbjogXCJFbmQgdGltZVwiIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19kb3dubG9hZFwiIH0pXSB9KSB9KSwganN4KFwidWxcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXJlY29yZGluZy1saXN0X19saXN0XCIsIGNoaWxkcmVuOiBjYWxsUmVjb3JkaW5ncy5tYXAoKHJlY29yZGluZykgPT4gKGpzeChDYWxsUmVjb3JkaW5nTGlzdEl0ZW0kMSwgeyByZWNvcmRpbmc6IHJlY29yZGluZyB9LCByZWNvcmRpbmcuZmlsZW5hbWUpKSkgfSldIH0pKSA6IChqc3goRW1wdHlDYWxsUmVjb3JkaW5nTGlzdCwge30pKSB9KV0gfSkpO1xufTtcblxuY29uc3QgUmluZ2luZ0NhbGxDb250cm9scyA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlQ2FsbENhbGxpbmdTdGF0ZSB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBjYWxsQ2FsbGluZ1N0YXRlID0gdXNlQ2FsbENhbGxpbmdTdGF0ZSgpO1xuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgYnV0dG9uc0Rpc2FibGVkID0gY2FsbENhbGxpbmdTdGF0ZSAhPT0gQ2FsbGluZ1N0YXRlLlJJTkdJTkc7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZW5kaW5nLWNhbGwtY29udHJvbHNcIiwgY2hpbGRyZW46IGNhbGwuaXNDcmVhdGVkQnlNZSA/IChqc3goQ2FuY2VsQ2FsbEJ1dHRvbiwgeyBkaXNhYmxlZDogYnV0dG9uc0Rpc2FibGVkIH0pKSA6IChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KEFjY2VwdENhbGxCdXR0b24sIHsgZGlzYWJsZWQ6IGJ1dHRvbnNEaXNhYmxlZCB9KSwganN4KENhbmNlbENhbGxCdXR0b24sIHsgb25DbGljazogKCkgPT4gY2FsbC5sZWF2ZSh7IHJlamVjdDogdHJ1ZSB9KSwgZGlzYWJsZWQ6IGJ1dHRvbnNEaXNhYmxlZCB9KV0gfSkpIH0pKTtcbn07XG5cbmNvbnN0IENBTExJTkdfU1RBVEVfVE9fTEFCRUwgPSB7XG4gICAgW0NhbGxpbmdTdGF0ZS5KT0lOSU5HXTogJ0pvaW5pbmcnLFxuICAgIFtDYWxsaW5nU3RhdGUuUklOR0lOR106ICdSaW5naW5nJyxcbiAgICBbQ2FsbGluZ1N0YXRlLk1JR1JBVElOR106ICdNaWdyYXRpbmcnLFxuICAgIFtDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HXTogJ1JlLWNvbm5lY3RpbmcnLFxuICAgIFtDYWxsaW5nU3RhdGUuUkVDT05ORUNUSU5HX0ZBSUxFRF06ICdGYWlsZWQnLFxuICAgIFtDYWxsaW5nU3RhdGUuT0ZGTElORV06ICdObyBpbnRlcm5ldCBjb25uZWN0aW9uJyxcbiAgICBbQ2FsbGluZ1N0YXRlLklETEVdOiAnJyxcbiAgICBbQ2FsbGluZ1N0YXRlLlVOS05PV05dOiAnJyxcbiAgICBbQ2FsbGluZ1N0YXRlLkpPSU5FRF06ICdKb2luZWQnLFxuICAgIFtDYWxsaW5nU3RhdGUuTEVGVF06ICdMZWZ0IGNhbGwnLFxufTtcbmNvbnN0IFJpbmdpbmdDYWxsID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBpbmNsdWRlU2VsZiA9IGZhbHNlLCB0b3RhbE1lbWJlcnNUb1Nob3cgPSAzIH0gPSBwcm9wcztcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHsgdXNlQ2FsbENhbGxpbmdTdGF0ZSwgdXNlQ2FsbE1lbWJlcnMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgY2FsbGluZ1N0YXRlID0gdXNlQ2FsbENhbGxpbmdTdGF0ZSgpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB1c2VDYWxsTWVtYmVycygpO1xuICAgIGNvbnN0IGNvbm5lY3RlZFVzZXIgPSB1c2VDb25uZWN0ZWRVc2VyKCk7XG4gICAgaWYgKCFjYWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyB0YWtlIHRoZSBmaXJzdCBOIG1lbWJlcnMgdG8gc2hvdyB0aGVpciBhdmF0YXJzXG4gICAgY29uc3QgbWVtYmVyc1RvU2hvdyA9IChtZW1iZXJzIHx8IFtdKVxuICAgICAgICAuc2xpY2UoMCwgdG90YWxNZW1iZXJzVG9TaG93KVxuICAgICAgICAubWFwKCh7IHVzZXIgfSkgPT4gdXNlcilcbiAgICAgICAgLmZpbHRlcigodXNlcikgPT4gdXNlci5pZCAhPT0gY29ubmVjdGVkVXNlcj8uaWQgfHwgaW5jbHVkZVNlbGYpO1xuICAgIGlmIChpbmNsdWRlU2VsZiAmJlxuICAgICAgICAhbWVtYmVyc1RvU2hvdy5maW5kKCh1c2VyKSA9PiB1c2VyLmlkID09PSBjb25uZWN0ZWRVc2VyPy5pZCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgdXNlciBpcyBub3QgaW4gdGhlIGluaXRpYWwgYmF0Y2ggb2YgbWVtYmVycyxcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgZmlyc3QgaXRlbSBpbiBtZW1iZXJzVG9TaG93IGFycmF5IHdpdGggdGhlIGN1cnJlbnQgdXNlclxuICAgICAgICBjb25zdCBzZWxmID0gbWVtYmVycy5maW5kKCh7IHVzZXIgfSkgPT4gdXNlci5pZCA9PT0gY29ubmVjdGVkVXNlcj8uaWQpO1xuICAgICAgICBpZiAoc2VsZikge1xuICAgICAgICAgICAgbWVtYmVyc1RvU2hvdy5zcGxpY2UoMCwgMSwgc2VsZi51c2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYWxsaW5nU3RhdGVMYWJlbCA9IENBTExJTkdfU1RBVEVfVE9fTEFCRUxbY2FsbGluZ1N0YXRlXTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19jYWxsLXBhbmVsIHN0ci12aWRlb19fY2FsbC1wYW5lbC0tcmluZ2luZ1wiLCBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2NhbGwtcGFuZWxfX21lbWJlcnMtbGlzdFwiLCBjaGlsZHJlbjogbWVtYmVyc1RvU2hvdy5tYXAoKHVzZXIpID0+IChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1wYW5lbF9fbWVtYmVyLWJveFwiLCBjaGlsZHJlbjogW2pzeChBdmF0YXIsIHsgbmFtZTogdXNlci5uYW1lLCBpbWFnZVNyYzogdXNlci5pbWFnZSB9KSwgdXNlci5uYW1lICYmIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19tZW1iZXJfZGV0YWlsc1wiLCBjaGlsZHJlbjoganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX21lbWJlcl9uYW1lXCIsIGNoaWxkcmVuOiB1c2VyLm5hbWUgfSkgfSkpXSB9LCB1c2VyLmlkKSkpIH0pLCBjYWxsaW5nU3RhdGVMYWJlbCAmJiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fY2FsbC1wYW5lbF9fY2FsbGluZy1zdGF0ZS1sYWJlbFwiLCBjaGlsZHJlbjogdChjYWxsaW5nU3RhdGVMYWJlbCkgfSkpLCBbQ2FsbGluZ1N0YXRlLlJJTkdJTkcsIENhbGxpbmdTdGF0ZS5KT0lOSU5HXS5pbmNsdWRlcyhjYWxsaW5nU3RhdGUpICYmIChqc3goUmluZ2luZ0NhbGxDb250cm9scywge30pKV0gfSkpO1xufTtcblxuY29uc3QgYnlOYW1lT3JJZCA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEubmFtZSAmJiBiLm5hbWUgJiYgYS5uYW1lIDwgYi5uYW1lKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEubmFtZSAmJiBiLm5hbWUgJiYgYS5uYW1lID4gYi5uYW1lKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoYS5pZCA8IGIuaWQpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoYS5pZCA+IGIuaWQpXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IFBlcm1pc3Npb25SZXF1ZXN0cyA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlTG9jYWxQYXJ0aWNpcGFudCwgdXNlSGFzUGVybWlzc2lvbnMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgbG9jYWxQYXJ0aWNpcGFudCA9IHVzZUxvY2FsUGFydGljaXBhbnQoKTtcbiAgICBjb25zdCBbZXhwYW5kZWQsIHNldEV4cGFuZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcGVybWlzc2lvblJlcXVlc3RzLCBzZXRQZXJtaXNzaW9uUmVxdWVzdHNdID0gdXNlU3RhdGUoW10pO1xuICAgIGNvbnN0IGNhblVwZGF0ZUNhbGxQZXJtaXNzaW9ucyA9IHVzZUhhc1Blcm1pc3Npb25zKE93bkNhcGFiaWxpdHkuVVBEQVRFX0NBTExfUEVSTUlTU0lPTlMpO1xuICAgIGNvbnN0IGxvY2FsVXNlcklkID0gbG9jYWxQYXJ0aWNpcGFudD8udXNlcklkO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FsbCB8fCAhY2FuVXBkYXRlQ2FsbFBlcm1pc3Npb25zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gY2FsbC5vbignY2FsbC5wZXJtaXNzaW9uX3JlcXVlc3QnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC51c2VyLmlkICE9PSBsb2NhbFVzZXJJZCkge1xuICAgICAgICAgICAgICAgIHNldFBlcm1pc3Npb25SZXF1ZXN0cygocmVxdWVzdHMpID0+IFsuLi5yZXF1ZXN0cywgZXZlbnRdLnNvcnQoKGEsIGIpID0+IGJ5TmFtZU9ySWQoYS51c2VyLCBiLnVzZXIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtjYWxsLCBjYW5VcGRhdGVDYWxsUGVybWlzc2lvbnMsIGxvY2FsVXNlcklkXSk7XG4gICAgY29uc3QgaGFuZGxlVXBkYXRlUGVybWlzc2lvbiA9IChyZXF1ZXN0LCB0eXBlKSA9PiB7XG4gICAgICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXIsIHBlcm1pc3Npb25zIH0gPSByZXF1ZXN0O1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZ3JhbnQnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWxsPy5ncmFudFBlcm1pc3Npb25zKHVzZXIuaWQsIHBlcm1pc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmV2b2tlJzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FsbD8ucmV2b2tlUGVybWlzc2lvbnModXNlci5pZCwgcGVybWlzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFBlcm1pc3Npb25SZXF1ZXN0cygocmVxdWVzdHMpID0+IHJlcXVlc3RzLmZpbHRlcigocikgPT4gciAhPT0gcmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgeyByZWZzLCB4LCB5LCBzdHJhdGVneSB9ID0gdXNlRmxvYXRpbmdVSVByZXNldCh7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIH0pO1xuICAgIC8vIGRvbid0IHJlbmRlciBhbnl0aGluZyBpZiB0aGVyZSBhcmUgbm8gcGVybWlzc2lvbiByZXF1ZXN0c1xuICAgIGlmIChwZXJtaXNzaW9uUmVxdWVzdHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RzXCIsIHJlZjogcmVmcy5zZXRSZWZlcmVuY2UsIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3Blcm1pc3Npb24tcmVxdWVzdHNfX25vdGlmaWNhdGlvblwiLCBjaGlsZHJlbjogW2pzeHMoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0c19fbm90aWZpY2F0aW9uX19tZXNzYWdlXCIsIGNoaWxkcmVuOiBbcGVybWlzc2lvblJlcXVlc3RzLmxlbmd0aCwgXCIgcGVuZGluZyBwZXJtaXNzaW9uIHJlcXVlc3RzXCJdIH0pLCBqc3goQnV0dG9uLCB7IHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFeHBhbmRlZCgoZSkgPT4gIWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGV4cGFuZGVkID8gJ0hpZGUgcmVxdWVzdHMnIDogJ1Nob3cgcmVxdWVzdHMnIH0pXSB9KSwgZXhwYW5kZWQgJiYgKGpzeChQZXJtaXNzaW9uUmVxdWVzdExpc3QsIHsgcmVmOiByZWZzLnNldEZsb2F0aW5nLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogeSA/PyAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nLFxuICAgICAgICAgICAgICAgIH0sIHBlcm1pc3Npb25SZXF1ZXN0czogcGVybWlzc2lvblJlcXVlc3RzLCBoYW5kbGVVcGRhdGVQZXJtaXNzaW9uOiBoYW5kbGVVcGRhdGVQZXJtaXNzaW9uIH0pKV0gfSkpO1xufTtcbmNvbnN0IFBlcm1pc3Npb25SZXF1ZXN0TGlzdCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gUGVybWlzc2lvblJlcXVlc3RMaXN0KHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7IHBlcm1pc3Npb25SZXF1ZXN0cywgaGFuZGxlVXBkYXRlUGVybWlzc2lvbiwgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RzLWxpc3RcIiwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBwZXJtaXNzaW9uUmVxdWVzdHMubWFwKChyZXF1ZXN0LCByZXFJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VyLCBwZXJtaXNzaW9ucyB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHJldHVybiAoanN4KEZyYWdtZW50JDEsIHsgY2hpbGRyZW46IHBlcm1pc3Npb25zLm1hcCgocGVybWlzc2lvbikgPT4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RfX21lc3NhZ2VcIiwgY2hpbGRyZW46IG1lc3NhZ2VGb3JQZXJtaXNzaW9uKHVzZXIubmFtZSB8fCB1c2VyLmlkLCBwZXJtaXNzaW9uLCB0KSB9KSwganN4KEJ1dHRvbiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RfX2J1dHRvbi0tYWxsb3dcIiwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogaGFuZGxlVXBkYXRlUGVybWlzc2lvbihyZXF1ZXN0LCAnZ3JhbnQnKSwgY2hpbGRyZW46IHQoJ0FsbG93JykgfSksIGpzeChCdXR0b24sIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGVybWlzc2lvbi1yZXF1ZXN0X19idXR0b24tLXJlamVjdFwiLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBoYW5kbGVVcGRhdGVQZXJtaXNzaW9uKHJlcXVlc3QsICdyZXZva2UnKSwgY2hpbGRyZW46IHQoJ1Jldm9rZScpIH0pLCBqc3goQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3Blcm1pc3Npb24tcmVxdWVzdF9fYnV0dG9uLS1yZWplY3RcIiwgdHlwZTogXCJidXR0b25cIiwgb25DbGljazogaGFuZGxlVXBkYXRlUGVybWlzc2lvbihyZXF1ZXN0LCAnZGlzbWlzcycpLCBjaGlsZHJlbjogdCgnRGlzbWlzcycpIH0pXSB9LCBwZXJtaXNzaW9uKSkpIH0sIGAke3VzZXIuaWR9LyR7cmVxSW5kZXh9YCkpO1xuICAgICAgICB9KSB9KSk7XG59KTtcbmNvbnN0IEJ1dHRvbiA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCAuLi5yZXN0IH0gPSBwcm9wcztcbiAgICByZXR1cm4gKGpzeChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19wZXJtaXNzaW9uLXJlcXVlc3RfX2J1dHRvbicsIGNsYXNzTmFtZSksIC4uLnJlc3QgfSkpO1xufTtcbmNvbnN0IG1lc3NhZ2VGb3JQZXJtaXNzaW9uID0gKHVzZXJOYW1lLCBwZXJtaXNzaW9uLCB0KSA9PiB7XG4gICAgc3dpdGNoIChwZXJtaXNzaW9uKSB7XG4gICAgICAgIGNhc2UgT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPOlxuICAgICAgICAgICAgcmV0dXJuIHQoJ3t7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gc3BlYWsnLCB7IHVzZXJOYW1lIH0pO1xuICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0VORF9WSURFTzpcbiAgICAgICAgICAgIHJldHVybiB0KCd7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNoYXJlIHRoZWlyIGNhbWVyYScsIHtcbiAgICAgICAgICAgICAgICB1c2VyTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkU6XG4gICAgICAgICAgICByZXR1cm4gdCgne3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBwcmVzZW50IHRoZWlyIHNjcmVlbicsIHtcbiAgICAgICAgICAgICAgICB1c2VyTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHQoJ3t7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbjoge3sgcGVybWlzc2lvbiB9fScsIHtcbiAgICAgICAgICAgICAgICB1c2VyTmFtZSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuY29uc3QgU3RyZWFtVGhlbWUgPSAoeyBhczogQ29tcG9uZW50ID0gJ2RpdicsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICByZXR1cm4gKGpzeChDb21wb25lbnQsIHsgLi4ucHJvcHMsIGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvJywgY2xhc3NOYW1lKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IERlZmF1bHRWaWRlb1BsYWNlaG9sZGVyID0gZm9yd2FyZFJlZihmdW5jdGlvbiBEZWZhdWx0VmlkZW9QbGFjZWhvbGRlcih7IHBhcnRpY2lwYW50LCBzdHlsZSB9LCByZWYpIHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBuYW1lID0gcGFydGljaXBhbnQubmFtZSB8fCBwYXJ0aWNpcGFudC51c2VySWQ7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fdmlkZW8tcGxhY2Vob2xkZXJcIiwgc3R5bGU6IHN0eWxlLCByZWY6IHJlZiwgY2hpbGRyZW46IFsoIXBhcnRpY2lwYW50LmltYWdlIHx8IGVycm9yKSAmJlxuICAgICAgICAgICAgICAgIChuYW1lID8gKGpzeChJbml0aWFsc0ZhbGxiYWNrLCB7IG5hbWU6IG5hbWUgfSkpIDogKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3ZpZGVvLXBsYWNlaG9sZGVyX19uby12aWRlby1sYWJlbFwiLCBjaGlsZHJlbjogdCgnVmlkZW8gaXMgZGlzYWJsZWQnKSB9KSkpLCBwYXJ0aWNpcGFudC5pbWFnZSAmJiAhZXJyb3IgJiYgKGpzeChcImltZ1wiLCB7IG9uRXJyb3I6ICgpID0+IHNldEVycm9yKHRydWUpLCBhbHQ6IFwidmlkZW8tcGxhY2Vob2xkZXJcIiwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fdmlkZW8tcGxhY2Vob2xkZXJfX2F2YXRhclwiLCBzcmM6IHBhcnRpY2lwYW50LmltYWdlIH0pKV0gfSkpO1xufSk7XG5jb25zdCBJbml0aWFsc0ZhbGxiYWNrID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBuYW1lIH0gPSBwcm9wcztcbiAgICBjb25zdCBpbml0aWFscyA9IG5hbWVcbiAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgLnNsaWNlKDAsIDIpXG4gICAgICAgIC5tYXAoKG4pID0+IG5bMF0pXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3ZpZGVvLXBsYWNlaG9sZGVyX19pbml0aWFscy1mYWxsYmFja1wiLCBjaGlsZHJlbjogaW5pdGlhbHMgfSkpO1xufTtcblxuY29uc3QgVmlkZW8kMSA9ICh7IHRyYWNrVHlwZSwgcGFydGljaXBhbnQsIGNsYXNzTmFtZSwgVmlkZW9QbGFjZWhvbGRlciA9IERlZmF1bHRWaWRlb1BsYWNlaG9sZGVyLCByZWZzLCAuLi5yZXN0IH0pID0+IHtcbiAgICBjb25zdCB7IHNlc3Npb25JZCwgdmlkZW9TdHJlYW0sIHNjcmVlblNoYXJlU3RyZWFtLCBwdWJsaXNoZWRUcmFja3MsIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlLCBpc0xvY2FsUGFydGljaXBhbnQsIHVzZXJJZCwgfSA9IHBhcnRpY2lwYW50O1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgW3ZpZGVvRWxlbWVudCwgc2V0VmlkZW9FbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIC8vIHN0YXJ0IHdpdGggdHJ1ZSwgd2lsbCBmbGlwIG9uY2UgdGhlIHZpZGVvIHN0YXJ0cyBwbGF5aW5nXG4gICAgY29uc3QgW2lzVmlkZW9QYXVzZWQsIHNldElzVmlkZW9QYXVzZWRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3QgW2lzV2lkZU1vZGUsIHNldElzV2lkZU1vZGVdID0gdXNlU3RhdGUodHJ1ZSk7XG4gICAgY29uc3Qgc3RyZWFtID0gdHJhY2tUeXBlID09PSAndmlkZW9UcmFjaydcbiAgICAgICAgPyB2aWRlb1N0cmVhbVxuICAgICAgICA6IHRyYWNrVHlwZSA9PT0gJ3NjcmVlblNoYXJlVHJhY2snXG4gICAgICAgICAgICA/IHNjcmVlblNoYXJlU3RyZWFtXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwgfHwgIXZpZGVvRWxlbWVudCB8fCB0cmFja1R5cGUgPT09ICdub25lJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuYmluZFZpZGVvRWxlbWVudCh2aWRlb0VsZW1lbnQsIHNlc3Npb25JZCwgdHJhY2tUeXBlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXA/LigpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxsLCB0cmFja1R5cGUsIHNlc3Npb25JZCwgdmlkZW9FbGVtZW50XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFzdHJlYW0gfHwgIXZpZGVvRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgW3RyYWNrXSA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpO1xuICAgICAgICBpZiAoIXRyYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVQbGF5UGF1c2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc1ZpZGVvUGF1c2VkKHZpZGVvRWxlbWVudC5wYXVzZWQpO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCA9IDAsIGhlaWdodCA9IDAgfSA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBzZXRJc1dpZGVNb2RlKHdpZHRoID49IGhlaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHBsYXliYWNrIG1heSBoYXZlIHN0YXJ0ZWQgYmVmb3JlIHdlIGhhZCBhIGNoYW5jZSB0b1xuICAgICAgICAvLyBhdHRhY2ggdGhlICdwbGF5L3BhdXNlJyBldmVudCBsaXN0ZW5lciwgc28gd2Ugc2V0IHRoZSBzdGF0ZVxuICAgICAgICAvLyBoZXJlIHRvIG1ha2Ugc3VyZSBpdCdzIGluIHN5bmNcbiAgICAgICAgc2V0SXNWaWRlb1BhdXNlZCh2aWRlb0VsZW1lbnQucGF1c2VkKTtcbiAgICAgICAgdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBoYW5kbGVQbGF5UGF1c2UpO1xuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBoYW5kbGVQbGF5UGF1c2UpO1xuICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCd1bm11dGUnLCBoYW5kbGVQbGF5UGF1c2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXknLCBoYW5kbGVQbGF5UGF1c2UpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgaGFuZGxlUGxheVBhdXNlKTtcbiAgICAgICAgICAgIHRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIGhhbmRsZVBsYXlQYXVzZSk7XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgJ3BhdXNlJyBzdGF0ZSBvbmNlIHdlIHVubW91bnQgdGhlIHZpZGVvIGVsZW1lbnRcbiAgICAgICAgICAgIHNldElzVmlkZW9QYXVzZWQodHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW3N0cmVhbSwgdmlkZW9FbGVtZW50XSk7XG4gICAgaWYgKCFjYWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpc1B1Ymxpc2hpbmdUcmFjayA9IHRyYWNrVHlwZSA9PT0gJ3ZpZGVvVHJhY2snXG4gICAgICAgID8gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuVklERU8pXG4gICAgICAgIDogdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVUcmFjaydcbiAgICAgICAgICAgID8gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuU0NSRUVOX1NIQVJFKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCBpc0ludmlzaWJsZSA9IHRyYWNrVHlwZSA9PT0gJ25vbmUnIHx8XG4gICAgICAgIHZpZXdwb3J0VmlzaWJpbGl0eVN0YXRlPy5bdHJhY2tUeXBlXSA9PT0gVmlzaWJpbGl0eVN0YXRlLklOVklTSUJMRTtcbiAgICBjb25zdCBoYXNOb1ZpZGVvT3JJbnZpc2libGUgPSAhaXNQdWJsaXNoaW5nVHJhY2sgfHwgaXNJbnZpc2libGU7XG4gICAgY29uc3QgbWlycm9yVmlkZW8gPSBpc0xvY2FsUGFydGljaXBhbnQgJiYgdHJhY2tUeXBlID09PSAndmlkZW9UcmFjayc7XG4gICAgY29uc3QgaXNTY3JlZW5TaGFyZVRyYWNrID0gdHJhY2tUeXBlID09PSAnc2NyZWVuU2hhcmVUcmFjayc7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbIWhhc05vVmlkZW9PckludmlzaWJsZSAmJiAoanN4KFwidmlkZW9cIiwgeyAuLi5yZXN0LCBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fdmlkZW8nLCBjbGFzc05hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tLW5vdC1wbGF5aW5nJzogaXNWaWRlb1BhdXNlZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tLXRhbGwnOiAhaXNXaWRlTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tLW1pcnJvcic6IG1pcnJvclZpZGVvLFxuICAgICAgICAgICAgICAgICAgICAnc3RyLXZpZGVvX192aWRlby0tc2NyZWVuLXNoYXJlJzogaXNTY3JlZW5TaGFyZVRyYWNrLFxuICAgICAgICAgICAgICAgIH0pLCBcImRhdGEtdXNlci1pZFwiOiB1c2VySWQsIFwiZGF0YS1zZXNzaW9uLWlkXCI6IHNlc3Npb25JZCwgcmVmOiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRWaWRlb0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZnM/LnNldFZpZGVvRWxlbWVudD8uKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gfSkpLCAoaGFzTm9WaWRlb09ySW52aXNpYmxlIHx8IGlzVmlkZW9QYXVzZWQpICYmIFZpZGVvUGxhY2Vob2xkZXIgJiYgKGpzeChWaWRlb1BsYWNlaG9sZGVyLCB7IHN0eWxlOiB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0sIHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCwgcmVmOiByZWZzPy5zZXRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudCB9KSldIH0pKTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEV4dGVuZHMgdmlkZW8gZWxlbWVudCB3aXRoIGBzdHJlYW1gIHByb3BlcnR5XG4gKiAoYHNyY09iamVjdGApIHRvIHJlYWN0aXZlbHkgaGFuZGxlIHN0cmVhbSBjaGFuZ2VzXG4gKi9cbmNvbnN0IEJhc2VWaWRlbyA9IGZvcndhcmRSZWYoZnVuY3Rpb24gQmFzZVZpZGVvKHsgc3RyZWFtLCAuLi5yZXN0IH0sIHJlZikge1xuICAgIGNvbnN0IFt2aWRlb0VsZW1lbnQsIHNldFZpZGVvRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXZpZGVvRWxlbWVudCB8fCAhc3RyZWFtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoc3RyZWFtID09PSB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICBpZiAoQnJvd3NlcnMuaXNTYWZhcmkoKSB8fCBCcm93c2Vycy5pc0ZpcmVmb3goKSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBhbmQgU2FmYXJpIGhhdmUgc29tZSB0aW1pbmcgaXNzdWVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LnBsYXkoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcGxheSBzdHJlYW1gLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICB9O1xuICAgIH0sIFtzdHJlYW0sIHZpZGVvRWxlbWVudF0pO1xuICAgIHJldHVybiAoanN4KFwidmlkZW9cIiwgeyBhdXRvUGxheTogdHJ1ZSwgcGxheXNJbmxpbmU6IHRydWUsIC4uLnJlc3QsIHJlZjogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGFwcGx5RWxlbWVudFRvUmVmKHJlZiwgZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRWaWRlb0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH0gfSkpO1xufSk7XG5cbmNvbnN0IERlZmF1bHREaXNhYmxlZFZpZGVvUHJldmlldyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHJfdmlkZW9fX3ZpZGVvLXByZXZpZXdfX2Rpc2FibGVkLXZpZGVvLXByZXZpZXdcIiwgY2hpbGRyZW46IHQoJ1ZpZGVvIGlzIGRpc2FibGVkJykgfSkpO1xufTtcbmNvbnN0IERlZmF1bHROb0NhbWVyYVByZXZpZXcgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyX3ZpZGVvX192aWRlby1wcmV2aWV3X19uby1jYW1lcmEtcHJldmlld1wiLCBjaGlsZHJlbjogdCgnTm8gY2FtZXJhIGZvdW5kJykgfSkpO1xufTtcbmNvbnN0IFZpZGVvUHJldmlldyA9ICh7IGNsYXNzTmFtZSwgbWlycm9yID0gdHJ1ZSwgRGlzYWJsZWRWaWRlb1ByZXZpZXcgPSBEZWZhdWx0RGlzYWJsZWRWaWRlb1ByZXZpZXcsIE5vQ2FtZXJhUHJldmlldyA9IERlZmF1bHROb0NhbWVyYVByZXZpZXcsIFN0YXJ0aW5nQ2FtZXJhUHJldmlldyA9IExvYWRpbmdJbmRpY2F0b3IsIH0pID0+IHtcbiAgICBjb25zdCB7IHVzZUNhbWVyYVN0YXRlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IHsgZGV2aWNlcywgc3RhdHVzLCBpc011dGUsIG1lZGlhU3RyZWFtIH0gPSB1c2VDYW1lcmFTdGF0ZSgpO1xuICAgIGxldCBjb250ZW50cztcbiAgICBpZiAoaXNNdXRlICYmIGRldmljZXM/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250ZW50cyA9IGpzeChOb0NhbWVyYVByZXZpZXcsIHt9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdHVzID09PSAnZW5hYmxlZCcpIHtcbiAgICAgICAgY29uc3QgbG9hZGluZyA9ICFtZWRpYVN0cmVhbTtcbiAgICAgICAgY29udGVudHMgPSAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW21lZGlhU3RyZWFtICYmIChqc3goQmFzZVZpZGVvLCB7IHN0cmVhbTogbWVkaWFTdHJlYW0sIGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX192aWRlby1wcmV2aWV3Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tcHJldmlldy0tbWlycm9yJzogbWlycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ci12aWRlb19fdmlkZW8tcHJldmlldy0tbG9hZGluZyc6IGxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0pKSwgbG9hZGluZyAmJiBqc3goU3RhcnRpbmdDYW1lcmFQcmV2aWV3LCB7fSldIH0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnRzID0ganN4KERpc2FibGVkVmlkZW9QcmV2aWV3LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3ZpZGVvLXByZXZpZXctY29udGFpbmVyJywgY2xhc3NOYW1lKSwgY2hpbGRyZW46IGNvbnRlbnRzIH0pKTtcbn07XG5cbmNvbnN0IFBhcnRpY2lwYW50QWN0aW9uc0NvbnRleHRNZW51ID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQsIHBhcnRpY2lwYW50Vmlld0VsZW1lbnQsIHZpZGVvRWxlbWVudCB9ID0gdXNlUGFydGljaXBhbnRWaWV3Q29udGV4dCgpO1xuICAgIGNvbnN0IFtmdWxsc2NyZWVuTW9kZU9uLCBzZXRGdWxsc2NyZWVuTW9kZU9uXSA9IHVzZVN0YXRlKCEhZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQpO1xuICAgIGNvbnN0IFtwaWN0dXJlSW5QaWN0dXJlRWxlbWVudCwgc2V0UGljdHVyZUluUGljdHVyZUVsZW1lbnRdID0gdXNlU3RhdGUoZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQpO1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgeyBwaW4sIHB1Ymxpc2hlZFRyYWNrcywgc2Vzc2lvbklkLCB1c2VySWQgfSA9IHBhcnRpY2lwYW50O1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuVklERU8pO1xuICAgIGNvbnN0IGhhc1NjcmVlblNoYXJlID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuU0NSRUVOX1NIQVJFKTtcbiAgICBjb25zdCBoYXNTY3JlZW5TaGFyZUF1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuU0NSRUVOX1NIQVJFX0FVRElPKTtcbiAgICBjb25zdCBibG9ja1VzZXIgPSAoKSA9PiBjYWxsPy5ibG9ja1VzZXIodXNlcklkKTtcbiAgICBjb25zdCBtdXRlQXVkaW8gPSAoKSA9PiBjYWxsPy5tdXRlVXNlcih1c2VySWQsICdhdWRpbycpO1xuICAgIGNvbnN0IG11dGVWaWRlbyA9ICgpID0+IGNhbGw/Lm11dGVVc2VyKHVzZXJJZCwgJ3ZpZGVvJyk7XG4gICAgY29uc3QgbXV0ZVNjcmVlblNoYXJlID0gKCkgPT4gY2FsbD8ubXV0ZVVzZXIodXNlcklkLCAnc2NyZWVuc2hhcmUnKTtcbiAgICBjb25zdCBtdXRlU2NyZWVuU2hhcmVBdWRpbyA9ICgpID0+IGNhbGw/Lm11dGVVc2VyKHVzZXJJZCwgJ3NjcmVlbnNoYXJlX2F1ZGlvJyk7XG4gICAgY29uc3QgZ3JhbnRQZXJtaXNzaW9uID0gKHBlcm1pc3Npb24pID0+ICgpID0+IHtcbiAgICAgICAgY2FsbD8udXBkYXRlVXNlclBlcm1pc3Npb25zKHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIGdyYW50X3Blcm1pc3Npb25zOiBbcGVybWlzc2lvbl0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmV2b2tlUGVybWlzc2lvbiA9IChwZXJtaXNzaW9uKSA9PiAoKSA9PiB7XG4gICAgICAgIGNhbGw/LnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICByZXZva2VfcGVybWlzc2lvbnM6IFtwZXJtaXNzaW9uXSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0b2dnbGVQYXJ0aWNpcGFudFBpbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBpbikge1xuICAgICAgICAgICAgY2FsbD8udW5waW4oc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGw/LnBpbihzZXNzaW9uSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwaW5Gb3JFdmVyeW9uZSA9ICgpID0+IHtcbiAgICAgICAgY2FsbFxuICAgICAgICAgICAgPy5waW5Gb3JFdmVyeW9uZSh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBpbiBwYXJ0aWNpcGFudCAke3VzZXJJZH1gLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVucGluRm9yRXZlcnlvbmUgPSAoKSA9PiB7XG4gICAgICAgIGNhbGxcbiAgICAgICAgICAgID8udW5waW5Gb3JFdmVyeW9uZSh7XG4gICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgICBzZXNzaW9uX2lkOiBzZXNzaW9uSWQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVucGluIHBhcnRpY2lwYW50ICR7dXNlcklkfWAsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdG9nZ2xlRnVsbHNjcmVlbk1vZGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICghZnVsbHNjcmVlbk1vZGVPbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50Vmlld0VsZW1lbnQ/LnJlcXVlc3RGdWxsc2NyZWVuKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgfTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBoYW5kbGVzIHRoZSBjYXNlIHdoZW4gZnVsbHNjcmVlbiBtb2RlIGlzIHRvZ2dsZWQgZXh0ZXJuYWxseSxcbiAgICAgICAgLy8gZS5nLiwgYnkgcHJlc3NpbmcgRVNDIGtleSBvciBzb21lIG90aGVyIGtleWJvYXJkIHNob3J0Y3V0XG4gICAgICAgIGNvbnN0IGhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBzZXRGdWxsc2NyZWVuTW9kZU9uKCEhZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdmlkZW9FbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVQaVAgPSAoKSA9PiB7XG4gICAgICAgICAgICBzZXRQaWN0dXJlSW5QaWN0dXJlRWxlbWVudChkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHZpZGVvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCBoYW5kbGVQaVApO1xuICAgICAgICB2aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGVhdmVwaWN0dXJlaW5waWN0dXJlJywgaGFuZGxlUGlQKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCBoYW5kbGVQaVApO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIGhhbmRsZVBpUCk7XG4gICAgICAgIH07XG4gICAgfSwgW3ZpZGVvRWxlbWVudF0pO1xuICAgIGNvbnN0IHRvZ2dsZVBpY3R1cmVJblBpY3R1cmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnQgJiYgcGljdHVyZUluUGljdHVyZUVsZW1lbnQgIT09IHZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0UGljdHVyZUluUGljdHVyZSgpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5leGl0UGljdHVyZUluUGljdHVyZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH07XG4gICAgY29uc3QgeyBjbG9zZSB9ID0gdXNlTWVudUNvbnRleHQoKSB8fCB7fTtcbiAgICByZXR1cm4gKGpzeHMoR2VuZXJpY01lbnUsIHsgb25JdGVtQ2xpY2s6IGNsb3NlLCBjaGlsZHJlbjogW2pzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHRvZ2dsZVBhcnRpY2lwYW50UGluLCBkaXNhYmxlZDogcGluICYmICFwaW4uaXNMb2NhbFBpbiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcInBpblwiIH0pLCBwaW4gPyB0KCdVbnBpbicpIDogdCgnUGluJyldIH0pLCBqc3hzKFJlc3RyaWN0ZWQsIHsgcmVxdWlyZWRHcmFudHM6IFtPd25DYXBhYmlsaXR5LlBJTl9GT1JfRVZFUllPTkVdLCBjaGlsZHJlbjogW2pzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHBpbkZvckV2ZXJ5b25lLCBkaXNhYmxlZDogcGluICYmICFwaW4uaXNMb2NhbFBpbiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcInBpblwiIH0pLCB0KCdQaW4gZm9yIGV2ZXJ5b25lJyldIH0pLCBqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiB1bnBpbkZvckV2ZXJ5b25lLCBkaXNhYmxlZDogIXBpbiB8fCBwaW4uaXNMb2NhbFBpbiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcInBpblwiIH0pLCB0KCdVbnBpbiBmb3IgZXZlcnlvbmUnKV0gfSldIH0pLCBqc3goUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuQkxPQ0tfVVNFUlNdLCBjaGlsZHJlbjoganN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogYmxvY2tVc2VyLCBjaGlsZHJlbjogW2pzeChJY29uLCB7IGljb246IFwibm90LWFsbG93ZWRcIiB9KSwgdCgnQmxvY2snKV0gfSkgfSksIGpzeHMoUmVzdHJpY3RlZCwgeyByZXF1aXJlZEdyYW50czogW093bkNhcGFiaWxpdHkuTVVURV9VU0VSU10sIGNoaWxkcmVuOiBbaGFzVmlkZW8gJiYgKGpzeHMoR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IG11dGVWaWRlbywgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcImNhbWVyYS1vZmYtb3V0bGluZVwiIH0pLCB0KCdUdXJuIG9mZiB2aWRlbycpXSB9KSksIGhhc1NjcmVlblNoYXJlICYmIChqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBtdXRlU2NyZWVuU2hhcmUsIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJzY3JlZW4tc2hhcmUtb2ZmXCIgfSksIHQoJ1R1cm4gb2ZmIHNjcmVlbiBzaGFyZScpXSB9KSksIGhhc0F1ZGlvICYmIChqc3hzKEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBtdXRlQXVkaW8sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJuby1hdWRpb1wiIH0pLCB0KCdNdXRlIGF1ZGlvJyldIH0pKSwgaGFzU2NyZWVuU2hhcmVBdWRpbyAmJiAoanN4cyhHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogbXV0ZVNjcmVlblNoYXJlQXVkaW8sIGNoaWxkcmVuOiBbanN4KEljb24sIHsgaWNvbjogXCJuby1hdWRpb1wiIH0pLCB0KCdNdXRlIHNjcmVlbiBzaGFyZSBhdWRpbycpXSB9KSldIH0pLCBwYXJ0aWNpcGFudFZpZXdFbGVtZW50ICYmIChqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHRvZ2dsZUZ1bGxzY3JlZW5Nb2RlLCBjaGlsZHJlbjogdCgne3sgZGlyZWN0aW9uIH19IGZ1bGxzY3JlZW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZnVsbHNjcmVlbk1vZGVPbiA/IHQoJ0xlYXZlJykgOiB0KCdFbnRlcicpLFxuICAgICAgICAgICAgICAgIH0pIH0pKSwgdmlkZW9FbGVtZW50ICYmIGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbmFibGVkICYmIChqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHRvZ2dsZVBpY3R1cmVJblBpY3R1cmUsIGNoaWxkcmVuOiB0KCd7eyBkaXJlY3Rpb24gfX0gcGljdHVyZS1pbi1waWN0dXJlJywge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IHBpY3R1cmVJblBpY3R1cmVFbGVtZW50ID09PSB2aWRlb0VsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdCgnTGVhdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0KCdFbnRlcicpLFxuICAgICAgICAgICAgICAgIH0pIH0pKSwganN4cyhSZXN0cmljdGVkLCB7IHJlcXVpcmVkR3JhbnRzOiBbT3duQ2FwYWJpbGl0eS5VUERBVEVfQ0FMTF9QRVJNSVNTSU9OU10sIGNoaWxkcmVuOiBbanN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiBncmFudFBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TRU5EX0FVRElPKSwgY2hpbGRyZW46IHQoJ0FsbG93IGF1ZGlvJykgfSksIGpzeChHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogZ3JhbnRQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0VORF9WSURFTyksIGNoaWxkcmVuOiB0KCdBbGxvdyB2aWRlbycpIH0pLCBqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IGdyYW50UGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNDUkVFTlNIQVJFKSwgY2hpbGRyZW46IHQoJ0FsbG93IHNjcmVlbiBzaGFyaW5nJykgfSksIGpzeChHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIHsgb25DbGljazogcmV2b2tlUGVybWlzc2lvbihPd25DYXBhYmlsaXR5LlNFTkRfQVVESU8pLCBjaGlsZHJlbjogdCgnRGlzYWJsZSBhdWRpbycpIH0pLCBqc3goR2VuZXJpY01lbnVCdXR0b25JdGVtLCB7IG9uQ2xpY2s6IHJldm9rZVBlcm1pc3Npb24oT3duQ2FwYWJpbGl0eS5TRU5EX1ZJREVPKSwgY2hpbGRyZW46IHQoJ0Rpc2FibGUgdmlkZW8nKSB9KSwganN4KEdlbmVyaWNNZW51QnV0dG9uSXRlbSwgeyBvbkNsaWNrOiByZXZva2VQZXJtaXNzaW9uKE93bkNhcGFiaWxpdHkuU0NSRUVOU0hBUkUpLCBjaGlsZHJlbjogdCgnRGlzYWJsZSBzY3JlZW4gc2hhcmluZycpIH0pXSB9KV0gfSkpO1xufTtcblxuY29uc3QgdXNlVHJhY2tFbGVtZW50VmlzaWJpbGl0eSA9ICh7IHRyYWNrZWRFbGVtZW50LCBkeW5hc2NhbGVNYW5hZ2VyOiBwcm9wc0R5bmFzY2FsZU1hbmFnZXIsIHNlc3Npb25JZCwgdHJhY2tUeXBlLCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCBtYW5hZ2VyID0gcHJvcHNEeW5hc2NhbGVNYW5hZ2VyID8/IGNhbGw/LmR5bmFzY2FsZU1hbmFnZXI7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0cmFja2VkRWxlbWVudCB8fCAhbWFuYWdlciB8fCAhY2FsbCB8fCB0cmFja1R5cGUgPT09ICdub25lJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdW5vYnNlcnZlID0gbWFuYWdlci50cmFja0VsZW1lbnRWaXNpYmlsaXR5KHRyYWNrZWRFbGVtZW50LCBzZXNzaW9uSWQsIHRyYWNrVHlwZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB1bm9ic2VydmUoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbdHJhY2tlZEVsZW1lbnQsIG1hbmFnZXIsIGNhbGwsIHNlc3Npb25JZCwgdHJhY2tUeXBlXSk7XG59O1xuXG5jb25zdCBUb2dnbGVCdXR0b24gPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRvZ2dsZUJ1dHRvbihwcm9wcywgcmVmKSB7XG4gICAgcmV0dXJuIGpzeChJY29uQnV0dG9uLCB7IGVuYWJsZWQ6IHByb3BzLm1lbnVTaG93biwgaWNvbjogXCJlbGxpcHNpc1wiLCByZWY6IHJlZiB9KTtcbn0pO1xuY29uc3QgRGVmYXVsdFNjcmVlblNoYXJlT3ZlcmxheSA9ICgpID0+IHtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdCB9ID0gdXNlSTE4bigpO1xuICAgIGNvbnN0IHN0b3BTY3JlZW5TaGFyZSA9ICgpID0+IHtcbiAgICAgICAgY2FsbD8uc2NyZWVuU2hhcmUuZGlzYWJsZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc2NyZWVuLXNoYXJlLW92ZXJsYXlcIiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcInNjcmVlbi1zaGFyZS1vZmZcIiB9KSwganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NjcmVlbi1zaGFyZS1vdmVybGF5X190aXRsZVwiLCBjaGlsZHJlbjogdCgnWW91IGFyZSBwcmVzZW50aW5nIHlvdXIgc2NyZWVuJykgfSksIGpzeHMoXCJidXR0b25cIiwgeyBvbkNsaWNrOiBzdG9wU2NyZWVuU2hhcmUsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NjcmVlbi1zaGFyZS1vdmVybGF5X19idXR0b25cIiwgY2hpbGRyZW46IFtqc3goSWNvbiwgeyBpY29uOiBcImNsb3NlXCIgfSksIFwiIFwiLCB0KCdTdG9wIFNjcmVlbiBTaGFyaW5nJyldIH0pXSB9KSk7XG59O1xuY29uc3QgRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJID0gKHsgaW5kaWNhdG9yc1Zpc2libGUgPSB0cnVlLCBtZW51UGxhY2VtZW50ID0gJ2JvdHRvbS1zdGFydCcsIHNob3dNZW51QnV0dG9uID0gdHJ1ZSwgUGFydGljaXBhbnRBY3Rpb25zQ29udGV4dE1lbnU6IFBhcnRpY2lwYW50QWN0aW9uc0NvbnRleHRNZW51JDEgPSBQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQsIHRyYWNrVHlwZSB9ID0gdXNlUGFydGljaXBhbnRWaWV3Q29udGV4dCgpO1xuICAgIGNvbnN0IHsgcHVibGlzaGVkVHJhY2tzIH0gPSBwYXJ0aWNpcGFudDtcbiAgICBjb25zdCBoYXNTY3JlZW5TaGFyZSA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG4gICAgaWYgKHBhcnRpY2lwYW50LmlzTG9jYWxQYXJ0aWNpcGFudCAmJlxuICAgICAgICBoYXNTY3JlZW5TaGFyZSAmJlxuICAgICAgICB0cmFja1R5cGUgPT09ICdzY3JlZW5TaGFyZVRyYWNrJykge1xuICAgICAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goRGVmYXVsdFNjcmVlblNoYXJlT3ZlcmxheSwge30pLCBqc3goUGFydGljaXBhbnREZXRhaWxzLCB7IGluZGljYXRvcnNWaXNpYmxlOiBpbmRpY2F0b3JzVmlzaWJsZSB9KV0gfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtzaG93TWVudUJ1dHRvbiAmJiAoanN4KE1lbnVUb2dnbGUsIHsgc3RyYXRlZ3k6IFwiZml4ZWRcIiwgcGxhY2VtZW50OiBtZW51UGxhY2VtZW50LCBUb2dnbGVCdXR0b246IFRvZ2dsZUJ1dHRvbiwgY2hpbGRyZW46IGpzeChQYXJ0aWNpcGFudEFjdGlvbnNDb250ZXh0TWVudSQxLCB7fSkgfSkpLCBqc3goUmVhY3Rpb24sIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50IH0pLCBqc3goUGFydGljaXBhbnREZXRhaWxzLCB7IGluZGljYXRvcnNWaXNpYmxlOiBpbmRpY2F0b3JzVmlzaWJsZSB9KV0gfSkpO1xufTtcbmNvbnN0IFBhcnRpY2lwYW50RGV0YWlscyA9ICh7IGluZGljYXRvcnNWaXNpYmxlID0gdHJ1ZSwgfSkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnQgfSA9IHVzZVBhcnRpY2lwYW50Vmlld0NvbnRleHQoKTtcbiAgICBjb25zdCB7IGlzTG9jYWxQYXJ0aWNpcGFudCwgY29ubmVjdGlvblF1YWxpdHksIHB1Ymxpc2hlZFRyYWNrcywgcGluLCBzZXNzaW9uSWQsIG5hbWUsIHVzZXJJZCwgfSA9IHBhcnRpY2lwYW50O1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XG4gICAgY29uc3QgY29ubmVjdGlvblF1YWxpdHlBc1N0cmluZyA9ICEhY29ubmVjdGlvblF1YWxpdHkgJiZcbiAgICAgICAgU2Z1TW9kZWxzLkNvbm5lY3Rpb25RdWFsaXR5W2Nvbm5lY3Rpb25RdWFsaXR5XS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc0F1ZGlvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuQVVESU8pO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gcHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuVklERU8pO1xuICAgIGNvbnN0IGNhblVucGluID0gISFwaW4gJiYgcGluLmlzTG9jYWxQaW47XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc1wiLCBjaGlsZHJlbjoganN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1kZXRhaWxzX19uYW1lXCIsIGNoaWxkcmVuOiBbbmFtZSB8fCB1c2VySWQsIGluZGljYXRvcnNWaXNpYmxlICYmICFoYXNBdWRpbyAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhcnRpY2lwYW50LWRldGFpbHNfX25hbWUtLWF1ZGlvLW11dGVkXCIgfSkpLCBpbmRpY2F0b3JzVmlzaWJsZSAmJiAhaGFzVmlkZW8gJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1kZXRhaWxzX19uYW1lLS12aWRlby1tdXRlZFwiIH0pKSwgaW5kaWNhdG9yc1Zpc2libGUgJiYgY2FuVW5waW4gJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgbW9uc3Ryb3NpdHkgb25jZSB3ZSBoYXZlIGEgcHJvcGVyIGRlc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAganN4KFwic3BhblwiLCB7IHRpdGxlOiB0KCdVbnBpbicpLCBvbkNsaWNrOiAoKSA9PiBjYWxsPy51bnBpbihzZXNzaW9uSWQpLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19wYXJ0aWNpcGFudC1kZXRhaWxzX19uYW1lLS1waW5uZWRcIiB9KSksIGluZGljYXRvcnNWaXNpYmxlICYmIGpzeChTcGVlY2hJbmRpY2F0b3IsIHt9KV0gfSkgfSksIGluZGljYXRvcnNWaXNpYmxlICYmIChqc3goTm90aWZpY2F0aW9uLCB7IGlzVmlzaWJsZTogaXNMb2NhbFBhcnRpY2lwYW50ICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25RdWFsaXR5ID09PSBTZnVNb2RlbHMuQ29ubmVjdGlvblF1YWxpdHkuUE9PUiwgbWVzc2FnZTogdCgnUG9vciBjb25uZWN0aW9uIHF1YWxpdHknKSwgY2hpbGRyZW46IGNvbm5lY3Rpb25RdWFsaXR5QXNTdHJpbmcgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fY29ubmVjdGlvbi1xdWFsaXR5JywgYHN0ci12aWRlb19fcGFydGljaXBhbnQtZGV0YWlsc19fY29ubmVjdGlvbi1xdWFsaXR5LS0ke2Nvbm5lY3Rpb25RdWFsaXR5QXNTdHJpbmd9YCksIHRpdGxlOiBjb25uZWN0aW9uUXVhbGl0eUFzU3RyaW5nIH0pKSB9KSldIH0pKTtcbn07XG5jb25zdCBTcGVlY2hJbmRpY2F0b3IgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBwYXJ0aWNpcGFudCB9ID0gdXNlUGFydGljaXBhbnRWaWV3Q29udGV4dCgpO1xuICAgIGNvbnN0IHsgaXNTcGVha2luZywgaXNEb21pbmFudFNwZWFrZXIgfSA9IHBhcnRpY2lwYW50O1xuICAgIHJldHVybiAoanN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNsc3goJ3N0ci12aWRlb19fc3BlZWNoLWluZGljYXRvcicsIGlzU3BlYWtpbmcgJiYgJ3N0ci12aWRlb19fc3BlZWNoLWluZGljYXRvci0tc3BlYWtpbmcnLCBpc0RvbWluYW50U3BlYWtlciAmJiAnc3RyLXZpZGVvX19zcGVlY2gtaW5kaWNhdG9yLS1kb21pbmFudCcpLCBjaGlsZHJlbjogW2pzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVlY2gtaW5kaWNhdG9yX19iYXJcIiB9KSwganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWVjaC1pbmRpY2F0b3JfX2JhclwiIH0pLCBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlZWNoLWluZGljYXRvcl9fYmFyXCIgfSldIH0pKTtcbn07XG5cbmNvbnN0IFBhcnRpY2lwYW50VmlldyA9IGZvcndhcmRSZWYoZnVuY3Rpb24gUGFydGljaXBhbnRWaWV3KHsgcGFydGljaXBhbnQsIHRyYWNrVHlwZSA9ICd2aWRlb1RyYWNrJywgbXV0ZUF1ZGlvLCByZWZzOiB7IHNldFZpZGVvRWxlbWVudCwgc2V0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQgfSA9IHt9LCBjbGFzc05hbWUsIFZpZGVvUGxhY2Vob2xkZXIsIFBhcnRpY2lwYW50Vmlld1VJID0gRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJLCB9LCByZWYpIHtcbiAgICBjb25zdCB7IGlzTG9jYWxQYXJ0aWNpcGFudCwgaXNTcGVha2luZywgaXNEb21pbmFudFNwZWFrZXIsIHB1Ymxpc2hlZFRyYWNrcywgc2Vzc2lvbklkLCB9ID0gcGFydGljaXBhbnQ7XG4gICAgY29uc3QgaGFzQXVkaW8gPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5BVURJTyk7XG4gICAgY29uc3QgaGFzVmlkZW8gPSBwdWJsaXNoZWRUcmFja3MuaW5jbHVkZXMoU2Z1TW9kZWxzLlRyYWNrVHlwZS5WSURFTyk7XG4gICAgY29uc3QgaGFzU2NyZWVuU2hhcmVBdWRpbyA9IHB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRV9BVURJTyk7XG4gICAgY29uc3QgW3RyYWNrZWRFbGVtZW50LCBzZXRUcmFja2VkRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY29udGV4dFZpZGVvRWxlbWVudCwgc2V0Q29udGV4dFZpZGVvRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY29udGV4dFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50LCBzZXRDb250ZXh0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgLy8gVE9ETzogYWxsb3cgdG8gcGFzcyBjdXN0b20gVmlld3BvcnRUcmFja2VyIGluc3RhbmNlIGZyb20gcHJvcHNcbiAgICB1c2VUcmFja0VsZW1lbnRWaXNpYmlsaXR5KHtcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICB0cmFja2VkRWxlbWVudCxcbiAgICAgICAgdHJhY2tUeXBlLFxuICAgIH0pO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50Vmlld0NvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgIHBhcnRpY2lwYW50Vmlld0VsZW1lbnQ6IHRyYWNrZWRFbGVtZW50LFxuICAgICAgICB2aWRlb0VsZW1lbnQ6IGNvbnRleHRWaWRlb0VsZW1lbnQsXG4gICAgICAgIHZpZGVvUGxhY2Vob2xkZXJFbGVtZW50OiBjb250ZXh0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQsXG4gICAgICAgIHRyYWNrVHlwZSxcbiAgICB9KSwgW1xuICAgICAgICBjb250ZXh0VmlkZW9FbGVtZW50LFxuICAgICAgICBjb250ZXh0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQsXG4gICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICB0cmFja2VkRWxlbWVudCxcbiAgICAgICAgdHJhY2tUeXBlLFxuICAgIF0pO1xuICAgIGNvbnN0IHZpZGVvUmVmcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgc2V0VmlkZW9FbGVtZW50OiAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgc2V0VmlkZW9FbGVtZW50Py4oZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRDb250ZXh0VmlkZW9FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRWaWRlb1BsYWNlaG9sZGVyRWxlbWVudDogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHNldFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50Py4oZWxlbWVudCk7XG4gICAgICAgICAgICBzZXRDb250ZXh0VmlkZW9QbGFjZWhvbGRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgfSksIFtzZXRWaWRlb0VsZW1lbnQsIHNldFZpZGVvUGxhY2Vob2xkZXJFbGVtZW50XSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBcImRhdGEtdGVzdGlkXCI6IFwicGFydGljaXBhbnQtdmlld1wiLCByZWY6IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBhcHBseUVsZW1lbnRUb1JlZihyZWYsIGVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VHJhY2tlZEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH0sIGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19wYXJ0aWNpcGFudC12aWV3JywgaXNEb21pbmFudFNwZWFrZXIgJiYgJ3N0ci12aWRlb19fcGFydGljaXBhbnQtdmlldy0tZG9taW5hbnQtc3BlYWtlcicsIGlzU3BlYWtpbmcgJiYgJ3N0ci12aWRlb19fcGFydGljaXBhbnQtdmlldy0tc3BlYWtpbmcnLCAhaGFzVmlkZW8gJiYgJ3N0ci12aWRlb19fcGFydGljaXBhbnQtdmlldy0tbm8tdmlkZW8nLCAhaGFzQXVkaW8gJiYgJ3N0ci12aWRlb19fcGFydGljaXBhbnQtdmlldy0tbm8tYXVkaW8nLCBjbGFzc05hbWUpLCBjaGlsZHJlbjoganN4cyhQYXJ0aWNpcGFudFZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwYXJ0aWNpcGFudFZpZXdDb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBbIWlzTG9jYWxQYXJ0aWNpcGFudCAmJiAhbXV0ZUF1ZGlvICYmIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbaGFzQXVkaW8gJiYgKGpzeChBdWRpbywgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQsIHRyYWNrVHlwZTogXCJhdWRpb1RyYWNrXCIgfSkpLCBoYXNTY3JlZW5TaGFyZUF1ZGlvICYmIChqc3goQXVkaW8sIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50LCB0cmFja1R5cGU6IFwic2NyZWVuU2hhcmVBdWRpb1RyYWNrXCIgfSkpXSB9KSksIGpzeChWaWRlbyQxLCB7IFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIsIHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudCwgdHJhY2tUeXBlOiB0cmFja1R5cGUsIHJlZnM6IHZpZGVvUmVmcywgYXV0b1BsYXk6IHRydWUgfSksIGlzQ29tcG9uZW50VHlwZShQYXJ0aWNpcGFudFZpZXdVSSkgPyAoanN4KFBhcnRpY2lwYW50Vmlld1VJLCB7fSkpIDogKFBhcnRpY2lwYW50Vmlld1VJKV0gfSkgfSkpO1xufSk7XG5cbi8vIHJlLWV4cG9ydGluZyB0aGUgU3RyZWFtQ2FsbFByb3ZpZGVyIGFzIFN0cmVhbUNhbGxcbmNvbnN0IFN0cmVhbUNhbGwgPSBTdHJlYW1DYWxsUHJvdmlkZXI7XG5cbnZhciBKb2luaW5nID0gXCJKb2luaW5nXCI7XG52YXIgTWljID0gXCJNaWNcIjtcbnZhciBSaW5naW5nID0gXCJSaW5naW5nXCI7XG52YXIgU3BlYWtlcnMgPSBcIlNwZWFrZXJzXCI7XG52YXIgVmlkZW8gPSBcIlZpZGVvXCI7XG52YXIgTGl2ZSA9IFwiTGl2ZVwiO1xudmFyIFJlYWN0aW9ucyA9IFwiUmVhY3Rpb25zXCI7XG52YXIgU3RhdGlzdGljcyA9IFwiU3RhdGlzdGljc1wiO1xudmFyIEludml0ZSA9IFwiSW52aXRlXCI7XG52YXIgSm9pbiA9IFwiSm9pblwiO1xudmFyIFlvdSA9IFwiWW91XCI7XG52YXIgTWUgPSBcIk1lXCI7XG52YXIgVW5rbm93biA9IFwiVW5rbm93blwiO1xudmFyIFJlZnJlc2ggPSBcIlJlZnJlc2hcIjtcbnZhciBBbGxvdyA9IFwiQWxsb3dcIjtcbnZhciBSZXZva2UgPSBcIlJldm9rZVwiO1xudmFyIERpc21pc3MgPSBcIkRpc21pc3NcIjtcbnZhciBQaW5uZWQgPSBcIlBpbm5lZFwiO1xudmFyIFVucGluID0gXCJVbnBpblwiO1xudmFyIFBpbiA9IFwiUGluXCI7XG52YXIgQmxvY2sgPSBcIkJsb2NrXCI7XG52YXIgRW50ZXIgPSBcIkVudGVyXCI7XG52YXIgTGVhdmUgPSBcIkxlYXZlXCI7XG52YXIgUGFydGljaXBhbnRzID0gXCJQYXJ0aWNpcGFudHNcIjtcbnZhciBBbm9ueW1vdXMgPSBcIiwgYW5kICh7eyBjb3VudCB9fSkgYW5vbnltb3VzXCI7XG52YXIgZW4gPSB7XG5cdEpvaW5pbmc6IEpvaW5pbmcsXG5cdE1pYzogTWljLFxuXHRcIk5vIGludGVybmV0IGNvbm5lY3Rpb25cIjogXCJObyBpbnRlcm5ldCBjb25uZWN0aW9uXCIsXG5cdFwiUmUtY29ubmVjdGluZ1wiOiBcIlJlLWNvbm5lY3RpbmdcIixcblx0UmluZ2luZzogUmluZ2luZyxcblx0XCJTY3JlZW4gU2hhcmVcIjogXCJTY3JlZW4gU2hhcmVcIixcblx0XCJTZWxlY3QgYSBDYW1lcmFcIjogXCJTZWxlY3QgYSBDYW1lcmFcIixcblx0XCJTZWxlY3QgYSBNaWNcIjogXCJTZWxlY3QgYSBNaWNcIixcblx0XCJTZWxlY3QgU3BlYWtlcnNcIjogXCJTZWxlY3QgU3BlYWtlcnNcIixcblx0U3BlYWtlcnM6IFNwZWFrZXJzLFxuXHRWaWRlbzogVmlkZW8sXG5cdFwiWW91IGFyZSBtdXRlZC4gVW5tdXRlIHRvIHNwZWFrLlwiOiBcIllvdSBhcmUgbXV0ZWQuIFVubXV0ZSB0byBzcGVhay5cIixcblx0TGl2ZTogTGl2ZSxcblx0XCJZb3UgY2FuIG5vdyBzcGVhay5cIjogXCJZb3UgY2FuIG5vdyBzcGVhay5cIixcblx0XCJBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc3BlYWsuXCI6IFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNwZWFrLlwiLFxuXHRcIllvdSBjYW4gbm8gbG9uZ2VyIHNwZWFrLlwiOiBcIllvdSBjYW4gbm8gbG9uZ2VyIHNwZWFrLlwiLFxuXHRcIllvdSBjYW4gbm93IHNoYXJlIHlvdXIgdmlkZW8uXCI6IFwiWW91IGNhbiBub3cgc2hhcmUgeW91ciB2aWRlby5cIixcblx0XCJBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc2hhcmUgeW91ciB2aWRlby5cIjogXCJBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc2hhcmUgeW91ciB2aWRlby5cIixcblx0XCJZb3UgY2FuIG5vIGxvbmdlciBzaGFyZSB5b3VyIHZpZGVvLlwiOiBcIllvdSBjYW4gbm8gbG9uZ2VyIHNoYXJlIHlvdXIgdmlkZW8uXCIsXG5cdFwiV2FpdGluZyBmb3IgcmVjb3JkaW5nIHRvIHN0b3AuLi5cIjogXCJXYWl0aW5nIGZvciByZWNvcmRpbmcgdG8gc3RvcC4uLlwiLFxuXHRcIldhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdGFydC4uLlwiOiBcIldhaXRpbmcgZm9yIHJlY29yZGluZyB0byBzdGFydC4uLlwiLFxuXHRcIlJlY29yZCBjYWxsXCI6IFwiUmVjb3JkIGNhbGxcIixcblx0UmVhY3Rpb25zOiBSZWFjdGlvbnMsXG5cdFN0YXRpc3RpY3M6IFN0YXRpc3RpY3MsXG5cdFwiWW91IGNhbiBub3cgc2hhcmUgeW91ciBzY3JlZW4uXCI6IFwiWW91IGNhbiBub3cgc2hhcmUgeW91ciBzY3JlZW4uXCIsXG5cdFwiQXdhaXRpbmcgZm9yIGFuIGFwcHJvdmFsIHRvIHNoYXJlIHNjcmVlbi5cIjogXCJBd2FpdGluZyBmb3IgYW4gYXBwcm92YWwgdG8gc2hhcmUgc2NyZWVuLlwiLFxuXHRcIllvdSBjYW4gbm8gbG9uZ2VyIHNoYXJlIHlvdXIgc2NyZWVuLlwiOiBcIllvdSBjYW4gbm8gbG9uZ2VyIHNoYXJlIHlvdXIgc2NyZWVuLlwiLFxuXHRcIlNoYXJlIHNjcmVlblwiOiBcIlNoYXJlIHNjcmVlblwiLFxuXHRcIkluY29taW5nIENhbGwuLi5cIjogXCJJbmNvbWluZyBDYWxsLi4uXCIsXG5cdFwiQ2FsbGluZy4uLlwiOiBcIkNhbGxpbmcuLi5cIixcblx0XCJNdXRlIEFsbFwiOiBcIk11dGUgQWxsXCIsXG5cdEludml0ZTogSW52aXRlLFxuXHRKb2luOiBKb2luLFxuXHRZb3U6IFlvdSxcblx0TWU6IE1lLFxuXHRVbmtub3duOiBVbmtub3duLFxuXHRcIlRvZ2dsZSBkZXZpY2UgbWVudVwiOiBcIlRvZ2dsZSBkZXZpY2UgbWVudVwiLFxuXHRcIkNhbGwgUmVjb3JkaW5nc1wiOiBcIkNhbGwgUmVjb3JkaW5nc1wiLFxuXHRSZWZyZXNoOiBSZWZyZXNoLFxuXHRcIkNoZWNrIHlvdXIgYnJvd3NlciB2aWRlbyBwZXJtaXNzaW9uc1wiOiBcIkNoZWNrIHlvdXIgYnJvd3NlciB2aWRlbyBwZXJtaXNzaW9uc1wiLFxuXHRcIlZpZGVvIHB1Ymxpc2hpbmcgaXMgZGlzYWJsZWQgYnkgdGhlIHN5c3RlbVwiOiBcIlZpZGVvIHB1Ymxpc2hpbmcgaXMgZGlzYWJsZWQgYnkgdGhlIHN5c3RlbVwiLFxuXHRcIllvdSBoYXZlIG5vIHBlcm1pc3Npb24gdG8gc2hhcmUgeW91ciB2aWRlb1wiOiBcIllvdSBoYXZlIG5vIHBlcm1pc3Npb24gdG8gc2hhcmUgeW91ciB2aWRlb1wiLFxuXHRcIllvdSBoYXZlIG5vIHBlcm1pc3Npb24gdG8gc2hhcmUgeW91ciBhdWRpb1wiOiBcIllvdSBoYXZlIG5vIHBlcm1pc3Npb24gdG8gc2hhcmUgeW91ciBhdWRpb1wiLFxuXHRcIllvdSBhcmUgcHJlc2VudGluZyB5b3VyIHNjcmVlblwiOiBcIllvdSBhcmUgcHJlc2VudGluZyB5b3VyIHNjcmVlblwiLFxuXHRcIlN0b3AgU2NyZWVuIFNoYXJpbmdcIjogXCJTdG9wIFNjcmVlbiBTaGFyaW5nXCIsXG5cdEFsbG93OiBBbGxvdyxcblx0UmV2b2tlOiBSZXZva2UsXG5cdERpc21pc3M6IERpc21pc3MsXG5cdFwiTWljcm9waG9uZSBvblwiOiBcIk1pY3JvcGhvbmUgb25cIixcblx0XCJNaWNyb3Bob25lIG9mZlwiOiBcIk1pY3JvcGhvbmUgb2ZmXCIsXG5cdFwiQ2FtZXJhIG9uXCI6IFwiQ2FtZXJhIG9uXCIsXG5cdFwiQ2FtZXJhIG9mZlwiOiBcIkNhbWVyYSBvZmZcIixcblx0XCJObyBjYW1lcmEgZm91bmRcIjogXCJObyBjYW1lcmEgZm91bmRcIixcblx0XCJWaWRlbyBpcyBkaXNhYmxlZFwiOiBcIlZpZGVvIGlzIGRpc2FibGVkXCIsXG5cdFBpbm5lZDogUGlubmVkLFxuXHRVbnBpbjogVW5waW4sXG5cdFBpbjogUGluLFxuXHRcIlBpbiBmb3IgZXZlcnlvbmVcIjogXCJQaW4gZm9yIGV2ZXJ5b25lXCIsXG5cdFwiVW5waW4gZm9yIGV2ZXJ5b25lXCI6IFwiVW5waW4gZm9yIGV2ZXJ5b25lXCIsXG5cdEJsb2NrOiBCbG9jayxcblx0XCJUdXJuIG9mZiB2aWRlb1wiOiBcIlR1cm4gb2ZmIHZpZGVvXCIsXG5cdFwiVHVybiBvZmYgc2NyZWVuIHNoYXJlXCI6IFwiVHVybiBvZmYgc2NyZWVuIHNoYXJlXCIsXG5cdFwiTXV0ZSBhdWRpb1wiOiBcIk11dGUgYXVkaW9cIixcblx0XCJNdXRlIHNjcmVlbiBzaGFyZSBhdWRpb1wiOiBcIk11dGUgc2NyZWVuIHNoYXJlIGF1ZGlvXCIsXG5cdFwiQWxsb3cgYXVkaW9cIjogXCJBbGxvdyBhdWRpb1wiLFxuXHRcIkFsbG93IHZpZGVvXCI6IFwiQWxsb3cgdmlkZW9cIixcblx0XCJBbGxvdyBzY3JlZW4gc2hhcmluZ1wiOiBcIkFsbG93IHNjcmVlbiBzaGFyaW5nXCIsXG5cdFwiRGlzYWJsZSBhdWRpb1wiOiBcIkRpc2FibGUgYXVkaW9cIixcblx0XCJEaXNhYmxlIHZpZGVvXCI6IFwiRGlzYWJsZSB2aWRlb1wiLFxuXHRcIkRpc2FibGUgc2NyZWVuIHNoYXJpbmdcIjogXCJEaXNhYmxlIHNjcmVlbiBzaGFyaW5nXCIsXG5cdEVudGVyOiBFbnRlcixcblx0TGVhdmU6IExlYXZlLFxuXHRcIkxlYXZlIGNhbGxcIjogXCJMZWF2ZSBjYWxsXCIsXG5cdFwiRW5kIGNhbGwgZm9yIGFsbFwiOiBcIkVuZCBjYWxsIGZvciBhbGxcIixcblx0XCJ7eyBkaXJlY3Rpb24gfX0gZnVsbHNjcmVlblwiOiBcInt7IGRpcmVjdGlvbiB9fSBmdWxsc2NyZWVuXCIsXG5cdFwie3sgZGlyZWN0aW9uIH19IHBpY3R1cmUtaW4tcGljdHVyZVwiOiBcInt7IGRpcmVjdGlvbiB9fSBwaWN0dXJlLWluLXBpY3R1cmVcIixcblx0XCJEb21pbmFudCBTcGVha2VyXCI6IFwiRG9taW5hbnQgU3BlYWtlclwiLFxuXHRcIlBvb3IgY29ubmVjdGlvbiBxdWFsaXR5XCI6IFwiUG9vciBjb25uZWN0aW9uIHF1YWxpdHkuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uXCIsXG5cdFBhcnRpY2lwYW50czogUGFydGljaXBhbnRzLFxuXHRBbm9ueW1vdXM6IEFub255bW91cyxcblx0XCJObyBwYXJ0aWNpcGFudHMgZm91bmRcIjogXCJObyBwYXJ0aWNpcGFudHMgZm91bmRcIixcblx0XCJQYXJ0aWNpcGFudHMgKHt7IG51bWJlck9mUGFydGljaXBhbnRzIH19KVwiOiBcIlBhcnRpY2lwYW50cyAoe3sgbnVtYmVyT2ZQYXJ0aWNpcGFudHMgfX0pXCIsXG5cdFwie3sgdXNlck5hbWUgfX0gaXMgc2hhcmluZyB0aGVpciBzY3JlZW5cIjogXCJ7eyB1c2VyTmFtZSB9fSBpcyBzaGFyaW5nIHRoZWlyIHNjcmVlblwiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gc3BlYWtcIjogXCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNwZWFrXCIsXG5cdFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyB0byBzaGFyZSB0aGVpciBjYW1lcmFcIjogXCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHNoYXJlIHRoZWlyIGNhbWVyYVwiLFxuXHRcInt7IHVzZXJOYW1lIH19IGlzIHJlcXVlc3RpbmcgdG8gcHJlc2VudCB0aGVpciBzY3JlZW5cIjogXCJ7eyB1c2VyTmFtZSB9fSBpcyByZXF1ZXN0aW5nIHRvIHByZXNlbnQgdGhlaXIgc2NyZWVuXCIsXG5cdFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyBwZXJtaXNzaW9uOiB7eyBwZXJtaXNzaW9uIH19XCI6IFwie3sgdXNlck5hbWUgfX0gaXMgcmVxdWVzdGluZyBwZXJtaXNzaW9uOiB7eyBwZXJtaXNzaW9uIH19XCJcbn07XG5cbmNvbnN0IHRyYW5zbGF0aW9ucyA9IHsgZW4gfTtcblxuY29uc3QgU3RyZWFtVmlkZW8gPSAocHJvcHMpID0+IHtcbiAgICByZXR1cm4gKGpzeChTdHJlYW1WaWRlb1Byb3ZpZGVyLCB7IHRyYW5zbGF0aW9uc092ZXJyaWRlczogdHJhbnNsYXRpb25zLCAuLi5wcm9wcyB9KSk7XG59O1xuXG5jb25zdCB1c2VQYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0ID0gKGNhbGwpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGwuc2V0U29ydFBhcnRpY2lwYW50c0J5KHBhZ2luYXRlZExheW91dFNvcnRQcmVzZXQpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzZXRTb3J0UHJlc2V0KGNhbGwpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxsXSk7XG59O1xuY29uc3QgdXNlU3BlYWtlckxheW91dFNvcnRQcmVzZXQgPSAoY2FsbCwgaXNPbmVPbk9uZUNhbGwpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGFsd2F5cyBzaG93IHRoZSByZW1vdGUgcGFydGljaXBhbnQgaW4gdGhlIHNwb3RsaWdodFxuICAgICAgICBpZiAoaXNPbmVPbk9uZUNhbGwpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0U29ydFBhcnRpY2lwYW50c0J5KGNvbWJpbmVDb21wYXJhdG9ycyhzY3JlZW5TaGFyaW5nLCBsb2dnZWRJbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbC5zZXRTb3J0UGFydGljaXBhbnRzQnkoc3BlYWtlckxheW91dFNvcnRQcmVzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNldFNvcnRQcmVzZXQoY2FsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGwsIGlzT25lT25PbmVDYWxsXSk7XG59O1xuY29uc3QgcmVzZXRTb3J0UHJlc2V0ID0gKGNhbGwpID0+IHtcbiAgICAvLyByZXNldCB0aGUgc29ydGluZyB0byB0aGUgZGVmYXVsdCBmb3IgdGhlIGNhbGwgdHlwZVxuICAgIGNvbnN0IGNhbGxDb25maWcgPSBDYWxsVHlwZXMuZ2V0KGNhbGwudHlwZSk7XG4gICAgY2FsbC5zZXRTb3J0UGFydGljaXBhbnRzQnkoY2FsbENvbmZpZy5vcHRpb25zLnNvcnRQYXJ0aWNpcGFudHNCeSB8fCBkZWZhdWx0U29ydFByZXNldCk7XG59O1xuY29uc3QgbG9nZ2VkSW4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLmlzTG9jYWxQYXJ0aWNpcGFudClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGIuaXNMb2NhbFBhcnRpY2lwYW50KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59O1xuXG5jb25zdCBMaXZlc3RyZWFtTGF5b3V0ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyB1c2VQYXJ0aWNpcGFudHMsIHVzZVJlbW90ZVBhcnRpY2lwYW50cywgdXNlSGFzT25nb2luZ1NjcmVlblNoYXJlIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGNhbGwgPSB1c2VDYWxsKCk7XG4gICAgY29uc3QgW2N1cnJlbnRTcGVha2VyLCAuLi5vdGhlclBhcnRpY2lwYW50c10gPSB1c2VQYXJ0aWNpcGFudHMoKTtcbiAgICBjb25zdCByZW1vdGVQYXJ0aWNpcGFudHMgPSB1c2VSZW1vdGVQYXJ0aWNpcGFudHMoKTtcbiAgICBjb25zdCBoYXNPbmdvaW5nU2NyZWVuU2hhcmUgPSB1c2VIYXNPbmdvaW5nU2NyZWVuU2hhcmUoKTtcbiAgICBjb25zdCBwcmVzZW50ZXIgPSBoYXNPbmdvaW5nU2NyZWVuU2hhcmVcbiAgICAgICAgPyBoYXNTY3JlZW5TaGFyZSQxKGN1cnJlbnRTcGVha2VyKSAmJiBjdXJyZW50U3BlYWtlclxuICAgICAgICA6IG90aGVyUGFydGljaXBhbnRzLmZpbmQoaGFzU2NyZWVuU2hhcmUkMSk7XG4gICAgdXNlUGFnaW5hdGVkTGF5b3V0U29ydFByZXNldChjYWxsKTtcbiAgICBjb25zdCBPdmVybGF5ID0gKGpzeChQYXJ0aWNpcGFudE92ZXJsYXksIHsgc2hvd1BhcnRpY2lwYW50Q291bnQ6IHByb3BzLnNob3dQYXJ0aWNpcGFudENvdW50LCBzaG93RHVyYXRpb246IHByb3BzLnNob3dEdXJhdGlvbiwgc2hvd0xpdmVCYWRnZTogcHJvcHMuc2hvd0xpdmVCYWRnZSwgc2hvd1NwZWFrZXJOYW1lOiBwcm9wcy5zaG93U3BlYWtlck5hbWUgfSkpO1xuICAgIGNvbnN0IHsgZmxvYXRpbmdQYXJ0aWNpcGFudFByb3BzIH0gPSBwcm9wcztcbiAgICBjb25zdCBGbG9hdGluZ1BhcnRpY2lwYW50T3ZlcmxheSA9IGhhc09uZ29pbmdTY3JlZW5TaGFyZSAmJiAoanN4KFBhcnRpY2lwYW50T3ZlcmxheVxuICAgIC8vIHRoZXNlIGVsZW1lbnRzIGFyZW4ndCBuZWVkZWQgZm9yIHRoZSB2aWRlbyBmZWVkXG4gICAgLCB7IFxuICAgICAgICAvLyB0aGVzZSBlbGVtZW50cyBhcmVuJ3QgbmVlZGVkIGZvciB0aGUgdmlkZW8gZmVlZFxuICAgICAgICBzaG93UGFydGljaXBhbnRDb3VudDogZmxvYXRpbmdQYXJ0aWNpcGFudFByb3BzPy5zaG93UGFydGljaXBhbnRDb3VudCA/PyBmYWxzZSwgc2hvd0R1cmF0aW9uOiBmbG9hdGluZ1BhcnRpY2lwYW50UHJvcHM/LnNob3dEdXJhdGlvbiA/PyBmYWxzZSwgc2hvd0xpdmVCYWRnZTogZmxvYXRpbmdQYXJ0aWNpcGFudFByb3BzPy5zaG93TGl2ZUJhZGdlID8/IGZhbHNlLCBzaG93U3BlYWtlck5hbWU6IGZsb2F0aW5nUGFydGljaXBhbnRQcm9wcz8uc2hvd1NwZWFrZXJOYW1lID8/IHRydWUgfSkpO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xpdmVzdHJlYW0tbGF5b3V0X193cmFwcGVyXCIsIGNoaWxkcmVuOiBbanN4KFBhcnRpY2lwYW50c0F1ZGlvLCB7IHBhcnRpY2lwYW50czogcmVtb3RlUGFydGljaXBhbnRzIH0pLCBoYXNPbmdvaW5nU2NyZWVuU2hhcmUgJiYgcHJlc2VudGVyICYmIChqc3goUGFydGljaXBhbnRWaWV3LCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xpdmVzdHJlYW0tbGF5b3V0X19zY3JlZW4tc2hhcmVcIiwgcGFydGljaXBhbnQ6IHByZXNlbnRlciwgUGFydGljaXBhbnRWaWV3VUk6IE92ZXJsYXksIHRyYWNrVHlwZTogXCJzY3JlZW5TaGFyZVRyYWNrXCIsIG11dGVBdWRpbyAvLyBhdWRpbyBpcyByZW5kZXJlZCBieSBQYXJ0aWNpcGFudHNBdWRpb1xuICAgICAgICAgICAgICAgIDogdHJ1ZSB9KSksIGN1cnJlbnRTcGVha2VyICYmIChqc3goUGFydGljaXBhbnRWaWV3LCB7IGNsYXNzTmFtZTogY2xzeChoYXNPbmdvaW5nU2NyZWVuU2hhcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2xzeCgnc3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fZmxvYXRpbmctcGFydGljaXBhbnQnLCBgc3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fZmxvYXRpbmctcGFydGljaXBhbnQtLSR7ZmxvYXRpbmdQYXJ0aWNpcGFudFByb3BzPy5wb3NpdGlvbiA/PyAndG9wLXJpZ2h0J31gKSksIHBhcnRpY2lwYW50OiBjdXJyZW50U3BlYWtlciwgUGFydGljaXBhbnRWaWV3VUk6IEZsb2F0aW5nUGFydGljaXBhbnRPdmVybGF5IHx8IE92ZXJsYXksIG11dGVBdWRpbyAvLyBhdWRpbyBpcyByZW5kZXJlZCBieSBQYXJ0aWNpcGFudHNBdWRpb1xuICAgICAgICAgICAgICAgIDogdHJ1ZSB9KSldIH0pKTtcbn07XG5jb25zdCBoYXNTY3JlZW5TaGFyZSQxID0gKHApID0+ICEhcD8ucHVibGlzaGVkVHJhY2tzLmluY2x1ZGVzKFNmdU1vZGVscy5UcmFja1R5cGUuU0NSRUVOX1NIQVJFKTtcbmNvbnN0IFBhcnRpY2lwYW50T3ZlcmxheSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZW5hYmxlRnVsbFNjcmVlbiA9IHRydWUsIHNob3dQYXJ0aWNpcGFudENvdW50ID0gdHJ1ZSwgc2hvd0R1cmF0aW9uID0gdHJ1ZSwgc2hvd0xpdmVCYWRnZSA9IHRydWUsIHNob3dTcGVha2VyTmFtZSA9IGZhbHNlLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBwYXJ0aWNpcGFudCB9ID0gdXNlUGFydGljaXBhbnRWaWV3Q29udGV4dCgpO1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRDb3VudCB9ID0gdXNlQ2FsbFN0YXRlSG9va3MoKTtcbiAgICBjb25zdCBwYXJ0aWNpcGFudENvdW50ID0gdXNlUGFydGljaXBhbnRDb3VudCgpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdXNlVXBkYXRlQ2FsbER1cmF0aW9uKCk7XG4gICAgY29uc3QgdG9nZ2xlRnVsbFNjcmVlbiA9IHVzZVRvZ2dsZUZ1bGxTY3JlZW4oKTtcbiAgICBjb25zdCB7IHQgfSA9IHVzZUkxOG4oKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xpdmVzdHJlYW0tbGF5b3V0X19vdmVybGF5XCIsIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fbGl2ZXN0cmVhbS1sYXlvdXRfX292ZXJsYXlfX2JhclwiLCBjaGlsZHJlbjogW3Nob3dMaXZlQmFkZ2UgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fbGl2ZS1iYWRnZVwiLCBjaGlsZHJlbjogdCgnTGl2ZScpIH0pKSwgc2hvd1BhcnRpY2lwYW50Q291bnQgJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fdmlld2Vycy1jb3VudFwiLCBjaGlsZHJlbjogcGFydGljaXBhbnRDb3VudCB9KSksIHNob3dTcGVha2VyTmFtZSAmJiAoanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX2xpdmVzdHJlYW0tbGF5b3V0X19zcGVha2VyLW5hbWVcIiwgdGl0bGU6IHBhcnRpY2lwYW50Lm5hbWUgfHwgcGFydGljaXBhbnQudXNlcklkIHx8ICcnLCBjaGlsZHJlbjogcGFydGljaXBhbnQubmFtZSB8fCBwYXJ0aWNpcGFudC51c2VySWQgfHwgJycgfSkpLCBzaG93RHVyYXRpb24gJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fZHVyYXRpb25cIiwgY2hpbGRyZW46IGZvcm1hdER1cmF0aW9uKGR1cmF0aW9uKSB9KSksIGVuYWJsZUZ1bGxTY3JlZW4gJiYgKGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19saXZlc3RyZWFtLWxheW91dF9fZ28tZnVsbHNjcmVlblwiLCBvbkNsaWNrOiB0b2dnbGVGdWxsU2NyZWVuIH0pKV0gfSkgfSkpO1xufTtcbmNvbnN0IHVzZVVwZGF0ZUNhbGxEdXJhdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHVzZUlzQ2FsbExpdmUsIHVzZUNhbGxTZXNzaW9uIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IGlzQ2FsbExpdmUgPSB1c2VJc0NhbGxMaXZlKCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHVzZUNhbGxTZXNzaW9uKCk7XG4gICAgY29uc3QgW2R1cmF0aW9uLCBzZXREdXJhdGlvbl0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5saXZlX3N0YXJ0ZWRfYXQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgbGl2ZVN0YXJ0VGltZSA9IG5ldyBEYXRlKHNlc3Npb24ubGl2ZV9zdGFydGVkX2F0KTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKG5vdy5nZXRUaW1lKCkgLSBsaXZlU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAxMDAwKTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzQ2FsbExpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgc2V0RHVyYXRpb24oKGQpID0+IGQgKyAxKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaXNDYWxsTGl2ZV0pO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbn07XG5jb25zdCB1c2VUb2dnbGVGdWxsU2NyZWVuID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcGFydGljaXBhbnRWaWV3RWxlbWVudCB9ID0gdXNlUGFydGljaXBhbnRWaWV3Q29udGV4dCgpO1xuICAgIGNvbnN0IFtpc0Z1bGxzY3JlZW4sIHNldElzRnVsbHNjcmVlbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRJc0Z1bGxzY3JlZW4oZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudFZpZXdFbGVtZW50Py5yZXF1ZXN0RnVsbHNjcmVlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldElzRnVsbHNjcmVlbih0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2lzRnVsbHNjcmVlbiwgcGFydGljaXBhbnRWaWV3RWxlbWVudF0pO1xufTtcbmNvbnN0IGZvcm1hdER1cmF0aW9uID0gKGR1cmF0aW9uSW5NcykgPT4ge1xuICAgIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGR1cmF0aW9uSW5NcyAvIDg2NDAwKTtcbiAgICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IoZHVyYXRpb25Jbk1zIC8gMzYwMCk7XG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKGR1cmF0aW9uSW5NcyAlIDM2MDApIC8gNjApO1xuICAgIGNvbnN0IHNlY29uZHMgPSBkdXJhdGlvbkluTXMgJSA2MDtcbiAgICByZXR1cm4gYCR7ZGF5cyA/IGRheXMgKyAnICcgOiAnJ30ke2hvdXJzID8gaG91cnMgKyAnOicgOiAnJ30ke21pbnV0ZXMgPCAxMCA/ICcwJyA6ICcnfSR7bWludXRlc306JHtzZWNvbmRzIDwgMTAgPyAnMCcgOiAnJ30ke3NlY29uZHN9YDtcbn07XG5cbmNvbnN0IEdST1VQX1NJWkUgPSAxNjtcbmNvbnN0IFBhZ2luYXRlZEdyaWRMYXlvdXRHcm91cCA9ICh7IGdyb3VwLCBWaWRlb1BsYWNlaG9sZGVyLCBQYXJ0aWNpcGFudFZpZXdVSSwgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbHN4KCdzdHItdmlkZW9fX3BhZ2luYXRlZC1ncmlkLWxheW91dF9fZ3JvdXAnLCB7XG4gICAgICAgICAgICAnc3RyLXZpZGVvX19wYWdpbmF0ZWQtZ3JpZC1sYXlvdXQtLW9uZSc6IGdyb3VwLmxlbmd0aCA9PT0gMSxcbiAgICAgICAgICAgICdzdHItdmlkZW9fX3BhZ2luYXRlZC1ncmlkLWxheW91dC0tdHdvLWZvdXInOiBncm91cC5sZW5ndGggPj0gMiAmJiBncm91cC5sZW5ndGggPD0gNCxcbiAgICAgICAgICAgICdzdHItdmlkZW9fX3BhZ2luYXRlZC1ncmlkLWxheW91dC0tZml2ZS1uaW5lJzogZ3JvdXAubGVuZ3RoID49IDUgJiYgZ3JvdXAubGVuZ3RoIDw9IDksXG4gICAgICAgIH0pLCBjaGlsZHJlbjogZ3JvdXAubWFwKChwYXJ0aWNpcGFudCkgPT4gKGpzeChQYXJ0aWNpcGFudFZpZXcsIHsgcGFydGljaXBhbnQ6IHBhcnRpY2lwYW50LCBtdXRlQXVkaW86IHRydWUsIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIsIFBhcnRpY2lwYW50Vmlld1VJOiBQYXJ0aWNpcGFudFZpZXdVSSB9LCBwYXJ0aWNpcGFudC5zZXNzaW9uSWQpKSkgfSkpO1xufTtcbmNvbnN0IFBhZ2luYXRlZEdyaWRMYXlvdXQgPSAoeyBncm91cFNpemUgPSBHUk9VUF9TSVpFLCBleGNsdWRlTG9jYWxQYXJ0aWNpcGFudCA9IGZhbHNlLCBwYWdlQXJyb3dzVmlzaWJsZSA9IHRydWUsIFZpZGVvUGxhY2Vob2xkZXIsIFBhcnRpY2lwYW50Vmlld1VJID0gRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJLCB9KSA9PiB7XG4gICAgY29uc3QgW3BhZ2UsIHNldFBhZ2VdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3BhZ2luYXRlZEdyaWRMYXlvdXRXcmFwcGVyRWxlbWVudCwgc2V0UGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50LF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBjYWxsID0gdXNlQ2FsbCgpO1xuICAgIGNvbnN0IHsgdXNlUGFydGljaXBhbnRzLCB1c2VSZW1vdGVQYXJ0aWNpcGFudHMgfSA9IHVzZUNhbGxTdGF0ZUhvb2tzKCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gdXNlUGFydGljaXBhbnRzKCk7XG4gICAgLy8gdXNlZCB0byByZW5kZXIgYXVkaW8gZWxlbWVudHNcbiAgICBjb25zdCByZW1vdGVQYXJ0aWNpcGFudHMgPSB1c2VSZW1vdGVQYXJ0aWNpcGFudHMoKTtcbiAgICB1c2VQYWdpbmF0ZWRMYXlvdXRTb3J0UHJlc2V0KGNhbGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50IHx8ICFjYWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gY2FsbC5zZXRWaWV3cG9ydChwYWdpbmF0ZWRHcmlkTGF5b3V0V3JhcHBlckVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYW51cCgpO1xuICAgIH0sIFtwYWdpbmF0ZWRHcmlkTGF5b3V0V3JhcHBlckVsZW1lbnQsIGNhbGxdKTtcbiAgICAvLyBvbmx5IHVzZWQgdG8gcmVuZGVyIHZpZGVvIGVsZW1lbnRzXG4gICAgY29uc3QgcGFydGljaXBhbnRHcm91cHMgPSB1c2VNZW1vKCgpID0+IGNodW5rKGV4Y2x1ZGVMb2NhbFBhcnRpY2lwYW50ID8gcmVtb3RlUGFydGljaXBhbnRzIDogcGFydGljaXBhbnRzLCBncm91cFNpemUpLCBbZXhjbHVkZUxvY2FsUGFydGljaXBhbnQsIHJlbW90ZVBhcnRpY2lwYW50cywgcGFydGljaXBhbnRzLCBncm91cFNpemVdKTtcbiAgICBjb25zdCBwYWdlQ291bnQgPSBwYXJ0aWNpcGFudEdyb3Vwcy5sZW5ndGg7XG4gICAgLy8gdXBkYXRlIHBhZ2Ugd2hlbiBwYWdlIGNvdW50IGlzIHJlZHVjZWQgYW5kIHNlbGVjdGVkIHBhZ2Ugbm8gbG9uZ2VyIGV4aXN0c1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwYWdlID4gcGFnZUNvdW50IC0gMSkge1xuICAgICAgICAgICAgc2V0UGFnZShNYXRoLm1heCgwLCBwYWdlQ291bnQgLSAxKSk7XG4gICAgICAgIH1cbiAgICB9LCBbcGFnZSwgcGFnZUNvdW50XSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRHcm91cCA9IHBhcnRpY2lwYW50R3JvdXBzW3BhZ2VdO1xuICAgIGlmICghY2FsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fcGFnaW5hdGVkLWdyaWQtbGF5b3V0X193cmFwcGVyXCIsIHJlZjogc2V0UGFnaW5hdGVkR3JpZExheW91dFdyYXBwZXJFbGVtZW50LCBjaGlsZHJlbjogW2pzeChQYXJ0aWNpcGFudHNBdWRpbywgeyBwYXJ0aWNpcGFudHM6IHJlbW90ZVBhcnRpY2lwYW50cyB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3BhZ2luYXRlZC1ncmlkLWxheW91dFwiLCBjaGlsZHJlbjogW3BhZ2VBcnJvd3NWaXNpYmxlICYmIHBhZ2VDb3VudCA+IDEgJiYgKGpzeChJY29uQnV0dG9uLCB7IGljb246IFwiY2FyZXQtbGVmdFwiLCBkaXNhYmxlZDogcGFnZSA9PT0gMCwgb25DbGljazogKCkgPT4gc2V0UGFnZSgoY3VycmVudFBhZ2UpID0+IE1hdGgubWF4KDAsIGN1cnJlbnRQYWdlIC0gMSkpIH0pKSwgc2VsZWN0ZWRHcm91cCAmJiAoanN4KFBhZ2luYXRlZEdyaWRMYXlvdXRHcm91cCwgeyBncm91cDogcGFydGljaXBhbnRHcm91cHNbcGFnZV0sIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIsIFBhcnRpY2lwYW50Vmlld1VJOiBQYXJ0aWNpcGFudFZpZXdVSSB9KSksIHBhZ2VBcnJvd3NWaXNpYmxlICYmIHBhZ2VDb3VudCA+IDEgJiYgKGpzeChJY29uQnV0dG9uLCB7IGRpc2FibGVkOiBwYWdlID09PSBwYWdlQ291bnQgLSAxLCBpY29uOiBcImNhcmV0LXJpZ2h0XCIsIG9uQ2xpY2s6ICgpID0+IHNldFBhZ2UoKGN1cnJlbnRQYWdlKSA9PiBNYXRoLm1pbihwYWdlQ291bnQgLSAxLCBjdXJyZW50UGFnZSArIDEpKSB9KSldIH0pXSB9KSk7XG59O1xuXG5jb25zdCB1c2VDYWxjdWxhdGVIYXJkTGltaXQgPSAoXG4vKipcbiAqIEVsZW1lbnQgdGhhdCBzdHJldGNoZXMgdG8gMTAwJSBvZiB0aGUgd2hvbGUgbGF5b3V0IGNvbXBvbmVudFxuICovXG53cmFwcGVyRWxlbWVudCwgXG4vKipcbiAqIEVsZW1lbnQgdGhhdCBkaXJlY3RseSBob3N0cyBpbmRpdmlkdWFsIGBQYXJ0aWNpcGFudFZpZXdgIChvciB3cmFwcGVyKSBlbGVtZW50c1xuICovXG5ob3N0RWxlbWVudCwgbGltaXQpID0+IHtcbiAgICBjb25zdCBbY2FsY3VsYXRlZExpbWl0LCBzZXRDYWxjdWxhdGVkTGltaXRdID0gdXNlU3RhdGUoe1xuICAgICAgICB2ZXJ0aWNhbDogdHlwZW9mIGxpbWl0ID09PSAnbnVtYmVyJyA/IGxpbWl0IDogbnVsbCxcbiAgICAgICAgaG9yaXpvbnRhbDogdHlwZW9mIGxpbWl0ID09PSAnbnVtYmVyJyA/IGxpbWl0IDogbnVsbCxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWhvc3RFbGVtZW50IHx8XG4gICAgICAgICAgICAhd3JhcHBlckVsZW1lbnQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsaW1pdCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjaGlsZFdpZHRoID0gbnVsbDtcbiAgICAgICAgbGV0IGNoaWxkSGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAvLyB0aGlzIHBhcnQgc2hvdWxkIGlkZWFsbHkgcnVuIGFzIGxpdHRsZSB0aW1lcyBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gZ2V0IGNoaWxkIG1lYXN1cmVtZW50cyBhbmQgZGlzY29ubmVjdFxuICAgICAgICAgICAgLy8gZG9lcyBub3QgY29uc2lkZXIgZHluYW1pY2FsbHkgc2l6ZWQgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoaXMgaG9vayBpcyBmb3IgU3BlYWtlckxheW91dCB1c2Ugb25seSwgd2hlcmUgY2hpbGRyZW4gaW4gdGhlIGJhciBhcmUgZml4ZWQgc2l6ZVxuICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gaG9zdEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRIZWlnaHQgPSBjaGlsZC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkV2lkdGggPSBjaGlsZC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBzdGF0ZSBhdCB7IHZlcnRpY2FsOiAxLCBob3Jpem9udGFsOiAxIH1cbiAgICAgICAgICAgIC8vIHVudGlsIHdlIGdldCB0aGUgcHJvcGVyIGNoaWxkIG1lYXN1cmVtZW50c1xuICAgICAgICAgICAgaWYgKGNoaWxkSGVpZ2h0ID09PSBudWxsIHx8IGNoaWxkV2lkdGggPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdmVydGljYWwgPSBNYXRoLmZsb29yKHdyYXBwZXJFbGVtZW50LmNsaWVudEhlaWdodCAvIGNoaWxkSGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWwgPSBNYXRoLmZsb29yKHdyYXBwZXJFbGVtZW50LmNsaWVudFdpZHRoIC8gY2hpbGRXaWR0aCk7XG4gICAgICAgICAgICBzZXRDYWxjdWxhdGVkTGltaXQoKHB2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHB2LnZlcnRpY2FsICE9PSB2ZXJ0aWNhbCB8fCBwdi5ob3Jpem9udGFsICE9PSBob3Jpem9udGFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh3cmFwcGVyRWxlbWVudCk7XG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoaG9zdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtob3N0RWxlbWVudCwgbGltaXQsIHdyYXBwZXJFbGVtZW50XSk7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZWRMaW1pdDtcbn07XG5cbmNvbnN0IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSUJhciA9ICgpID0+IChqc3goRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJLCB7IG1lbnVQbGFjZW1lbnQ6IFwidG9wLWVuZFwiIH0pKTtcbmNvbnN0IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSVNwb3RsaWdodCA9ICgpID0+IGpzeChEZWZhdWx0UGFydGljaXBhbnRWaWV3VUksIHt9KTtcbmNvbnN0IFNwZWFrZXJMYXlvdXQgPSAoeyBQYXJ0aWNpcGFudFZpZXdVSUJhciA9IERlZmF1bHRQYXJ0aWNpcGFudFZpZXdVSUJhciwgUGFydGljaXBhbnRWaWV3VUlTcG90bGlnaHQgPSBEZWZhdWx0UGFydGljaXBhbnRWaWV3VUlTcG90bGlnaHQsIFZpZGVvUGxhY2Vob2xkZXIsIHBhcnRpY2lwYW50c0JhclBvc2l0aW9uID0gJ2JvdHRvbScsIHBhcnRpY2lwYW50c0JhckxpbWl0LCB9KSA9PiB7XG4gICAgY29uc3QgY2FsbCA9IHVzZUNhbGwoKTtcbiAgICBjb25zdCB7IHVzZVBhcnRpY2lwYW50cywgdXNlUmVtb3RlUGFydGljaXBhbnRzIH0gPSB1c2VDYWxsU3RhdGVIb29rcygpO1xuICAgIGNvbnN0IFtwYXJ0aWNpcGFudEluU3BvdGxpZ2h0LCAuLi5vdGhlclBhcnRpY2lwYW50c10gPSB1c2VQYXJ0aWNpcGFudHMoKTtcbiAgICBjb25zdCByZW1vdGVQYXJ0aWNpcGFudHMgPSB1c2VSZW1vdGVQYXJ0aWNpcGFudHMoKTtcbiAgICBjb25zdCBbcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQsIHNldFBhcnRpY2lwYW50c0JhcldyYXBwZXJFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtwYXJ0aWNpcGFudHNCYXJFbGVtZW50LCBzZXRQYXJ0aWNpcGFudHNCYXJFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtidXR0b25zV3JhcHBlckVsZW1lbnQsIHNldEJ1dHRvbnNXcmFwcGVyRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBpc1NwZWFrZXJTY3JlZW5TaGFyaW5nID0gaGFzU2NyZWVuU2hhcmUocGFydGljaXBhbnRJblNwb3RsaWdodCk7XG4gICAgY29uc3QgaGFyZExpbWl0ID0gdXNlQ2FsY3VsYXRlSGFyZExpbWl0KGJ1dHRvbnNXcmFwcGVyRWxlbWVudCwgcGFydGljaXBhbnRzQmFyRWxlbWVudCwgcGFydGljaXBhbnRzQmFyTGltaXQpO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBhcnRpY2lwYW50c0JhclBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHBhcnRpY2lwYW50c0JhclBvc2l0aW9uID09PSAndG9wJyB8fCBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFwYXJ0aWNpcGFudHNCYXJXcmFwcGVyRWxlbWVudCB8fCAhY2FsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IGNhbGwuc2V0Vmlld3BvcnQocGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYW51cCgpO1xuICAgIH0sIFtwYXJ0aWNpcGFudHNCYXJXcmFwcGVyRWxlbWVudCwgY2FsbF0pO1xuICAgIGNvbnN0IGlzT25lT25PbmVDYWxsID0gb3RoZXJQYXJ0aWNpcGFudHMubGVuZ3RoID09PSAxO1xuICAgIHVzZVNwZWFrZXJMYXlvdXRTb3J0UHJlc2V0KGNhbGwsIGlzT25lT25PbmVDYWxsKTtcbiAgICBsZXQgcGFydGljaXBhbnRzV2l0aEFwcGxpZWRMaW1pdCA9IG90aGVyUGFydGljaXBhbnRzO1xuICAgIGNvbnN0IGhhcmRMaW1pdFRvQXBwbHkgPSBpc1ZlcnRpY2FsXG4gICAgICAgID8gaGFyZExpbWl0LnZlcnRpY2FsXG4gICAgICAgIDogaGFyZExpbWl0Lmhvcml6b250YWw7XG4gICAgaWYgKHR5cGVvZiBwYXJ0aWNpcGFudHNCYXJMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgaGFyZExpbWl0VG9BcHBseSAhPT0gbnVsbCkge1xuICAgICAgICBwYXJ0aWNpcGFudHNXaXRoQXBwbGllZExpbWl0ID0gb3RoZXJQYXJ0aWNpcGFudHMuc2xpY2UoMCwgXG4gICAgICAgIC8vIHN1YnRyYWN0IDEgaWYgc3BlYWtlciBpcyBzaGFyaW5nIHNjcmVlbiBhc1xuICAgICAgICAvLyB0aGF0IG9uZSBpcyByZW5kZXJlZCBpbmRlcGVuZGVudGx5IGZyb20gb3RoZXJQYXJ0aWNpcGFudHMgYXJyYXlcbiAgICAgICAgaGFyZExpbWl0VG9BcHBseSAtIChpc1NwZWFrZXJTY3JlZW5TaGFyaW5nID8gMSA6IDApKTtcbiAgICB9XG4gICAgaWYgKCFjYWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fd3JhcHBlclwiLCBjaGlsZHJlbjogW2pzeChQYXJ0aWNpcGFudHNBdWRpbywgeyBwYXJ0aWNpcGFudHM6IHJlbW90ZVBhcnRpY2lwYW50cyB9KSwganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xzeCgnc3RyLXZpZGVvX19zcGVha2VyLWxheW91dCcsIHBhcnRpY2lwYW50c0JhclBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIGBzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0LS12YXJpYW50LSR7cGFydGljaXBhbnRzQmFyUG9zaXRpb259YCksIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3Nwb3RsaWdodFwiLCBjaGlsZHJlbjogcGFydGljaXBhbnRJblNwb3RsaWdodCAmJiAoanN4KFBhcnRpY2lwYW50VmlldywgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnRJblNwb3RsaWdodCwgbXV0ZUF1ZGlvOiB0cnVlLCB0cmFja1R5cGU6IGlzU3BlYWtlclNjcmVlblNoYXJpbmcgPyAnc2NyZWVuU2hhcmVUcmFjaycgOiAndmlkZW9UcmFjaycsIFBhcnRpY2lwYW50Vmlld1VJOiBQYXJ0aWNpcGFudFZpZXdVSVNwb3RsaWdodCwgVmlkZW9QbGFjZWhvbGRlcjogVmlkZW9QbGFjZWhvbGRlciB9KSkgfSksIHBhcnRpY2lwYW50c1dpdGhBcHBsaWVkTGltaXQubGVuZ3RoID4gMCAmJiBwYXJ0aWNpcGFudHNCYXJQb3NpdGlvbiAmJiAoanN4cyhcImRpdlwiLCB7IHJlZjogc2V0QnV0dG9uc1dyYXBwZXJFbGVtZW50LCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnRzLWJhci1idXR0b25zLXdyYXBwZXJcIiwgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnRzLWJhci13cmFwcGVyXCIsIHJlZjogc2V0UGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQsIGNoaWxkcmVuOiBqc3hzKFwiZGl2XCIsIHsgcmVmOiBzZXRQYXJ0aWNpcGFudHNCYXJFbGVtZW50LCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnRzLWJhclwiLCBjaGlsZHJlbjogW2lzU3BlYWtlclNjcmVlblNoYXJpbmcgJiYgKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19wYXJ0aWNpcGFudC10aWxlXCIsIGNoaWxkcmVuOiBqc3goUGFydGljaXBhbnRWaWV3LCB7IHBhcnRpY2lwYW50OiBwYXJ0aWNpcGFudEluU3BvdGxpZ2h0LCBQYXJ0aWNpcGFudFZpZXdVSTogUGFydGljaXBhbnRWaWV3VUlCYXIsIFZpZGVvUGxhY2Vob2xkZXI6IFZpZGVvUGxhY2Vob2xkZXIsIG11dGVBdWRpbzogdHJ1ZSB9KSB9LCBwYXJ0aWNpcGFudEluU3BvdGxpZ2h0LnNlc3Npb25JZCkpLCBwYXJ0aWNpcGFudHNXaXRoQXBwbGllZExpbWl0Lm1hcCgocGFydGljaXBhbnQpID0+IChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnQtdGlsZVwiLCBjaGlsZHJlbjoganN4KFBhcnRpY2lwYW50VmlldywgeyBwYXJ0aWNpcGFudDogcGFydGljaXBhbnQsIFBhcnRpY2lwYW50Vmlld1VJOiBQYXJ0aWNpcGFudFZpZXdVSUJhciwgVmlkZW9QbGFjZWhvbGRlcjogVmlkZW9QbGFjZWhvbGRlciwgbXV0ZUF1ZGlvOiB0cnVlIH0pIH0sIHBhcnRpY2lwYW50LnNlc3Npb25JZCkpKV0gfSkgfSksIGlzVmVydGljYWwgJiYgKGpzeChWZXJ0aWNhbFNjcm9sbEJ1dHRvbnMsIHsgc2Nyb2xsV3JhcHBlcjogcGFydGljaXBhbnRzQmFyV3JhcHBlckVsZW1lbnQgfSkpLCBpc0hvcml6b250YWwgJiYgKGpzeChIb3Jpem9udGFsU2Nyb2xsQnV0dG9ucywgeyBzY3JvbGxXcmFwcGVyOiBwYXJ0aWNpcGFudHNCYXJXcmFwcGVyRWxlbWVudCB9KSldIH0pKV0gfSldIH0pKTtcbn07XG5jb25zdCBIb3Jpem9udGFsU2Nyb2xsQnV0dG9ucyA9ICh7IHNjcm9sbFdyYXBwZXIsIH0pID0+IHtcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHVzZUhvcml6b250YWxTY3JvbGxQb3NpdGlvbihzY3JvbGxXcmFwcGVyKTtcbiAgICBjb25zdCBzY3JvbGxTdGFydENsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2Nyb2xsV3JhcHBlcj8uc2Nyb2xsQnkoeyBsZWZ0OiAtMTUwLCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzY3JvbGxFbmRDbGlja0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbFdyYXBwZXI/LnNjcm9sbEJ5KHsgbGVmdDogMTUwLCBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtzY3JvbGxQb3NpdGlvbiAmJiBzY3JvbGxQb3NpdGlvbiAhPT0gJ3N0YXJ0JyAmJiAoanN4KEljb25CdXR0b24sIHsgb25DbGljazogc2Nyb2xsU3RhcnRDbGlja0hhbmRsZXIsIGljb246IFwiY2FyZXQtbGVmdFwiLCBjbGFzc05hbWU6IFwic3RyLXZpZGVvX19zcGVha2VyLWxheW91dF9fcGFydGljaXBhbnRzLWJhci0tYnV0dG9uLWxlZnRcIiB9KSksIHNjcm9sbFBvc2l0aW9uICYmIHNjcm9sbFBvc2l0aW9uICE9PSAnZW5kJyAmJiAoanN4KEljb25CdXR0b24sIHsgb25DbGljazogc2Nyb2xsRW5kQ2xpY2tIYW5kbGVyLCBpY29uOiBcImNhcmV0LXJpZ2h0XCIsIGNsYXNzTmFtZTogXCJzdHItdmlkZW9fX3NwZWFrZXItbGF5b3V0X19wYXJ0aWNpcGFudHMtYmFyLS1idXR0b24tcmlnaHRcIiB9KSldIH0pKTtcbn07XG5jb25zdCBWZXJ0aWNhbFNjcm9sbEJ1dHRvbnMgPSAoeyBzY3JvbGxXcmFwcGVyLCB9KSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB1c2VWZXJ0aWNhbFNjcm9sbFBvc2l0aW9uKHNjcm9sbFdyYXBwZXIpO1xuICAgIGNvbnN0IHNjcm9sbFRvcENsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2Nyb2xsV3JhcHBlcj8uc2Nyb2xsQnkoeyB0b3A6IC0xNTAsIGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNjcm9sbEJvdHRvbUNsaWNrSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgc2Nyb2xsV3JhcHBlcj8uc2Nyb2xsQnkoeyB0b3A6IDE1MCwgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbc2Nyb2xsUG9zaXRpb24gJiYgc2Nyb2xsUG9zaXRpb24gIT09ICd0b3AnICYmIChqc3goSWNvbkJ1dHRvbiwgeyBvbkNsaWNrOiBzY3JvbGxUb3BDbGlja0hhbmRsZXIsIGljb246IFwiY2FyZXQtdXBcIiwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItLWJ1dHRvbi10b3BcIiB9KSksIHNjcm9sbFBvc2l0aW9uICYmIHNjcm9sbFBvc2l0aW9uICE9PSAnYm90dG9tJyAmJiAoanN4KEljb25CdXR0b24sIHsgb25DbGljazogc2Nyb2xsQm90dG9tQ2xpY2tIYW5kbGVyLCBpY29uOiBcImNhcmV0LWRvd25cIiwgY2xhc3NOYW1lOiBcInN0ci12aWRlb19fc3BlYWtlci1sYXlvdXRfX3BhcnRpY2lwYW50cy1iYXItLWJ1dHRvbi1ib3R0b21cIiB9KSldIH0pKTtcbn07XG5jb25zdCBoYXNTY3JlZW5TaGFyZSA9IChwKSA9PiAhIXA/LnB1Ymxpc2hlZFRyYWNrcy5pbmNsdWRlcyhTZnVNb2RlbHMuVHJhY2tUeXBlLlNDUkVFTl9TSEFSRSk7XG5cbmNvbnN0IFttYWpvciwgbWlub3IsIHBhdGNoXSA9IChcIjAuNS4xXCIgKS5zcGxpdCgnLicpO1xuc2V0U2RrSW5mbyh7XG4gICAgdHlwZTogU2Z1TW9kZWxzLlNka1R5cGUuUkVBQ1QsXG4gICAgbWFqb3IsXG4gICAgbWlub3IsXG4gICAgcGF0Y2gsXG59KTtcblxuZXhwb3J0IHsgQWNjZXB0Q2FsbEJ1dHRvbiwgQXVkaW8sIEF2YXRhciwgQXZhdGFyRmFsbGJhY2ssIEJhc2VWaWRlbywgQ2FsbENvbnRyb2xzLCBDYWxsUGFydGljaXBhbnRMaXN0aW5nLCBDYWxsUGFydGljaXBhbnRMaXN0aW5nSXRlbSwgQ2FsbFBhcnRpY2lwYW50c0xpc3QsIENhbGxQcmV2aWV3LCBDYWxsUmVjb3JkaW5nTGlzdCwgQ2FsbFJlY29yZGluZ0xpc3RIZWFkZXIsIENhbGxSZWNvcmRpbmdMaXN0SXRlbSwgQ2FsbFN0YXRzLCBDYWxsU3RhdHNCdXR0b24sIENhbGxTdGF0c0xhdGVuY3lDaGFydCwgQ2FuY2VsQ2FsbEJ1dHRvbiwgQ2FuY2VsQ2FsbENvbmZpcm1CdXR0b24sIENvbXBvc2l0ZUJ1dHRvbiwgRGVmYXVsdFBhcnRpY2lwYW50Vmlld1VJLCBEZWZhdWx0UmVhY3Rpb25zTWVudSwgRGVmYXVsdFNjcmVlblNoYXJlT3ZlcmxheSwgRGVmYXVsdFZpZGVvUGxhY2Vob2xkZXIsIERldmljZVNlbGVjdG9yLCBEZXZpY2VTZWxlY3RvckF1ZGlvSW5wdXQsIERldmljZVNlbGVjdG9yQXVkaW9PdXRwdXQsIERldmljZVNlbGVjdG9yVmlkZW8sIERldmljZVNldHRpbmdzLCBEcm9wRG93blNlbGVjdCwgRHJvcERvd25TZWxlY3RPcHRpb24sIEVtcHR5Q2FsbFJlY29yZGluZ0xpc3RpbmcsIEdlbmVyaWNNZW51LCBHZW5lcmljTWVudUJ1dHRvbkl0ZW0sIEljb24sIEljb25CdXR0b24sIExpdmVzdHJlYW1MYXlvdXQsIExvYWRpbmdDYWxsUmVjb3JkaW5nTGlzdGluZywgTG9hZGluZ0luZGljYXRvciwgTWVudVRvZ2dsZSwgTWVudVZpc3VhbFR5cGUsIE5vdGlmaWNhdGlvbiwgUGFnaW5hdGVkR3JpZExheW91dCwgUGFydGljaXBhbnRBY3Rpb25zQ29udGV4dE1lbnUsIFBhcnRpY2lwYW50RGV0YWlscywgUGFydGljaXBhbnRWaWV3LCBQYXJ0aWNpcGFudFZpZXdDb250ZXh0LCBQYXJ0aWNpcGFudHNBdWRpbywgUGVybWlzc2lvbk5vdGlmaWNhdGlvbiwgUGVybWlzc2lvblJlcXVlc3RMaXN0LCBQZXJtaXNzaW9uUmVxdWVzdHMsIFJlYWN0aW9uc0J1dHRvbiwgUmVjb3JkQ2FsbEJ1dHRvbiwgUmVjb3JkQ2FsbENvbmZpcm1hdGlvbkJ1dHRvbiwgUmVjb3JkaW5nSW5Qcm9ncmVzc05vdGlmaWNhdGlvbiwgUmluZ2luZ0NhbGwsIFJpbmdpbmdDYWxsQ29udHJvbHMsIFNjcmVlblNoYXJlQnV0dG9uLCBTZWFyY2hJbnB1dCwgU2VhcmNoUmVzdWx0cywgU3BlYWtlckxheW91dCwgU3BlYWtpbmdXaGlsZU11dGVkTm90aWZpY2F0aW9uLCBTcGVlY2hJbmRpY2F0b3IsIFN0YXRDYXJkLCBTdGF0Q2FyZEV4cGxhbmF0aW9uLCBTdGF0c1RhZywgU3RhdHVzZXMsIFN0cmVhbUNhbGwsIFN0cmVhbVRoZW1lLCBTdHJlYW1WaWRlbywgVGV4dEJ1dHRvbiwgVG9nZ2xlQXVkaW9PdXRwdXRCdXR0b24sIFRvZ2dsZUF1ZGlvUHJldmlld0J1dHRvbiwgVG9nZ2xlQXVkaW9QdWJsaXNoaW5nQnV0dG9uLCBUb2dnbGVWaWRlb1ByZXZpZXdCdXR0b24sIFRvZ2dsZVZpZGVvUHVibGlzaGluZ0J1dHRvbiwgVG9vbHRpcCwgVmlkZW8kMSBhcyBWaWRlbywgVmlkZW9QcmV2aWV3LCBXaXRoVG9vbHRpcCwgZGVmYXVsdFJlYWN0aW9ucywgdHJhbnNsYXRpb25zLCB1c2VIb3Jpem9udGFsU2Nyb2xsUG9zaXRpb24sIHVzZU1lbnVDb250ZXh0LCB1c2VQYXJ0aWNpcGFudFZpZXdDb250ZXh0LCB1c2VQZXJzaXN0ZWREZXZpY2VQcmVmZXJlbmNlcywgdXNlUmVxdWVzdFBlcm1pc3Npb24sIHVzZVRyYWNrRWxlbWVudFZpc2liaWxpdHksIHVzZVZlcnRpY2FsU2Nyb2xsUG9zaXRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stream-io/video-react-sdk/dist/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@stream-io/video-react-sdk/dist/css/styles.css":
/*!*********************************************************************!*\
  !*** ./node_modules/@stream-io/video-react-sdk/dist/css/styles.css ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2605c43b14ca\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHN0cmVhbS1pby92aWRlby1yZWFjdC1zZGsvZGlzdC9jc3Mvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VhZ2xlcy1yaW5nLy4vbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vdmlkZW8tcmVhY3Qtc2RrL2Rpc3QvY3NzL3N0eWxlcy5jc3M/MzhiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjI2MDVjNDNiMTRjYVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@stream-io/video-react-sdk/dist/css/styles.css\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@stream-io/node-sdk/dist/index.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@stream-io/node-sdk/dist/index.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APNConfigRequestAuthTypeEnum: () => (/* binding */ APNConfigRequestAuthTypeEnum),\n/* harmony export */   AppSearchBackendEnum: () => (/* binding */ AppSearchBackendEnum),\n/* harmony export */   AsyncModerationCallbackConfigRequestModeEnum: () => (/* binding */ AsyncModerationCallbackConfigRequestModeEnum),\n/* harmony export */   AudioSettingsDefaultDeviceEnum: () => (/* binding */ AudioSettingsDefaultDeviceEnum),\n/* harmony export */   BlockListOptionsBehaviorEnum: () => (/* binding */ BlockListOptionsBehaviorEnum),\n/* harmony export */   BlockListOptionsRequestBehaviorEnum: () => (/* binding */ BlockListOptionsRequestBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodBehaviorEnum: () => (/* binding */ ChannelConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigAutomodEnum: () => (/* binding */ ChannelConfigAutomodEnum),\n/* harmony export */   ChannelConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoAutomodEnum: () => (/* binding */ ChannelConfigWithInfoAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoBlocklistBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodBehaviorEnum),\n/* harmony export */   ChannelConfigWithInfoRequestAutomodEnum: () => (/* binding */ ChannelConfigWithInfoRequestAutomodEnum),\n/* harmony export */   ChannelConfigWithInfoRequestBlocklistBehaviorEnum: () => (/* binding */ ChannelConfigWithInfoRequestBlocklistBehaviorEnum),\n/* harmony export */   ChannelMemberRequestRoleEnum: () => (/* binding */ ChannelMemberRequestRoleEnum),\n/* harmony export */   ChannelMemberRoleEnum: () => (/* binding */ ChannelMemberRoleEnum),\n/* harmony export */   ChannelTypeConfigAutomodBehaviorEnum: () => (/* binding */ ChannelTypeConfigAutomodBehaviorEnum),\n/* harmony export */   ChannelTypeConfigAutomodEnum: () => (/* binding */ ChannelTypeConfigAutomodEnum),\n/* harmony export */   ChannelTypeConfigBlocklistBehaviorEnum: () => (/* binding */ ChannelTypeConfigBlocklistBehaviorEnum),\n/* harmony export */   CheckPushRequestPushProviderTypeEnum: () => (/* binding */ CheckPushRequestPushProviderTypeEnum),\n/* harmony export */   CheckSNSResponseStatusEnum: () => (/* binding */ CheckSNSResponseStatusEnum),\n/* harmony export */   CheckSQSResponseStatusEnum: () => (/* binding */ CheckSQSResponseStatusEnum),\n/* harmony export */   ConfigDefaultRoleEnum: () => (/* binding */ ConfigDefaultRoleEnum),\n/* harmony export */   ConfigRequestDefaultRoleEnum: () => (/* binding */ ConfigRequestDefaultRoleEnum),\n/* harmony export */   CreateCallRequestTypeEnum: () => (/* binding */ CreateCallRequestTypeEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeRequestAutomodEnum: () => (/* binding */ CreateChannelTypeRequestAutomodEnum),\n/* harmony export */   CreateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   CreateChannelTypeResponseAutomodEnum: () => (/* binding */ CreateChannelTypeResponseAutomodEnum),\n/* harmony export */   CreateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ CreateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   CreateDeviceRequestPushProviderEnum: () => (/* binding */ CreateDeviceRequestPushProviderEnum),\n/* harmony export */   CreateImportRequestModeEnum: () => (/* binding */ CreateImportRequestModeEnum),\n/* harmony export */   DeleteUsersRequestConversationsEnum: () => (/* binding */ DeleteUsersRequestConversationsEnum),\n/* harmony export */   DeleteUsersRequestMessagesEnum: () => (/* binding */ DeleteUsersRequestMessagesEnum),\n/* harmony export */   DeleteUsersRequestUserEnum: () => (/* binding */ DeleteUsersRequestUserEnum),\n/* harmony export */   DeviceFieldsPushProviderEnum: () => (/* binding */ DeviceFieldsPushProviderEnum),\n/* harmony export */   DevicePushProviderEnum: () => (/* binding */ DevicePushProviderEnum),\n/* harmony export */   DeviceRequestPushProviderEnum: () => (/* binding */ DeviceRequestPushProviderEnum),\n/* harmony export */   ImageSizeCropEnum: () => (/* binding */ ImageSizeCropEnum),\n/* harmony export */   ImageSizeResizeEnum: () => (/* binding */ ImageSizeResizeEnum),\n/* harmony export */   LayoutSettingsNameEnum: () => (/* binding */ LayoutSettingsNameEnum),\n/* harmony export */   MessageRequest1TypeEnum: () => (/* binding */ MessageRequest1TypeEnum),\n/* harmony export */   MessageRequestTypeEnum: () => (/* binding */ MessageRequestTypeEnum),\n/* harmony export */   MessageTypeEnum: () => (/* binding */ MessageTypeEnum),\n/* harmony export */   PermissionLevelEnum: () => (/* binding */ PermissionLevelEnum),\n/* harmony export */   PolicyRequest1ActionEnum: () => (/* binding */ PolicyRequest1ActionEnum),\n/* harmony export */   PolicyRequestActionEnum: () => (/* binding */ PolicyRequestActionEnum),\n/* harmony export */   PushConfigRequestVersionEnum: () => (/* binding */ PushConfigRequestVersionEnum),\n/* harmony export */   StreamCall: () => (/* binding */ StreamCall),\n/* harmony export */   StreamChannel: () => (/* binding */ StreamChannel),\n/* harmony export */   StreamChatClient: () => (/* binding */ StreamChatClient),\n/* harmony export */   StreamClient: () => (/* binding */ StreamClient),\n/* harmony export */   StreamVideoClient: () => (/* binding */ StreamVideoClient),\n/* harmony export */   TranscriptionSettingsModeEnum: () => (/* binding */ TranscriptionSettingsModeEnum),\n/* harmony export */   TranslateMessageRequestLanguageEnum: () => (/* binding */ TranslateMessageRequestLanguageEnum),\n/* harmony export */   UpdateAppRequestEnforceUniqueUsernamesEnum: () => (/* binding */ UpdateAppRequestEnforceUniqueUsernamesEnum),\n/* harmony export */   UpdateAppRequestPermissionVersionEnum: () => (/* binding */ UpdateAppRequestPermissionVersionEnum),\n/* harmony export */   UpdateAppRequestVideoProviderEnum: () => (/* binding */ UpdateAppRequestVideoProviderEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeRequestAutomodEnum: () => (/* binding */ UpdateChannelTypeRequestAutomodEnum),\n/* harmony export */   UpdateChannelTypeRequestBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeRequestBlocklistBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodBehaviorEnum),\n/* harmony export */   UpdateChannelTypeResponseAutomodEnum: () => (/* binding */ UpdateChannelTypeResponseAutomodEnum),\n/* harmony export */   UpdateChannelTypeResponseBlocklistBehaviorEnum: () => (/* binding */ UpdateChannelTypeResponseBlocklistBehaviorEnum),\n/* harmony export */   VideoAudioSettingsDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsDefaultDeviceEnum),\n/* harmony export */   VideoAudioSettingsRequestDefaultDeviceEnum: () => (/* binding */ VideoAudioSettingsRequestDefaultDeviceEnum),\n/* harmony export */   VideoCreateDeviceRequestPushProviderEnum: () => (/* binding */ VideoCreateDeviceRequestPushProviderEnum),\n/* harmony export */   VideoLayoutSettingsNameEnum: () => (/* binding */ VideoLayoutSettingsNameEnum),\n/* harmony export */   VideoLayoutSettingsRequestNameEnum: () => (/* binding */ VideoLayoutSettingsRequestNameEnum),\n/* harmony export */   VideoOwnCapability: () => (/* binding */ VideoOwnCapability),\n/* harmony export */   VideoRecordSettingsRequestModeEnum: () => (/* binding */ VideoRecordSettingsRequestModeEnum),\n/* harmony export */   VideoRecordSettingsRequestQualityEnum: () => (/* binding */ VideoRecordSettingsRequestQualityEnum),\n/* harmony export */   VideoSettingsCameraFacingEnum: () => (/* binding */ VideoSettingsCameraFacingEnum),\n/* harmony export */   VideoTranscriptionSettingsModeEnum: () => (/* binding */ VideoTranscriptionSettingsModeEnum),\n/* harmony export */   VideoTranscriptionSettingsRequestModeEnum: () => (/* binding */ VideoTranscriptionSettingsRequestModeEnum),\n/* harmony export */   VideoVideoSettingsCameraFacingEnum: () => (/* binding */ VideoVideoSettingsCameraFacingEnum),\n/* harmony export */   VideoVideoSettingsRequestCameraFacingEnum: () => (/* binding */ VideoVideoSettingsRequestCameraFacingEnum)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/uuid/dist/esm-node/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonwebtoken */ \"(action-browser)/./node_modules/jsonwebtoken/index.js\");\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n/**\n * @export\n */\nconst APNConfigRequestAuthTypeEnum = {\n    CERTIFICATE: 'certificate',\n    TOKEN: 'token'\n};\n/**\n * @export\n */\nconst AppSearchBackendEnum = {\n    ELASTICSEARCH: 'elasticsearch',\n    POSTGRES: 'postgres',\n    DISABLED: 'disabled'\n};\n/**\n * @export\n */\nconst AsyncModerationCallbackConfigRequestModeEnum = {\n    NONE: 'CALLBACK_MODE_NONE',\n    REST: 'CALLBACK_MODE_REST',\n    TWIRP: 'CALLBACK_MODE_TWIRP'\n};\n/**\n * @export\n */\nconst AudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst BlockListOptionsBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst BlockListOptionsRequestBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelConfigWithInfoRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelMemberRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelMemberRequestRoleEnum = {\n    MEMBER: 'member',\n    MODERATOR: 'moderator',\n    ADMIN: 'admin',\n    OWNER: 'owner'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst ChannelTypeConfigBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CheckPushRequestPushProviderTypeEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CheckSNSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst CheckSQSResponseStatusEnum = {\n    OK: 'ok',\n    ERROR: 'error'\n};\n/**\n * @export\n */\nconst ConfigDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst ConfigRequestDefaultRoleEnum = {\n    ATTENDEE: 'attendee',\n    PUBLISHER: 'publisher',\n    SUBSCRIBER: 'subscriber',\n    ADMIN: 'admin'\n};\n/**\n * @export\n */\nconst CreateCallRequestTypeEnum = {\n    AUDIO: 'audio',\n    VIDEO: 'video'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst CreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst CreateImportRequestModeEnum = {\n    INSERT: 'insert',\n    UPSERT: 'upsert'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestConversationsEnum = {\n    SOFT: 'soft',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestMessagesEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DeleteUsersRequestUserEnum = {\n    SOFT: 'soft',\n    PRUNING: 'pruning',\n    HARD: 'hard'\n};\n/**\n * @export\n */\nconst DevicePushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceFieldsPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst DeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst ImageSizeCropEnum = {\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    RIGHT: 'right',\n    CENTER: 'center'\n};\n/**\n * @export\n */\nconst ImageSizeResizeEnum = {\n    CLIP: 'clip',\n    CROP: 'crop',\n    SCALE: 'scale',\n    FILL: 'fill'\n};\n/**\n * @export\n */\nconst LayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst MessageTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequestTypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst MessageRequest1TypeEnum = {\n    REGULAR: 'regular',\n    EPHEMERAL: 'ephemeral',\n    ERROR: 'error',\n    REPLY: 'reply',\n    SYSTEM: 'system',\n    DELETED: 'deleted'\n};\n/**\n * @export\n */\nconst PermissionLevelEnum = {\n    APP: 'app',\n    CHANNEL: 'channel'\n};\n/**\n * @export\n */\nconst PolicyRequestActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PolicyRequest1ActionEnum = {\n    DENY: 'Deny',\n    ALLOW: 'Allow'\n};\n/**\n * @export\n */\nconst PushConfigRequestVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst TranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst TranslateMessageRequestLanguageEnum = {\n    AF: 'af',\n    SQ: 'sq',\n    AM: 'am',\n    AR: 'ar',\n    AZ: 'az',\n    BN: 'bn',\n    BS: 'bs',\n    BG: 'bg',\n    ZH: 'zh',\n    ZH_TW: 'zh-TW',\n    HR: 'hr',\n    CS: 'cs',\n    DA: 'da',\n    FA_AF: 'fa-AF',\n    NL: 'nl',\n    EN: 'en',\n    ET: 'et',\n    FI: 'fi',\n    FR: 'fr',\n    FR_CA: 'fr-CA',\n    KA: 'ka',\n    DE: 'de',\n    EL: 'el',\n    HA: 'ha',\n    HE: 'he',\n    HI: 'hi',\n    HU: 'hu',\n    ID: 'id',\n    IT: 'it',\n    JA: 'ja',\n    KO: 'ko',\n    LV: 'lv',\n    MS: 'ms',\n    NO: 'no',\n    FA: 'fa',\n    PS: 'ps',\n    PL: 'pl',\n    PT: 'pt',\n    RO: 'ro',\n    RU: 'ru',\n    SR: 'sr',\n    SK: 'sk',\n    SL: 'sl',\n    SO: 'so',\n    ES: 'es',\n    ES_MX: 'es-MX',\n    SW: 'sw',\n    SV: 'sv',\n    TL: 'tl',\n    TA: 'ta',\n    TH: 'th',\n    TR: 'tr',\n    UK: 'uk',\n    UR: 'ur',\n    VI: 'vi'\n};\n/**\n * @export\n */\nconst UpdateAppRequestEnforceUniqueUsernamesEnum = {\n    NO: 'no',\n    APP: 'app',\n    TEAM: 'team'\n};\n/**\n * @export\n */\nconst UpdateAppRequestPermissionVersionEnum = {\n    V1: 'v1',\n    V2: 'v2'\n};\n/**\n * @export\n */\nconst UpdateAppRequestVideoProviderEnum = {\n    AGORA: 'agora',\n    HMS: 'hms'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeRequestBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodEnum = {\n    DISABLED: 'disabled',\n    SIMPLE: 'simple',\n    AI: 'AI'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseAutomodBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst UpdateChannelTypeResponseBlocklistBehaviorEnum = {\n    FLAG: 'flag',\n    BLOCK: 'block'\n};\n/**\n * @export\n */\nconst VideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/**\n * @export\n */\nconst VideoAudioSettingsDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoAudioSettingsRequestDefaultDeviceEnum = {\n    SPEAKER: 'speaker',\n    EARPIECE: 'earpiece'\n};\n/**\n * @export\n */\nconst VideoCreateDeviceRequestPushProviderEnum = {\n    FIREBASE: 'firebase',\n    APN: 'apn',\n    HUAWEI: 'huawei',\n    XIAOMI: 'xiaomi'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * @export\n */\nconst VideoLayoutSettingsRequestNameEnum = {\n    SPOTLIGHT: 'spotlight',\n    GRID: 'grid',\n    SINGLE_PARTICIPANT: 'single-participant',\n    MOBILE: 'mobile',\n    CUSTOM: 'custom'\n};\n/**\n * All possibility of string to use\n * @export\n */\nconst VideoOwnCapability = {\n    BLOCK_USERS: 'block-users',\n    CREATE_CALL: 'create-call',\n    CREATE_REACTION: 'create-reaction',\n    END_CALL: 'end-call',\n    JOIN_BACKSTAGE: 'join-backstage',\n    JOIN_CALL: 'join-call',\n    JOIN_ENDED_CALL: 'join-ended-call',\n    MUTE_USERS: 'mute-users',\n    PIN_FOR_EVERYONE: 'pin-for-everyone',\n    READ_CALL: 'read-call',\n    REMOVE_CALL_MEMBER: 'remove-call-member',\n    SCREENSHARE: 'screenshare',\n    SEND_AUDIO: 'send-audio',\n    SEND_VIDEO: 'send-video',\n    START_BROADCAST_CALL: 'start-broadcast-call',\n    START_RECORD_CALL: 'start-record-call',\n    START_TRANSCRIPTION_CALL: 'start-transcription-call',\n    STOP_BROADCAST_CALL: 'stop-broadcast-call',\n    STOP_RECORD_CALL: 'stop-record-call',\n    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',\n    UPDATE_CALL: 'update-call',\n    UPDATE_CALL_MEMBER: 'update-call-member',\n    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',\n    UPDATE_CALL_SETTINGS: 'update-call-settings'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoRecordSettingsRequestQualityEnum = {\n    _360P: '360p',\n    _480P: '480p',\n    _720P: '720p',\n    _1080P: '1080p',\n    _1440P: '1440p'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoTranscriptionSettingsRequestModeEnum = {\n    AVAILABLE: 'available',\n    DISABLED: 'disabled',\n    AUTO_ON: 'auto-on'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n/**\n * @export\n */\nconst VideoVideoSettingsRequestCameraFacingEnum = {\n    FRONT: 'front',\n    BACK: 'back',\n    EXTERNAL: 'external'\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH$1 = \"https://chat.stream-io-api.com\".replace(/\\/+$/, \"\");\nlet Configuration$1 = class Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH$1;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring$1;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n};\nconst DefaultConfig$1 = new Configuration$1();\n/**\n * This is the base class for all generated API classes.\n */\nlet BaseAPI$1 = class BaseAPI {\n    constructor(configuration = DefaultConfig$1) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError$1(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError$1(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData$1(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob$1(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n};\nBaseAPI$1.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob$1(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData$1(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nlet ResponseError$1 = class ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n};\nlet FetchError$1 = class FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n};\nlet RequiredError$1 = class RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n};\nconst COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\nfunction querystring$1(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey$1(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey$1(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey$1(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring$1(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nfunction canConsumeForm(consumes) {\n    for (const consume of consumes) {\n        if ('multipart/form-data' === consume.contentType) {\n            return true;\n        }\n    }\n    return false;\n}\nlet JSONApiResponse$1 = class JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n};\nlet VoidApiResponse$1 = class VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelTypesApi extends BaseAPI$1 {\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ChannelsApi extends BaseAPI$1 {\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteChannel.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Delete channel\n     */\n    deleteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteChannelsRequest === null || requestParameters.deleteChannelsRequest === undefined) {\n                throw new RequiredError$1('deleteChannelsRequest', 'Required parameter requestParameters.deleteChannelsRequest was null or undefined when calling deleteChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Allows to delete several channels at once asynchronously  Sends events: - channel.deleted  Required permissions: - DeleteChannel\n     * Deletes channels asynchronously\n     */\n    deleteChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportChannelsRequest === null || requestParameters.exportChannelsRequest === undefined) {\n                throw new RequiredError$1('exportChannelsRequest', 'Required parameter requestParameters.exportChannelsRequest was null or undefined when calling exportChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports channel data to JSON file\n     * Export channels\n     */\n    exportChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatusRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getExportChannelsStatus.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export_channels/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     *\n     * Export channels status\n     */\n    getExportChannelsStatus(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getExportChannelsStatusRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateChannel.');\n            }\n            if (requestParameters.channelGetOrCreateRequest === null || requestParameters.channelGetOrCreateRequest === undefined) {\n                throw new RequiredError$1('channelGetOrCreateRequest', 'Required parameter requestParameters.channelGetOrCreateRequest was null or undefined when calling getOrCreateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/query`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.channelGetOrCreateRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method creates a channel or returns an existing one with matching attributes  Sends events: - channel.created - member.added - member.removed - member.updated - user.watching.start\n     * Get or create channel\n     */\n    getOrCreateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling hideChannel.');\n            }\n            if (requestParameters.hideChannelRequest === null || requestParameters.hideChannelRequest === undefined) {\n                throw new RequiredError$1('hideChannelRequest', 'Required parameter requestParameters.hideChannelRequest was null or undefined when calling hideChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/hide`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.hideChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as hidden for current user  Sends events: - channel.hidden  Required permissions: - ReadChannel\n     * Hide channel\n     */\n    hideChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.hideChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteChannelRequest === null || requestParameters.muteChannelRequest === undefined) {\n                throw new RequiredError$1('muteChannelRequest', 'Required parameter requestParameters.muteChannelRequest was null or undefined when calling muteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes channel for user  Sends events: - channel.muted  Required permissions: - MuteChannel\n     * Mute channel\n     */\n    muteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannelsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.queryChannelsRequest === null || requestParameters.queryChannelsRequest === undefined) {\n                throw new RequiredError$1('queryChannelsRequest', 'Required parameter requestParameters.queryChannelsRequest was null or undefined when calling queryChannels.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.queryChannelsRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Query channels with filter query  Required permissions: - ReadChannel\n     * Query channels\n     */\n    queryChannels(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryChannelsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/members`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel members  Required permissions: - ReadChannel\n     * Query members\n     */\n    queryMembers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling showChannel.');\n            }\n            if (requestParameters.showChannelRequest === null || requestParameters.showChannelRequest === undefined) {\n                throw new RequiredError$1('showChannelRequest', 'Required parameter requestParameters.showChannelRequest was null or undefined when calling showChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/show`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.showChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Shows previously hidden channel  Sends events: - channel.visible\n     * Show channel\n     */\n    showChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.showChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling truncateChannel.');\n            }\n            if (requestParameters.truncateChannelRequest === null || requestParameters.truncateChannelRequest === undefined) {\n                throw new RequiredError$1('truncateChannelRequest', 'Required parameter requestParameters.truncateChannelRequest was null or undefined when calling truncateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/truncate`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.truncateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Truncates channel  Sends events: - channel.truncated  Required permissions: - DeleteChannel - TruncateChannel\n     * Truncate channel\n     */\n    truncateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.truncateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteChannelRequest === null || requestParameters.unmuteChannelRequest === undefined) {\n                throw new RequiredError$1('unmuteChannelRequest', 'Required parameter requestParameters.unmuteChannelRequest was null or undefined when calling unmuteChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute/channel`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes channel for user  Sends events: - channel.unmuted  Required permissions: - MuteChannel\n     * Unmute channel\n     */\n    unmuteChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCountsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/unread`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * UnreadCount counts\n     * UnreadCount counts\n     */\n    unreadCounts(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unreadCountsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannelRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannel.');\n            }\n            if (requestParameters.updateChannelRequest === null || requestParameters.updateChannelRequest === undefined) {\n                throw new RequiredError$1('updateChannelRequest', 'Required parameter requestParameters.updateChannelRequest was null or undefined when calling updateChannel.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Change channel data  Sends events: - channel.updated - member.added - member.removed - member.updated - message.new  Required permissions: - AddOwnChannelMembership - RemoveOwnChannelMembership - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen - UpdateChannelMembers\n     * Update channel\n     */\n    updateChannel(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateChannelPartial.');\n            }\n            if (requestParameters.updateChannelPartialRequest === null || requestParameters.updateChannelPartialRequest === undefined) {\n                throw new RequiredError$1('updateChannelPartialRequest', 'Required parameter requestParameters.updateChannelPartialRequest was null or undefined when calling updateChannelPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the channel  Sends events: - channel.updated  Required permissions: - UpdateChannel - UpdateChannelCooldown - UpdateChannelFrozen\n     * Partially update channel\n     */\n    updateChannelPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass CustomCommandsApi extends BaseAPI$1 {\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createCommandRequest === null || requestParameters.createCommandRequest === undefined) {\n                throw new RequiredError$1('createCommandRequest', 'Required parameter requestParameters.createCommandRequest was null or undefined when calling createCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom chat command\n     * Create command\n     */\n    createCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom chat command\n     * Delete command\n     */\n    deleteCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns custom command by its name\n     * Get command\n     */\n    getCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommandsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all custom commands\n     * List commands\n     */\n    listCommands(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCommandsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommandRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateCommand.');\n            }\n            if (requestParameters.updateCommandRequest === null || requestParameters.updateCommandRequest === undefined) {\n                throw new RequiredError$1('updateCommandRequest', 'Required parameter requestParameters.updateCommandRequest was null or undefined when calling updateCommand.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/commands/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateCommandRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates custom chat command\n     * Update command\n     */\n    updateCommand(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCommandRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DevicesApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass EventsApi extends BaseAPI$1 {\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.sendEventRequest === null || requestParameters.sendEventRequest === undefined) {\n                throw new RequiredError$1('sendEventRequest', 'Required parameter requestParameters.sendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends event to the channel  Sends events: - any  Required permissions: - SendCustomEvent\n     * Send event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling sendUserCustomEvent.');\n            }\n            if (requestParameters.sendUserCustomEventRequest === null || requestParameters.sendUserCustomEventRequest === undefined) {\n                throw new RequiredError$1('sendUserCustomEventRequest', 'Required parameter requestParameters.sendUserCustomEventRequest was null or undefined when calling sendUserCustomEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/event`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendUserCustomEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a custom event to a user  Sends events: - custom\n     * Send user event\n     */\n    sendUserCustomEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendUserCustomEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass MessagesApi extends BaseAPI$1 {\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteFile.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded file  Required permissions: - DeleteAttachment\n     * Delete file\n     */\n    deleteFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteImage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously uploaded image  Required permissions: - DeleteAttachment\n     * Delete image\n     */\n    deleteImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteMessage.');\n            }\n            const queryParameters = {};\n            if (requestParameters.hard !== undefined) {\n                queryParameters['hard'] = requestParameters.hard;\n            }\n            if (requestParameters.deletedBy !== undefined) {\n                queryParameters['deleted_by'] = requestParameters.deletedBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes message  Sends events: - message.deleted  Required permissions: - DeleteMessage\n     * Delete message\n     */\n    deleteMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling deleteReaction.');\n            }\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deleteReaction.');\n            }\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction/{type}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes user reaction from the message  Sends events: - reaction.deleted  Required permissions: - DeleteReaction\n     * Delete reaction\n     */\n    deleteReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessagesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling getManyMessages.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getManyMessages.');\n            }\n            const queryParameters = {};\n            if (requestParameters.ids) {\n                queryParameters['ids'] = requestParameters.ids.join(',');\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/messages`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list messages found by IDs  Required permissions: - ReadChannel\n     * Get many messages\n     */\n    getManyMessages(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getManyMessagesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns message by ID  Required permissions: - ReadChannel\n     * Get message\n     */\n    getMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOGRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.url !== undefined) {\n                queryParameters['url'] = requestParameters.url;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/og`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get an OpenGraph attachment for a link\n     * Get OG\n     */\n    getOG(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOGRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getReactions.');\n            }\n            const queryParameters = {};\n            if (requestParameters.limit !== undefined) {\n                queryParameters['limit'] = requestParameters.limit;\n            }\n            if (requestParameters.offset !== undefined) {\n                queryParameters['offset'] = requestParameters.offset;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reactions`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns list of reactions of specific message  Required permissions: - ReadChannel\n     * Get reactions\n     */\n    getReactions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getReactionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getRepliesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.parentId === null || requestParameters.parentId === undefined) {\n                throw new RequiredError$1('parentId', 'Required parameter requestParameters.parentId was null or undefined when calling getReplies.');\n            }\n            const queryParameters = {};\n            if (requestParameters.idGte !== undefined) {\n                queryParameters['id_gte'] = requestParameters.idGte;\n            }\n            if (requestParameters.idGt !== undefined) {\n                queryParameters['id_gt'] = requestParameters.idGt;\n            }\n            if (requestParameters.idLte !== undefined) {\n                queryParameters['id_lte'] = requestParameters.idLte;\n            }\n            if (requestParameters.idLt !== undefined) {\n                queryParameters['id_lt'] = requestParameters.idLt;\n            }\n            if (requestParameters.createdAtAfterOrEqual !== undefined) {\n                queryParameters['created_at_after_or_equal'] = requestParameters.createdAtAfterOrEqual;\n            }\n            if (requestParameters.createdAtAfter !== undefined) {\n                queryParameters['created_at_after'] = requestParameters.createdAtAfter;\n            }\n            if (requestParameters.createdAtBeforeOrEqual !== undefined) {\n                queryParameters['created_at_before_or_equal'] = requestParameters.createdAtBeforeOrEqual;\n            }\n            if (requestParameters.createdAtBefore !== undefined) {\n                queryParameters['created_at_before'] = requestParameters.createdAtBefore;\n            }\n            if (requestParameters.idAround !== undefined) {\n                queryParameters['id_around'] = requestParameters.idAround;\n            }\n            if (requestParameters.createdAtAround !== undefined) {\n                queryParameters['created_at_around'] = requestParameters.createdAtAround;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{parent_id}/replies`.replace(`{${\"parent_id\"}}`, encodeURIComponent(String(requestParameters.parentId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns replies (thread) of the message  Required permissions: - ReadChannel\n     * Get replies\n     */\n    getReplies(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRepliesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.markChannelsReadRequest === null || requestParameters.markChannelsReadRequest === undefined) {\n                throw new RequiredError$1('markChannelsReadRequest', 'Required parameter requestParameters.markChannelsReadRequest was null or undefined when calling markChannelsRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/read`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markChannelsReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channels as read up to the specific message. If no channels is given, mark all channel as read  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark channels as read\n     */\n    markChannelsRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markChannelsReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markReadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markRead.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markRead.');\n            }\n            if (requestParameters.markReadRequest === null || requestParameters.markReadRequest === undefined) {\n                throw new RequiredError$1('markReadRequest', 'Required parameter requestParameters.markReadRequest was null or undefined when calling markRead.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/read`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markReadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as read up to the specific message  Sends events: - message.read  Required permissions: - ReadChannel\n     * Mark read\n     */\n    markRead(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markReadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnreadRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling markUnread.');\n            }\n            if (requestParameters.markUnreadRequest === null || requestParameters.markUnreadRequest === undefined) {\n                throw new RequiredError$1('markUnreadRequest', 'Required parameter requestParameters.markUnreadRequest was null or undefined when calling markUnread.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/unread`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.markUnreadRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Marks channel as unread from a specific message  Required permissions: - ReadChannel\n     * Mark unread\n     */\n    markUnread(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.markUnreadRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlagsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flags/message`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter message flags  Required permissions: - ReadMessageFlags\n     * Query Message Flags\n     */\n    queryMessageFlags(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMessageFlagsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageActionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling runMessageAction.');\n            }\n            if (requestParameters.messageActionRequest === null || requestParameters.messageActionRequest === undefined) {\n                throw new RequiredError$1('messageActionRequest', 'Required parameter requestParameters.messageActionRequest was null or undefined when calling runMessageAction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/action`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.messageActionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Executes message command action with given parameters  Sends events: - message.new  Required permissions: - RunMessageAction\n     * Run message command action\n     */\n    runMessageAction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.runMessageActionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    searchRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/search`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Search messages across channels  Required permissions: - ReadChannel\n     * Search messages\n     */\n    search(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.searchRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendMessage.');\n            }\n            if (requestParameters.sendMessageRequest === null || requestParameters.sendMessageRequest === undefined) {\n                throw new RequiredError$1('sendMessageRequest', 'Required parameter requestParameters.sendMessageRequest was null or undefined when calling sendMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/message`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends new message to the specified channel  Sends events: - message.new - message.updated  Required permissions: - AddLinks - CreateMessage - PinMessage - SkipChannelCooldown - SkipMessageModeration - UseFrozenChannel\n     * Send new message\n     */\n    sendMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReactionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling sendReaction.');\n            }\n            if (requestParameters.sendReactionRequest === null || requestParameters.sendReactionRequest === undefined) {\n                throw new RequiredError$1('sendReactionRequest', 'Required parameter requestParameters.sendReactionRequest was null or undefined when calling sendReaction.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/reaction`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.sendReactionRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends reaction to specified message  Sends events: - reaction.new - reaction.updated  Required permissions: - CreateReaction - UseFrozenChannel\n     * Send reaction\n     */\n    sendReaction(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendReactionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling translateMessage.');\n            }\n            if (requestParameters.translateMessageRequest === null || requestParameters.translateMessageRequest === undefined) {\n                throw new RequiredError$1('translateMessageRequest', 'Required parameter requestParameters.translateMessageRequest was null or undefined when calling translateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}/translate`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.translateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Translates message to a given language using automated translation software  Sends events: - message.updated  Required permissions: - ReadChannel\n     * Translate message\n     */\n    translateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.translateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessage.');\n            }\n            if (requestParameters.updateMessageRequest === null || requestParameters.updateMessageRequest === undefined) {\n                throw new RequiredError$1('updateMessageRequest', 'Required parameter requestParameters.updateMessageRequest was null or undefined when calling updateMessage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessageRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates message with new data  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Update message\n     */\n    updateMessage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling updateMessagePartial.');\n            }\n            if (requestParameters.updateMessagePartialRequest === null || requestParameters.updateMessagePartialRequest === undefined) {\n                throw new RequiredError$1('updateMessagePartialRequest', 'Required parameter requestParameters.updateMessagePartialRequest was null or undefined when calling updateMessagePartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/messages/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateMessagePartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the message  Sends events: - message.updated  Required permissions: - AddLinks - PinMessage - SkipMessageModeration - UpdateMessage\n     * Partially message update\n     */\n    updateMessagePartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateMessagePartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFileRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadFile.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadFile.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/file`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads file  Required permissions: - UploadAttachment\n     * Upload file\n     */\n    uploadFile(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadFileRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling uploadImage.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling uploadImage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const consumes = [\n                { contentType: 'multipart/form-data' },\n            ];\n            // @ts-ignore: canConsumeForm may be unused\n            canConsumeForm(consumes);\n            let formParams;\n            {\n                formParams = new URLSearchParams();\n            }\n            if (requestParameters.file !== undefined) {\n                formParams.append('file', requestParameters.file);\n            }\n            if (requestParameters.uploadSizes) {\n                formParams.append('upload_sizes', requestParameters.uploadSizes.join(COLLECTION_FORMATS[\"csv\"]));\n            }\n            if (requestParameters.user !== undefined) {\n                formParams.append('user', new Blob([JSON.stringify(requestParameters.user)], { type: \"application/json\", }));\n            }\n            const response = yield this.request({\n                path: `/channels/{type}/{id}/image`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: formParams,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Uploads image  Required permissions: - UploadAttachment\n     * Upload image\n     */\n    uploadImage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.uploadImageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PermissionsV2Api extends BaseAPI$1 {\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createRoleRequest === null || requestParameters.createRoleRequest === undefined) {\n                throw new RequiredError$1('createRoleRequest', 'Required parameter requestParameters.createRoleRequest was null or undefined when calling createRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createRoleRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates custom role\n     * Create role\n     */\n    createRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRoleRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteRole.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes custom role\n     * Delete role\n     */\n    deleteRole(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteRoleRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermissionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getPermission.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets custom permission\n     * Get permission\n     */\n    getPermission(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getPermissionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissionsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/permissions`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available permissions\n     * List permissions\n     */\n    listPermissions(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPermissionsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRolesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/roles`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available roles\n     * List roles\n     */\n    listRoles(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRolesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass PushApi extends BaseAPI$1 {\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createDeviceRequest === null || requestParameters.createDeviceRequest === undefined) {\n                throw new RequiredError$1('createDeviceRequest', 'Required parameter requestParameters.createDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createDeviceRequest,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.createDeviceRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet ServerSideApi$1 = class ServerSideApi extends BaseAPI$1 {\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.upsertPushProviderRequest === null || requestParameters.upsertPushProviderRequest === undefined) {\n                throw new RequiredError$1('upsertPushProviderRequest', 'Required parameter requestParameters.upsertPushProviderRequest was null or undefined when calling upsertPushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.upsertPushProviderRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Upsert a push provider for v2 with multi bundle/package support\n     * Upsert a push provider\n     */\n    upsertPushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.upsertPushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nlet SettingsApi$1 = class SettingsApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createBlockListRequest === null || requestParameters.createBlockListRequest === undefined) {\n                throw new RequiredError$1('createBlockListRequest', 'Required parameter requestParameters.createBlockListRequest was null or undefined when calling createBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates a new application blocklist, once created the blocklist can be used by any channel type\n     * Create block list\n     */\n    createBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.createChannelTypeRequest === null || requestParameters.createChannelTypeRequest === undefined) {\n                throw new RequiredError$1('createChannelTypeRequest', 'Required parameter requestParameters.createChannelTypeRequest was null or undefined when calling createChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.createChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates new channel type\n     * Create channel type\n     */\n    createChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes previously created application blocklist\n     * Delete block list\n     */\n    deleteBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deleteChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes channel type\n     * Delete channel type\n     */\n    deleteChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProviderRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError$1('type', 'Required parameter requestParameters.type was null or undefined when calling deletePushProvider.');\n            }\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling deletePushProvider.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers/{type}/{name}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Delete a push provider from v2 with multi bundle/package support. v1 isn\\'t supported in this endpoint\n     * Delete a push provider\n     */\n    deletePushProvider(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deletePushProviderRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getAppRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method returns the application settings\n     * Get App Settings\n     */\n    getApp(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getAppRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns block list by given name\n     * Get block list\n     */\n    getBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling getChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets channel type\n     * Get channel type\n     */\n    getChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimitsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.serverSide !== undefined) {\n                queryParameters['server_side'] = requestParameters.serverSide;\n            }\n            if (requestParameters.android !== undefined) {\n                queryParameters['android'] = requestParameters.android;\n            }\n            if (requestParameters.ios !== undefined) {\n                queryParameters['ios'] = requestParameters.ios;\n            }\n            if (requestParameters.web !== undefined) {\n                queryParameters['web'] = requestParameters.web;\n            }\n            if (requestParameters.endpoints !== undefined) {\n                queryParameters['endpoints'] = requestParameters.endpoints;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/rate_limits`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Get rate limits usage and quotas\n     * Get rate limits\n     */\n    getRateLimits(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getRateLimitsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockListsRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Returns all available block lists\n     * List block lists\n     */\n    listBlockLists(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listBlockListsRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Lists all available channel types\n     * List channel types\n     */\n    listChannelTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listChannelTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProvidersRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/push_providers`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * List details of all push providers.\n     * List push providers\n     */\n    listPushProviders(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listPushProvidersRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateAppRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateAppRequest === null || requestParameters.updateAppRequest === undefined) {\n                throw new RequiredError$1('updateAppRequest', 'Required parameter requestParameters.updateAppRequest was null or undefined when calling updateApp.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/app`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateAppRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * This method updates one or more application settings\n     * Update App Settings\n     */\n    updateApp(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateAppRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockListRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateBlockList.');\n            }\n            if (requestParameters.updateBlockListRequest === null || requestParameters.updateBlockListRequest === undefined) {\n                throw new RequiredError$1('updateBlockListRequest', 'Required parameter requestParameters.updateBlockListRequest was null or undefined when calling updateBlockList.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/blocklists/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateBlockListRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates contents of the block list\n     * Update block list\n     */\n    updateBlockList(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateBlockListRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError$1('name', 'Required parameter requestParameters.name was null or undefined when calling updateChannelType.');\n            }\n            if (requestParameters.updateChannelTypeRequest === null || requestParameters.updateChannelTypeRequest === undefined) {\n                throw new RequiredError$1('updateChannelTypeRequest', 'Required parameter requestParameters.updateChannelTypeRequest was null or undefined when calling updateChannelType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/channeltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateChannelTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates channel type\n     * Update channel type\n     */\n    updateChannelType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateChannelTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n};\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TasksApi extends BaseAPI$1 {\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTaskRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError$1('id', 'Required parameter requestParameters.id was null or undefined when calling getTask.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/tasks/{id}`.replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Gets status of a task\n     * Get status of a task\n     */\n    getTask(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getTaskRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass TestingApi extends BaseAPI$1 {\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPushRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkPushRequest === null || requestParameters.checkPushRequest === undefined) {\n                throw new RequiredError$1('checkPushRequest', 'Required parameter requestParameters.checkPushRequest was null or undefined when calling checkPush.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_push`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkPushRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Sends a test message via push, this is a test endpoint to verify your push settings\n     * Check push\n     */\n    checkPush(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkPushRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSNSRequest === null || requestParameters.checkSNSRequest === undefined) {\n                throw new RequiredError$1('checkSNSRequest', 'Required parameter requestParameters.checkSNSRequest was null or undefined when calling checkSNS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sns`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSNSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SNS configuration\n     * Check SNS\n     */\n    checkSNS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSNSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQSRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.checkSQSRequest === null || requestParameters.checkSQSRequest === undefined) {\n                throw new RequiredError$1('checkSQSRequest', 'Required parameter requestParameters.checkSQSRequest was null or undefined when calling checkSQS.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/check_sqs`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.checkSQSRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Validates Amazon SQS credentials\n     * Check SQS\n     */\n    checkSQS(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkSQSRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream Chat API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v92.7.0\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass UsersApi extends BaseAPI$1 {\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    banRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.banRequest === null || requestParameters.banRequest === undefined) {\n                throw new RequiredError$1('banRequest', 'Required parameter requestParameters.banRequest was null or undefined when calling ban.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.banRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restricts user activity either in specific channel or globally  Sends events: - user.banned  Required permissions: - BanChannelMember - BanUser\n     * Ban user\n     */\n    ban(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.banRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user  Sends events: - user.updated\n     * Connect (WebSocket)\n     */\n    connect(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.connectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.guestRequest === null || requestParameters.guestRequest === undefined) {\n                throw new RequiredError$1('guestRequest', 'Required parameter requestParameters.guestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.guestRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Creates guest user\n     * Create guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');\n            }\n            if (requestParameters.deactivateUserRequest === null || requestParameters.deactivateUserRequest === undefined) {\n                throw new RequiredError$1('deactivateUserRequest', 'Required parameter requestParameters.deactivateUserRequest was null or undefined when calling deactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/deactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivates user with possibility to activate it back  Sends events: - user.deactivated\n     * Deactivate user\n     */\n    deactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deactivateUsersRequest === null || requestParameters.deactivateUsersRequest === undefined) {\n                throw new RequiredError$1('deactivateUsersRequest', 'Required parameter requestParameters.deactivateUsersRequest was null or undefined when calling deactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/deactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deactivate users in batches  Sends events: - user.deactivated\n     * Deactivate users\n     */\n    deactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling deleteUser.');\n            }\n            const queryParameters = {};\n            if (requestParameters.markMessagesDeleted !== undefined) {\n                queryParameters['mark_messages_deleted'] = requestParameters.markMessagesDeleted;\n            }\n            if (requestParameters.hardDelete !== undefined) {\n                queryParameters['hard_delete'] = requestParameters.hardDelete;\n            }\n            if (requestParameters.deleteConversationChannels !== undefined) {\n                queryParameters['delete_conversation_channels'] = requestParameters.deleteConversationChannels;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes user and optionally all their belongings. The Endpoint is deprecated, please use \\'Delete Users\\' endpoint instead  Sends events: - channel.deleted - message.deleted - user.deleted\n     * Delete user\n     */\n    deleteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.deleteUsersRequest === null || requestParameters.deleteUsersRequest === undefined) {\n                throw new RequiredError$1('deleteUsersRequest', 'Required parameter requestParameters.deleteUsersRequest was null or undefined when calling deleteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/delete`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.deleteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Deletes users and optionally all their belongings asynchronously.  Sends events: - channel.deleted - user.deleted\n     * Delete Users\n     */\n    deleteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling exportUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/export`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports the user\\'s profile, reactions and messages. Raises an error if a user has more than 10k messages or reactions\n     * Export user\n     */\n    exportUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.exportUsersRequest === null || requestParameters.exportUsersRequest === undefined) {\n                throw new RequiredError$1('exportUsersRequest', 'Required parameter requestParameters.exportUsersRequest was null or undefined when calling exportUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/export/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.exportUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Exports user profile, reactions and messages for list of given users\n     * Export users\n     */\n    exportUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.exportUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling flag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/flag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reports message or user for review by moderators  Sends events: - message.flagged - user.flagged  Required permissions: - FlagMessage - FlagUser\n     * Flag\n     */\n    flag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.flagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPollRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.json !== undefined) {\n                queryParameters['json'] = requestParameters.json;\n            }\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/longpoll`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new VoidApiResponse$1(response);\n        });\n    }\n    /**\n     * WebSocket fallback transport endpoint  Sends events: - user.updated\n     * Long Poll (Transport)\n     */\n    longPoll(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.longPollRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.muteUserRequest === null || requestParameters.muteUserRequest === undefined) {\n                throw new RequiredError$1('muteUserRequest', 'Required parameter requestParameters.muteUserRequest was null or undefined when calling muteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/mute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.muteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Mutes one or several users  Sends events: - user.muted  Required permissions: - MuteUser\n     * Mute user\n     */\n    muteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/query_banned_users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter channel scoped or global user bans  Required permissions: - ReadChannel\n     * Query Banned Users\n     */\n    queryBannedUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryBannedUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.payload !== undefined) {\n                queryParameters['payload'] = requestParameters.payload;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Find and filter users  Required permissions: - SearchUser\n     * Query users\n     */\n    queryUsers(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.userId === null || requestParameters.userId === undefined) {\n                throw new RequiredError$1('userId', 'Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');\n            }\n            if (requestParameters.reactivateUserRequest === null || requestParameters.reactivateUserRequest === undefined) {\n                throw new RequiredError$1('reactivateUserRequest', 'Required parameter requestParameters.reactivateUserRequest was null or undefined when calling reactivateUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/{user_id}/reactivate`.replace(`{${\"user_id\"}}`, encodeURIComponent(String(requestParameters.userId))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Activates user who\\'s been deactivated previously  Sends events: - user.reactivated\n     * Reactivate user\n     */\n    reactivateUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.reactivateUsersRequest === null || requestParameters.reactivateUsersRequest === undefined) {\n                throw new RequiredError$1('reactivateUsersRequest', 'Required parameter requestParameters.reactivateUsersRequest was null or undefined when calling reactivateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/reactivate`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.reactivateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Reactivate users in batches  Sends events: - user.reactivated\n     * Reactivate users\n     */\n    reactivateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.reactivateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.restoreUsersRequest === null || requestParameters.restoreUsersRequest === undefined) {\n                throw new RequiredError$1('restoreUsersRequest', 'Required parameter requestParameters.restoreUsersRequest was null or undefined when calling restoreUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users/restore`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.restoreUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Restore soft deleted users\n     * Restore users\n     */\n    restoreUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.restoreUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unbanRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.targetUserId !== undefined) {\n                queryParameters['target_user_id'] = requestParameters.targetUserId;\n            }\n            if (requestParameters.type !== undefined) {\n                queryParameters['type'] = requestParameters.type;\n            }\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.createdBy !== undefined) {\n                queryParameters['created_by'] = requestParameters.createdBy;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/ban`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously applied ban  Sends events: - user.unbanned  Required permissions: - BanChannelMember - BanUser\n     * Unban user\n     */\n    unban(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unbanRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflagRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.flagRequest === null || requestParameters.flagRequest === undefined) {\n                throw new RequiredError$1('flagRequest', 'Required parameter requestParameters.flagRequest was null or undefined when calling unflag.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unflag`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.flagRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Removes previously created user or message flag  Required permissions: - FlagMessage - FlagUser\n     * Unflag\n     */\n    unflag(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unflagRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.unmuteUserRequest === null || requestParameters.unmuteUserRequest === undefined) {\n                throw new RequiredError$1('unmuteUserRequest', 'Required parameter requestParameters.unmuteUserRequest was null or undefined when calling unmuteUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/moderation/unmute`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.unmuteUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Unmutes previously muted user  Sends events: - user.unmuted  Required permissions: - MuteUser\n     * Unmute user\n     */\n    unmuteUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unmuteUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUsersRequest === null || requestParameters.updateUsersRequest === undefined) {\n                throw new RequiredError$1('updateUsersRequest', 'Required parameter requestParameters.updateUsersRequest was null or undefined when calling updateUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Update or create users in bulk  Sends events: - user.updated\n     * Upsert users\n     */\n    updateUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartialRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.updateUserPartialRequest === null || requestParameters.updateUserPartialRequest === undefined) {\n                throw new RequiredError$1('updateUserPartialRequest', 'Required parameter requestParameters.updateUserPartialRequest was null or undefined when calling updateUsersPartial.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/users`,\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.updateUserPartialRequest,\n            }, initOverrides);\n            return new JSONApiResponse$1(response);\n        });\n    }\n    /**\n     * Updates certain fields of the user  Sends events: - user.presence.changed - user.updated\n     * Partially update user\n     */\n    updateUsersPartial(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUsersPartialRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamChannel {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.delete = (request) => {\n            return this.channelsApi.deleteChannel(Object.assign(Object.assign({}, this.baseRequest), (request !== null && request !== void 0 ? request : {})));\n        };\n        this.update = (updateChannelRequest) => {\n            return this.channelsApi.updateChannel(Object.assign(Object.assign({}, this.baseRequest), { updateChannelRequest }));\n        };\n        this.updatePartial = (updateChannelPartialRequest) => {\n            return this.channelsApi.updateChannelPartial(Object.assign(Object.assign({}, this.baseRequest), { updateChannelPartialRequest }));\n        };\n        this.getOrCreate = (channelGetOrCreateRequest) => __awaiter(this, void 0, void 0, function* () {\n            if (this.id) {\n                return yield this.channelsApi.getOrCreateChannel(Object.assign(Object.assign({}, this.baseRequest), { channelGetOrCreateRequest: channelGetOrCreateRequest !== null && channelGetOrCreateRequest !== void 0 ? channelGetOrCreateRequest : {} }));\n            }\n            else {\n                throw new Error(`This operation isn't yet implemented`);\n                // if (!channelGetOrCreateRequest?.data?.members) {\n                //   throw new Error('You need to provide members to create a channel without ID');\n                // }\n                // const response = await this.channelsApi.getOrCreateChannelType1({type: this.type, channelGetOrCreateRequest});\n                // this.id = response.channel?.id;\n                // return response;\n            }\n        });\n        this.markRead = (markReadRequest) => {\n            return this.channelsApi.markRead(Object.assign(Object.assign({}, this.baseRequest), { markReadRequest }));\n        };\n        this.markUnread = (markUnreadRequest) => {\n            return this.channelsApi.markUnread(Object.assign(Object.assign({}, this.baseRequest), { markUnreadRequest }));\n        };\n        this.show = (showChannelRequest) => {\n            return this.channelsApi.showChannel(Object.assign(Object.assign({}, this.baseRequest), { showChannelRequest }));\n        };\n        this.hide = (hideChannelRequest) => {\n            return this.channelsApi.hideChannel(Object.assign(Object.assign({}, this.baseRequest), { hideChannelRequest }));\n        };\n        this.truncate = (truncateChannelRequest) => {\n            return this.channelsApi.truncateChannel(Object.assign(Object.assign({}, this.baseRequest), { truncateChannelRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.channelsApi.queryMembers({\n                payload: Object.assign(Object.assign({}, this.baseRequest), request),\n            });\n        };\n        this.mute = (muteChannelRequest) => {\n            return this.channelsApi.muteChannel({\n                muteChannelRequest: Object.assign(Object.assign({}, muteChannelRequest), { channel_cids: [this.cid] }),\n            });\n        };\n        this.unmute = (unmuteChannelRequest) => {\n            return this.channelsApi.unmuteChannel({\n                unmuteChannelRequest: Object.assign(Object.assign({}, unmuteChannelRequest), { channel_cid: this.cid, channel_cids: [] }),\n            });\n        };\n        // TODO: there is probably an issue with the generated code here\n        // uploadFile = (options: Omit<OmitTypeId<UploadFileRequest>, 'file'>, file: Buffer) => {\n        //   return this.messagesApi.uploadFile({...options, ...this.baseRequest, file: file as any as string});\n        // }\n        // deleteFile = (request: OmitTypeId<DeleteFileRequest>) => {\n        //   return this.messagesApi.deleteFile({...request, ...this.baseRequest});\n        // }\n        // uploadImage = (request: OmitTypeId<UploadImageRequest>) => {\n        //   return this.messagesApi.uploadImage({...request, ...this.baseRequest});\n        // }\n        // deleteImage = (request: OmitTypeId<DeleteImageRequest>) => {\n        //   return this.messagesApi.deleteImage({...request, ...this.baseRequest});\n        // }\n        this.sendMessage = (sendMessageRequest) => {\n            return this.messagesApi.sendMessage(Object.assign(Object.assign({}, this.baseRequest), { sendMessageRequest }));\n        };\n        this.deleteMessage = (request) => {\n            return this.messagesApi.deleteMessage(request);\n        };\n        this.updateMessage = (id, updateMessageRequest) => {\n            return this.messagesApi.updateMessage({ id, updateMessageRequest });\n        };\n        this.updateMessagePartial = (id, updateMessagePartialRequest) => {\n            return this.messagesApi.updateMessagePartial({\n                id,\n                updateMessagePartialRequest,\n            });\n        };\n        this.getMessage = (request) => {\n            return this.messagesApi.getMessage(request);\n        };\n        this.getManyMessages = (request) => {\n            return this.messagesApi.getManyMessages(Object.assign(Object.assign({}, request), this.baseRequest));\n        };\n        this.translateMessage = (id, translateMessageRequest) => {\n            return this.messagesApi.translateMessage({ id, translateMessageRequest });\n        };\n        this.getMessagesAround = (request) => {\n            return this.messagesApi.getReplies(request);\n        };\n        this.getOpenGraphData = (request) => {\n            return this.messagesApi.getOG(request);\n        };\n        this.sendMessageReaction = (messageId, sendReactionRequest) => {\n            return this.messagesApi.sendReaction({\n                id: messageId,\n                sendReactionRequest,\n            });\n        };\n        this.deleteMessageReaction = (messageId, request) => {\n            return this.messagesApi.deleteReaction(Object.assign(Object.assign({}, request), { id: messageId }));\n        };\n        this.getMessageReactions = (messageId, request) => {\n            return this.messagesApi.getReactions(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), { id: messageId }));\n        };\n        this.sendCustomEvent = (event) => {\n            return this.eventsApi.sendEvent(Object.assign(Object.assign({}, this.baseRequest), { sendEventRequest: { event } }));\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.messagesApi = new MessagesApi(configuration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(configuration);\n    }\n    get cid() {\n        return `${this.baseRequest.type}:${this.baseRequest.id}`;\n    }\n    get baseRequest() {\n        if (!this.id) {\n            throw new Error('You need to initialize the channel with `getOrCreate`');\n        }\n        return {\n            id: this.id,\n            type: this.type,\n        };\n    }\n}\n\nclass StreamChatClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.channel = (type, id) => {\n            return new StreamChannel(this.streamClient, type, id);\n        };\n        this.createBlockList = (createBlockListRequest) => {\n            return this.settingsApi.createBlockList({ createBlockListRequest });\n        };\n        this.listBlockLists = () => {\n            return this.settingsApi.listBlockLists();\n        };\n        this.getBlockList = (request) => {\n            return this.settingsApi.getBlockList(request);\n        };\n        this.updateBlockList = (name, updateBlockListRequest) => {\n            return this.settingsApi.updateBlockList({ name, updateBlockListRequest });\n        };\n        this.deleteBlockList = (request) => {\n            return this.settingsApi.deleteBlockList(request);\n        };\n        this.createChannelType = (createChannelTypeRequest) => {\n            return this.channelTypesApi.createChannelType({ createChannelTypeRequest });\n        };\n        this.deleteChannelType = (request) => {\n            return this.channelTypesApi.deleteChannelType(request);\n        };\n        this.getChannelType = (request) => {\n            return this.channelTypesApi.getChannelType(request);\n        };\n        this.listChannelTypes = () => {\n            return this.channelTypesApi.listChannelTypes();\n        };\n        this.updateChannelType = (name, updateChannelTypeRequest) => {\n            return this.channelTypesApi.updateChannelType({\n                name,\n                updateChannelTypeRequest,\n            });\n        };\n        this.queryChannels = (queryChannelsRequest) => {\n            return this.channelsApi.queryChannels({\n                queryChannelsRequest: queryChannelsRequest !== null && queryChannelsRequest !== void 0 ? queryChannelsRequest : null,\n            });\n        };\n        this.searchMessages = (payload) => {\n            return this.channelsApi.search({ payload });\n        };\n        this.exportChannels = (exportChannelsRequest) => {\n            return this.channelsApi.exportChannels({\n                exportChannelsRequest: exportChannelsRequest !== null && exportChannelsRequest !== void 0 ? exportChannelsRequest : null,\n            });\n        };\n        this.getExportStatus = (request) => {\n            return this.channelsApi.getExportChannelsStatus(request);\n        };\n        this.listCommands = () => {\n            return this.commandsApi.listCommands();\n        };\n        this.createCommand = (createCommandRequest) => {\n            return this.commandsApi.createCommand({ createCommandRequest });\n        };\n        this.getCommand = (getCommandRequest) => {\n            return this.commandsApi.getCommand(getCommandRequest);\n        };\n        this.updateCommand = (name, updateCommandRequest) => {\n            return this.commandsApi.updateCommand({ name, updateCommandRequest });\n        };\n        this.deleteCommand = (request) => {\n            return this.commandsApi.deleteCommand(request);\n        };\n        const configuration = this.streamClient.getConfiguration();\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(configuration);\n        /** @ts-expect-error */\n        this.channelTypesApi = new ChannelTypesApi(configuration);\n        /** @ts-expect-error */\n        this.channelsApi = new ChannelsApi(configuration);\n        /** @ts-expect-error */\n        this.commandsApi = new CustomCommandsApi(configuration);\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nconst BASE_PATH = \"https://stream-io-api.com\".replace(/\\/+$/, \"\");\nclass Configuration {\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n    }\n    set config(configuration) {\n        this.configuration = configuration;\n    }\n    get basePath() {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;\n    }\n    get fetchApi() {\n        return this.configuration.fetchApi;\n    }\n    get middleware() {\n        return this.configuration.middleware || [];\n    }\n    get queryParamsStringify() {\n        return this.configuration.queryParamsStringify || querystring;\n    }\n    get username() {\n        return this.configuration.username;\n    }\n    get password() {\n        return this.configuration.password;\n    }\n    get apiKey() {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n    get accessToken() {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : () => __awaiter(this, void 0, void 0, function* () { return accessToken; });\n        }\n        return undefined;\n    }\n    get headers() {\n        return this.configuration.headers;\n    }\n    get credentials() {\n        return this.configuration.credentials;\n    }\n}\nconst DefaultConfig = new Configuration();\n/**\n * This is the base class for all generated API classes.\n */\nclass BaseAPI {\n    constructor(configuration = DefaultConfig) {\n        this.configuration = configuration;\n        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {\n            let fetchParams = { url, init };\n            for (const middleware of this.middleware) {\n                if (middleware.pre) {\n                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;\n                }\n            }\n            let response = undefined;\n            try {\n                response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n            }\n            catch (e) {\n                for (const middleware of this.middleware) {\n                    if (middleware.onError) {\n                        response = (yield middleware.onError({\n                            fetch: this.fetchApi,\n                            url: fetchParams.url,\n                            init: fetchParams.init,\n                            error: e,\n                            response: response ? response.clone() : undefined,\n                        })) || response;\n                    }\n                }\n                if (response === undefined) {\n                    if (e instanceof Error) {\n                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            for (const middleware of this.middleware) {\n                if (middleware.post) {\n                    response = (yield middleware.post({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        response: response.clone(),\n                    })) || response;\n                }\n            }\n            return response;\n        });\n        this.middleware = configuration.middleware;\n    }\n    withMiddleware(...middlewares) {\n        const next = this.clone();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n    withPreMiddleware(...preMiddlewares) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware(...middlewares);\n    }\n    withPostMiddleware(...postMiddlewares) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware(...middlewares);\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        if (!mime) {\n            return false;\n        }\n        return BaseAPI.jsonRegex.test(mime);\n    }\n    request(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { url, init } = yield this.createFetchParams(context, initOverrides);\n            const response = yield this.fetchApi(url, init);\n            if (response && (response.status >= 200 && response.status < 300)) {\n                return response;\n            }\n            throw new ResponseError(response, 'Response returned an error code');\n        });\n    }\n    createFetchParams(context, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let url = this.configuration.basePath + context.path;\n            if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n                // only add the querystring to the URL if there are query parameters.\n                // this is done to avoid urls ending with a \"?\" character which buggy webservers\n                // do not handle correctly sometimes.\n                url += '?' + this.configuration.queryParamsStringify(context.query);\n            }\n            const headers = Object.assign({}, this.configuration.headers, context.headers);\n            Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n            const initOverrideFn = typeof initOverrides === \"function\"\n                ? initOverrides\n                : () => __awaiter(this, void 0, void 0, function* () { return initOverrides; });\n            const initParams = {\n                method: context.method,\n                headers,\n                body: context.body,\n                credentials: this.configuration.credentials,\n            };\n            const overriddenInit = Object.assign(Object.assign({}, initParams), (yield initOverrideFn({\n                init: initParams,\n                context,\n            })));\n            const init = Object.assign(Object.assign({}, overriddenInit), { body: isFormData(overriddenInit.body) ||\n                    overriddenInit.body instanceof URLSearchParams ||\n                    isBlob(overriddenInit.body)\n                    ? overriddenInit.body\n                    : JSON.stringify(overriddenInit.body) });\n            return { url, init };\n        });\n    }\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    clone() {\n        const constructor = this.constructor;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n}\nBaseAPI.jsonRegex = new RegExp('^(:?application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(:?;.*)?$', 'i');\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\nfunction isFormData(value) {\n    return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nclass ResponseError extends Error {\n    constructor(response, msg) {\n        super(msg);\n        this.response = response;\n        this.name = \"ResponseError\";\n    }\n}\nclass FetchError extends Error {\n    constructor(cause, msg) {\n        super(msg);\n        this.cause = cause;\n        this.name = \"FetchError\";\n    }\n}\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nfunction querystring(params, prefix = '') {\n    return Object.keys(params)\n        .map(key => querystringSingleKey(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\nfunction querystringSingleKey(key, value, keyPrefix = '') {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring(value, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\nclass JSONApiResponse {\n    constructor(raw, transformer = (jsonValue) => jsonValue) {\n        this.raw = raw;\n        this.transformer = transformer;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.transformer(yield this.raw.json());\n        });\n    }\n}\nclass VoidApiResponse {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    value() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return undefined;\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass DefaultApi extends BaseAPI {\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling blockUser.');\n            }\n            if (requestParameters.videoBlockUserRequest === null || requestParameters.videoBlockUserRequest === undefined) {\n                throw new RequiredError('videoBlockUserRequest', 'Required parameter requestParameters.videoBlockUserRequest was null or undefined when calling blockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/block`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoBlockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Block a user, preventing them from joining the call until they are unblocked.  Sends events: - call.blocked_user  Required permissions: - BlockUser\n     * Block user on a call\n     */\n    blockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.blockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateDeviceRequest === null || requestParameters.videoCreateDeviceRequest === undefined) {\n                throw new RequiredError('videoCreateDeviceRequest', 'Required parameter requestParameters.videoCreateDeviceRequest was null or undefined when calling createDevice.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateDeviceRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Adds a new device to a user, if the same device already exists the call will have no effect\n     * Create device\n     */\n    createDevice(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuestRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateGuestRequest === null || requestParameters.videoCreateGuestRequest === undefined) {\n                throw new RequiredError('videoCreateGuestRequest', 'Required parameter requestParameters.videoCreateGuestRequest was null or undefined when calling createGuest.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/guest`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateGuestRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Guest\n     */\n    createGuest(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createGuestRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDeviceRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.id !== undefined) {\n                queryParameters['id'] = requestParameters.id;\n            }\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes one device\n     * Delete device\n     */\n    deleteDevice(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteDeviceRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling endCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling endCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mark_ended`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.ended  Required permissions: - EndCall\n     * End call\n     */\n    endCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.endCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            if (requestParameters.membersLimit !== undefined) {\n                queryParameters['members_limit'] = requestParameters.membersLimit;\n            }\n            if (requestParameters.ring !== undefined) {\n                queryParameters['ring'] = requestParameters.ring;\n            }\n            if (requestParameters.notify !== undefined) {\n                queryParameters['notify'] = requestParameters.notify;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Required permissions: - ReadCall\n     * Get Call\n     */\n    getCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdgesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/edges`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns the list of all edges available for video calls.\n     * Get Edges\n     */\n    getEdges(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getEdgesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling getOrCreateCall.');\n            }\n            if (requestParameters.videoGetOrCreateCallRequest === null || requestParameters.videoGetOrCreateCallRequest === undefined) {\n                throw new RequiredError('videoGetOrCreateCallRequest', 'Required parameter requestParameters.videoGetOrCreateCallRequest was null or undefined when calling getOrCreateCall.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGetOrCreateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Gets or creates a new call  Sends events: - call.created - call.notification - call.ring  Required permissions: - CreateCall - ReadCall - UpdateCallSettings\n     * Get or create a call\n     */\n    getOrCreateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getOrCreateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling goLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling goLive.');\n            }\n            if (requestParameters.videoGoLiveRequest === null || requestParameters.videoGoLiveRequest === undefined) {\n                throw new RequiredError('videoGoLiveRequest', 'Required parameter requestParameters.videoGoLiveRequest was null or undefined when calling goLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/go_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoGoLiveRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.live_started  Required permissions: - UpdateCall\n     * Set call as live\n     */\n    goLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.goLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevicesRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            if (requestParameters.userId !== undefined) {\n                queryParameters['user_id'] = requestParameters.userId;\n            }\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/devices`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Returns all available devices\n     * List devices\n     */\n    listDevices(requestParameters = {}, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listDevicesRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordingsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listRecordings.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listRecordings.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/recordings`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists recordings  Required permissions: - ListRecordings\n     * List recordings\n     */\n    listRecordings(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listRecordingsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling listTranscriptions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling listTranscriptions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/transcriptions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists transcriptions  Required permissions: - ListTranscriptions\n     * List transcriptions\n     */\n    listTranscriptions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listTranscriptionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling muteUsers.');\n            }\n            if (requestParameters.videoMuteUsersRequest === null || requestParameters.videoMuteUsersRequest === undefined) {\n                throw new RequiredError('videoMuteUsersRequest', 'Required parameter requestParameters.videoMuteUsersRequest was null or undefined when calling muteUsers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/mute_users`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoMuteUsersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Mutes users in a call  Required permissions: - MuteUsers\n     * Mute users\n     */\n    muteUsers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.muteUsersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCallsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryCallsRequest === null || requestParameters.videoQueryCallsRequest === undefined) {\n                throw new RequiredError('videoQueryCallsRequest', 'Required parameter requestParameters.videoQueryCallsRequest was null or undefined when calling queryCalls.');\n            }\n            const queryParameters = {};\n            if (requestParameters.connectionId !== undefined) {\n                queryParameters['connection_id'] = requestParameters.connectionId;\n            }\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calls`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryCallsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query calls with filter query  Required permissions: - ReadCall\n     * Query call\n     */\n    queryCalls(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryCallsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoQueryMembersRequest === null || requestParameters.videoQueryMembersRequest === undefined) {\n                throw new RequiredError('videoQueryMembersRequest', 'Required parameter requestParameters.videoQueryMembersRequest was null or undefined when calling queryMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/members`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoQueryMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Query call members with filter query  Required permissions: - ReadCall\n     * Query call members\n     */\n    queryMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.queryMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEventRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling sendEvent.');\n            }\n            if (requestParameters.videoSendEventRequest === null || requestParameters.videoSendEventRequest === undefined) {\n                throw new RequiredError('videoSendEventRequest', 'Required parameter requestParameters.videoSendEventRequest was null or undefined when calling sendEvent.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/event`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoSendEventRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Sends custom event to the call  Sends events: - custom  Required permissions: - SendEvent\n     * Send custom event\n     */\n    sendEvent(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.sendEventRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts HLS broadcasting  Required permissions: - StartBroadcasting\n     * Start HLS broadcasting\n     */\n    startHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startRecording.');\n            }\n            if (requestParameters.videoStartRecordingRequest === null || requestParameters.videoStartRecordingRequest === undefined) {\n                throw new RequiredError('videoStartRecordingRequest', 'Required parameter requestParameters.videoStartRecordingRequest was null or undefined when calling startRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartRecordingRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts recording  Sends events: - call.recording_started  Required permissions: - StartRecording\n     * Start recording\n     */\n    startRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling startTranscription.');\n            }\n            if (requestParameters.videoStartTranscriptionRequest === null || requestParameters.videoStartTranscriptionRequest === undefined) {\n                throw new RequiredError('videoStartTranscriptionRequest', 'Required parameter requestParameters.videoStartTranscriptionRequest was null or undefined when calling startTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/start_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoStartTranscriptionRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Starts transcription  Required permissions: - StartTranscription\n     * Start transcription\n     */\n    startTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.startTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcastingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopHLSBroadcasting.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopHLSBroadcasting.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_broadcasting`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops HLS broadcasting  Required permissions: - StopBroadcasting\n     * Stop HLS broadcasting\n     */\n    stopHLSBroadcasting(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopHLSBroadcastingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLiveRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopLive.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopLive.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_live`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Set call as not live\n     */\n    stopLive(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopLiveRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecordingRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopRecording.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopRecording.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_recording`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops recording  Sends events: - call.recording_stopped  Required permissions: - StopRecording\n     * Stop recording\n     */\n    stopRecording(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopRecordingRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscriptionRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling stopTranscription.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling stopTranscription.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/stop_transcription`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Stops transcription  Sends events: - call.transcription_stopped  Required permissions: - StopTranscription\n     * Stop transcription\n     */\n    stopTranscription(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.stopTranscriptionRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUserRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling unblockUser.');\n            }\n            if (requestParameters.videoUnblockUserRequest === null || requestParameters.videoUnblockUserRequest === undefined) {\n                throw new RequiredError('videoUnblockUserRequest', 'Required parameter requestParameters.videoUnblockUserRequest was null or undefined when calling unblockUser.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unblock`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnblockUserRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Removes the block for a user on a call. The user will be able to join the call again.  Sends events: - call.unblocked_user  Required permissions: - BlockUser\n     * Unblocks user on a call\n     */\n    unblockUser(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.unblockUserRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCallRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCall.');\n            }\n            if (requestParameters.videoUpdateCallRequest === null || requestParameters.videoUpdateCallRequest === undefined) {\n                throw new RequiredError('videoUpdateCallRequest', 'Required parameter requestParameters.videoUpdateCallRequest was null or undefined when calling updateCall.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'PATCH',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.updated  Required permissions: - UpdateCall\n     * Update Call\n     */\n    updateCall(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembersRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateCallMembers.');\n            }\n            if (requestParameters.videoUpdateCallMembersRequest === null || requestParameters.videoUpdateCallMembersRequest === undefined) {\n                throw new RequiredError('videoUpdateCallMembersRequest', 'Required parameter requestParameters.videoUpdateCallMembersRequest was null or undefined when calling updateCallMembers.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/members`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallMembersRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *   Sends events: - call.member_added - call.member_removed - call.member_updated  Required permissions: - RemoveCallMember - UpdateCallMember - UpdateCallMemberRole\n     * Update Call Member\n     */\n    updateCallMembers(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallMembersRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissionsRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling updateUserPermissions.');\n            }\n            if (requestParameters.videoUpdateUserPermissionsRequest === null || requestParameters.videoUpdateUserPermissionsRequest === undefined) {\n                throw new RequiredError('videoUpdateUserPermissionsRequest', 'Required parameter requestParameters.videoUpdateUserPermissionsRequest was null or undefined when calling updateUserPermissions.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/user_permissions`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateUserPermissionsRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Updates user permissions  Sends events: - call.permissions_updated  Required permissions: - UpdateCallPermissions\n     * Update user permissions\n     */\n    updateUserPermissions(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateUserPermissionsRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnectRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoWSAuthMessageRequest === null || requestParameters.videoWSAuthMessageRequest === undefined) {\n                throw new RequiredError('videoWSAuthMessageRequest', 'Required parameter requestParameters.videoWSAuthMessageRequest was null or undefined when calling videoConnect.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/connect`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoWSAuthMessageRequest,\n            }, initOverrides);\n            return new VoidApiResponse(response);\n        });\n    }\n    /**\n     * Establishes WebSocket connection for user to video  Sends events: - connection.ok - health.check\n     * Video Connect (WebSocket)\n     */\n    videoConnect(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.videoConnectRaw(requestParameters, initOverrides);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoPin.');\n            }\n            if (requestParameters.videoPinRequest === null || requestParameters.videoPinRequest === undefined) {\n                throw new RequiredError('videoPinRequest', 'Required parameter requestParameters.videoPinRequest was null or undefined when calling videoPin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/pin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoPinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Pins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Pin\n     */\n    videoPin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoPinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpinRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.type === null || requestParameters.type === undefined) {\n                throw new RequiredError('type', 'Required parameter requestParameters.type was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.id === null || requestParameters.id === undefined) {\n                throw new RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling videoUnpin.');\n            }\n            if (requestParameters.videoUnpinRequest === null || requestParameters.videoUnpinRequest === undefined) {\n                throw new RequiredError('videoUnpinRequest', 'Required parameter requestParameters.videoUnpinRequest was null or undefined when calling videoUnpin.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/call/{type}/{id}/unpin`.replace(`{${\"type\"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${\"id\"}}`, encodeURIComponent(String(requestParameters.id))),\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUnpinRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Unpins a track for all users in the call.  Required permissions: - PinCallTrack\n     * Unpin\n     */\n    videoUnpin(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.videoUnpinRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass ServerSideApi extends BaseAPI {\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling checkExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}/check`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Check External Storage\n     */\n    checkExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.checkExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateCallTypeRequest === null || requestParameters.videoCreateCallTypeRequest === undefined) {\n                throw new RequiredError('videoCreateCallTypeRequest', 'Required parameter requestParameters.videoCreateCallTypeRequest was null or undefined when calling createCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Create Call Type\n     */\n    createCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Delete Call Type\n     */\n    deleteCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling getCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Get Call Type\n     */\n    getCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.getCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypesRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * List Call Type\n     */\n    listCallTypes(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listCallTypesRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallTypeRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateCallType.');\n            }\n            if (requestParameters.videoUpdateCallTypeRequest === null || requestParameters.videoUpdateCallTypeRequest === undefined) {\n                throw new RequiredError('videoUpdateCallTypeRequest', 'Required parameter requestParameters.videoUpdateCallTypeRequest was null or undefined when calling updateCallType.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/calltypes/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateCallTypeRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update Call Type\n     */\n    updateCallType(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateCallTypeRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling updateExternalStorage.');\n            }\n            if (requestParameters.videoUpdateExternalStorageRequest === null || requestParameters.videoUpdateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoUpdateExternalStorageRequest', 'Required parameter requestParameters.videoUpdateExternalStorageRequest was null or undefined when calling updateExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'PUT',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoUpdateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     *\n     * Update External Storage\n     */\n    updateExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.updateExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Stream API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: v100.4.3\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/**\n *\n */\nclass SettingsApi extends BaseAPI {\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.videoCreateExternalStorageRequest === null || requestParameters.videoCreateExternalStorageRequest === undefined) {\n                throw new RequiredError('videoCreateExternalStorageRequest', 'Required parameter requestParameters.videoCreateExternalStorageRequest was null or undefined when calling createExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            headerParameters['Content-Type'] = 'application/json';\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'POST',\n                headers: headerParameters,\n                query: queryParameters,\n                body: requestParameters.videoCreateExternalStorageRequest,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Creates new external storage\n     * Create external storage\n     */\n    createExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.createExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorageRaw(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (requestParameters.name === null || requestParameters.name === undefined) {\n                throw new RequiredError('name', 'Required parameter requestParameters.name was null or undefined when calling deleteExternalStorage.');\n            }\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage/{name}`.replace(`{${\"name\"}}`, encodeURIComponent(String(requestParameters.name))),\n                method: 'DELETE',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Deletes external storage\n     * Delete external storage\n     */\n    deleteExternalStorage(requestParameters, initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.deleteExternalStorageRaw(requestParameters, initOverrides);\n            return yield response.value();\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorageRaw(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const queryParameters = {};\n            const headerParameters = {};\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Stream-Auth-Type\"] = this.configuration.apiKey(\"Stream-Auth-Type\"); // stream-auth-type authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                queryParameters[\"api_key\"] = this.configuration.apiKey(\"api_key\"); // api_key authentication\n            }\n            if (this.configuration && this.configuration.apiKey) {\n                headerParameters[\"Authorization\"] = this.configuration.apiKey(\"Authorization\"); // JWT authentication\n            }\n            const response = yield this.request({\n                path: `/video/external_storage`,\n                method: 'GET',\n                headers: headerParameters,\n                query: queryParameters,\n            }, initOverrides);\n            return new JSONApiResponse(response);\n        });\n    }\n    /**\n     * Lists external storage\n     * List external storage\n     */\n    listExternalStorage(initOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.listExternalStorageRaw(initOverrides);\n            return yield response.value();\n        });\n    }\n}\n\nclass StreamCall {\n    constructor(streamClient, type, id) {\n        this.streamClient = streamClient;\n        this.type = type;\n        this.id = id;\n        this.blockUser = (videoBlockUserRequest) => {\n            return this.apiClient.blockUser(Object.assign(Object.assign({}, this.baseRequest), { videoBlockUserRequest }));\n        };\n        this.endCall = () => {\n            return this.apiClient.endCall(Object.assign({}, this.baseRequest));\n        };\n        this.get = (request) => {\n            return this.apiClient.getCall(Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest));\n        };\n        this.getOrCreate = (videoGetOrCreateCallRequest) => {\n            return this.apiClient.getOrCreateCall(Object.assign(Object.assign({}, this.baseRequest), { videoGetOrCreateCallRequest: videoGetOrCreateCallRequest !== null && videoGetOrCreateCallRequest !== void 0 ? videoGetOrCreateCallRequest : {} }));\n        };\n        this.create = (getOrCreateCallRequest) => {\n            return this.getOrCreate(getOrCreateCallRequest);\n        };\n        this.goLive = (videoGoLiveRequest) => {\n            return this.apiClient.goLive(Object.assign(Object.assign({}, this.baseRequest), { videoGoLiveRequest: videoGoLiveRequest !== null && videoGoLiveRequest !== void 0 ? videoGoLiveRequest : {} }));\n        };\n        this.listRecordings = () => {\n            return this.apiClient.listRecordings(Object.assign({}, this.baseRequest));\n        };\n        this.muteUsers = (videoMuteUsersRequest) => {\n            return this.apiClient.muteUsers(Object.assign(Object.assign({}, this.baseRequest), { videoMuteUsersRequest }));\n        };\n        this.queryMembers = (request) => {\n            return this.apiClient.queryMembers({\n                videoQueryMembersRequest: Object.assign(Object.assign({}, (request !== null && request !== void 0 ? request : {})), this.baseRequest),\n            });\n        };\n        this.sendCustomEvent = (event) => {\n            return this.apiClient.sendEvent(Object.assign({ videoSendEventRequest: { custom: event } }, this.baseRequest));\n        };\n        this.startHLSBroadcasting = () => {\n            return this.apiClient.startHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.startRecording = (request) => {\n            return this.apiClient.startRecording(Object.assign(Object.assign({}, this.baseRequest), { videoStartRecordingRequest: request !== null && request !== void 0 ? request : {} }));\n        };\n        this.startTranscription = (videoStartTranscriptionRequest = {}) => {\n            return this.apiClient.startTranscription(Object.assign(Object.assign({}, this.baseRequest), { videoStartTranscriptionRequest }));\n        };\n        this.stopHLSBroadcasting = () => {\n            return this.apiClient.stopHLSBroadcasting(Object.assign({}, this.baseRequest));\n        };\n        this.stopLive = () => {\n            return this.apiClient.stopLive(Object.assign({}, this.baseRequest));\n        };\n        this.stopRecording = () => {\n            return this.apiClient.stopRecording(Object.assign({}, this.baseRequest));\n        };\n        this.stopTranscription = () => {\n            return this.apiClient.stopTranscription(Object.assign({}, this.baseRequest));\n        };\n        this.unblockUser = (videoUnblockUserRequest) => {\n            return this.apiClient.unblockUser(Object.assign({ videoUnblockUserRequest }, this.baseRequest));\n        };\n        this.update = (videoUpdateCallRequest) => {\n            return this.apiClient.updateCall(Object.assign({ videoUpdateCallRequest }, this.baseRequest));\n        };\n        this.updateCallMembers = (videoUpdateCallMembersRequest) => {\n            return this.apiClient.updateCallMembers(Object.assign({ videoUpdateCallMembersRequest }, this.baseRequest));\n        };\n        this.updateUserPermissions = (videoUpdateUserPermissionsRequest) => {\n            return this.apiClient.updateUserPermissions(Object.assign({ videoUpdateUserPermissionsRequest }, this.baseRequest));\n        };\n        this.pinVideo = (videoPinRequest) => {\n            return this.apiClient.videoPin(Object.assign({ videoPinRequest }, this.baseRequest));\n        };\n        this.unpinVideo = (videoUnpinRequest) => {\n            return this.apiClient.videoUnpin(Object.assign({ videoUnpinRequest }, this.baseRequest));\n        };\n        this.baseRequest = { id: this.id, type: this.type };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n    }\n}\n\nclass StreamVideoClient {\n    constructor(streamClient) {\n        this.streamClient = streamClient;\n        this.call = (type, id) => {\n            return new StreamCall(this.streamClient, type, id);\n        };\n        this.queryCalls = (request) => {\n            return this.apiClient.queryCalls({\n                videoQueryCallsRequest: request !== null && request !== void 0 ? request : {},\n            });\n        };\n        this.createCallType = (videoCreateCallTypeRequest) => {\n            return this.videoServerSideApiClient.createCallType({\n                videoCreateCallTypeRequest,\n            });\n        };\n        this.deleteCallType = (request) => {\n            return this.videoServerSideApiClient.deleteCallType(request);\n        };\n        this.getCallType = (request) => {\n            return this.videoServerSideApiClient.getCallType(request);\n        };\n        this.listCallTypes = () => {\n            return this.videoServerSideApiClient.listCallTypes();\n        };\n        this.updateCallType = (name, videoUpdateCallTypeRequest) => {\n            return this.videoServerSideApiClient.updateCallType({\n                name,\n                videoUpdateCallTypeRequest,\n            });\n        };\n        this.listExternalStorages = () => {\n            return this.settingsApi.listExternalStorage();\n        };\n        this.createExternalStorage = (videoCreateExternalStorageRequest) => {\n            return this.settingsApi.createExternalStorage({\n                videoCreateExternalStorageRequest,\n            });\n        };\n        this.deleteExternalStorage = (request) => {\n            return this.settingsApi.deleteExternalStorage(request);\n        };\n        this.updateExternalStorage = (name, videoUpdateExternalStorageRequest) => {\n            return this.videoServerSideApiClient.updateExternalStorage({\n                name,\n                videoUpdateExternalStorageRequest,\n            });\n        };\n        this.checkExternalStorage = (request) => {\n            return this.videoServerSideApiClient.checkExternalStorage(request);\n        };\n        const configuration = this.streamClient.getConfiguration('video');\n        this.apiClient = new DefaultApi(configuration);\n        this.settingsApi = new SettingsApi(configuration);\n        this.videoServerSideApiClient = new ServerSideApi(configuration);\n    }\n}\n\nfunction JWTUserToken(apiSecret, userId, extraData = {}, jwtOptions = {}) {\n    if (typeof userId !== 'string') {\n        throw new TypeError('userId should be a string');\n    }\n    const payload = Object.assign({ user_id: userId }, extraData);\n    // make sure we return a clear error when jwt is shimmed (ie. browser build)\n    if ((jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default()) == null || (jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign) == null) {\n        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);\n    }\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    if (payload.iat) {\n        opts.noTimestamp = false;\n    }\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\nfunction JWTServerToken(apiSecret, jwtOptions = {}) {\n    const payload = {\n        server: true,\n    };\n    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);\n    return jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, apiSecret, opts);\n}\n\nclass StreamClient {\n    /**\n     *\n     * @param apiKey\n     * @param secret\n     * @param config can be a string, which will be interpreted as base path (deprecated), or a config object\n     */\n    constructor(apiKey, secret, config) {\n        var _a;\n        this.apiKey = apiKey;\n        this.secret = secret;\n        this.config = config;\n        this.options = {};\n        this.createDevice = (createDeviceRequest) => {\n            return this.devicesApi.createDevice({ createDeviceRequest });\n        };\n        this.deleteDevice = (requestParameters) => {\n            return this.devicesApi.deleteDevice(requestParameters);\n        };\n        this.listDevices = (requestParameters) => {\n            return this.devicesApi.listDevices(requestParameters);\n        };\n        this.listPushProviders = () => {\n            return this.pushApi.listPushProviders();\n        };\n        this.deletePushProvider = (request) => {\n            return this.pushApi.deletePushProvider(request);\n        };\n        this.upsertPushProvider = (request) => {\n            return this.serversideApi.upsertPushProvider({\n                upsertPushProviderRequest: { push_provider: request },\n            });\n        };\n        this.checkPush = (checkPushRequest) => {\n            return this.testingApi.checkPush({ checkPushRequest });\n        };\n        this.createGuest = (guestRequest) => __awaiter(this, void 0, void 0, function* () {\n            guestRequest.user = this.mapCustomDataBeforeSend(guestRequest.user);\n            const response = yield this.usersApi.createGuest({ guestRequest });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.banUser = (banRequest) => {\n            banRequest.user = this.mapCustomDataBeforeSend(banRequest.user);\n            banRequest.banned_by = this.mapCustomDataBeforeSend(banRequest.banned_by);\n            return this.usersApi.ban({ banRequest });\n        };\n        this.deactivateUser = (deactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deactivateUser({\n                deactivateUserRequest,\n                userId: deactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deactivateUsers = (deactivateUsersRequest) => {\n            return this.usersApi.deactivateUsers({ deactivateUsersRequest });\n        };\n        /**\n         * @deprecated use `deleteUsers` instead\n         * @param deleteUsersRequest\n         * @returns\n         */\n        this.deleteUser = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.deleteUser(request);\n            response.user = this.mapCustomDataAfterReceive(response.user);\n            return response;\n        });\n        this.deleteUsers = (deleteUsersRequest) => {\n            return this.usersApi.deleteUsers({ deleteUsersRequest });\n        };\n        this.exportUser = (request) => {\n            return this.usersApi.exportUser(request);\n        };\n        this.exportUsers = (exportUsersRequest) => {\n            return this.usersApi.exportUsers({ exportUsersRequest });\n        };\n        this.flag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _b, _c;\n            flagRequest.user = this.mapCustomDataBeforeSend(flagRequest.user);\n            const response = yield this.usersApi.flag({ flagRequest });\n            if ((_b = response.flag) === null || _b === void 0 ? void 0 : _b.user) {\n                response.flag.user = this.mapCustomDataAfterReceive((_c = response.flag) === null || _c === void 0 ? void 0 : _c.user);\n            }\n            return response;\n        });\n        this.queryBannedUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryBannedUsers({ payload });\n            response.bans.forEach((b) => {\n                b.banned_by = this.mapCustomDataAfterReceive(b.banned_by);\n                b.user = this.mapCustomDataAfterReceive(b.user);\n            });\n            return response;\n        });\n        this.queryUsers = (payload) => __awaiter(this, void 0, void 0, function* () {\n            payload.user = this.mapCustomDataBeforeSend(payload.user);\n            const response = yield this.usersApi.queryUsers({ payload });\n            /** @ts-expect-error */\n            response.users = response.users.map((u) => this.mapCustomDataAfterReceive(u));\n            return response;\n        });\n        this.reactivateUser = (reactivateUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.reactivateUser({\n                reactivateUserRequest,\n                userId: reactivateUserRequest.user_id,\n            });\n            response.user = this.mapCustomDataAfterReceive(response.user);\n        });\n        this.reactivateUsers = (reactivateUsersRequest) => {\n            return this.usersApi.reactivateUsers({ reactivateUsersRequest });\n        };\n        this.restoreUsers = (restoreUsersRequest) => {\n            return this.usersApi.restoreUsers({ restoreUsersRequest });\n        };\n        this.unbanUser = (request) => {\n            return this.usersApi.unban(request);\n        };\n        this.unflag = (flagRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _d;\n            const response = yield this.usersApi.unflag({ flagRequest });\n            if ((_d = response.flag) === null || _d === void 0 ? void 0 : _d.user) {\n                response.flag.user = this.mapCustomDataAfterReceive(response.flag.user);\n            }\n            return response;\n        });\n        this.upsertUsers = (updateUsersRequest) => __awaiter(this, void 0, void 0, function* () {\n            Object.keys(updateUsersRequest.users).forEach((key) => {\n                updateUsersRequest.users[key] = this.mapCustomDataBeforeSend(updateUsersRequest.users[key]);\n            });\n            const response = yield this.usersApi.updateUsers({ updateUsersRequest });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.updateUsersPartial = (request) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.usersApi.updateUsersPartial({\n                /** @ts-expect-error */\n                updateUserPartialRequest: request,\n            });\n            Object.keys(response.users).forEach((key) => {\n                response.users[key] = this.mapCustomDataAfterReceive(response.users[key]);\n            });\n            return response;\n        });\n        this.muteUser = (muteUserRequest) => __awaiter(this, void 0, void 0, function* () {\n            var _e, _f;\n            muteUserRequest.user = this.mapCustomDataBeforeSend(muteUserRequest.user);\n            const response = yield this.usersApi.muteUser({ muteUserRequest });\n            if ((_e = response.mute) === null || _e === void 0 ? void 0 : _e.user) {\n                response.mute.user = this.mapCustomDataAfterReceive((_f = response.mute) === null || _f === void 0 ? void 0 : _f.user);\n            }\n            if (response.mutes) {\n                response.mutes = response.mutes.map((m) => {\n                    return Object.assign(Object.assign({}, m), { user: this.mapCustomDataAfterReceive(m.user) });\n                });\n            }\n            return response;\n        });\n        this.unmuteUser = (unmuteUserRequest) => {\n            unmuteUserRequest.user = this.mapCustomDataBeforeSend(unmuteUserRequest.user);\n            return this.usersApi.unmuteUser({ unmuteUserRequest });\n        };\n        this.sendCustomEventToUser = (userId, event) => {\n            return this.eventsApi.sendUserCustomEvent({\n                userId,\n                sendUserCustomEventRequest: { event },\n            });\n        };\n        this.createRole = (createRoleRequest) => {\n            return this.permissionsApi.createRole({ createRoleRequest });\n        };\n        this.deleteRole = (request) => {\n            return this.permissionsApi.deleteRole(request);\n        };\n        this.getPermission = (request) => {\n            return this.permissionsApi.getPermission(request);\n        };\n        this.listPermissions = () => {\n            return this.permissionsApi.listPermissions();\n        };\n        this.listRoles = () => {\n            return this.permissionsApi.listRoles();\n        };\n        this.getAppSettings = () => {\n            return this.settingsApi.getApp();\n        };\n        this.updateAppSettings = (updateAppRequest) => {\n            return this.settingsApi.updateApp({ updateAppRequest });\n        };\n        this.getRateLimits = () => {\n            return this.settingsApi.getRateLimits();\n        };\n        this.getTaskStatus = (request) => {\n            return this.tasksApi.getTask(request);\n        };\n        this.verifyWebhook = (requestBody, xSignature) => {\n            const key = Buffer.from(this.secret, 'utf8');\n            const hash = crypto__WEBPACK_IMPORTED_MODULE_1___default().createHmac('sha256', key)\n                .update(requestBody)\n                .digest('hex');\n            try {\n                return crypto__WEBPACK_IMPORTED_MODULE_1___default().timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));\n            }\n            catch (err) {\n                return false;\n            }\n        };\n        this.getConfiguration = (product = 'chat') => {\n            var _a;\n            return new Configuration({\n                apiKey: (name) => {\n                    const mapping = {\n                        'Stream-Auth-Type': 'jwt',\n                        api_key: this.apiKey,\n                        Authorization: this.token,\n                    };\n                    return mapping[name];\n                },\n                basePath: (_a = this.options.basePath) !== null && _a !== void 0 ? _a : (product === 'chat'\n                    ? 'https://chat.stream-io-api.com'\n                    : 'https://video.stream-io-api.com'),\n                headers: {\n                    'X-Stream-Client': 'stream-node-' + \"0.1.12\",\n                },\n                middleware: [\n                    {\n                        pre: (context) => {\n                            context.init.headers = Object.assign(Object.assign({}, context.init.headers), { 'x-client-request-id': (0,uuid__WEBPACK_IMPORTED_MODULE_2__.v4)(), 'Accept-Encoding': 'gzip' });\n                            return Promise.resolve(context);\n                        },\n                    },\n                    {\n                        // This should be the last post middleware because that will throw an error\n                        // The Fetch API won't throw an error for HTTP error responses, which means the \"onError\" middleware won't be called so we need to throw error from \"post\" middleware\n                        post: (context) => __awaiter(this, void 0, void 0, function* () {\n                            if ((context.response && context.response.status < 200) ||\n                                context.response.status >= 300) {\n                                const response = new JSONApiResponse(context.response);\n                                const value = (yield response.value());\n                                throw new Error(`Stream error code ${value.code}: ${value.message}`);\n                            }\n                        }),\n                    },\n                    {\n                        pre: (context) => {\n                            context.init.signal = AbortSignal.timeout(this.options.timeout);\n                            return Promise.resolve(context);\n                        },\n                        onError: (context) => {\n                            const error = context.error;\n                            if (error.name === 'AbortError' || error.name === 'TimeoutError') {\n                                throw new FetchError(error, `The request was aborted due to to the ${this.options.timeout}ms timeout, you can set the timeout in the StreamClient constructor`);\n                            }\n                            return Promise.resolve(context.response);\n                        },\n                    },\n                ],\n                // https://github.com/OpenAPITools/openapi-generator/issues/13222\n                queryParamsStringify: (params) => {\n                    const newParams = [];\n                    for (const k in params) {\n                        if (Array.isArray(params[k]) || typeof params[k] === 'object') {\n                            newParams.push(`${k}=${encodeURIComponent(JSON.stringify(params[k]))}`);\n                        }\n                        else {\n                            const value = params[k];\n                            if (typeof value === 'string' ||\n                                typeof value === 'number' ||\n                                typeof value === 'boolean') {\n                                newParams.push(`${k}=${encodeURIComponent(value)}`);\n                            }\n                        }\n                    }\n                    return newParams.join('&');\n                },\n            });\n        };\n        this.reservedKeywords = [\n            'ban_expires',\n            'banned',\n            'id',\n            'invisible',\n            'language',\n            'push_notifications',\n            'revoke_tokens_issued_before',\n            'role',\n            'teams',\n            'created_at',\n            'deactivated_at',\n            'deleted_at',\n            'last_active',\n            'online',\n            'updated_at',\n            'shadow_banned',\n            'name',\n            'image',\n        ];\n        this.mapCustomDataBeforeSend = (user) => {\n            if (!user) {\n                return undefined;\n            }\n            const copy = Object.assign({}, user);\n            delete copy.custom;\n            return Object.assign(Object.assign({}, copy), user.custom);\n        };\n        this.token = JWTServerToken(this.secret);\n        if (typeof config === 'string') {\n            this.options.basePath = config;\n            this.options.timeout = StreamClient.DEFAULT_TIMEOUT;\n        }\n        else {\n            if (config) {\n                this.options = config;\n            }\n            this.options.timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : StreamClient.DEFAULT_TIMEOUT;\n        }\n        this.video = new StreamVideoClient(this);\n        this.chat = new StreamChatClient(this);\n        const chatConfiguration = this.getConfiguration();\n        /** @ts-expect-error */\n        this.usersApi = new UsersApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.devicesApi = new DevicesApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.pushApi = new PushApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.serversideApi = new ServerSideApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.testingApi = new TestingApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.permissionsApi = new PermissionsV2Api(chatConfiguration);\n        /** @ts-expect-error */\n        this.settingsApi = new SettingsApi$1(chatConfiguration);\n        /** @ts-expect-error */\n        this.eventsApi = new EventsApi(chatConfiguration);\n        /** @ts-expect-error */\n        this.tasksApi = new TasksApi(chatConfiguration);\n    }\n    /**\n     *\n     * @param userID\n     * @param exp\n     * @param iat deprecated, the default date will be set internally\n     * @param call_cids this parameter is deprecated use `createCallToken` for call tokens\n     * @returns\n     */\n    createToken(userID, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000), call_cids) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        if (call_cids) {\n            console.warn(`Use createCallToken method for creating call tokens, the \"call_cids\" param will be removed from the createToken method with version 0.2.0`);\n            extra.call_cids = call_cids;\n        }\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    /**\n     *\n     * @param userID\n     * @param call_cids\n     * @param exp\n     * @param iat this is deprecated, the current date will be set internally\n     * @returns\n     */\n    createCallToken(userID, call_cids, exp = Math.round(new Date().getTime() / 1000) + 60 * 60, iat = Math.round(Date.now() / 1000)) {\n        const extra = {};\n        if (exp) {\n            extra.exp = exp;\n        }\n        if (iat) {\n            extra.iat = iat;\n        }\n        extra.call_cids = call_cids;\n        return JWTUserToken(this.secret, userID, extra);\n    }\n    mapCustomDataAfterReceive(user) {\n        if (!user) {\n            return undefined;\n        }\n        /** @ts-expect-error */\n        const result = {};\n        Object.keys(user).forEach((key) => {\n            if (!this.reservedKeywords.includes(key)) {\n                if (!result.custom) {\n                    result.custom = {};\n                }\n                result.custom[key] = user[key];\n            }\n            else {\n                result[key] = user[key];\n            }\n        });\n        return result;\n    }\n}\nStreamClient.DEFAULT_TIMEOUT = 3000;\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RyZWFtLWlvL25vZGUtc2RrL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUNLO0FBQ0g7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztB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LE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLHdDQUF3QyxLQUFLLEVBQUUsS0FBSyxZQUFZLEVBQUUsUUFBUSxpRUFBaUUsRUFBRSxRQUFRO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLG9DQUFvQyxLQUFLLFlBQVksRUFBRSxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0Esd0NBQXdDLEtBQUssRUFBRSxLQUFLLFlBQVksRUFBRSxRQUFRLGlFQUFpRSxFQUFFLFFBQVE7QUFDcko7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLG9DQUFvQyxLQUFLLFlBQVksRUFBRSxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSyxZQUFZLEVBQUUsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBLHNDQUFzQyxLQUFLLFlBQVksRUFBRSxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRyxZQUFZLEVBQUUsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsK0JBQStCLFFBQVEsdUJBQXVCLEVBQUUsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsK0JBQStCLFFBQVEsWUFBWSxFQUFFLFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSxtQkFBbUIsRUFBRSxXQUFXO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSx1QkFBdUIsRUFBRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFd25GO0FBQ3huRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VhZ2xlcy1yaW5nLy4vbm9kZV9tb2R1bGVzL0BzdHJlYW0taW8vbm9kZS1zZGsvZGlzdC9pbmRleC5lcy5qcz85MjI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBUE5Db25maWdSZXF1ZXN0QXV0aFR5cGVFbnVtID0ge1xuICAgIENFUlRJRklDQVRFOiAnY2VydGlmaWNhdGUnLFxuICAgIFRPS0VOOiAndG9rZW4nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFwcFNlYXJjaEJhY2tlbmRFbnVtID0ge1xuICAgIEVMQVNUSUNTRUFSQ0g6ICdlbGFzdGljc2VhcmNoJyxcbiAgICBQT1NUR1JFUzogJ3Bvc3RncmVzJyxcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3luY01vZGVyYXRpb25DYWxsYmFja0NvbmZpZ1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBOT05FOiAnQ0FMTEJBQ0tfTU9ERV9OT05FJyxcbiAgICBSRVNUOiAnQ0FMTEJBQ0tfTU9ERV9SRVNUJyxcbiAgICBUV0lSUDogJ0NBTExCQUNLX01PREVfVFdJUlAnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEF1ZGlvU2V0dGluZ3NEZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tMaXN0T3B0aW9uc0JlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQmxvY2tMaXN0T3B0aW9uc1JlcXVlc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hhbm5lbENvbmZpZ1dpdGhJbmZvQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9BdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9CbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsQ29uZmlnV2l0aEluZm9SZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsTWVtYmVyUm9sZUVudW0gPSB7XG4gICAgTUVNQkVSOiAnbWVtYmVyJyxcbiAgICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InLFxuICAgIEFETUlOOiAnYWRtaW4nLFxuICAgIE9XTkVSOiAnb3duZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxNZW1iZXJSZXF1ZXN0Um9sZUVudW0gPSB7XG4gICAgTUVNQkVSOiAnbWVtYmVyJyxcbiAgICBNT0RFUkFUT1I6ICdtb2RlcmF0b3InLFxuICAgIEFETUlOOiAnYWRtaW4nLFxuICAgIE9XTkVSOiAnb3duZXInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENoYW5uZWxUeXBlQ29uZmlnQmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDaGVja1B1c2hSZXF1ZXN0UHVzaFByb3ZpZGVyVHlwZUVudW0gPSB7XG4gICAgRklSRUJBU0U6ICdmaXJlYmFzZScsXG4gICAgQVBOOiAnYXBuJyxcbiAgICBIVUFXRUk6ICdodWF3ZWknLFxuICAgIFhJQU9NSTogJ3hpYW9taSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hlY2tTTlNSZXNwb25zZVN0YXR1c0VudW0gPSB7XG4gICAgT0s6ICdvaycsXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ2hlY2tTUVNSZXNwb25zZVN0YXR1c0VudW0gPSB7XG4gICAgT0s6ICdvaycsXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29uZmlnRGVmYXVsdFJvbGVFbnVtID0ge1xuICAgIEFUVEVOREVFOiAnYXR0ZW5kZWUnLFxuICAgIFBVQkxJU0hFUjogJ3B1Ymxpc2hlcicsXG4gICAgU1VCU0NSSUJFUjogJ3N1YnNjcmliZXInLFxuICAgIEFETUlOOiAnYWRtaW4nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbmZpZ1JlcXVlc3REZWZhdWx0Um9sZUVudW0gPSB7XG4gICAgQVRURU5ERUU6ICdhdHRlbmRlZScsXG4gICAgUFVCTElTSEVSOiAncHVibGlzaGVyJyxcbiAgICBTVUJTQ1JJQkVSOiAnc3Vic2NyaWJlcicsXG4gICAgQURNSU46ICdhZG1pbidcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2FsbFJlcXVlc3RUeXBlRW51bSA9IHtcbiAgICBBVURJTzogJ2F1ZGlvJyxcbiAgICBWSURFTzogJ3ZpZGVvJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBDcmVhdGVDaGFubmVsVHlwZVJlcXVlc3RBdXRvbW9kRW51bSA9IHtcbiAgICBESVNBQkxFRDogJ2Rpc2FibGVkJyxcbiAgICBTSU1QTEU6ICdzaW1wbGUnLFxuICAgIEFJOiAnQUknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VCbG9ja2xpc3RCZWhhdmlvckVudW0gPSB7XG4gICAgRkxBRzogJ2ZsYWcnLFxuICAgIEJMT0NLOiAnYmxvY2snXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZURldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENyZWF0ZUltcG9ydFJlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBJTlNFUlQ6ICdpbnNlcnQnLFxuICAgIFVQU0VSVDogJ3Vwc2VydCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGVsZXRlVXNlcnNSZXF1ZXN0Q29udmVyc2F0aW9uc0VudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIEhBUkQ6ICdoYXJkJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZWxldGVVc2Vyc1JlcXVlc3RNZXNzYWdlc0VudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIFBSVU5JTkc6ICdwcnVuaW5nJyxcbiAgICBIQVJEOiAnaGFyZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGVsZXRlVXNlcnNSZXF1ZXN0VXNlckVudW0gPSB7XG4gICAgU09GVDogJ3NvZnQnLFxuICAgIFBSVU5JTkc6ICdwcnVuaW5nJyxcbiAgICBIQVJEOiAnaGFyZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRGV2aWNlUHVzaFByb3ZpZGVyRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBEZXZpY2VGaWVsZHNQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IERldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtID0ge1xuICAgIEZJUkVCQVNFOiAnZmlyZWJhc2UnLFxuICAgIEFQTjogJ2FwbicsXG4gICAgSFVBV0VJOiAnaHVhd2VpJyxcbiAgICBYSUFPTUk6ICd4aWFvbWknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEltYWdlU2l6ZUNyb3BFbnVtID0ge1xuICAgIFRPUDogJ3RvcCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCcsXG4gICAgQ0VOVEVSOiAnY2VudGVyJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBJbWFnZVNpemVSZXNpemVFbnVtID0ge1xuICAgIENMSVA6ICdjbGlwJyxcbiAgICBDUk9QOiAnY3JvcCcsXG4gICAgU0NBTEU6ICdzY2FsZScsXG4gICAgRklMTDogJ2ZpbGwnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IExheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVR5cGVFbnVtID0ge1xuICAgIFJFR1VMQVI6ICdyZWd1bGFyJyxcbiAgICBFUEhFTUVSQUw6ICdlcGhlbWVyYWwnLFxuICAgIEVSUk9SOiAnZXJyb3InLFxuICAgIFJFUExZOiAncmVwbHknLFxuICAgIFNZU1RFTTogJ3N5c3RlbScsXG4gICAgREVMRVRFRDogJ2RlbGV0ZWQnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE1lc3NhZ2VSZXF1ZXN0VHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTWVzc2FnZVJlcXVlc3QxVHlwZUVudW0gPSB7XG4gICAgUkVHVUxBUjogJ3JlZ3VsYXInLFxuICAgIEVQSEVNRVJBTDogJ2VwaGVtZXJhbCcsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgUkVQTFk6ICdyZXBseScsXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgICBERUxFVEVEOiAnZGVsZXRlZCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUGVybWlzc2lvbkxldmVsRW51bSA9IHtcbiAgICBBUFA6ICdhcHAnLFxuICAgIENIQU5ORUw6ICdjaGFubmVsJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQb2xpY3lSZXF1ZXN0QWN0aW9uRW51bSA9IHtcbiAgICBERU5ZOiAnRGVueScsXG4gICAgQUxMT1c6ICdBbGxvdydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUG9saWN5UmVxdWVzdDFBY3Rpb25FbnVtID0ge1xuICAgIERFTlk6ICdEZW55JyxcbiAgICBBTExPVzogJ0FsbG93J1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBQdXNoQ29uZmlnUmVxdWVzdFZlcnNpb25FbnVtID0ge1xuICAgIFYxOiAndjEnLFxuICAgIFYyOiAndjInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtID0ge1xuICAgIEFWQUlMQUJMRTogJ2F2YWlsYWJsZScsXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgQVVUT19PTjogJ2F1dG8tb24nXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0TGFuZ3VhZ2VFbnVtID0ge1xuICAgIEFGOiAnYWYnLFxuICAgIFNROiAnc3EnLFxuICAgIEFNOiAnYW0nLFxuICAgIEFSOiAnYXInLFxuICAgIEFaOiAnYXonLFxuICAgIEJOOiAnYm4nLFxuICAgIEJTOiAnYnMnLFxuICAgIEJHOiAnYmcnLFxuICAgIFpIOiAnemgnLFxuICAgIFpIX1RXOiAnemgtVFcnLFxuICAgIEhSOiAnaHInLFxuICAgIENTOiAnY3MnLFxuICAgIERBOiAnZGEnLFxuICAgIEZBX0FGOiAnZmEtQUYnLFxuICAgIE5MOiAnbmwnLFxuICAgIEVOOiAnZW4nLFxuICAgIEVUOiAnZXQnLFxuICAgIEZJOiAnZmknLFxuICAgIEZSOiAnZnInLFxuICAgIEZSX0NBOiAnZnItQ0EnLFxuICAgIEtBOiAna2EnLFxuICAgIERFOiAnZGUnLFxuICAgIEVMOiAnZWwnLFxuICAgIEhBOiAnaGEnLFxuICAgIEhFOiAnaGUnLFxuICAgIEhJOiAnaGknLFxuICAgIEhVOiAnaHUnLFxuICAgIElEOiAnaWQnLFxuICAgIElUOiAnaXQnLFxuICAgIEpBOiAnamEnLFxuICAgIEtPOiAna28nLFxuICAgIExWOiAnbHYnLFxuICAgIE1TOiAnbXMnLFxuICAgIE5POiAnbm8nLFxuICAgIEZBOiAnZmEnLFxuICAgIFBTOiAncHMnLFxuICAgIFBMOiAncGwnLFxuICAgIFBUOiAncHQnLFxuICAgIFJPOiAncm8nLFxuICAgIFJVOiAncnUnLFxuICAgIFNSOiAnc3InLFxuICAgIFNLOiAnc2snLFxuICAgIFNMOiAnc2wnLFxuICAgIFNPOiAnc28nLFxuICAgIEVTOiAnZXMnLFxuICAgIEVTX01YOiAnZXMtTVgnLFxuICAgIFNXOiAnc3cnLFxuICAgIFNWOiAnc3YnLFxuICAgIFRMOiAndGwnLFxuICAgIFRBOiAndGEnLFxuICAgIFRIOiAndGgnLFxuICAgIFRSOiAndHInLFxuICAgIFVLOiAndWsnLFxuICAgIFVSOiAndXInLFxuICAgIFZJOiAndmknXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RFbmZvcmNlVW5pcXVlVXNlcm5hbWVzRW51bSA9IHtcbiAgICBOTzogJ25vJyxcbiAgICBBUFA6ICdhcHAnLFxuICAgIFRFQU06ICd0ZWFtJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVBcHBSZXF1ZXN0UGVybWlzc2lvblZlcnNpb25FbnVtID0ge1xuICAgIFYxOiAndjEnLFxuICAgIFYyOiAndjInXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUFwcFJlcXVlc3RWaWRlb1Byb3ZpZGVyRW51bSA9IHtcbiAgICBBR09SQTogJ2Fnb3JhJyxcbiAgICBITVM6ICdobXMnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdEF1dG9tb2RFbnVtID0ge1xuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIFNJTVBMRTogJ3NpbXBsZScsXG4gICAgQUk6ICdBSSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QmxvY2tsaXN0QmVoYXZpb3JFbnVtID0ge1xuICAgIEZMQUc6ICdmbGFnJyxcbiAgICBCTE9DSzogJ2Jsb2NrJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEVudW0gPSB7XG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXG4gICAgU0lNUExFOiAnc2ltcGxlJyxcbiAgICBBSTogJ0FJJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBVcGRhdGVDaGFubmVsVHlwZVJlc3BvbnNlQXV0b21vZEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSA9IHtcbiAgICBGTEFHOiAnZmxhZycsXG4gICAgQkxPQ0s6ICdibG9jaydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9TZXR0aW5nc0NhbWVyYUZhY2luZ0VudW0gPSB7XG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgQkFDSzogJ2JhY2snLFxuICAgIEVYVEVSTkFMOiAnZXh0ZXJuYWwnXG59O1xuXG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9BdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0gPSB7XG4gICAgU1BFQUtFUjogJ3NwZWFrZXInLFxuICAgIEVBUlBJRUNFOiAnZWFycGllY2UnXG59O1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZpZGVvQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSA9IHtcbiAgICBTUEVBS0VSOiAnc3BlYWtlcicsXG4gICAgRUFSUElFQ0U6ICdlYXJwaWVjZSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSA9IHtcbiAgICBGSVJFQkFTRTogJ2ZpcmViYXNlJyxcbiAgICBBUE46ICdhcG4nLFxuICAgIEhVQVdFSTogJ2h1YXdlaScsXG4gICAgWElBT01JOiAneGlhb21pJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb0xheW91dFNldHRpbmdzTmFtZUVudW0gPSB7XG4gICAgU1BPVExJR0hUOiAnc3BvdGxpZ2h0JyxcbiAgICBHUklEOiAnZ3JpZCcsXG4gICAgU0lOR0xFX1BBUlRJQ0lQQU5UOiAnc2luZ2xlLXBhcnRpY2lwYW50JyxcbiAgICBNT0JJTEU6ICdtb2JpbGUnLFxuICAgIENVU1RPTTogJ2N1c3RvbSdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9MYXlvdXRTZXR0aW5nc1JlcXVlc3ROYW1lRW51bSA9IHtcbiAgICBTUE9UTElHSFQ6ICdzcG90bGlnaHQnLFxuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBTSU5HTEVfUEFSVElDSVBBTlQ6ICdzaW5nbGUtcGFydGljaXBhbnQnLFxuICAgIE1PQklMRTogJ21vYmlsZScsXG4gICAgQ1VTVE9NOiAnY3VzdG9tJ1xufTtcbi8qKlxuICogQWxsIHBvc3NpYmlsaXR5IG9mIHN0cmluZyB0byB1c2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9Pd25DYXBhYmlsaXR5ID0ge1xuICAgIEJMT0NLX1VTRVJTOiAnYmxvY2stdXNlcnMnLFxuICAgIENSRUFURV9DQUxMOiAnY3JlYXRlLWNhbGwnLFxuICAgIENSRUFURV9SRUFDVElPTjogJ2NyZWF0ZS1yZWFjdGlvbicsXG4gICAgRU5EX0NBTEw6ICdlbmQtY2FsbCcsXG4gICAgSk9JTl9CQUNLU1RBR0U6ICdqb2luLWJhY2tzdGFnZScsXG4gICAgSk9JTl9DQUxMOiAnam9pbi1jYWxsJyxcbiAgICBKT0lOX0VOREVEX0NBTEw6ICdqb2luLWVuZGVkLWNhbGwnLFxuICAgIE1VVEVfVVNFUlM6ICdtdXRlLXVzZXJzJyxcbiAgICBQSU5fRk9SX0VWRVJZT05FOiAncGluLWZvci1ldmVyeW9uZScsXG4gICAgUkVBRF9DQUxMOiAncmVhZC1jYWxsJyxcbiAgICBSRU1PVkVfQ0FMTF9NRU1CRVI6ICdyZW1vdmUtY2FsbC1tZW1iZXInLFxuICAgIFNDUkVFTlNIQVJFOiAnc2NyZWVuc2hhcmUnLFxuICAgIFNFTkRfQVVESU86ICdzZW5kLWF1ZGlvJyxcbiAgICBTRU5EX1ZJREVPOiAnc2VuZC12aWRlbycsXG4gICAgU1RBUlRfQlJPQURDQVNUX0NBTEw6ICdzdGFydC1icm9hZGNhc3QtY2FsbCcsXG4gICAgU1RBUlRfUkVDT1JEX0NBTEw6ICdzdGFydC1yZWNvcmQtY2FsbCcsXG4gICAgU1RBUlRfVFJBTlNDUklQVElPTl9DQUxMOiAnc3RhcnQtdHJhbnNjcmlwdGlvbi1jYWxsJyxcbiAgICBTVE9QX0JST0FEQ0FTVF9DQUxMOiAnc3RvcC1icm9hZGNhc3QtY2FsbCcsXG4gICAgU1RPUF9SRUNPUkRfQ0FMTDogJ3N0b3AtcmVjb3JkLWNhbGwnLFxuICAgIFNUT1BfVFJBTlNDUklQVElPTl9DQUxMOiAnc3RvcC10cmFuc2NyaXB0aW9uLWNhbGwnLFxuICAgIFVQREFURV9DQUxMOiAndXBkYXRlLWNhbGwnLFxuICAgIFVQREFURV9DQUxMX01FTUJFUjogJ3VwZGF0ZS1jYWxsLW1lbWJlcicsXG4gICAgVVBEQVRFX0NBTExfUEVSTUlTU0lPTlM6ICd1cGRhdGUtY2FsbC1wZXJtaXNzaW9ucycsXG4gICAgVVBEQVRFX0NBTExfU0VUVElOR1M6ICd1cGRhdGUtY2FsbC1zZXR0aW5ncydcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9SZWNvcmRTZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1JlY29yZFNldHRpbmdzUmVxdWVzdFF1YWxpdHlFbnVtID0ge1xuICAgIF8zNjBQOiAnMzYwcCcsXG4gICAgXzQ4MFA6ICc0ODBwJyxcbiAgICBfNzIwUDogJzcyMHAnLFxuICAgIF8xMDgwUDogJzEwODBwJyxcbiAgICBfMTQ0MFA6ICcxNDQwcCdcbn07XG4vKipcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmlkZW9UcmFuc2NyaXB0aW9uU2V0dGluZ3NNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSA9IHtcbiAgICBBVkFJTEFCTEU6ICdhdmFpbGFibGUnLFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIEFVVE9fT046ICdhdXRvLW9uJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1ZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtID0ge1xuICAgIEZST05UOiAnZnJvbnQnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBFWFRFUk5BTDogJ2V4dGVybmFsJ1xufTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBWaWRlb1ZpZGVvU2V0dGluZ3NSZXF1ZXN0Q2FtZXJhRmFjaW5nRW51bSA9IHtcbiAgICBGUk9OVDogJ2Zyb250JyxcbiAgICBCQUNLOiAnYmFjaycsXG4gICAgRVhURVJOQUw6ICdleHRlcm5hbCdcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuY29uc3QgQkFTRV9QQVRIJDEgPSBcImh0dHBzOi8vY2hhdC5zdHJlYW0taW8tYXBpLmNvbVwiLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG5sZXQgQ29uZmlndXJhdGlvbiQxID0gY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIHNldCBjb25maWcoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggIT0gbnVsbCA/IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCA6IEJBU0VfUEFUSCQxO1xuICAgIH1cbiAgICBnZXQgZmV0Y2hBcGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGk7XG4gICAgfVxuICAgIGdldCBtaWRkbGV3YXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm1pZGRsZXdhcmUgfHwgW107XG4gICAgfVxuICAgIGdldCBxdWVyeVBhcmFtc1N0cmluZ2lmeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeSB8fCBxdWVyeXN0cmluZyQxO1xuICAgIH1cbiAgICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24udXNlcm5hbWU7XG4gICAgfVxuICAgIGdldCBwYXNzd29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IGFwaUtleSgpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleTtcbiAgICAgICAgaWYgKGFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcGlLZXkgPT09ICdmdW5jdGlvbicgPyBhcGlLZXkgOiAoKSA9PiBhcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGFjY2Vzc1Rva2VuKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbjtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nID8gYWNjZXNzVG9rZW4gOiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBhY2Nlc3NUb2tlbjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmNyZWRlbnRpYWxzO1xuICAgIH1cbn07XG5jb25zdCBEZWZhdWx0Q29uZmlnJDEgPSBuZXcgQ29uZmlndXJhdGlvbiQxKCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWQgQVBJIGNsYXNzZXMuXG4gKi9cbmxldCBCYXNlQVBJJDEgPSBjbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uID0gRGVmYXVsdENvbmZpZyQxKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZmV0Y2hBcGkgPSAodXJsLCBpbml0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hQYXJhbXMgPSB7IHVybCwgaW5pdCB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcyA9ICh5aWVsZCBtaWRkbGV3YXJlLnByZShPYmplY3QuYXNzaWduKHsgZmV0Y2g6IHRoaXMuZmV0Y2hBcGkgfSwgZmV0Y2hQYXJhbXMpKSkgfHwgZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkICh0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGkgfHwgZmV0Y2gpKGZldGNoUGFyYW1zLnVybCwgZmV0Y2hQYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSA/IHJlc3BvbnNlLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IkMShlLCAnVGhlIHJlcXVlc3QgZmFpbGVkIGFuZCB0aGUgaW50ZXJjZXB0b3JzIGRpZCBub3QgcmV0dXJuIGFuIGFsdGVybmF0aXZlIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5wb3N0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoQXBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBmZXRjaFBhcmFtcy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIH0pKSB8fCByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmUgPSBjb25maWd1cmF0aW9uLm1pZGRsZXdhcmU7XG4gICAgfVxuICAgIHdpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG5leHQubWlkZGxld2FyZSA9IG5leHQubWlkZGxld2FyZS5jb25jYXQoLi4ubWlkZGxld2FyZXMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgd2l0aFByZU1pZGRsZXdhcmUoLi4ucHJlTWlkZGxld2FyZXMpIHtcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZXMgPSBwcmVNaWRkbGV3YXJlcy5tYXAoKHByZSkgPT4gKHsgcHJlIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpO1xuICAgIH1cbiAgICB3aXRoUG9zdE1pZGRsZXdhcmUoLi4ucG9zdE1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcG9zdE1pZGRsZXdhcmVzLm1hcCgocG9zdCkgPT4gKHsgcG9zdCB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIE1JTUUgaXMgYSBKU09OIE1JTUUuXG4gICAgICogSlNPTiBNSU1FIGV4YW1wbGVzOlxuICAgICAqICAgYXBwbGljYXRpb24vanNvblxuICAgICAqICAgYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEY4XG4gICAgICogICBBUFBMSUNBVElPTi9KU09OXG4gICAgICogICBhcHBsaWNhdGlvbi92bmQuY29tcGFueStqc29uXG4gICAgICogQHBhcmFtIG1pbWUgLSBNSU1FIChNdWx0aXB1cnBvc2UgSW50ZXJuZXQgTWFpbCBFeHRlbnNpb25zKVxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBKU09OLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNKc29uTWltZShtaW1lKSB7XG4gICAgICAgIGlmICghbWltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYXNlQVBJLmpzb25SZWdleC50ZXN0KG1pbWUpO1xuICAgIH1cbiAgICByZXF1ZXN0KGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBpbml0IH0gPSB5aWVsZCB0aGlzLmNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoQXBpKHVybCwgaW5pdCk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yJDEocmVzcG9uc2UsICdSZXNwb25zZSByZXR1cm5lZCBhbiBlcnJvciBjb2RlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVGZXRjaFBhcmFtcyhjb250ZXh0LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5jb25maWd1cmF0aW9uLmJhc2VQYXRoICsgY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucXVlcnkgIT09IHVuZGVmaW5lZCAmJiBPYmplY3Qua2V5cyhjb250ZXh0LnF1ZXJ5KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFkZCB0aGUgcXVlcnlzdHJpbmcgdG8gdGhlIFVSTCBpZiB0aGVyZSBhcmUgcXVlcnkgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGRvbmUgdG8gYXZvaWQgdXJscyBlbmRpbmcgd2l0aCBhIFwiP1wiIGNoYXJhY3RlciB3aGljaCBidWdneSB3ZWJzZXJ2ZXJzXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGhhbmRsZSBjb3JyZWN0bHkgc29tZXRpbWVzLlxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLmNvbmZpZ3VyYXRpb24ucXVlcnlQYXJhbXNTdHJpbmdpZnkoY29udGV4dC5xdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWd1cmF0aW9uLmhlYWRlcnMsIGNvbnRleHQuaGVhZGVycyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGtleSA9PiBoZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCA/IGRlbGV0ZSBoZWFkZXJzW2tleV0gOiB7fSk7XG4gICAgICAgICAgICBjb25zdCBpbml0T3ZlcnJpZGVGbiA9IHR5cGVvZiBpbml0T3ZlcnJpZGVzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IGluaXRPdmVycmlkZXNcbiAgICAgICAgICAgICAgICA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGluaXRPdmVycmlkZXM7IH0pO1xuICAgICAgICAgICAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogY29udGV4dC5ib2R5LFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGRlbkluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluaXRQYXJhbXMpLCAoeWllbGQgaW5pdE92ZXJyaWRlRm4oe1xuICAgICAgICAgICAgICAgIGluaXQ6IGluaXRQYXJhbXMsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBjb25zdCBpbml0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZGVuSW5pdCksIHsgYm9keTogaXNGb3JtRGF0YSQxKG92ZXJyaWRkZW5Jbml0LmJvZHkpIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5Jbml0LmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9iJDEob3ZlcnJpZGRlbkluaXQuYm9keSlcbiAgICAgICAgICAgICAgICAgICAgPyBvdmVycmlkZGVuSW5pdC5ib2R5XG4gICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkob3ZlcnJpZGRlbkluaXQuYm9keSkgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB1cmwsIGluaXQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY2xvbmUgb2YgYHRoaXNgIGJ5IGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZVxuICAgICAqIGFuZCB0aGVuIHNoYWxsb3cgY2xvbmluZyBkYXRhIG1lbWJlcnMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgbmV4dCA9IG5ldyBjb25zdHJ1Y3Rvcih0aGlzLmNvbmZpZ3VyYXRpb24pO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSB0aGlzLm1pZGRsZXdhcmUuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxufTtcbkJhc2VBUEkkMS5qc29uUmVnZXggPSBuZXcgUmVnRXhwKCdeKDo/YXBwbGljYXRpb25cXC9qc29ufFteOy8gXFx0XStcXC9bXjsvIFxcdF0rWytdanNvbilbIFxcdF0qKDo/Oy4qKT8kJywgJ2knKTtcbmZ1bmN0aW9uIGlzQmxvYiQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2I7XG59XG5mdW5jdGlvbiBpc0Zvcm1EYXRhJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5sZXQgUmVzcG9uc2VFcnJvciQxID0gY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgbXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSZXNwb25zZUVycm9yXCI7XG4gICAgfVxufTtcbmxldCBGZXRjaEVycm9yJDEgPSBjbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICB9XG59O1xubGV0IFJlcXVpcmVkRXJyb3IkMSA9IGNsYXNzIFJlcXVpcmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUmVxdWlyZWRFcnJvclwiO1xuICAgIH1cbn07XG5jb25zdCBDT0xMRUNUSU9OX0ZPUk1BVFMgPSB7XG4gICAgY3N2OiBcIixcIixcbiAgICBzc3Y6IFwiIFwiLFxuICAgIHRzdjogXCJcXHRcIixcbiAgICBwaXBlczogXCJ8XCIsXG59O1xuZnVuY3Rpb24gcXVlcnlzdHJpbmckMShwYXJhbXMsIHByZWZpeCA9ICcnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChrZXkgPT4gcXVlcnlzdHJpbmdTaW5nbGVLZXkkMShrZXksIHBhcmFtc1trZXldLCBwcmVmaXgpKVxuICAgICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydC5sZW5ndGggPiAwKVxuICAgICAgICAuam9pbignJicpO1xufVxuZnVuY3Rpb24gcXVlcnlzdHJpbmdTaW5nbGVLZXkkMShrZXksIHZhbHVlLCBrZXlQcmVmaXggPSAnJykge1xuICAgIGNvbnN0IGZ1bGxLZXkgPSBrZXlQcmVmaXggKyAoa2V5UHJlZml4Lmxlbmd0aCA/IGBbJHtrZXl9XWAgOiBrZXkpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IG11bHRpVmFsdWUgPSB2YWx1ZS5tYXAoc2luZ2xlVmFsdWUgPT4gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzaW5nbGVWYWx1ZSkpKVxuICAgICAgICAgICAgLmpvaW4oYCYke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09YCk7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7bXVsdGlWYWx1ZX1gO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBc0FycmF5ID0gQXJyYXkuZnJvbSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBxdWVyeXN0cmluZ1NpbmdsZUtleSQxKGtleSwgdmFsdWVBc0FycmF5LCBrZXlQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvSVNPU3RyaW5nKCkpfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmckMSh2YWx1ZSwgZnVsbEtleSk7XG4gICAgfVxuICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWx1ZSkpfWA7XG59XG5mdW5jdGlvbiBjYW5Db25zdW1lRm9ybShjb25zdW1lcykge1xuICAgIGZvciAoY29uc3QgY29uc3VtZSBvZiBjb25zdW1lcykge1xuICAgICAgICBpZiAoJ211bHRpcGFydC9mb3JtLWRhdGEnID09PSBjb25zdW1lLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5sZXQgSlNPTkFwaVJlc3BvbnNlJDEgPSBjbGFzcyBKU09OQXBpUmVzcG9uc2Uge1xuICAgIGNvbnN0cnVjdG9yKHJhdywgdHJhbnNmb3JtZXIgPSAoanNvblZhbHVlKSA9PiBqc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1lcih5aWVsZCB0aGlzLnJhdy5qc29uKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xubGV0IFZvaWRBcGlSZXNwb25zZSQxID0gY2xhc3MgVm9pZEFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBDaGFubmVsVHlwZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWx0eXBlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBjaGFubmVsIHR5cGVcbiAgICAgKiBDcmVhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgY3JlYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBjaGFubmVsIHR5cGVzXG4gICAgICogTGlzdCBjaGFubmVsIHR5cGVzXG4gICAgICovXG4gICAgbGlzdENoYW5uZWxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogVXBkYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIENoYW5uZWxzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUNoYW5uZWxcbiAgICAgKiBEZWxldGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydoYXJkX2RlbGV0ZSddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZERlbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBkZWxldGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBkZWxldGUgc2V2ZXJhbCBjaGFubmVscyBhdCBvbmNlIGFzeW5jaHJvbm91c2x5ICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlcyBjaGFubmVscyBhc3luY2hyb25vdXNseVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZUNoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVDaGFubmVsc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvZGVsZXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ2hhbm5lbHNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byBkZWxldGUgc2V2ZXJhbCBjaGFubmVscyBhdCBvbmNlIGFzeW5jaHJvbm91c2x5ICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsXG4gICAgICogRGVsZXRlcyBjaGFubmVscyBhc3luY2hyb25vdXNseVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNoYW5uZWwgZGF0YSB0byBKU09OIGZpbGVcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBleHBvcnRDaGFubmVsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRDaGFubmVsc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2V4cG9ydENoYW5uZWxzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0Q2hhbm5lbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZXhwb3J0Q2hhbm5lbHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2V4cG9ydF9jaGFubmVsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydENoYW5uZWxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIGNoYW5uZWwgZGF0YSB0byBKU09OIGZpbGVcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBleHBvcnRDaGFubmVscyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmV4cG9ydENoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFeHBvcnQgY2hhbm5lbHMgc3RhdHVzXG4gICAgICovXG4gICAgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9leHBvcnRfY2hhbm5lbHMve2lkfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRXhwb3J0IGNoYW5uZWxzIHN0YXR1c1xuICAgICAqL1xuICAgIGdldEV4cG9ydENoYW5uZWxzU3RhdHVzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgY2hhbm5lbCBvciByZXR1cm5zIGFuIGV4aXN0aW5nIG9uZSB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLmNyZWF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gdXNlci53YXRjaGluZy5zdGFydFxuICAgICAqIEdldCBvciBjcmVhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcXVlcnlgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5jaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBjaGFubmVsIG9yIHJldHVybnMgYW4gZXhpc3Rpbmcgb25lIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcyAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuY3JlYXRlZCAtIG1lbWJlci5hZGRlZCAtIG1lbWJlci5yZW1vdmVkIC0gbWVtYmVyLnVwZGF0ZWQgLSB1c2VyLndhdGNoaW5nLnN0YXJ0XG4gICAgICogR2V0IG9yIGNyZWF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T3JDcmVhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyBoaWRkZW4gZm9yIGN1cnJlbnQgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuaGlkZGVuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEhpZGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGhpZGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGhpZGVDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhpZGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2hpZGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaGlkZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgaGlkZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L2hpZGVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5oaWRlQ2hhbm5lbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgY2hhbm5lbCBhcyBoaWRkZW4gZm9yIGN1cnJlbnQgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuaGlkZGVuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEhpZGUgY2hhbm5lbFxuICAgICAqL1xuICAgIGhpZGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGlkZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVscyBhcyByZWFkIHVwIHRvIHRoZSBzcGVjaWZpYyBtZXNzYWdlLiBJZiBubyBjaGFubmVscyBpcyBnaXZlbiwgbWFyayBhbGwgY2hhbm5lbCBhcyByZWFkICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5yZWFkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgY2hhbm5lbHMgYXMgcmVhZFxuICAgICAqL1xuICAgIG1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya0NoYW5uZWxzUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya0NoYW5uZWxzUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvcmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1JlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1JlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21hcmtVbnJlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3VucmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtVbnJlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdXRlcyBjaGFubmVsIGZvciB1c2VyICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBNdXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICBtdXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tdXRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ211dGVDaGFubmVsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbXV0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vbXV0ZS9jaGFubmVsYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubXV0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIGNoYW5uZWwgZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlQ2hhbm5lbFxuICAgICAqIE11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIG11dGVDaGFubmVsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFubmVscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBjaGFubmVsc1xuICAgICAqL1xuICAgIHF1ZXJ5Q2hhbm5lbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncXVlcnlDaGFubmVsc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcXVlcnlDaGFubmVscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5xdWVyeUNoYW5uZWxzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBjaGFubmVscyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBjaGFubmVsc1xuICAgICAqL1xuICAgIHF1ZXJ5Q2hhbm5lbHMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeUNoYW5uZWxzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgbWVtYmVycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbWVtYmVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgbWVtYmVycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBRdWVyeSBtZW1iZXJzXG4gICAgICovXG4gICAgcXVlcnlNZW1iZXJzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5xdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3NlYXJjaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzIGFjcm9zcyBjaGFubmVscyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXNcbiAgICAgKi9cbiAgICBzZWFyY2gocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlYXJjaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByZXZpb3VzbHkgaGlkZGVuIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnZpc2libGVcbiAgICAgKiBTaG93IGNoYW5uZWxcbiAgICAgKi9cbiAgICBzaG93Q2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzaG93Q2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zaG93Q2hhbm5lbFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzaG93Q2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNob3dDaGFubmVsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNob3dDaGFubmVsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9zaG93YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2hvd0NoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByZXZpb3VzbHkgaGlkZGVuIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnZpc2libGVcbiAgICAgKiBTaG93IGNoYW5uZWxcbiAgICAgKi9cbiAgICBzaG93Q2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNob3dDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnRydW5jYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQ2hhbm5lbCAtIFRydW5jYXRlQ2hhbm5lbFxuICAgICAqIFRydW5jYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB0cnVuY2F0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cnVuY2F0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHRydW5jYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50cnVuY2F0ZUNoYW5uZWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3RydW5jYXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnRydW5jYXRlQ2hhbm5lbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cnVuY2F0ZUNoYW5uZWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3RydW5jYXRlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudHJ1bmNhdGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudHJ1bmNhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVDaGFubmVsIC0gVHJ1bmNhdGVDaGFubmVsXG4gICAgICogVHJ1bmNhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHRydW5jYXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnRydW5jYXRlQ2hhbm5lbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudW5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBVbm11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVubXV0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51bm11dGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51bm11dGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndW5tdXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5tdXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bm11dGUvY2hhbm5lbGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZUNoYW5uZWxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgY2hhbm5lbCBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwudW5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZUNoYW5uZWxcbiAgICAgKiBVbm11dGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVubXV0ZUNoYW5uZWwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bm11dGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICovXG4gICAgdW5yZWFkQ291bnRzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VucmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICogVW5yZWFkQ291bnQgY291bnRzXG4gICAgICovXG4gICAgdW5yZWFkQ291bnRzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bnJlYWRDb3VudHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSBjaGFubmVsIGRhdGEgIFNlbmRzIGV2ZW50czogLSBjaGFubmVsLnVwZGF0ZWQgLSBtZW1iZXIuYWRkZWQgLSBtZW1iZXIucmVtb3ZlZCAtIG1lbWJlci51cGRhdGVkIC0gbWVzc2FnZS5uZXcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZE93bkNoYW5uZWxNZW1iZXJzaGlwIC0gUmVtb3ZlT3duQ2hhbm5lbE1lbWJlcnNoaXAgLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plbiAtIFVwZGF0ZUNoYW5uZWxNZW1iZXJzXG4gICAgICogVXBkYXRlIGNoYW5uZWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGFubmVsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY2hhbm5lbCBkYXRhICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkIC0gbWVtYmVyLmFkZGVkIC0gbWVtYmVyLnJlbW92ZWQgLSBtZW1iZXIudXBkYXRlZCAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRPd25DaGFubmVsTWVtYmVyc2hpcCAtIFJlbW92ZU93bkNoYW5uZWxNZW1iZXJzaGlwIC0gVXBkYXRlQ2hhbm5lbCAtIFVwZGF0ZUNoYW5uZWxDb29sZG93biAtIFVwZGF0ZUNoYW5uZWxGcm96ZW4gLSBVcGRhdGVDaGFubmVsTWVtYmVyc1xuICAgICAqIFVwZGF0ZSBjaGFubmVsXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUNoYW5uZWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plblxuICAgICAqIFBhcnRpYWxseSB1cGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsUGFydGlhbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDaGFubmVsIC0gVXBkYXRlQ2hhbm5lbENvb2xkb3duIC0gVXBkYXRlQ2hhbm5lbEZyb3plblxuICAgICAqIFBhcnRpYWxseSB1cGRhdGUgY2hhbm5lbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2hhbm5lbFBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBDdXN0b21Db21tYW5kc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogQ3JlYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NyZWF0ZUNvbW1hbmRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDb21tYW5kUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NvbW1hbmRzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ29tbWFuZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogQ3JlYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY3VzdG9tIGNoYXQgY29tbWFuZFxuICAgICAqIERlbGV0ZSBjb21tYW5kXG4gICAgICovXG4gICAgZGVsZXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUNvbW1hbmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogRGVsZXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICBkZWxldGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VzdG9tIGNvbW1hbmQgYnkgaXRzIG5hbWVcbiAgICAgKiBHZXQgY29tbWFuZFxuICAgICAqL1xuICAgIGdldENvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29tbWFuZHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VzdG9tIGNvbW1hbmQgYnkgaXRzIG5hbWVcbiAgICAgKiBHZXQgY29tbWFuZFxuICAgICAqL1xuICAgIGdldENvbW1hbmQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRDb21tYW5kUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3VzdG9tIGNvbW1hbmRzXG4gICAgICogTGlzdCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3RDb21tYW5kc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3VzdG9tIGNvbW1hbmRzXG4gICAgICogTGlzdCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3RDb21tYW5kcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENvbW1hbmRzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1c3RvbSBjaGF0IGNvbW1hbmRcbiAgICAgKiBVcGRhdGUgY29tbWFuZFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbW1hbmRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNvbW1hbmRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNvbW1hbmRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVDb21tYW5kUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDb21tYW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jb21tYW5kcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ29tbWFuZFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjdXN0b20gY2hhdCBjb21tYW5kXG4gICAgICogVXBkYXRlIGNvbW1hbmRcbiAgICAgKi9cbiAgICB1cGRhdGVDb21tYW5kKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ29tbWFuZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIERldmljZXNBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRGV2aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBvbmUgZGV2aWNlXG4gICAgICogRGVsZXRlIGRldmljZVxuICAgICAqL1xuICAgIGRlbGV0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGRldmljZXNcbiAgICAgKiBMaXN0IGRldmljZXNcbiAgICAgKi9cbiAgICBsaXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdmFpbGFibGUgZGV2aWNlc1xuICAgICAqIExpc3QgZGV2aWNlc1xuICAgICAqL1xuICAgIGxpc3REZXZpY2VzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0RGV2aWNlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIEV2ZW50c0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogU2VuZHMgZXZlbnQgdG8gdGhlIGNoYW5uZWwgIFNlbmRzIGV2ZW50czogLSBhbnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlbmRDdXN0b21FdmVudFxuICAgICAqIFNlbmQgZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kRXZlbnRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRFdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRFdmVudFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L2V2ZW50YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZEV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBldmVudCB0byB0aGUgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIGFueSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEN1c3RvbUV2ZW50XG4gICAgICogU2VuZCBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgY3VzdG9tIGV2ZW50IHRvIGEgdXNlciAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbVxuICAgICAqIFNlbmQgdXNlciBldmVudFxuICAgICAqL1xuICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRVc2VyQ3VzdG9tRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZFVzZXJDdXN0b21FdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3NlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRVc2VyQ3VzdG9tRXZlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3t1c2VyX2lkfS9ldmVudGAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5zZW5kVXNlckN1c3RvbUV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGN1c3RvbSBldmVudCB0byBhIHVzZXIgIFNlbmRzIGV2ZW50czogLSBjdXN0b21cbiAgICAgKiBTZW5kIHVzZXIgZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kVXNlckN1c3RvbUV2ZW50KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFVzZXJDdXN0b21FdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIE1lc3NhZ2VzQXBpIGV4dGVuZHMgQmFzZUFQSSQxIHtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgdXBsb2FkZWQgZmlsZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBmaWxlXG4gICAgICovXG4gICAgZGVsZXRlRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZUZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXJsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZmlsZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZUF0dGFjaG1lbnRcbiAgICAgKiBEZWxldGUgZmlsZVxuICAgICAqL1xuICAgIGRlbGV0ZUZpbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVGaWxlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IHVwbG9hZGVkIGltYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVBdHRhY2htZW50XG4gICAgICogRGVsZXRlIGltYWdlXG4gICAgICovXG4gICAgZGVsZXRlSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlSW1hZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXJsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaW1hZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgcHJldmlvdXNseSB1cGxvYWRlZCBpbWFnZSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRGVsZXRlQXR0YWNobWVudFxuICAgICAqIERlbGV0ZSBpbWFnZVxuICAgICAqL1xuICAgIGRlbGV0ZUltYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlSW1hZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZU1lc3NhZ2VcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaGFyZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuaGFyZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVkQnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snZGVsZXRlZF9ieSddID0gcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlZEJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmRlbGV0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIERlbGV0ZU1lc3NhZ2VcbiAgICAgKiBEZWxldGUgbWVzc2FnZVxuICAgICAqL1xuICAgIGRlbGV0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyIHJlYWN0aW9uIGZyb20gdGhlIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVSZWFjdGlvblxuICAgICAqIERlbGV0ZSByZWFjdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3JlYWN0aW9uL3t0eXBlfWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyIHJlYWN0aW9uIGZyb20gdGhlIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5kZWxldGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBEZWxldGVSZWFjdGlvblxuICAgICAqIERlbGV0ZSByZWFjdGlvblxuICAgICAqL1xuICAgIGRlbGV0ZVJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUmVhY3Rpb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdmbGFnUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBmbGFnLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL2ZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIG1lc3NhZ2Ugb3IgdXNlciBmb3IgcmV2aWV3IGJ5IG1vZGVyYXRvcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLmZsYWdnZWQgLSB1c2VyLmZsYWdnZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEZsYWdNZXNzYWdlIC0gRmxhZ1VzZXJcbiAgICAgKiBGbGFnXG4gICAgICovXG4gICAgZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3QgbWVzc2FnZXMgZm91bmQgYnkgSURzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCBtYW55IG1lc3NhZ2VzXG4gICAgICovXG4gICAgZ2V0TWFueU1lc3NhZ2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0TWFueU1lc3NhZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRNYW55TWVzc2FnZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkcyddID0gcmVxdWVzdFBhcmFtZXRlcnMuaWRzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9tZXNzYWdlc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG1lc3NhZ2VzIGZvdW5kIGJ5IElEcyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWFueSBtZXNzYWdlc1xuICAgICAqL1xuICAgIGdldE1hbnlNZXNzYWdlcyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldE1hbnlNZXNzYWdlc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbWVzc2FnZSBieSBJRCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENoYW5uZWxcbiAgICAgKiBHZXQgbWVzc2FnZVxuICAgICAqL1xuICAgIGdldE1lc3NhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0TWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG1lc3NhZ2UgYnkgSUQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBnZXRNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0TWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBPcGVuR3JhcGggYXR0YWNobWVudCBmb3IgYSBsaW5rXG4gICAgICogR2V0IE9HXG4gICAgICovXG4gICAgZ2V0T0dSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1cmwnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9vZ2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIE9wZW5HcmFwaCBhdHRhY2htZW50IGZvciBhIGxpbmtcbiAgICAgKiBHZXQgT0dcbiAgICAgKi9cbiAgICBnZXRPRyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0T0dSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGxpc3Qgb2YgcmVhY3Rpb25zIG9mIHNwZWNpZmljIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlYWN0aW9uc1xuICAgICAqL1xuICAgIGdldFJlYWN0aW9uc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRSZWFjdGlvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5saW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydsaW1pdCddID0gcmVxdWVzdFBhcmFtZXRlcnMubGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ29mZnNldCddID0gcmVxdWVzdFBhcmFtZXRlcnMub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH0vcmVhY3Rpb25zYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBsaXN0IG9mIHJlYWN0aW9ucyBvZiBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCByZWFjdGlvbnNcbiAgICAgKi9cbiAgICBnZXRSZWFjdGlvbnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRSZWFjdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJlcGxpZXMgKHRocmVhZCkgb2YgdGhlIG1lc3NhZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogR2V0IHJlcGxpZXNcbiAgICAgKi9cbiAgICBnZXRSZXBsaWVzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3BhcmVudElkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5wYXJlbnRJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFJlcGxpZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEd0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9ndGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfZ3QnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkR3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWRMdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWRfbHRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZEx0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkX2x0J10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZEx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFmdGVyT3JFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2FmdGVyX29yX2VxdWFsJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRBZnRlck9yRXF1YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY3JlYXRlZF9hdF9hZnRlciddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlT3JFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2JlZm9yZV9vcl9lcXVhbCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QmVmb3JlT3JFcXVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQXRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snY3JlYXRlZF9hdF9iZWZvcmUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEJlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZEFyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydpZF9hcm91bmQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkQXJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRBdEFyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2F0X2Fyb3VuZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlZEF0QXJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3twYXJlbnRfaWR9L3JlcGxpZXNgLnJlcGxhY2UoYHske1wicGFyZW50X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMucGFyZW50SWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyByZXBsaWVzICh0aHJlYWQpIG9mIHRoZSBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIEdldCByZXBsaWVzXG4gICAgICovXG4gICAgZ2V0UmVwbGllcyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFJlcGxpZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVscyBhcyByZWFkIHVwIHRvIHRoZSBzcGVjaWZpYyBtZXNzYWdlLiBJZiBubyBjaGFubmVscyBpcyBnaXZlbiwgbWFyayBhbGwgY2hhbm5lbCBhcyByZWFkICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5yZWFkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgY2hhbm5lbHMgYXMgcmVhZFxuICAgICAqL1xuICAgIG1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5tYXJrQ2hhbm5lbHNSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya0NoYW5uZWxzUmVhZFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya0NoYW5uZWxzUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMvcmVhZGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtDaGFubmVsc1JlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWxzIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UuIElmIG5vIGNoYW5uZWxzIGlzIGdpdmVuLCBtYXJrIGFsbCBjaGFubmVsIGFzIHJlYWQgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayBjaGFubmVscyBhcyByZWFkXG4gICAgICovXG4gICAgbWFya0NoYW5uZWxzUmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtDaGFubmVsc1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbWFya1JlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1JlYWRSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbWFya1JlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrUmVhZFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtYXJrUmVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vcmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtSZWFkUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjaGFubmVsIGFzIHJlYWQgdXAgdG8gdGhlIHNwZWNpZmljIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnJlYWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogTWFyayByZWFkXG4gICAgICovXG4gICAgbWFya1JlYWQocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5tYXJrUmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubWFya1VucmVhZFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ21hcmtVbnJlYWRSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tYXJrVW5yZWFkUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG1hcmtVbnJlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoYW5uZWxzL3t0eXBlfS97aWR9L3VucmVhZGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtVbnJlYWRSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGNoYW5uZWwgYXMgdW5yZWFkIGZyb20gYSBzcGVjaWZpYyBtZXNzYWdlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIE1hcmsgdW5yZWFkXG4gICAgICovXG4gICAgbWFya1VucmVhZChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm1hcmtVbnJlYWRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgbWVzc2FnZSBmbGFncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZE1lc3NhZ2VGbGFnc1xuICAgICAqIFF1ZXJ5IE1lc3NhZ2UgRmxhZ3NcbiAgICAgKi9cbiAgICBxdWVyeU1lc3NhZ2VGbGFnc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21vZGVyYXRpb24vZmxhZ3MvbWVzc2FnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIG1lc3NhZ2UgZmxhZ3MgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRNZXNzYWdlRmxhZ3NcbiAgICAgKiBRdWVyeSBNZXNzYWdlIEZsYWdzXG4gICAgICovXG4gICAgcXVlcnlNZXNzYWdlRmxhZ3MocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVzc2FnZUZsYWdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgbWVzc2FnZSBjb21tYW5kIGFjdGlvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLm5ldyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUnVuTWVzc2FnZUFjdGlvblxuICAgICAqIFJ1biBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uXG4gICAgICovXG4gICAgcnVuTWVzc2FnZUFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBydW5NZXNzYWdlQWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm1lc3NhZ2VBY3Rpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdtZXNzYWdlQWN0aW9uUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubWVzc2FnZUFjdGlvblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBydW5NZXNzYWdlQWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L2FjdGlvbmAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5tZXNzYWdlQWN0aW9uUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBtZXNzYWdlIGNvbW1hbmQgYWN0aW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycyAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSdW5NZXNzYWdlQWN0aW9uXG4gICAgICogUnVuIG1lc3NhZ2UgY29tbWFuZCBhY3Rpb25cbiAgICAgKi9cbiAgICBydW5NZXNzYWdlQWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucnVuTWVzc2FnZUFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBtZXNzYWdlcyBhY3Jvc3MgY2hhbm5lbHMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogU2VhcmNoIG1lc3NhZ2VzXG4gICAgICovXG4gICAgc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3BheWxvYWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvc2VhcmNoYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggbWVzc2FnZXMgYWNyb3NzIGNoYW5uZWxzICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFNlYXJjaCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHNlYXJjaChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VhcmNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgbmV3IG1lc3NhZ2UgdG8gdGhlIHNwZWNpZmllZCBjaGFubmVsICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5uZXcgLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gQ3JlYXRlTWVzc2FnZSAtIFBpbk1lc3NhZ2UgLSBTa2lwQ2hhbm5lbENvb2xkb3duIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXNlRnJvemVuQ2hhbm5lbFxuICAgICAqIFNlbmQgbmV3IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzZW5kTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kTWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZW5kTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzZW5kTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVscy97dHlwZX0ve2lkfS9tZXNzYWdlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuc2VuZE1lc3NhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG5ldyBtZXNzYWdlIHRvIHRoZSBzcGVjaWZpZWQgY2hhbm5lbCAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UubmV3IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIENyZWF0ZU1lc3NhZ2UgLSBQaW5NZXNzYWdlIC0gU2tpcENoYW5uZWxDb29sZG93biAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIG5ldyBtZXNzYWdlXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIHJlYWN0aW9uIHRvIHNwZWNpZmllZCBtZXNzYWdlICBTZW5kcyBldmVudHM6IC0gcmVhY3Rpb24ubmV3IC0gcmVhY3Rpb24udXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQ3JlYXRlUmVhY3Rpb24gLSBVc2VGcm96ZW5DaGFubmVsXG4gICAgICogU2VuZCByZWFjdGlvblxuICAgICAqL1xuICAgIHNlbmRSZWFjdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzZW5kUmVhY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuc2VuZFJlYWN0aW9uUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdzZW5kUmVhY3Rpb25SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5zZW5kUmVhY3Rpb25SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZFJlYWN0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3JlYWN0aW9uYC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnNlbmRSZWFjdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgcmVhY3Rpb24gdG8gc3BlY2lmaWVkIG1lc3NhZ2UgIFNlbmRzIGV2ZW50czogLSByZWFjdGlvbi5uZXcgLSByZWFjdGlvbi51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVSZWFjdGlvbiAtIFVzZUZyb3plbkNoYW5uZWxcbiAgICAgKiBTZW5kIHJlYWN0aW9uXG4gICAgICovXG4gICAgc2VuZFJlYWN0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc2VuZFJlYWN0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBtZXNzYWdlIHRvIGEgZ2l2ZW4gbGFuZ3VhZ2UgdXNpbmcgYXV0b21hdGVkIHRyYW5zbGF0aW9uIHNvZnR3YXJlICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2hhbm5lbFxuICAgICAqIFRyYW5zbGF0ZSBtZXNzYWdlXG4gICAgICovXG4gICAgdHJhbnNsYXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cmFuc2xhdGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHJhbnNsYXRlTWVzc2FnZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB0cmFuc2xhdGVNZXNzYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tZXNzYWdlcy97aWR9L3RyYW5zbGF0ZWAucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy50cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIG1lc3NhZ2UgdG8gYSBnaXZlbiBsYW5ndWFnZSB1c2luZyBhdXRvbWF0ZWQgdHJhbnNsYXRpb24gc29mdHdhcmUgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogVHJhbnNsYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB0cmFuc2xhdGVNZXNzYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudHJhbnNsYXRlTWVzc2FnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bmZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2VyIG9yIG1lc3NhZ2UgZmxhZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIFVuZmxhZ1xuICAgICAqL1xuICAgIHVuZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgbWVzc2FnZSB3aXRoIG5ldyBkYXRhICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBBZGRMaW5rcyAtIFBpbk1lc3NhZ2UgLSBTa2lwTWVzc2FnZU1vZGVyYXRpb24gLSBVcGRhdGVNZXNzYWdlXG4gICAgICogVXBkYXRlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZU1lc3NhZ2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBtZXNzYWdlIHdpdGggbmV3IGRhdGEgIFNlbmRzIGV2ZW50czogLSBtZXNzYWdlLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEFkZExpbmtzIC0gUGluTWVzc2FnZSAtIFNraXBNZXNzYWdlTW9kZXJhdGlvbiAtIFVwZGF0ZU1lc3NhZ2VcbiAgICAgKiBVcGRhdGUgbWVzc2FnZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVNZXNzYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjZXJ0YWluIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFBhcnRpYWxseSBtZXNzYWdlIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlTWVzc2FnZVBhcnRpYWxSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlTWVzc2FnZVBhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL21lc3NhZ2VzL3tpZH1gLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVNZXNzYWdlUGFydGlhbFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjZXJ0YWluIGZpZWxkcyBvZiB0aGUgbWVzc2FnZSAgU2VuZHMgZXZlbnRzOiAtIG1lc3NhZ2UudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQWRkTGlua3MgLSBQaW5NZXNzYWdlIC0gU2tpcE1lc3NhZ2VNb2RlcmF0aW9uIC0gVXBkYXRlTWVzc2FnZVxuICAgICAqIFBhcnRpYWxseSBtZXNzYWdlIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlTWVzc2FnZVBhcnRpYWxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGZpbGUgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgZmlsZVxuICAgICAqL1xuICAgIHVwbG9hZEZpbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRGaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRGaWxlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uc3VtZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBjb250ZW50VHlwZTogJ211bHRpcGFydC9mb3JtLWRhdGEnIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogY2FuQ29uc3VtZUZvcm0gbWF5IGJlIHVudXNlZFxuICAgICAgICAgICAgY2FuQ29uc3VtZUZvcm0oY29uc3VtZXMpO1xuICAgICAgICAgICAgbGV0IGZvcm1QYXJhbXM7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5maWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3JtUGFyYW1zLmFwcGVuZCgnZmlsZScsIHJlcXVlc3RQYXJhbWV0ZXJzLmZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vZmlsZWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGZvcm1QYXJhbXMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBmaWxlICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGxvYWRBdHRhY2htZW50XG4gICAgICogVXBsb2FkIGZpbGVcbiAgICAgKi9cbiAgICB1cGxvYWRGaWxlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBsb2FkRmlsZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgaW1hZ2VcbiAgICAgKi9cbiAgICB1cGxvYWRJbWFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwbG9hZEltYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGxvYWRJbWFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVzID0gW1xuICAgICAgICAgICAgICAgIHsgY29udGVudFR5cGU6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGNhbkNvbnN1bWVGb3JtIG1heSBiZSB1bnVzZWRcbiAgICAgICAgICAgIGNhbkNvbnN1bWVGb3JtKGNvbnN1bWVzKTtcbiAgICAgICAgICAgIGxldCBmb3JtUGFyYW1zO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9ybVBhcmFtcy5hcHBlbmQoJ2ZpbGUnLCByZXF1ZXN0UGFyYW1ldGVycy5maWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cGxvYWRTaXplcykge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1cGxvYWRfc2l6ZXMnLCByZXF1ZXN0UGFyYW1ldGVycy51cGxvYWRTaXplcy5qb2luKENPTExFQ1RJT05fRk9STUFUU1tcImNzdlwiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcm1QYXJhbXMuYXBwZW5kKCd1c2VyJywgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXIpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHMve3R5cGV9L3tpZH0vaW1hZ2VgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtUGFyYW1zLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgaW1hZ2UgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwbG9hZEF0dGFjaG1lbnRcbiAgICAgKiBVcGxvYWQgaW1hZ2VcbiAgICAgKi9cbiAgICB1cGxvYWRJbWFnZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwbG9hZEltYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgUGVybWlzc2lvbnNWMkFwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjdXN0b20gcm9sZVxuICAgICAqIENyZWF0ZSByb2xlXG4gICAgICovXG4gICAgY3JlYXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVSb2xlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlUm9sZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVSb2xlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZVJvbGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY3VzdG9tIHJvbGVcbiAgICAgKiBDcmVhdGUgcm9sZVxuICAgICAqL1xuICAgIGNyZWF0ZVJvbGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVSb2xlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gcm9sZVxuICAgICAqIERlbGV0ZSByb2xlXG4gICAgICovXG4gICAgZGVsZXRlUm9sZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVJvbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yb2xlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjdXN0b20gcm9sZVxuICAgICAqIERlbGV0ZSByb2xlXG4gICAgICovXG4gICAgZGVsZXRlUm9sZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVJvbGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGN1c3RvbSBwZXJtaXNzaW9uXG4gICAgICogR2V0IHBlcm1pc3Npb25cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFBlcm1pc3Npb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wZXJtaXNzaW9ucy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXN0b20gcGVybWlzc2lvblxuICAgICAqIEdldCBwZXJtaXNzaW9uXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvbihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldFBlcm1pc3Npb25SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIHBlcm1pc3Npb25zXG4gICAgICogTGlzdCBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIGxpc3RQZXJtaXNzaW9uc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wZXJtaXNzaW9uc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSBwZXJtaXNzaW9uc1xuICAgICAqIExpc3QgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICBsaXN0UGVybWlzc2lvbnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQZXJtaXNzaW9uc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIGF2YWlsYWJsZSByb2xlc1xuICAgICAqIExpc3Qgcm9sZXNcbiAgICAgKi9cbiAgICBsaXN0Um9sZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcm9sZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgcm9sZXNcbiAgICAgKiBMaXN0IHJvbGVzXG4gICAgICovXG4gICAgbGlzdFJvbGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Um9sZXNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFB1c2hBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVEZXZpY2VSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlRGV2aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9kZXZpY2VzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlRGV2aWNlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRldmljZSB0byBhIHVzZXIsIGlmIHRoZSBzYW1lIGRldmljZSBhbHJlYWR5IGV4aXN0cyB0aGUgY2FsbCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICogQ3JlYXRlIGRldmljZVxuICAgICAqL1xuICAgIGNyZWF0ZURldmljZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlUHVzaFByb3ZpZGVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnMve3R5cGV9L3tuYW1lfWAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXIgZnJvbSB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnQuIHYxIGlzblxcJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW5kcG9pbnRcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgZGVsZXRlUHVzaFByb3ZpZGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlUHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvcHVzaF9wcm92aWRlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZGV0YWlscyBvZiBhbGwgcHVzaCBwcm92aWRlcnMuXG4gICAgICogTGlzdCBwdXNoIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIGxpc3RQdXNoUHJvdmlkZXJzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQ2hhdCBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjkyLjcuMFxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xubGV0IFNlcnZlclNpZGVBcGkkMSA9IGNsYXNzIFNlcnZlclNpZGVBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXIgZm9yIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydFxuICAgICAqIFVwc2VydCBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICB1cHNlcnRQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51cHNlcnRQdXNoUHJvdmlkZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Vwc2VydFB1c2hQcm92aWRlclJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVwc2VydFB1c2hQcm92aWRlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cHNlcnRQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3B1c2hfcHJvdmlkZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcHNlcnQgYSBwdXNoIHByb3ZpZGVyIGZvciB2MiB3aXRoIG11bHRpIGJ1bmRsZS9wYWNrYWdlIHN1cHBvcnRcbiAgICAgKiBVcHNlcnQgYSBwdXNoIHByb3ZpZGVyXG4gICAgICovXG4gICAgdXBzZXJ0UHVzaFByb3ZpZGVyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBzZXJ0UHVzaFByb3ZpZGVyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmxldCBTZXR0aW5nc0FwaSQxID0gY2xhc3MgU2V0dGluZ3NBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdGVzdCBtZXNzYWdlIHZpYSBwdXNoLCB0aGlzIGlzIGEgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgeW91ciBwdXNoIHNldHRpbmdzXG4gICAgICogQ2hlY2sgcHVzaFxuICAgICAqL1xuICAgIGNoZWNrUHVzaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tQdXNoUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrUHVzaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfcHVzaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTTlNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NOUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU05TIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBDaGVjayBTTlNcbiAgICAgKi9cbiAgICBjaGVja1NOUyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTUVMgY3JlZGVudGlhbHNcbiAgICAgKiBDaGVjayBTUVNcbiAgICAgKi9cbiAgICBjaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NoZWNrU1FTUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tTUVMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoZWNrX3Nxc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTUVNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGJsb2NrbGlzdCwgb25jZSBjcmVhdGVkIHRoZSBibG9ja2xpc3QgY2FuIGJlIHVzZWQgYnkgYW55IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdjcmVhdGVCbG9ja0xpc3RSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVCbG9ja0xpc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlQmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQmxvY2tMaXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFwcGxpY2F0aW9uIGJsb2NrbGlzdCwgb25jZSBjcmVhdGVkIHRoZSBibG9ja2xpc3QgY2FuIGJlIHVzZWQgYnkgYW55IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBibG9jayBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlQmxvY2tMaXN0KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQmxvY2tMaXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgY2hhbm5lbCB0eXBlXG4gICAgICogQ3JlYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGNoYW5uZWwgdHlwZVxuICAgICAqIENyZWF0ZSBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBwcmV2aW91c2x5IGNyZWF0ZWQgYXBwbGljYXRpb24gYmxvY2tsaXN0XG4gICAgICogRGVsZXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBkZWxldGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHByZXZpb3VzbHkgY3JlYXRlZCBhcHBsaWNhdGlvbiBibG9ja2xpc3RcbiAgICAgKiBEZWxldGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGRlbGV0ZUJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9jaGFubmVsdHlwZXMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogRGVsZXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNoYW5uZWxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2hhbm5lbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwdXNoIHByb3ZpZGVyIGZyb20gdjIgd2l0aCBtdWx0aSBidW5kbGUvcGFja2FnZSBzdXBwb3J0LiB2MSBpc25cXCd0IHN1cHBvcnRlZCBpbiB0aGlzIGVuZHBvaW50XG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlclxuICAgICAqL1xuICAgIGRlbGV0ZVB1c2hQcm92aWRlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlbGV0ZVB1c2hQcm92aWRlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVQdXNoUHJvdmlkZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVycy97dHlwZX0ve25hbWV9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHVzaCBwcm92aWRlciBmcm9tIHYyIHdpdGggbXVsdGkgYnVuZGxlL3BhY2thZ2Ugc3VwcG9ydC4gdjEgaXNuXFwndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbmRwb2ludFxuICAgICAqIERlbGV0ZSBhIHB1c2ggcHJvdmlkZXJcbiAgICAgKi9cbiAgICBkZWxldGVQdXNoUHJvdmlkZXIocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVQdXNoUHJvdmlkZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIEdldCBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRBcHBSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYXBwYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIEdldCBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRBcHAoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldEFwcFJhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBibG9jayBsaXN0IGJ5IGdpdmVuIG5hbWVcbiAgICAgKiBHZXQgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIGdldEJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldEJsb2NrTGlzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHMve25hbWV9YC5yZXBsYWNlKGB7JHtcIm5hbWVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5uYW1lKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYmxvY2sgbGlzdCBieSBnaXZlbiBuYW1lXG4gICAgICogR2V0IGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICBnZXRCbG9ja0xpc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbmFtZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldENoYW5uZWxUeXBlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNoYW5uZWwgdHlwZVxuICAgICAqIEdldCBjaGFubmVsIHR5cGVcbiAgICAgKi9cbiAgICBnZXRDaGFubmVsVHlwZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldENoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJhdGUgbGltaXRzIHVzYWdlIGFuZCBxdW90YXNcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHNcbiAgICAgKi9cbiAgICBnZXRSYXRlTGltaXRzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5zZXJ2ZXJTaWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3NlcnZlcl9zaWRlJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5zZXJ2ZXJTaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmFuZHJvaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snYW5kcm9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMuYW5kcm9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaW9zJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMud2ViICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3dlYiddID0gcmVxdWVzdFBhcmFtZXRlcnMud2ViO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmVuZHBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydlbmRwb2ludHMnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmVuZHBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9yYXRlX2xpbWl0c2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHJhdGUgbGltaXRzIHVzYWdlIGFuZCBxdW90YXNcbiAgICAgKiBHZXQgcmF0ZSBsaW1pdHNcbiAgICAgKi9cbiAgICBnZXRSYXRlTGltaXRzKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRSYXRlTGltaXRzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGJsb2NrIGxpc3RzXG4gICAgICogTGlzdCBibG9jayBsaXN0c1xuICAgICAqL1xuICAgIGxpc3RCbG9ja0xpc3RzUmF3KGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2Jsb2NrbGlzdHNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBibG9jayBsaXN0c1xuICAgICAqIExpc3QgYmxvY2sgbGlzdHNcbiAgICAgKi9cbiAgICBsaXN0QmxvY2tMaXN0cyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdEJsb2NrTGlzdHNSYXcoaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBhdmFpbGFibGUgY2hhbm5lbCB0eXBlc1xuICAgICAqIExpc3QgY2hhbm5lbCB0eXBlc1xuICAgICAqL1xuICAgIGxpc3RDaGFubmVsVHlwZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgYXZhaWxhYmxlIGNoYW5uZWwgdHlwZXNcbiAgICAgKiBMaXN0IGNoYW5uZWwgdHlwZXNcbiAgICAgKi9cbiAgICBsaXN0Q2hhbm5lbFR5cGVzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0Q2hhbm5lbFR5cGVzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGRldGFpbHMgb2YgYWxsIHB1c2ggcHJvdmlkZXJzLlxuICAgICAqIExpc3QgcHVzaCBwcm92aWRlcnNcbiAgICAgKi9cbiAgICBsaXN0UHVzaFByb3ZpZGVyc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9wdXNoX3Byb3ZpZGVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBkZXRhaWxzIG9mIGFsbCBwdXNoIHByb3ZpZGVycy5cbiAgICAgKiBMaXN0IHB1c2ggcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdFB1c2hQcm92aWRlcnMoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RQdXNoUHJvdmlkZXJzUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIG9uZSBvciBtb3JlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAgICogVXBkYXRlIEFwcCBTZXR0aW5nc1xuICAgICAqL1xuICAgIHVwZGF0ZUFwcFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUFwcFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQXBwUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQXBwUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUFwcC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvYXBwYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUFwcFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXBkYXRlcyBvbmUgb3IgbW9yZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgICAqIFVwZGF0ZSBBcHAgU2V0dGluZ3NcbiAgICAgKi9cbiAgICB1cGRhdGVBcHAocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVBcHBSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNvbnRlbnRzIG9mIHRoZSBibG9jayBsaXN0XG4gICAgICogVXBkYXRlIGJsb2NrIGxpc3RcbiAgICAgKi9cbiAgICB1cGRhdGVCbG9ja0xpc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVCbG9ja0xpc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQmxvY2tMaXN0UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1cGRhdGVCbG9ja0xpc3RSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQmxvY2tMaXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ibG9ja2xpc3RzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVCbG9ja0xpc3RSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udGVudHMgb2YgdGhlIGJsb2NrIGxpc3RcbiAgICAgKiBVcGRhdGUgYmxvY2sgbGlzdFxuICAgICAqL1xuICAgIHVwZGF0ZUJsb2NrTGlzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVwZGF0ZUJsb2NrTGlzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY2hhbm5lbCB0eXBlXG4gICAgICogVXBkYXRlIGNoYW5uZWwgdHlwZVxuICAgICAqL1xuICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2hhbm5lbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDaGFubmVsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hhbm5lbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVDaGFubmVsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjaGFubmVsIHR5cGVcbiAgICAgKiBVcGRhdGUgY2hhbm5lbCB0eXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2hhbm5lbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDaGFubmVsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBUYXNrc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgYSB0YXNrXG4gICAgICogR2V0IHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKi9cbiAgICBnZXRUYXNrUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldFRhc2suJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC90YXNrcy97aWR9YC5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBzdGF0dXMgb2YgYSB0YXNrXG4gICAgICogR2V0IHN0YXR1cyBvZiBhIHRhc2tcbiAgICAgKi9cbiAgICBnZXRUYXNrKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0VGFza1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIENoYXQgQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHY5Mi43LjBcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG4vKipcbiAqXG4gKi9cbmNsYXNzIFRlc3RpbmdBcGkgZXh0ZW5kcyBCYXNlQVBJJDEge1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdGVzdCBtZXNzYWdlIHZpYSBwdXNoLCB0aGlzIGlzIGEgdGVzdCBlbmRwb2ludCB0byB2ZXJpZnkgeW91ciBwdXNoIHNldHRpbmdzXG4gICAgICogQ2hlY2sgcHVzaFxuICAgICAqL1xuICAgIGNoZWNrUHVzaFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tQdXNoUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tQdXNoUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNoZWNrUHVzaC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfcHVzaGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrUHVzaFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0ZXN0IG1lc3NhZ2UgdmlhIHB1c2gsIHRoaXMgaXMgYSB0ZXN0IGVuZHBvaW50IHRvIHZlcmlmeSB5b3VyIHB1c2ggc2V0dGluZ3NcbiAgICAgKiBDaGVjayBwdXNoXG4gICAgICovXG4gICAgY2hlY2tQdXNoKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tQdXNoUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTTlMgY29uZmlndXJhdGlvblxuICAgICAqIENoZWNrIFNOU1xuICAgICAqL1xuICAgIGNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU05TUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnY2hlY2tTTlNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NOU1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjaGVja1NOUy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY2hlY2tfc25zYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTTlNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBBbWF6b24gU05TIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBDaGVjayBTTlNcbiAgICAgKi9cbiAgICBjaGVja1NOUyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNoZWNrU05TUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIEFtYXpvbiBTUVMgY3JlZGVudGlhbHNcbiAgICAgKiBDaGVjayBTUVNcbiAgICAgKi9cbiAgICBjaGVja1NRU1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5jaGVja1NRU1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2NoZWNrU1FTUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuY2hlY2tTUVNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tTUVMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2NoZWNrX3Nxc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmNoZWNrU1FTUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgQW1hem9uIFNRUyBjcmVkZW50aWFsc1xuICAgICAqIENoZWNrIFNRU1xuICAgICAqL1xuICAgIGNoZWNrU1FTKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2hlY2tTUVNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBDaGF0IEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2OTIuNy4wXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBVc2Vyc0FwaSBleHRlbmRzIEJhc2VBUEkkMSB7XG4gICAgLyoqXG4gICAgICogUmVzdHJpY3RzIHVzZXIgYWN0aXZpdHkgZWl0aGVyIGluIHNwZWNpZmljIGNoYW5uZWwgb3IgZ2xvYmFsbHkgIFNlbmRzIGV2ZW50czogLSB1c2VyLmJhbm5lZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQmFuQ2hhbm5lbE1lbWJlciAtIEJhblVzZXJcbiAgICAgKiBCYW4gdXNlclxuICAgICAqL1xuICAgIGJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmJhblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnYmFuUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuYmFuUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJhbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9iYW5gLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5iYW5SZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RyaWN0cyB1c2VyIGFjdGl2aXR5IGVpdGhlciBpbiBzcGVjaWZpYyBjaGFubmVsIG9yIGdsb2JhbGx5ICBTZW5kcyBldmVudHM6IC0gdXNlci5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogQmFuIHVzZXJcbiAgICAgKi9cbiAgICBiYW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5iYW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyBXZWJTb2NrZXQgY29ubmVjdGlvbiBmb3IgdXNlciAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICBjb25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2pzb24nXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvY29ubmVjdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBDb25uZWN0IChXZWJTb2NrZXQpXG4gICAgICovXG4gICAgY29ubmVjdChyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBndWVzdCB1c2VyXG4gICAgICogQ3JlYXRlIGd1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlR3Vlc3RSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5ndWVzdFJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZ3Vlc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdndWVzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUd1ZXN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9ndWVzdGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmd1ZXN0UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGd1ZXN0IHVzZXJcbiAgICAgKiBDcmVhdGUgZ3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmNyZWF0ZUd1ZXN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgdXNlciB3aXRoIHBvc3NpYmlsaXR5IHRvIGFjdGl2YXRlIGl0IGJhY2sgIFNlbmRzIGV2ZW50czogLSB1c2VyLmRlYWN0aXZhdGVkXG4gICAgICogRGVhY3RpdmF0ZSB1c2VyXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1c2VySWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGRlYWN0aXZhdGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2RlYWN0aXZhdGVVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3t1c2VyX2lkfS9kZWFjdGl2YXRlYC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlcyB1c2VyIHdpdGggcG9zc2liaWxpdHkgdG8gYWN0aXZhdGUgaXQgYmFjayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlYWN0aXZhdGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5kZWFjdGl2YXRlZFxuICAgICAqIERlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2RlYWN0aXZhdGVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmRlYWN0aXZhdGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWFjdGl2YXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL2RlYWN0aXZhdGVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5kZWFjdGl2YXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGUgdXNlcnMgaW4gYmF0Y2hlcyAgU2VuZHMgZXZlbnRzOiAtIHVzZXIuZGVhY3RpdmF0ZWRcbiAgICAgKiBEZWFjdGl2YXRlIHVzZXJzXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVhY3RpdmF0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VyIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzLiBUaGUgRW5kcG9pbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcXCdEZWxldGUgVXNlcnNcXCcgZW5kcG9pbnQgaW5zdGVhZCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIG1lc3NhZ2UuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICovXG4gICAgZGVsZXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm1hcmtNZXNzYWdlc0RlbGV0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snbWFya19tZXNzYWdlc19kZWxldGVkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5tYXJrTWVzc2FnZXNEZWxldGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmREZWxldGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaGFyZF9kZWxldGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmhhcmREZWxldGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ29udmVyc2F0aW9uQ2hhbm5lbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snZGVsZXRlX2NvbnZlcnNhdGlvbl9jaGFubmVscyddID0gcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlQ29udmVyc2F0aW9uQ2hhbm5lbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9YC5yZXBsYWNlKGB7JHtcInVzZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB1c2VyIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzLiBUaGUgRW5kcG9pbnQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBcXCdEZWxldGUgVXNlcnNcXCcgZW5kcG9pbnQgaW5zdGVhZCAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIG1lc3NhZ2UuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSB1c2VyXG4gICAgICovXG4gICAgZGVsZXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmRlbGV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHVzZXJzIGFuZCBvcHRpb25hbGx5IGFsbCB0aGVpciBiZWxvbmdpbmdzIGFzeW5jaHJvbm91c2x5LiAgU2VuZHMgZXZlbnRzOiAtIGNoYW5uZWwuZGVsZXRlZCAtIHVzZXIuZGVsZXRlZFxuICAgICAqIERlbGV0ZSBVc2Vyc1xuICAgICAqL1xuICAgIGRlbGV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmRlbGV0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZGVsZXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5kZWxldGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvZGVsZXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZGVsZXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdXNlcnMgYW5kIG9wdGlvbmFsbHkgYWxsIHRoZWlyIGJlbG9uZ2luZ3MgYXN5bmNocm9ub3VzbHkuICBTZW5kcyBldmVudHM6IC0gY2hhbm5lbC5kZWxldGVkIC0gdXNlci5kZWxldGVkXG4gICAgICogRGVsZXRlIFVzZXJzXG4gICAgICovXG4gICAgZGVsZXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHVzZXJcXCdzIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMuIFJhaXNlcyBhbiBlcnJvciBpZiBhIHVzZXIgaGFzIG1vcmUgdGhhbiAxMGsgbWVzc2FnZXMgb3IgcmVhY3Rpb25zXG4gICAgICogRXhwb3J0IHVzZXJcbiAgICAgKi9cbiAgICBleHBvcnRVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXNlcklkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBleHBvcnRVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L2V4cG9ydGAucmVwbGFjZShgeyR7XCJ1c2VyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudXNlcklkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHVzZXJcXCdzIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMuIFJhaXNlcyBhbiBlcnJvciBpZiBhIHVzZXIgaGFzIG1vcmUgdGhhbiAxMGsgbWVzc2FnZXMgb3IgcmVhY3Rpb25zXG4gICAgICogRXhwb3J0IHVzZXJcbiAgICAgKi9cbiAgICBleHBvcnRVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZXhwb3J0VXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdXNlciBwcm9maWxlLCByZWFjdGlvbnMgYW5kIG1lc3NhZ2VzIGZvciBsaXN0IG9mIGdpdmVuIHVzZXJzXG4gICAgICogRXhwb3J0IHVzZXJzXG4gICAgICovXG4gICAgZXhwb3J0VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZXhwb3J0VXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCdleHBvcnRVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmV4cG9ydFVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGV4cG9ydFVzZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9leHBvcnQvdXNlcnNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5leHBvcnRVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB1c2VyIHByb2ZpbGUsIHJlYWN0aW9ucyBhbmQgbWVzc2FnZXMgZm9yIGxpc3Qgb2YgZ2l2ZW4gdXNlcnNcbiAgICAgKiBFeHBvcnQgdXNlcnNcbiAgICAgKi9cbiAgICBleHBvcnRVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmV4cG9ydFVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBtZXNzYWdlIG9yIHVzZXIgZm9yIHJldmlldyBieSBtb2RlcmF0b3JzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5mbGFnZ2VkIC0gdXNlci5mbGFnZ2VkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogRmxhZ1xuICAgICAqL1xuICAgIGZsYWdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnZmxhZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmZsYWdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9mbGFnYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBtZXNzYWdlIG9yIHVzZXIgZm9yIHJldmlldyBieSBtb2RlcmF0b3JzICBTZW5kcyBldmVudHM6IC0gbWVzc2FnZS5mbGFnZ2VkIC0gdXNlci5mbGFnZ2VkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogRmxhZ1xuICAgICAqL1xuICAgIGZsYWcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IGZhbGxiYWNrIHRyYW5zcG9ydCBlbmRwb2ludCAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIExvbmcgUG9sbCAoVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGxvbmdQb2xsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5qc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2pzb24nXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2Nvbm5lY3Rpb25faWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb25ncG9sbGAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IGZhbGxiYWNrIHRyYW5zcG9ydCBlbmRwb2ludCAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIExvbmcgUG9sbCAoVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGxvbmdQb2xsKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubG9uZ1BvbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgb25lIG9yIHNldmVyYWwgdXNlcnMgIFNlbmRzIGV2ZW50czogLSB1c2VyLm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIE11dGUgdXNlclxuICAgICAqL1xuICAgIG11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm11dGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgnbXV0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5tdXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9tdXRlYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMubXV0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11dGVzIG9uZSBvciBzZXZlcmFsIHVzZXJzICBTZW5kcyBldmVudHM6IC0gdXNlci5tdXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTXV0ZVVzZXJcbiAgICAgKiBNdXRlIHVzZXJcbiAgICAgKi9cbiAgICBtdXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLm11dGVVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgc2NvcGVkIG9yIGdsb2JhbCB1c2VyIGJhbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogUXVlcnkgQmFubmVkIFVzZXJzXG4gICAgICovXG4gICAgcXVlcnlCYW5uZWRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3F1ZXJ5X2Jhbm5lZF91c2Vyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbmQgZmlsdGVyIGNoYW5uZWwgc2NvcGVkIG9yIGdsb2JhbCB1c2VyIGJhbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDaGFubmVsXG4gICAgICogUXVlcnkgQmFubmVkIFVzZXJzXG4gICAgICovXG4gICAgcXVlcnlCYW5uZWRVc2VycyhyZXF1ZXN0UGFyYW1ldGVycyA9IHt9LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlCYW5uZWRVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgYW5kIGZpbHRlciB1c2VycyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VhcmNoVXNlclxuICAgICAqIFF1ZXJ5IHVzZXJzXG4gICAgICovXG4gICAgcXVlcnlVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydwYXlsb2FkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5wYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCBmaWx0ZXIgdXNlcnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFNlYXJjaFVzZXJcbiAgICAgKiBRdWVyeSB1c2Vyc1xuICAgICAqL1xuICAgIHF1ZXJ5VXNlcnMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5VXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdXNlciB3aG9cXCdzIGJlZW4gZGVhY3RpdmF0ZWQgcHJldmlvdXNseSAgU2VuZHMgZXZlbnRzOiAtIHVzZXIucmVhY3RpdmF0ZWRcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJcbiAgICAgKi9cbiAgICByZWFjdGl2YXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VzZXJJZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcmVhY3RpdmF0ZVVzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2VyUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVhY3RpdmF0ZVVzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5yZWFjdGl2YXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZWFjdGl2YXRlVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMve3VzZXJfaWR9L3JlYWN0aXZhdGVgLnJlcGxhY2UoYHske1widXNlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB1c2VyIHdob1xcJ3MgYmVlbiBkZWFjdGl2YXRlZCBwcmV2aW91c2x5ICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlclxuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVhY3RpdmF0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFjdGl2YXRlIHVzZXJzIGluIGJhdGNoZXMgIFNlbmRzIGV2ZW50czogLSB1c2VyLnJlYWN0aXZhdGVkXG4gICAgICogUmVhY3RpdmF0ZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlYWN0aXZhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgncmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMucmVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHJlYWN0aXZhdGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdXNlcnMvcmVhY3RpdmF0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlJDEocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhY3RpdmF0ZSB1c2VycyBpbiBiYXRjaGVzICBTZW5kcyBldmVudHM6IC0gdXNlci5yZWFjdGl2YXRlZFxuICAgICAqIFJlYWN0aXZhdGUgdXNlcnNcbiAgICAgKi9cbiAgICByZWFjdGl2YXRlVXNlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZWFjdGl2YXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHNvZnQgZGVsZXRlZCB1c2Vyc1xuICAgICAqIFJlc3RvcmUgdXNlcnNcbiAgICAgKi9cbiAgICByZXN0b3JlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yZXN0b3JlVXNlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3Jlc3RvcmVVc2Vyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnJlc3RvcmVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyByZXN0b3JlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzL3Jlc3RvcmVgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5yZXN0b3JlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc29mdCBkZWxldGVkIHVzZXJzXG4gICAgICogUmVzdG9yZSB1c2Vyc1xuICAgICAqL1xuICAgIHJlc3RvcmVVc2VycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlc3RvcmVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBhcHBsaWVkIGJhbiAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudW5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogVW5iYW4gdXNlclxuICAgICAqL1xuICAgIHVuYmFuUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50YXJnZXRVc2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndGFyZ2V0X3VzZXJfaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnRhcmdldFVzZXJJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3R5cGUnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1snaWQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNyZWF0ZWRCeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjcmVhdGVkX2J5J10gPSByZXF1ZXN0UGFyYW1ldGVycy5jcmVhdGVkQnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi9iYW5gLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBhcHBsaWVkIGJhbiAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudW5iYW5uZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJhbkNoYW5uZWxNZW1iZXIgLSBCYW5Vc2VyXG4gICAgICogVW5iYW4gdXNlclxuICAgICAqL1xuICAgIHVuYmFuKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51bmJhblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcHJldmlvdXNseSBjcmVhdGVkIHVzZXIgb3IgbWVzc2FnZSBmbGFnICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBGbGFnTWVzc2FnZSAtIEZsYWdVc2VyXG4gICAgICogVW5mbGFnXG4gICAgICovXG4gICAgdW5mbGFnUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuZmxhZ1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ2ZsYWdSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuZmxhZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvbW9kZXJhdGlvbi91bmZsYWdgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy5mbGFnUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZXZpb3VzbHkgY3JlYXRlZCB1c2VyIG9yIG1lc3NhZ2UgZmxhZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gRmxhZ01lc3NhZ2UgLSBGbGFnVXNlclxuICAgICAqIFVuZmxhZ1xuICAgICAqL1xuICAgIHVuZmxhZyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVuZmxhZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgcHJldmlvdXNseSBtdXRlZCB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIFVubXV0ZSB1c2VyXG4gICAgICovXG4gICAgdW5tdXRlVXNlclJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvciQxKCd1bm11dGVVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudW5tdXRlVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bm11dGVVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC9tb2RlcmF0aW9uL3VubXV0ZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVubXV0ZVVzZXJSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubXV0ZXMgcHJldmlvdXNseSBtdXRlZCB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci51bm11dGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlclxuICAgICAqIFVubXV0ZSB1c2VyXG4gICAgICovXG4gICAgdW5tdXRlVXNlcihyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVubXV0ZVVzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgb3IgY3JlYXRlIHVzZXJzIGluIGJ1bGsgIFNlbmRzIGV2ZW50czogLSB1c2VyLnVwZGF0ZWRcbiAgICAgKiBVcHNlcnQgdXNlcnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2Vyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJzUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2Vyc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yJDEoJ3VwZGF0ZVVzZXJzUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZSQxKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBvciBjcmVhdGUgdXNlcnMgaW4gYnVsayAgU2VuZHMgZXZlbnRzOiAtIHVzZXIudXBkYXRlZFxuICAgICAqIFVwc2VydCB1c2Vyc1xuICAgICAqL1xuICAgIHVwZGF0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci5wcmVzZW5jZS5jaGFuZ2VkIC0gdXNlci51cGRhdGVkXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSB1c2VyXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnNQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IkMSgndXBkYXRlVXNlclBhcnRpYWxSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy51cGRhdGVVc2VyUGFydGlhbFJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVVc2Vyc1BhcnRpYWwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3VzZXJzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnVwZGF0ZVVzZXJQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UkMShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNlcnRhaW4gZmllbGRzIG9mIHRoZSB1c2VyICBTZW5kcyBldmVudHM6IC0gdXNlci5wcmVzZW5jZS5jaGFuZ2VkIC0gdXNlci51cGRhdGVkXG4gICAgICogUGFydGlhbGx5IHVwZGF0ZSB1c2VyXG4gICAgICovXG4gICAgdXBkYXRlVXNlcnNQYXJ0aWFsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlcnNQYXJ0aWFsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFN0cmVhbUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCwgdHlwZSwgaWQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5kZWxldGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZGVsZXRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCAocmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDoge30pKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHVwZGF0ZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51cGRhdGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdXBkYXRlQ2hhbm5lbFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcnRpYWwgPSAodXBkYXRlQ2hhbm5lbFBhcnRpYWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS51cGRhdGVDaGFubmVsUGFydGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHVwZGF0ZUNoYW5uZWxQYXJ0aWFsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0T3JDcmVhdGUgPSAoY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jaGFubmVsc0FwaS5nZXRPckNyZWF0ZUNoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0OiBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0ICE9PSBudWxsICYmIGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgIT09IHZvaWQgMCA/IGNoYW5uZWxHZXRPckNyZWF0ZVJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgb3BlcmF0aW9uIGlzbid0IHlldCBpbXBsZW1lbnRlZGApO1xuICAgICAgICAgICAgICAgIC8vIGlmICghY2hhbm5lbEdldE9yQ3JlYXRlUmVxdWVzdD8uZGF0YT8ubWVtYmVycykge1xuICAgICAgICAgICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwcm92aWRlIG1lbWJlcnMgdG8gY3JlYXRlIGEgY2hhbm5lbCB3aXRob3V0IElEJyk7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jaGFubmVsc0FwaS5nZXRPckNyZWF0ZUNoYW5uZWxUeXBlMSh7dHlwZTogdGhpcy50eXBlLCBjaGFubmVsR2V0T3JDcmVhdGVSZXF1ZXN0fSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5pZCA9IHJlc3BvbnNlLmNoYW5uZWw/LmlkO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya1JlYWQgPSAobWFya1JlYWRSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5tYXJrUmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IG1hcmtSZWFkUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFya1VucmVhZCA9IChtYXJrVW5yZWFkUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkubWFya1VucmVhZChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IG1hcmtVbnJlYWRSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zaG93ID0gKHNob3dDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuc2hvd0NoYW5uZWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyBzaG93Q2hhbm5lbFJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhpZGUgPSAoaGlkZUNoYW5uZWxSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsc0FwaS5oaWRlQ2hhbm5lbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IGhpZGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJ1bmNhdGUgPSAodHJ1bmNhdGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkudHJ1bmNhdGVDaGFubmVsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdHJ1bmNhdGVDaGFubmVsUmVxdWVzdCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVlcnlNZW1iZXJzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnF1ZXJ5TWVtYmVycyh7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgcmVxdWVzdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdXRlID0gKG11dGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkubXV0ZUNoYW5uZWwoe1xuICAgICAgICAgICAgICAgIG11dGVDaGFubmVsUmVxdWVzdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtdXRlQ2hhbm5lbFJlcXVlc3QpLCB7IGNoYW5uZWxfY2lkczogW3RoaXMuY2lkXSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVubXV0ZSA9ICh1bm11dGVDaGFubmVsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkudW5tdXRlQ2hhbm5lbCh7XG4gICAgICAgICAgICAgICAgdW5tdXRlQ2hhbm5lbFJlcXVlc3Q6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdW5tdXRlQ2hhbm5lbFJlcXVlc3QpLCB7IGNoYW5uZWxfY2lkOiB0aGlzLmNpZCwgY2hhbm5lbF9jaWRzOiBbXSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiB0aGVyZSBpcyBwcm9iYWJseSBhbiBpc3N1ZSB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZSBoZXJlXG4gICAgICAgIC8vIHVwbG9hZEZpbGUgPSAob3B0aW9uczogT21pdDxPbWl0VHlwZUlkPFVwbG9hZEZpbGVSZXF1ZXN0PiwgJ2ZpbGUnPiwgZmlsZTogQnVmZmVyKSA9PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBsb2FkRmlsZSh7Li4ub3B0aW9ucywgLi4udGhpcy5iYXNlUmVxdWVzdCwgZmlsZTogZmlsZSBhcyBhbnkgYXMgc3RyaW5nfSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZGVsZXRlRmlsZSA9IChyZXF1ZXN0OiBPbWl0VHlwZUlkPERlbGV0ZUZpbGVSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZUZpbGUoey4uLnJlcXVlc3QsIC4uLnRoaXMuYmFzZVJlcXVlc3R9KTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB1cGxvYWRJbWFnZSA9IChyZXF1ZXN0OiBPbWl0VHlwZUlkPFVwbG9hZEltYWdlUmVxdWVzdD4pID0+IHtcbiAgICAgICAgLy8gICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS51cGxvYWRJbWFnZSh7Li4ucmVxdWVzdCwgLi4udGhpcy5iYXNlUmVxdWVzdH0pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGRlbGV0ZUltYWdlID0gKHJlcXVlc3Q6IE9taXRUeXBlSWQ8RGVsZXRlSW1hZ2VSZXF1ZXN0PikgPT4ge1xuICAgICAgICAvLyAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZUltYWdlKHsuLi5yZXF1ZXN0LCAuLi50aGlzLmJhc2VSZXF1ZXN0fSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSA9IChzZW5kTWVzc2FnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnNlbmRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgc2VuZE1lc3NhZ2VSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVNZXNzYWdlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLmRlbGV0ZU1lc3NhZ2UocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZSA9IChpZCwgdXBkYXRlTWVzc2FnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnVwZGF0ZU1lc3NhZ2UoeyBpZCwgdXBkYXRlTWVzc2FnZVJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZVBhcnRpYWwgPSAoaWQsIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudXBkYXRlTWVzc2FnZVBhcnRpYWwoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHVwZGF0ZU1lc3NhZ2VQYXJ0aWFsUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE1lc3NhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0TWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNYW55TWVzc2FnZXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0TWFueU1lc3NhZ2VzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGVNZXNzYWdlID0gKGlkLCB0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkudHJhbnNsYXRlTWVzc2FnZSh7IGlkLCB0cmFuc2xhdGVNZXNzYWdlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlc0Fyb3VuZCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc0FwaS5nZXRSZXBsaWVzKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldE9wZW5HcmFwaERhdGEgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0T0cocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VSZWFjdGlvbiA9IChtZXNzYWdlSWQsIHNlbmRSZWFjdGlvblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzQXBpLnNlbmRSZWFjdGlvbih7XG4gICAgICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBzZW5kUmVhY3Rpb25SZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlTWVzc2FnZVJlYWN0aW9uID0gKG1lc3NhZ2VJZCwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZGVsZXRlUmVhY3Rpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZDogbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRNZXNzYWdlUmVhY3Rpb25zID0gKG1lc3NhZ2VJZCwgcmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNBcGkuZ2V0UmVhY3Rpb25zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHsgaWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VuZEN1c3RvbUV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNBcGkuc2VuZEV2ZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgc2VuZEV2ZW50UmVxdWVzdDogeyBldmVudCB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuc3RyZWFtQ2xpZW50LmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5jaGFubmVsc0FwaSA9IG5ldyBDaGFubmVsc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlc0FwaSA9IG5ldyBNZXNzYWdlc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5ldmVudHNBcGkgPSBuZXcgRXZlbnRzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBnZXQgY2lkKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlUmVxdWVzdC50eXBlfToke3RoaXMuYmFzZVJlcXVlc3QuaWR9YDtcbiAgICB9XG4gICAgZ2V0IGJhc2VSZXF1ZXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGUgY2hhbm5lbCB3aXRoIGBnZXRPckNyZWF0ZWAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBTdHJlYW1DaGF0Q2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW1DbGllbnQpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1DbGllbnQgPSBzdHJlYW1DbGllbnQ7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1DaGFubmVsKHRoaXMuc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQmxvY2tMaXN0ID0gKGNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmNyZWF0ZUJsb2NrTGlzdCh7IGNyZWF0ZUJsb2NrTGlzdFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEJsb2NrTGlzdHMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5saXN0QmxvY2tMaXN0cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldEJsb2NrTGlzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5nZXRCbG9ja0xpc3QocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlQmxvY2tMaXN0ID0gKG5hbWUsIHVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLnVwZGF0ZUJsb2NrTGlzdCh7IG5hbWUsIHVwZGF0ZUJsb2NrTGlzdFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQmxvY2tMaXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmRlbGV0ZUJsb2NrTGlzdChyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVDaGFubmVsVHlwZSA9IChjcmVhdGVDaGFubmVsVHlwZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxUeXBlc0FwaS5jcmVhdGVDaGFubmVsVHlwZSh7IGNyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDaGFubmVsVHlwZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkuZGVsZXRlQ2hhbm5lbFR5cGUocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Q2hhbm5lbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLmdldENoYW5uZWxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RDaGFubmVsVHlwZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsVHlwZXNBcGkubGlzdENoYW5uZWxUeXBlcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNoYW5uZWxUeXBlID0gKG5hbWUsIHVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGVzQXBpLnVwZGF0ZUNoYW5uZWxUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnF1ZXJ5Q2hhbm5lbHMgPSAocXVlcnlDaGFubmVsc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLnF1ZXJ5Q2hhbm5lbHMoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5Q2hhbm5lbHNSZXF1ZXN0OiBxdWVyeUNoYW5uZWxzUmVxdWVzdCAhPT0gbnVsbCAmJiBxdWVyeUNoYW5uZWxzUmVxdWVzdCAhPT0gdm9pZCAwID8gcXVlcnlDaGFubmVsc1JlcXVlc3QgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VhcmNoTWVzc2FnZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuc2VhcmNoKHsgcGF5bG9hZCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRDaGFubmVscyA9IChleHBvcnRDaGFubmVsc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzQXBpLmV4cG9ydENoYW5uZWxzKHtcbiAgICAgICAgICAgICAgICBleHBvcnRDaGFubmVsc1JlcXVlc3Q6IGV4cG9ydENoYW5uZWxzUmVxdWVzdCAhPT0gbnVsbCAmJiBleHBvcnRDaGFubmVsc1JlcXVlc3QgIT09IHZvaWQgMCA/IGV4cG9ydENoYW5uZWxzUmVxdWVzdCA6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRFeHBvcnRTdGF0dXMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNBcGkuZ2V0RXhwb3J0Q2hhbm5lbHNTdGF0dXMocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdENvbW1hbmRzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkubGlzdENvbW1hbmRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlQ29tbWFuZCA9IChjcmVhdGVDb21tYW5kUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHNBcGkuY3JlYXRlQ29tbWFuZCh7IGNyZWF0ZUNvbW1hbmRSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbW1hbmQgPSAoZ2V0Q29tbWFuZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLmdldENvbW1hbmQoZ2V0Q29tbWFuZFJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbW1hbmQgPSAobmFtZSwgdXBkYXRlQ29tbWFuZFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLnVwZGF0ZUNvbW1hbmQoeyBuYW1lLCB1cGRhdGVDb21tYW5kUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVDb21tYW5kID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzQXBpLmRlbGV0ZUNvbW1hbmQocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuc2V0dGluZ3NBcGkgPSBuZXcgU2V0dGluZ3NBcGkkMShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5jaGFubmVsVHlwZXNBcGkgPSBuZXcgQ2hhbm5lbFR5cGVzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxzQXBpID0gbmV3IENoYW5uZWxzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmNvbW1hbmRzQXBpID0gbmV3IEN1c3RvbUNvbW1hbmRzQXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIFN0cmVhbSBBUElcbiAqIE5vIGRlc2NyaXB0aW9uIHByb3ZpZGVkIChnZW5lcmF0ZWQgYnkgT3BlbmFwaSBHZW5lcmF0b3IgaHR0cHM6Ly9naXRodWIuY29tL29wZW5hcGl0b29scy9vcGVuYXBpLWdlbmVyYXRvcilcbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogdjEwMC40LjNcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5jb25zdCBCQVNFX1BBVEggPSBcImh0dHBzOi8vc3RyZWFtLWlvLWFwaS5jb21cIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvbiA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIHNldCBjb25maWcoY29uZmlndXJhdGlvbikge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggIT0gbnVsbCA/IHRoaXMuY29uZmlndXJhdGlvbi5iYXNlUGF0aCA6IEJBU0VfUEFUSDtcbiAgICB9XG4gICAgZ2V0IGZldGNoQXBpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmZldGNoQXBpO1xuICAgIH1cbiAgICBnZXQgbWlkZGxld2FyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5taWRkbGV3YXJlIHx8IFtdO1xuICAgIH1cbiAgICBnZXQgcXVlcnlQYXJhbXNTdHJpbmdpZnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24ucXVlcnlQYXJhbXNTdHJpbmdpZnkgfHwgcXVlcnlzdHJpbmc7XG4gICAgfVxuICAgIGdldCB1c2VybmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi51c2VybmFtZTtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnBhc3N3b3JkO1xuICAgIH1cbiAgICBnZXQgYXBpS2V5KCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5O1xuICAgICAgICBpZiAoYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFwaUtleSA9PT0gJ2Z1bmN0aW9uJyA/IGFwaUtleSA6ICgpID0+IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgYWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdGhpcy5jb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbicgPyBhY2Nlc3NUb2tlbiA6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIGFjY2Vzc1Rva2VuOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5oZWFkZXJzO1xuICAgIH1cbiAgICBnZXQgY3JlZGVudGlhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uY3JlZGVudGlhbHM7XG4gICAgfVxufVxuY29uc3QgRGVmYXVsdENvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKCk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWQgQVBJIGNsYXNzZXMuXG4gKi9cbmNsYXNzIEJhc2VBUEkge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24gPSBEZWZhdWx0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRoaXMuZmV0Y2hBcGkgPSAodXJsLCBpbml0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hQYXJhbXMgPSB7IHVybCwgaW5pdCB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIHRoaXMubWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGlmIChtaWRkbGV3YXJlLnByZSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFBhcmFtcyA9ICh5aWVsZCBtaWRkbGV3YXJlLnByZShPYmplY3QuYXNzaWduKHsgZmV0Y2g6IHRoaXMuZmV0Y2hBcGkgfSwgZmV0Y2hQYXJhbXMpKSkgfHwgZmV0Y2hQYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkICh0aGlzLmNvbmZpZ3VyYXRpb24uZmV0Y2hBcGkgfHwgZmV0Y2gpKGZldGNoUGFyYW1zLnVybCwgZmV0Y2hQYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZXdhcmUub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSAoeWllbGQgbWlkZGxld2FyZS5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZldGNoUGFyYW1zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmZXRjaFBhcmFtcy5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSA/IHJlc3BvbnNlLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZldGNoRXJyb3IoZSwgJ1RoZSByZXF1ZXN0IGZhaWxlZCBhbmQgdGhlIGludGVyY2VwdG9ycyBkaWQgbm90IHJldHVybiBhbiBhbHRlcm5hdGl2ZSByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiB0aGlzLm1pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWlkZGxld2FyZS5wb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gKHlpZWxkIG1pZGRsZXdhcmUucG9zdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZmV0Y2hQYXJhbXMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogZmV0Y2hQYXJhbXMuaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICB9KSkgfHwgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlID0gY29uZmlndXJhdGlvbi5taWRkbGV3YXJlO1xuICAgIH1cbiAgICB3aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBuZXh0Lm1pZGRsZXdhcmUgPSBuZXh0Lm1pZGRsZXdhcmUuY29uY2F0KC4uLm1pZGRsZXdhcmVzKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIHdpdGhQcmVNaWRkbGV3YXJlKC4uLnByZU1pZGRsZXdhcmVzKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gcHJlTWlkZGxld2FyZXMubWFwKChwcmUpID0+ICh7IHByZSB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmVzKTtcbiAgICB9XG4gICAgd2l0aFBvc3RNaWRkbGV3YXJlKC4uLnBvc3RNaWRkbGV3YXJlcykge1xuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IHBvc3RNaWRkbGV3YXJlcy5tYXAoKHBvc3QpID0+ICh7IHBvc3QgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoTWlkZGxld2FyZSguLi5taWRkbGV3YXJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBNSU1FIGlzIGEgSlNPTiBNSU1FLlxuICAgICAqIEpTT04gTUlNRSBleGFtcGxlczpcbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAgIGFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGOFxuICAgICAqICAgQVBQTElDQVRJT04vSlNPTlxuICAgICAqICAgYXBwbGljYXRpb24vdm5kLmNvbXBhbnkranNvblxuICAgICAqIEBwYXJhbSBtaW1lIC0gTUlNRSAoTXVsdGlwdXJwb3NlIEludGVybmV0IE1haWwgRXh0ZW5zaW9ucylcbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGdpdmVuIE1JTUUgaXMgSlNPTiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzSnNvbk1pbWUobWltZSkge1xuICAgICAgICBpZiAoIW1pbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmFzZUFQSS5qc29uUmVnZXgudGVzdChtaW1lKTtcbiAgICB9XG4gICAgcmVxdWVzdChjb250ZXh0LCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgaW5pdCB9ID0geWllbGQgdGhpcy5jcmVhdGVGZXRjaFBhcmFtcyhjb250ZXh0LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mZXRjaEFwaSh1cmwsIGluaXQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgJ1Jlc3BvbnNlIHJldHVybmVkIGFuIGVycm9yIGNvZGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUZldGNoUGFyYW1zKGNvbnRleHQsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYmFzZVBhdGggKyBjb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5xdWVyeSAhPT0gdW5kZWZpbmVkICYmIE9iamVjdC5rZXlzKGNvbnRleHQucXVlcnkpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoZSBxdWVyeXN0cmluZyB0byB0aGUgVVJMIGlmIHRoZXJlIGFyZSBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZG9uZSB0byBhdm9pZCB1cmxzIGVuZGluZyB3aXRoIGEgXCI/XCIgY2hhcmFjdGVyIHdoaWNoIGJ1Z2d5IHdlYnNlcnZlcnNcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaGFuZGxlIGNvcnJlY3RseSBzb21ldGltZXMuXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMuY29uZmlndXJhdGlvbi5xdWVyeVBhcmFtc1N0cmluZ2lmeShjb250ZXh0LnF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZ3VyYXRpb24uaGVhZGVycywgY29udGV4dC5oZWFkZXJzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IGhlYWRlcnNba2V5XSA9PT0gdW5kZWZpbmVkID8gZGVsZXRlIGhlYWRlcnNba2V5XSA6IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRPdmVycmlkZUZuID0gdHlwZW9mIGluaXRPdmVycmlkZXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gaW5pdE92ZXJyaWRlc1xuICAgICAgICAgICAgICAgIDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gaW5pdE92ZXJyaWRlczsgfSk7XG4gICAgICAgICAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBjb250ZXh0LmJvZHksXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY29uZmlndXJhdGlvbi5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZGVuSW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdFBhcmFtcyksICh5aWVsZCBpbml0T3ZlcnJpZGVGbih7XG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdFBhcmFtcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRkZW5Jbml0KSwgeyBib2R5OiBpc0Zvcm1EYXRhKG92ZXJyaWRkZW5Jbml0LmJvZHkpIHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRkZW5Jbml0LmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9iKG92ZXJyaWRkZW5Jbml0LmJvZHkpXG4gICAgICAgICAgICAgICAgICAgID8gb3ZlcnJpZGRlbkluaXQuYm9keVxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG92ZXJyaWRkZW5Jbml0LmJvZHkpIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXJsLCBpbml0IH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNsb25lIG9mIGB0aGlzYCBieSBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2VcbiAgICAgKiBhbmQgdGhlbiBzaGFsbG93IGNsb25pbmcgZGF0YSBtZW1iZXJzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXcgY29uc3RydWN0b3IodGhpcy5jb25maWd1cmF0aW9uKTtcbiAgICAgICAgbmV4dC5taWRkbGV3YXJlID0gdGhpcy5taWRkbGV3YXJlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgIH1cbn1cbkJhc2VBUEkuanNvblJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig6P2FwcGxpY2F0aW9uXFwvanNvbnxbXjsvIFxcdF0rXFwvW147LyBcXHRdK1srXWpzb24pWyBcXHRdKig6PzsuKik/JCcsICdpJyk7XG5mdW5jdGlvbiBpc0Jsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYjtcbn1cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgRm9ybURhdGE7XG59XG5jbGFzcyBSZXNwb25zZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc3BvbnNlRXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdXNlLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkZldGNoRXJyb3JcIjtcbiAgICB9XG59XG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5mdW5jdGlvbiBxdWVyeXN0cmluZyhwYXJhbXMsIHByZWZpeCA9ICcnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgICAgLm1hcChrZXkgPT4gcXVlcnlzdHJpbmdTaW5nbGVLZXkoa2V5LCBwYXJhbXNba2V5XSwgcHJlZml4KSlcbiAgICAgICAgLmZpbHRlcihwYXJ0ID0+IHBhcnQubGVuZ3RoID4gMClcbiAgICAgICAgLmpvaW4oJyYnKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5KGtleSwgdmFsdWUsIGtleVByZWZpeCA9ICcnKSB7XG4gICAgY29uc3QgZnVsbEtleSA9IGtleVByZWZpeCArIChrZXlQcmVmaXgubGVuZ3RoID8gYFske2tleX1dYCA6IGtleSk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgbXVsdGlWYWx1ZSA9IHZhbHVlLm1hcChzaW5nbGVWYWx1ZSA9PiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNpbmdsZVZhbHVlKSkpXG4gICAgICAgICAgICAuam9pbihgJiR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT1gKTtcbiAgICAgICAgcmV0dXJuIGAke2VuY29kZVVSSUNvbXBvbmVudChmdWxsS2V5KX09JHttdWx0aVZhbHVlfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUFzQXJyYXkgPSBBcnJheS5mcm9tKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5c3RyaW5nU2luZ2xlS2V5KGtleSwgdmFsdWVBc0FycmF5LCBrZXlQcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoZnVsbEtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlLnRvSVNPU3RyaW5nKCkpfWA7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcXVlcnlzdHJpbmcodmFsdWUsIGZ1bGxLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGZ1bGxLZXkpfT0ke2VuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKX1gO1xufVxuY2xhc3MgSlNPTkFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcsIHRyYW5zZm9ybWVyID0gKGpzb25WYWx1ZSkgPT4ganNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtZXIoeWllbGQgdGhpcy5yYXcuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVm9pZEFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogU3RyZWFtIEFQSVxuICogTm8gZGVzY3JpcHRpb24gcHJvdmlkZWQgKGdlbmVyYXRlZCBieSBPcGVuYXBpIEdlbmVyYXRvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFwaXRvb2xzL29wZW5hcGktZ2VuZXJhdG9yKVxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiB2MTAwLjQuM1xuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbi8qKlxuICpcbiAqL1xuY2xhc3MgRGVmYXVsdEFwaSBleHRlbmRzIEJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgdXNlciwgcHJldmVudGluZyB0aGVtIGZyb20gam9pbmluZyB0aGUgY2FsbCB1bnRpbCB0aGV5IGFyZSB1bmJsb2NrZWQuICBTZW5kcyBldmVudHM6IC0gY2FsbC5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIEJsb2NrIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9CbG9ja1VzZXJSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9CbG9ja1VzZXJSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vYmxvY2tgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0Jsb2NrVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJsb2NrIGEgdXNlciwgcHJldmVudGluZyB0aGVtIGZyb20gam9pbmluZyB0aGUgY2FsbCB1bnRpbCB0aGV5IGFyZSB1bmJsb2NrZWQuICBTZW5kcyBldmVudHM6IC0gY2FsbC5ibG9ja2VkX3VzZXIgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEJsb2NrVXNlclxuICAgICAqIEJsb2NrIHVzZXIgb24gYSBjYWxsXG4gICAgICovXG4gICAgYmxvY2tVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBkZXZpY2UgdG8gYSB1c2VyLCBpZiB0aGUgc2FtZSBkZXZpY2UgYWxyZWFkeSBleGlzdHMgdGhlIGNhbGwgd2lsbCBoYXZlIG5vIGVmZmVjdFxuICAgICAqIENyZWF0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBjcmVhdGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVEZXZpY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZURldmljZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZGV2aWNlIHRvIGEgdXNlciwgaWYgdGhlIHNhbWUgZGV2aWNlIGFscmVhZHkgZXhpc3RzIHRoZSBjYWxsIHdpbGwgaGF2ZSBubyBlZmZlY3RcbiAgICAgKiBDcmVhdGUgZGV2aWNlXG4gICAgICovXG4gICAgY3JlYXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlRGV2aWNlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGUgR3Vlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlR3Vlc3RSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY3JlYXRlR3Vlc3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2d1ZXN0YCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVHdWVzdFJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIEd1ZXN0XG4gICAgICovXG4gICAgY3JlYXRlR3Vlc3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jcmVhdGVHdWVzdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgb25lIGRldmljZVxuICAgICAqIERlbGV0ZSBkZXZpY2VcbiAgICAgKi9cbiAgICBkZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy51c2VySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1sndXNlcl9pZCddID0gcmVxdWVzdFBhcmFtZXRlcnMudXNlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2RldmljZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIG9uZSBkZXZpY2VcbiAgICAgKiBEZWxldGUgZGV2aWNlXG4gICAgICovXG4gICAgZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzID0ge30sIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5kZWxldGVEZXZpY2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLmVuZGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBFbmRDYWxsXG4gICAgICogRW5kIGNhbGxcbiAgICAgKi9cbiAgICBlbmRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGVuZENhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBlbmRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9tYXJrX2VuZGVkYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuZW5kZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIEVuZENhbGxcbiAgICAgKiBFbmQgY2FsbFxuICAgICAqL1xuICAgIGVuZENhbGwocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5lbmRDYWxsUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIEdldCBDYWxsXG4gICAgICovXG4gICAgZ2V0Q2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0Q2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubWVtYmVyc0xpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ21lbWJlcnNfbGltaXQnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLm1lbWJlcnNMaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5yaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ3JpbmcnXSA9IHJlcXVlc3RQYXJhbWV0ZXJzLnJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMubm90aWZ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbJ25vdGlmeSddID0gcmVxdWVzdFBhcmFtZXRlcnMubm90aWZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogR2V0IENhbGxcbiAgICAgKi9cbiAgICBnZXRDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGVkZ2VzIGF2YWlsYWJsZSBmb3IgdmlkZW8gY2FsbHMuXG4gICAgICogR2V0IEVkZ2VzXG4gICAgICovXG4gICAgZ2V0RWRnZXNSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZWRnZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBlZGdlcyBhdmFpbGFibGUgZm9yIHZpZGVvIGNhbGxzLlxuICAgICAqIEdldCBFZGdlc1xuICAgICAqL1xuICAgIGdldEVkZ2VzKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5nZXRFZGdlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBjcmVhdGVzIGEgbmV3IGNhbGwgIFNlbmRzIGV2ZW50czogLSBjYWxsLmNyZWF0ZWQgLSBjYWxsLm5vdGlmaWNhdGlvbiAtIGNhbGwucmluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gQ3JlYXRlQ2FsbCAtIFJlYWRDYWxsIC0gVXBkYXRlQ2FsbFNldHRpbmdzXG4gICAgICogR2V0IG9yIGNyZWF0ZSBhIGNhbGxcbiAgICAgKi9cbiAgICBnZXRPckNyZWF0ZUNhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ2V0T3JDcmVhdGVDYWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGdldE9yQ3JlYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9YC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9HZXRPckNyZWF0ZUNhbGxSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIGNyZWF0ZXMgYSBuZXcgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGNhbGwuY3JlYXRlZCAtIGNhbGwubm90aWZpY2F0aW9uIC0gY2FsbC5yaW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBDcmVhdGVDYWxsIC0gUmVhZENhbGwgLSBVcGRhdGVDYWxsU2V0dGluZ3NcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEgY2FsbFxuICAgICAqL1xuICAgIGdldE9yQ3JlYXRlQ2FsbChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdldE9yQ3JlYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubGl2ZV9zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbGl2ZVxuICAgICAqL1xuICAgIGdvTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnb0xpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvR29MaXZlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvR29MaXZlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9Hb0xpdmVSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZ29MaXZlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L2dvX2xpdmVgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0dvTGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubGl2ZV9zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogU2V0IGNhbGwgYXMgbGl2ZVxuICAgICAqL1xuICAgIGdvTGl2ZShyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmdvTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnVzZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWyd1c2VyX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy51c2VySWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZGV2aWNlc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBkZXZpY2VzXG4gICAgICogTGlzdCBkZXZpY2VzXG4gICAgICovXG4gICAgbGlzdERldmljZXMocmVxdWVzdFBhcmFtZXRlcnMgPSB7fSwgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3REZXZpY2VzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgcmVjb3JkaW5ncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFJlY29yZGluZ3NcbiAgICAgKiBMaXN0IHJlY29yZGluZ3NcbiAgICAgKi9cbiAgICBsaXN0UmVjb3JkaW5nc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBsaXN0UmVjb3JkaW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGxpc3RSZWNvcmRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9yZWNvcmRpbmdzYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgcmVjb3JkaW5ncyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gTGlzdFJlY29yZGluZ3NcbiAgICAgKiBMaXN0IHJlY29yZGluZ3NcbiAgICAgKi9cbiAgICBsaXN0UmVjb3JkaW5ncyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmxpc3RSZWNvcmRpbmdzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdHJhbnNjcmlwdGlvbnMgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIExpc3RUcmFuc2NyaXB0aW9uc1xuICAgICAqIExpc3QgdHJhbnNjcmlwdGlvbnNcbiAgICAgKi9cbiAgICBsaXN0VHJhbnNjcmlwdGlvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFRyYW5zY3JpcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgbGlzdFRyYW5zY3JpcHRpb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS90cmFuc2NyaXB0aW9uc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRyYW5zY3JpcHRpb25zICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBMaXN0VHJhbnNjcmlwdGlvbnNcbiAgICAgKiBMaXN0IHRyYW5zY3JpcHRpb25zXG4gICAgICovXG4gICAgbGlzdFRyYW5zY3JpcHRpb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdFRyYW5zY3JpcHRpb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgdXNlcnMgaW4gYSBjYWxsICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlcnNcbiAgICAgKiBNdXRlIHVzZXJzXG4gICAgICovXG4gICAgbXV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIG11dGVVc2Vycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9NdXRlVXNlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9NdXRlVXNlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb011dGVVc2Vyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBtdXRlVXNlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vbXV0ZV91c2Vyc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvTXV0ZVVzZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXV0ZXMgdXNlcnMgaW4gYSBjYWxsICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBNdXRlVXNlcnNcbiAgICAgKiBNdXRlIHVzZXJzXG4gICAgICovXG4gICAgbXV0ZVVzZXJzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubXV0ZVVzZXJzUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbHMgd2l0aCBmaWx0ZXIgcXVlcnkgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlYWRDYWxsXG4gICAgICogUXVlcnkgY2FsbFxuICAgICAqL1xuICAgIHF1ZXJ5Q2FsbHNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgcXVlcnlDYWxscy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzWydjb25uZWN0aW9uX2lkJ10gPSByZXF1ZXN0UGFyYW1ldGVycy5jb25uZWN0aW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlDYWxsc1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNhbGxzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGxcbiAgICAgKi9cbiAgICBxdWVyeUNhbGxzKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucXVlcnlDYWxsc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVycyB3aXRoIGZpbHRlciBxdWVyeSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUmVhZENhbGxcbiAgICAgKiBRdWVyeSBjYWxsIG1lbWJlcnNcbiAgICAgKi9cbiAgICBxdWVyeU1lbWJlcnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1F1ZXJ5TWVtYmVyc1JlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBxdWVyeU1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwvbWVtYmVyc2AsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvUXVlcnlNZW1iZXJzUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgY2FsbCBtZW1iZXJzIHdpdGggZmlsdGVyIHF1ZXJ5ICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZWFkQ2FsbFxuICAgICAqIFF1ZXJ5IGNhbGwgbWVtYmVyc1xuICAgICAqL1xuICAgIHF1ZXJ5TWVtYmVycyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnF1ZXJ5TWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGN1c3RvbSBldmVudCB0byB0aGUgY2FsbCAgU2VuZHMgZXZlbnRzOiAtIGN1c3RvbSAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU2VuZEV2ZW50XG4gICAgICogU2VuZCBjdXN0b20gZXZlbnRcbiAgICAgKi9cbiAgICBzZW5kRXZlbnRSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc2VuZEV2ZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1NlbmRFdmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1NlbmRFdmVudFJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHNlbmRFdmVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9ldmVudGAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU2VuZEV2ZW50UmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgY3VzdG9tIGV2ZW50IHRvIHRoZSBjYWxsICBTZW5kcyBldmVudHM6IC0gY3VzdG9tICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTZW5kRXZlbnRcbiAgICAgKiBTZW5kIGN1c3RvbSBldmVudFxuICAgICAqL1xuICAgIHNlbmRFdmVudChyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnNlbmRFdmVudFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBITFMgYnJvYWRjYXN0aW5nICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydEJyb2FkY2FzdGluZ1xuICAgICAqIFN0YXJ0IEhMUyBicm9hZGNhc3RpbmdcbiAgICAgKi9cbiAgICBzdGFydEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0SExTQnJvYWRjYXN0aW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9zdGFydF9icm9hZGNhc3RpbmdgLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0YXJ0QnJvYWRjYXN0aW5nXG4gICAgICogU3RhcnQgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0YXJ0SExTQnJvYWRjYXN0aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRITFNCcm9hZGNhc3RpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcmVjb3JkaW5nICBTZW5kcyBldmVudHM6IC0gY2FsbC5yZWNvcmRpbmdfc3RhcnRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRSZWNvcmRpbmdcbiAgICAgKiBTdGFydCByZWNvcmRpbmdcbiAgICAgKi9cbiAgICBzdGFydFJlY29yZGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RhcnRfcmVjb3JkaW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFJlY29yZGluZ1JlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyByZWNvcmRpbmcgIFNlbmRzIGV2ZW50czogLSBjYWxsLnJlY29yZGluZ19zdGFydGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFJlY29yZGluZ1xuICAgICAqIFN0YXJ0IHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0YXJ0UmVjb3JkaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJhbnNjcmlwdGlvbiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RhcnRUcmFuc2NyaXB0aW9uXG4gICAgICogU3RhcnQgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHN0YXJ0VHJhbnNjcmlwdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdGFydFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RhcnRUcmFuc2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0YXJ0X3RyYW5zY3JpcHRpb25gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1N0YXJ0VHJhbnNjcmlwdGlvblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0cmFuc2NyaXB0aW9uICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdGFydFRyYW5zY3JpcHRpb25cbiAgICAgKiBTdGFydCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RhcnRUcmFuc2NyaXB0aW9uKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgSExTIGJyb2FkY2FzdGluZyAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gU3RvcEJyb2FkY2FzdGluZ1xuICAgICAqIFN0b3AgSExTIGJyb2FkY2FzdGluZ1xuICAgICAqL1xuICAgIHN0b3BITFNCcm9hZGNhc3RpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcEhMU0Jyb2FkY2FzdGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BITFNCcm9hZGNhc3RpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfYnJvYWRjYXN0aW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIEhMUyBicm9hZGNhc3RpbmcgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BCcm9hZGNhc3RpbmdcbiAgICAgKiBTdG9wIEhMUyBicm9hZGNhc3RpbmdcbiAgICAgKi9cbiAgICBzdG9wSExTQnJvYWRjYXN0aW5nKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuc3RvcEhMU0Jyb2FkY2FzdGluZ1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFNldCBjYWxsIGFzIG5vdCBsaXZlXG4gICAgICovXG4gICAgc3RvcExpdmVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcExpdmUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBzdG9wTGl2ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vc3RvcF9saXZlYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFxuICAgICAqIFNldCBjYWxsIGFzIG5vdCBsaXZlXG4gICAgICovXG4gICAgc3RvcExpdmUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wTGl2ZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BSZWNvcmRpbmdcbiAgICAgKiBTdG9wIHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0b3BSZWNvcmRpbmdSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFJlY29yZGluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BSZWNvcmRpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfcmVjb3JkaW5nYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHJlY29yZGluZyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucmVjb3JkaW5nX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BSZWNvcmRpbmdcbiAgICAgKiBTdG9wIHJlY29yZGluZ1xuICAgICAqL1xuICAgIHN0b3BSZWNvcmRpbmcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wUmVjb3JkaW5nUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdHJhbnNjcmlwdGlvbiAgU2VuZHMgZXZlbnRzOiAtIGNhbGwudHJhbnNjcmlwdGlvbl9zdG9wcGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBTdG9wVHJhbnNjcmlwdGlvblxuICAgICAqIFN0b3AgdHJhbnNjcmlwdGlvblxuICAgICAqL1xuICAgIHN0b3BUcmFuc2NyaXB0aW9uUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHN0b3BUcmFuc2NyaXB0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgc3RvcFRyYW5zY3JpcHRpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3N0b3BfdHJhbnNjcmlwdGlvbmAucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0cmFuc2NyaXB0aW9uICBTZW5kcyBldmVudHM6IC0gY2FsbC50cmFuc2NyaXB0aW9uX3N0b3BwZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFN0b3BUcmFuc2NyaXB0aW9uXG4gICAgICogU3RvcCB0cmFuc2NyaXB0aW9uXG4gICAgICovXG4gICAgc3RvcFRyYW5zY3JpcHRpb24ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zdG9wVHJhbnNjcmlwdGlvblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJsb2NrIGZvciBhIHVzZXIgb24gYSBjYWxsLiBUaGUgdXNlciB3aWxsIGJlIGFibGUgdG8gam9pbiB0aGUgY2FsbCBhZ2Fpbi4gIFNlbmRzIGV2ZW50czogLSBjYWxsLnVuYmxvY2tlZF91c2VyICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCbG9ja1VzZXJcbiAgICAgKiBVbmJsb2NrcyB1c2VyIG9uIGEgY2FsbFxuICAgICAqL1xuICAgIHVuYmxvY2tVc2VyUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndHlwZScsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVuYmxvY2tVc2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdW5ibG9ja1VzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1bmJsb2NrVXNlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS91bmJsb2NrYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbmJsb2NrVXNlclJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGJsb2NrIGZvciBhIHVzZXIgb24gYSBjYWxsLiBUaGUgdXNlciB3aWxsIGJlIGFibGUgdG8gam9pbiB0aGUgY2FsbCBhZ2Fpbi4gIFNlbmRzIGV2ZW50czogLSBjYWxsLnVuYmxvY2tlZF91c2VyICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBCbG9ja1VzZXJcbiAgICAgKiBVbmJsb2NrcyB1c2VyIG9uIGEgY2FsbFxuICAgICAqL1xuICAgIHVuYmxvY2tVc2VyKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudW5ibG9ja1VzZXJSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLnVwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxcbiAgICAgKiBVcGRhdGUgQ2FsbFxuICAgICAqL1xuICAgIHVwZGF0ZUNhbGxSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9VcGRhdGVDYWxsUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH1gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogICBTZW5kcyBldmVudHM6IC0gY2FsbC51cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBVcGRhdGVDYWxsXG4gICAgICogVXBkYXRlIENhbGxcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlQ2FsbFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICAgU2VuZHMgZXZlbnRzOiAtIGNhbGwubWVtYmVyX2FkZGVkIC0gY2FsbC5tZW1iZXJfcmVtb3ZlZCAtIGNhbGwubWVtYmVyX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFJlbW92ZUNhbGxNZW1iZXIgLSBVcGRhdGVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlclJvbGVcbiAgICAgKiBVcGRhdGUgQ2FsbCBNZW1iZXJcbiAgICAgKi9cbiAgICB1cGRhdGVDYWxsTWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3R5cGUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsTWVtYmVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUNhbGxNZW1iZXJzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9VcGRhdGVDYWxsTWVtYmVyc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0IHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbE1lbWJlcnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGwve3R5cGV9L3tpZH0vbWVtYmVyc2AucmVwbGFjZShgeyR7XCJ0eXBlXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMudHlwZSkpKS5yZXBsYWNlKGB7JHtcImlkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMuaWQpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlQ2FsbE1lbWJlcnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgIFNlbmRzIGV2ZW50czogLSBjYWxsLm1lbWJlcl9hZGRlZCAtIGNhbGwubWVtYmVyX3JlbW92ZWQgLSBjYWxsLm1lbWJlcl91cGRhdGVkICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBSZW1vdmVDYWxsTWVtYmVyIC0gVXBkYXRlQ2FsbE1lbWJlciAtIFVwZGF0ZUNhbGxNZW1iZXJSb2xlXG4gICAgICogVXBkYXRlIENhbGwgTWVtYmVyXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbE1lbWJlcnMocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsTWVtYmVyc1JhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBwZXJtaXNzaW9ucyAgU2VuZHMgZXZlbnRzOiAtIGNhbGwucGVybWlzc2lvbnNfdXBkYXRlZCAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gVXBkYXRlQ2FsbFBlcm1pc3Npb25zXG4gICAgICogVXBkYXRlIHVzZXIgcGVybWlzc2lvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVVc2VyUGVybWlzc2lvbnNSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcignaWQnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLmlkIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlVXNlclBlcm1pc3Npb25zLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZVVzZXJQZXJtaXNzaW9uc1JlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZVVzZXJQZXJtaXNzaW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS91c2VyX3Blcm1pc3Npb25zYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgcGVybWlzc2lvbnMgIFNlbmRzIGV2ZW50czogLSBjYWxsLnBlcm1pc3Npb25zX3VwZGF0ZWQgIFJlcXVpcmVkIHBlcm1pc3Npb25zOiAtIFVwZGF0ZUNhbGxQZXJtaXNzaW9uc1xuICAgICAqIFVwZGF0ZSB1c2VyIHBlcm1pc3Npb25zXG4gICAgICovXG4gICAgdXBkYXRlVXNlclBlcm1pc3Npb25zKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gZm9yIHVzZXIgdG8gdmlkZW8gIFNlbmRzIGV2ZW50czogLSBjb25uZWN0aW9uLm9rIC0gaGVhbHRoLmNoZWNrXG4gICAgICogVmlkZW8gQ29ubmVjdCAoV2ViU29ja2V0KVxuICAgICAqL1xuICAgIHZpZGVvQ29ubmVjdFJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9XU0F1dGhNZXNzYWdlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ3ZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb0Nvbm5lY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2Nvbm5lY3RgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvV1NBdXRoTWVzc2FnZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZEFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIFdlYlNvY2tldCBjb25uZWN0aW9uIGZvciB1c2VyIHRvIHZpZGVvICBTZW5kcyBldmVudHM6IC0gY29ubmVjdGlvbi5vayAtIGhlYWx0aC5jaGVja1xuICAgICAqIFZpZGVvIENvbm5lY3QgKFdlYlNvY2tldClcbiAgICAgKi9cbiAgICB2aWRlb0Nvbm5lY3QocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudmlkZW9Db25uZWN0UmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbnMgYSB0cmFjayBmb3IgYWxsIHVzZXJzIGluIHRoZSBjYWxsLiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUGluQ2FsbFRyYWNrXG4gICAgICogUGluXG4gICAgICovXG4gICAgdmlkZW9QaW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9QaW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCdpZCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMuaWQgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9QaW5SZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVxdWlyZWRFcnJvcigndmlkZW9QaW5SZXF1ZXN0JywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1Bpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbC97dHlwZX0ve2lkfS9waW5gLnJlcGxhY2UoYHske1widHlwZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUpKSkucmVwbGFjZShgeyR7XCJpZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLmlkKSkpLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1BpblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpbnMgYSB0cmFjayBmb3IgYWxsIHVzZXJzIGluIHRoZSBjYWxsLiAgUmVxdWlyZWQgcGVybWlzc2lvbnM6IC0gUGluQ2FsbFRyYWNrXG4gICAgICogUGluXG4gICAgICovXG4gICAgdmlkZW9QaW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy52aWRlb1BpblJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBVbnBpblxuICAgICAqL1xuICAgIHZpZGVvVW5waW5SYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy50eXBlID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd0eXBlJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy50eXBlIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdmlkZW9VbnBpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ2lkJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5pZCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHZpZGVvVW5waW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VucGluUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB2aWRlb1VucGluLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsL3t0eXBlfS97aWR9L3VucGluYC5yZXBsYWNlKGB7JHtcInR5cGVcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy50eXBlKSkpLnJlcGxhY2UoYHske1wiaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhyZXF1ZXN0UGFyYW1ldGVycy5pZCkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VbnBpblJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucGlucyBhIHRyYWNrIGZvciBhbGwgdXNlcnMgaW4gdGhlIGNhbGwuICBSZXF1aXJlZCBwZXJtaXNzaW9uczogLSBQaW5DYWxsVHJhY2tcbiAgICAgKiBVbnBpblxuICAgICAqL1xuICAgIHZpZGVvVW5waW4ocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy52aWRlb1VucGluUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBTZXJ2ZXJTaWRlQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgY2hlY2tFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgY2hlY2tFeHRlcm5hbFN0b3JhZ2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9leHRlcm5hbF9zdG9yYWdlL3tuYW1lfS9jaGVja2AucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgY2hlY2tFeHRlcm5hbFN0b3JhZ2UocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jaGVja0V4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUeXBlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUNhbGxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBjcmVhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzYCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9DcmVhdGVDYWxsVHlwZVJlcXVlc3QsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlbGV0ZSBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBkZWxldGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBkZWxldGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVsZXRlIENhbGwgVHlwZVxuICAgICAqL1xuICAgIGRlbGV0ZUNhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldCBDYWxsIFR5cGVcbiAgICAgKi9cbiAgICBnZXRDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkRXJyb3IoJ25hbWUnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyBnZXRDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIlN0cmVhbS1BdXRoLVR5cGVcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiU3RyZWFtLUF1dGgtVHlwZVwiKTsgLy8gc3RyZWFtLWF1dGgtdHlwZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbWV0ZXJzW1wiYXBpX2tleVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJhcGlfa2V5XCIpOyAvLyBhcGlfa2V5IGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJBdXRob3JpemF0aW9uXCIpOyAvLyBKV1QgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBgL3ZpZGVvL2NhbGx0eXBlcy97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogR2V0IENhbGwgVHlwZVxuICAgICAqL1xuICAgIGdldENhbGxUeXBlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZ2V0Q2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3QgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgbGlzdENhbGxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJTdHJlYW0tQXV0aC1UeXBlXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIlN0cmVhbS1BdXRoLVR5cGVcIik7IC8vIHN0cmVhbS1hdXRoLXR5cGUgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1ldGVyc1tcImFwaV9rZXlcIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiYXBpX2tleVwiKTsgLy8gYXBpX2tleSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbiAmJiB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXBpS2V5KFwiQXV0aG9yaXphdGlvblwiKTsgLy8gSldUIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogYC92aWRlby9jYWxsdHlwZXNgLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3QgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgbGlzdENhbGxUeXBlcyhpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMubGlzdENhbGxUeXBlc1Jhdyhpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFR5cGVSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlQ2FsbFR5cGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QgPT09IG51bGwgfHwgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCcsICdSZXF1aXJlZCBwYXJhbWV0ZXIgcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVDYWxsVHlwZVJlcXVlc3Qgd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyB1cGRhdGVDYWxsVHlwZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vY2FsbHR5cGVzL3tuYW1lfWAucmVwbGFjZShgeyR7XCJuYW1lXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocmVxdWVzdFBhcmFtZXRlcnMubmFtZSkpKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlclBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGUgQ2FsbCBUeXBlXG4gICAgICovXG4gICAgdXBkYXRlQ2FsbFR5cGUocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51cGRhdGVDYWxsVHlwZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzcG9uc2UudmFsdWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXBkYXRlIEV4dGVybmFsIFN0b3JhZ2VcbiAgICAgKi9cbiAgICB1cGRhdGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvVXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIHVwZGF0ZUV4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZS97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogcmVxdWVzdFBhcmFtZXRlcnMudmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSwgaW5pdE92ZXJyaWRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05BcGlSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZSBFeHRlcm5hbCBTdG9yYWdlXG4gICAgICovXG4gICAgdXBkYXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXBkYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBTdHJlYW0gQVBJXG4gKiBObyBkZXNjcmlwdGlvbiBwcm92aWRlZCAoZ2VuZXJhdGVkIGJ5IE9wZW5hcGkgR2VuZXJhdG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYXBpdG9vbHMvb3BlbmFwaS1nZW5lcmF0b3IpXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IHYxMDAuNC4zXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuLyoqXG4gKlxuICovXG5jbGFzcyBTZXR0aW5nc0FwaSBleHRlbmRzIEJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBDcmVhdGUgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGNyZWF0ZUV4dGVybmFsU3RvcmFnZVJhdyhyZXF1ZXN0UGFyYW1ldGVycywgaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCA9PT0gbnVsbCB8fCByZXF1ZXN0UGFyYW1ldGVycy52aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCd2aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QnLCAnUmVxdWlyZWQgcGFyYW1ldGVyIHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCB3YXMgbnVsbCBvciB1bmRlZmluZWQgd2hlbiBjYWxsaW5nIGNyZWF0ZUV4dGVybmFsU3RvcmFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyUGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgaGVhZGVyUGFyYW1ldGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3RQYXJhbWV0ZXJzLnZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCxcbiAgICAgICAgICAgIH0sIGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQXBpUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIENyZWF0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgY3JlYXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBleHRlcm5hbCBzdG9yYWdlXG4gICAgICogRGVsZXRlIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBkZWxldGVFeHRlcm5hbFN0b3JhZ2VSYXcocmVxdWVzdFBhcmFtZXRlcnMsIGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0UGFyYW1ldGVycy5uYW1lID09PSBudWxsIHx8IHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZEVycm9yKCduYW1lJywgJ1JlcXVpcmVkIHBhcmFtZXRlciByZXF1ZXN0UGFyYW1ldGVycy5uYW1lIHdhcyBudWxsIG9yIHVuZGVmaW5lZCB3aGVuIGNhbGxpbmcgZGVsZXRlRXh0ZXJuYWxTdG9yYWdlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZS97bmFtZX1gLnJlcGxhY2UoYHske1wibmFtZVwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHJlcXVlc3RQYXJhbWV0ZXJzLm5hbWUpKSksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIERlbGV0ZSBleHRlcm5hbCBzdG9yYWdlXG4gICAgICovXG4gICAgZGVsZXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZGVsZXRlRXh0ZXJuYWxTdG9yYWdlUmF3KHJlcXVlc3RQYXJhbWV0ZXJzLCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNwb25zZS52YWx1ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqIExpc3QgZXh0ZXJuYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIGxpc3RFeHRlcm5hbFN0b3JhZ2VSYXcoaW5pdE92ZXJyaWRlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJQYXJhbWV0ZXJzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJQYXJhbWV0ZXJzW1wiU3RyZWFtLUF1dGgtVHlwZVwiXSA9IHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkoXCJTdHJlYW0tQXV0aC1UeXBlXCIpOyAvLyBzdHJlYW0tYXV0aC10eXBlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uICYmIHRoaXMuY29uZmlndXJhdGlvbi5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtZXRlcnNbXCJhcGlfa2V5XCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcImFwaV9rZXlcIik7IC8vIGFwaV9rZXkgYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24gJiYgdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGhlYWRlclBhcmFtZXRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gdGhpcy5jb25maWd1cmF0aW9uLmFwaUtleShcIkF1dGhvcml6YXRpb25cIik7IC8vIEpXVCBhdXRoZW50aWNhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGAvdmlkZW8vZXh0ZXJuYWxfc3RvcmFnZWAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeVBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9LCBpbml0T3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTkFwaVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKiBMaXN0IGV4dGVybmFsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBsaXN0RXh0ZXJuYWxTdG9yYWdlKGluaXRPdmVycmlkZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5saXN0RXh0ZXJuYWxTdG9yYWdlUmF3KGluaXRPdmVycmlkZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLnZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtQ2FsbCB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtQ2xpZW50LCB0eXBlLCBpZCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmJsb2NrVXNlciA9ICh2aWRlb0Jsb2NrVXNlclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5ibG9ja1VzZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb0Jsb2NrVXNlclJlcXVlc3QgfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZENhbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuZW5kQ2FsbChPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5nZXRDYWxsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3QgIT09IG51bGwgJiYgcmVxdWVzdCAhPT0gdm9pZCAwID8gcmVxdWVzdCA6IHt9KSksIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRPckNyZWF0ZSA9ICh2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5nZXRPckNyZWF0ZUNhbGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJhc2VSZXF1ZXN0KSwgeyB2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3Q6IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCAhPT0gbnVsbCAmJiB2aWRlb0dldE9yQ3JlYXRlQ2FsbFJlcXVlc3QgIT09IHZvaWQgMCA/IHZpZGVvR2V0T3JDcmVhdGVDYWxsUmVxdWVzdCA6IHt9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSAoZ2V0T3JDcmVhdGVDYWxsUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JDcmVhdGUoZ2V0T3JDcmVhdGVDYWxsUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ29MaXZlID0gKHZpZGVvR29MaXZlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LmdvTGl2ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvR29MaXZlUmVxdWVzdDogdmlkZW9Hb0xpdmVSZXF1ZXN0ICE9PSBudWxsICYmIHZpZGVvR29MaXZlUmVxdWVzdCAhPT0gdm9pZCAwID8gdmlkZW9Hb0xpdmVSZXF1ZXN0IDoge30gfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3RSZWNvcmRpbmdzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50Lmxpc3RSZWNvcmRpbmdzKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tdXRlVXNlcnMgPSAodmlkZW9NdXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQubXV0ZVVzZXJzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9NdXRlVXNlcnNSZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeU1lbWJlcnMgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnF1ZXJ5TWVtYmVycyh7XG4gICAgICAgICAgICAgICAgdmlkZW9RdWVyeU1lbWJlcnNSZXF1ZXN0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSkpLCB0aGlzLmJhc2VSZXF1ZXN0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnNlbmRFdmVudChPYmplY3QuYXNzaWduKHsgdmlkZW9TZW5kRXZlbnRSZXF1ZXN0OiB7IGN1c3RvbTogZXZlbnQgfSB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRITFNCcm9hZGNhc3RpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RhcnRITFNCcm9hZGNhc3RpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5zdGFydFJlY29yZGluZyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpLCB7IHZpZGVvU3RhcnRSZWNvcmRpbmdSZXF1ZXN0OiByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRUcmFuc2NyaXB0aW9uID0gKHZpZGVvU3RhcnRUcmFuc2NyaXB0aW9uUmVxdWVzdCA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQuc3RhcnRUcmFuc2NyaXB0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCksIHsgdmlkZW9TdGFydFRyYW5zY3JpcHRpb25SZXF1ZXN0IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wSExTQnJvYWRjYXN0aW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BITFNCcm9hZGNhc3RpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BMaXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BMaXZlKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BSZWNvcmRpbmcoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0b3BUcmFuc2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnN0b3BUcmFuc2NyaXB0aW9uKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bmJsb2NrVXNlciA9ICh2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVuYmxvY2tVc2VyKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VuYmxvY2tVc2VyUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gKHZpZGVvVXBkYXRlQ2FsbFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC51cGRhdGVDYWxsKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZUNhbGxSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsTWVtYmVycyA9ICh2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZUNhbGxNZW1iZXJzKE9iamVjdC5hc3NpZ24oeyB2aWRlb1VwZGF0ZUNhbGxNZW1iZXJzUmVxdWVzdCB9LCB0aGlzLmJhc2VSZXF1ZXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlVXNlclBlcm1pc3Npb25zID0gKHZpZGVvVXBkYXRlVXNlclBlcm1pc3Npb25zUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2xpZW50LnVwZGF0ZVVzZXJQZXJtaXNzaW9ucyhPYmplY3QuYXNzaWduKHsgdmlkZW9VcGRhdGVVc2VyUGVybWlzc2lvbnNSZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5waW5WaWRlbyA9ICh2aWRlb1BpblJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC52aWRlb1BpbihPYmplY3QuYXNzaWduKHsgdmlkZW9QaW5SZXF1ZXN0IH0sIHRoaXMuYmFzZVJlcXVlc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnBpblZpZGVvID0gKHZpZGVvVW5waW5SZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnQudmlkZW9VbnBpbihPYmplY3QuYXNzaWduKHsgdmlkZW9VbnBpblJlcXVlc3QgfSwgdGhpcy5iYXNlUmVxdWVzdCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhc2VSZXF1ZXN0ID0geyBpZDogdGhpcy5pZCwgdHlwZTogdGhpcy50eXBlIH07XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLnN0cmVhbUNsaWVudC5nZXRDb25maWd1cmF0aW9uKCd2aWRlbycpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBEZWZhdWx0QXBpKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyZWFtVmlkZW9DbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbUNsaWVudCkge1xuICAgICAgICB0aGlzLnN0cmVhbUNsaWVudCA9IHN0cmVhbUNsaWVudDtcbiAgICAgICAgdGhpcy5jYWxsID0gKHR5cGUsIGlkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUNhbGwodGhpcy5zdHJlYW1DbGllbnQsIHR5cGUsIGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWVyeUNhbGxzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudC5xdWVyeUNhbGxzKHtcbiAgICAgICAgICAgICAgICB2aWRlb1F1ZXJ5Q2FsbHNSZXF1ZXN0OiByZXF1ZXN0ICE9PSBudWxsICYmIHJlcXVlc3QgIT09IHZvaWQgMCA/IHJlcXVlc3QgOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbGxUeXBlID0gKHZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQuY3JlYXRlQ2FsbFR5cGUoe1xuICAgICAgICAgICAgICAgIHZpZGVvQ3JlYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FsbFR5cGUgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmRlbGV0ZUNhbGxUeXBlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENhbGxUeXBlID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC5nZXRDYWxsVHlwZShyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Q2FsbFR5cGVzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50Lmxpc3RDYWxsVHlwZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsVHlwZSA9IChuYW1lLCB2aWRlb1VwZGF0ZUNhbGxUeXBlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LnVwZGF0ZUNhbGxUeXBlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZpZGVvVXBkYXRlQ2FsbFR5cGVSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdEV4dGVybmFsU3RvcmFnZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc0FwaS5saXN0RXh0ZXJuYWxTdG9yYWdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlID0gKHZpZGVvQ3JlYXRlRXh0ZXJuYWxTdG9yYWdlUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuY3JlYXRlRXh0ZXJuYWxTdG9yYWdlKHtcbiAgICAgICAgICAgICAgICB2aWRlb0NyZWF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVFeHRlcm5hbFN0b3JhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3NBcGkuZGVsZXRlRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUV4dGVybmFsU3RvcmFnZSA9IChuYW1lLCB2aWRlb1VwZGF0ZUV4dGVybmFsU3RvcmFnZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZGVvU2VydmVyU2lkZUFwaUNsaWVudC51cGRhdGVFeHRlcm5hbFN0b3JhZ2Uoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmlkZW9VcGRhdGVFeHRlcm5hbFN0b3JhZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hlY2tFeHRlcm5hbFN0b3JhZ2UgPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9TZXJ2ZXJTaWRlQXBpQ2xpZW50LmNoZWNrRXh0ZXJuYWxTdG9yYWdlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5zdHJlYW1DbGllbnQuZ2V0Q29uZmlndXJhdGlvbigndmlkZW8nKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgRGVmYXVsdEFwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0FwaSA9IG5ldyBTZXR0aW5nc0FwaShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgdGhpcy52aWRlb1NlcnZlclNpZGVBcGlDbGllbnQgPSBuZXcgU2VydmVyU2lkZUFwaShjb25maWd1cmF0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEpXVFVzZXJUb2tlbihhcGlTZWNyZXQsIHVzZXJJZCwgZXh0cmFEYXRhID0ge30sIGp3dE9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1c2VySWQgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHsgdXNlcl9pZDogdXNlcklkIH0sIGV4dHJhRGF0YSk7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHJldHVybiBhIGNsZWFyIGVycm9yIHdoZW4gand0IGlzIHNoaW1tZWQgKGllLiBicm93c2VyIGJ1aWxkKVxuICAgIGlmIChqd3QgPT0gbnVsbCB8fCBqd3Quc2lnbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBqd3QgY3J5cHRvLCBpZiB5b3UgYXJlIGdldHRpbmcgdGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHlvdSBhcmUgdHJ5aW5nIHRvIGdlbmVyYXRlIHRva2VucyBvbiBicm93c2VyIG9yIFJlYWN0IE5hdGl2ZSAob3Igb3RoZXIgZW52aXJvbm1lbnQgd2hlcmUgY3J5cHRvIGZ1bmN0aW9ucyBhcmUgbm90IGF2YWlsYWJsZSkuIFBsZWFzZSBOb3RlOiB0b2tlbiBzaG91bGQgb25seSBiZSBnZW5lcmF0ZWQgc2VydmVyLXNpZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgYWxnb3JpdGhtOiAnSFMyNTYnLCBub1RpbWVzdGFtcDogdHJ1ZSB9LCBqd3RPcHRpb25zKTtcbiAgICBpZiAocGF5bG9hZC5pYXQpIHtcbiAgICAgICAgb3B0cy5ub1RpbWVzdGFtcCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gand0LnNpZ24ocGF5bG9hZCwgYXBpU2VjcmV0LCBvcHRzKTtcbn1cbmZ1bmN0aW9uIEpXVFNlcnZlclRva2VuKGFwaVNlY3JldCwgand0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgc2VydmVyOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBhbGdvcml0aG06ICdIUzI1NicsIG5vVGltZXN0YW1wOiB0cnVlIH0sIGp3dE9wdGlvbnMpO1xuICAgIHJldHVybiBqd3Quc2lnbihwYXlsb2FkLCBhcGlTZWNyZXQsIG9wdHMpO1xufVxuXG5jbGFzcyBTdHJlYW1DbGllbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwaUtleVxuICAgICAqIEBwYXJhbSBzZWNyZXRcbiAgICAgKiBAcGFyYW0gY29uZmlnIGNhbiBiZSBhIHN0cmluZywgd2hpY2ggd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBiYXNlIHBhdGggKGRlcHJlY2F0ZWQpLCBvciBhIGNvbmZpZyBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIHNlY3JldCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuY3JlYXRlRGV2aWNlID0gKGNyZWF0ZURldmljZVJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldmljZXNBcGkuY3JlYXRlRGV2aWNlKHsgY3JlYXRlRGV2aWNlUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGVEZXZpY2UgPSAocmVxdWVzdFBhcmFtZXRlcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRldmljZXNBcGkuZGVsZXRlRGV2aWNlKHJlcXVlc3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0RGV2aWNlcyA9IChyZXF1ZXN0UGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV2aWNlc0FwaS5saXN0RGV2aWNlcyhyZXF1ZXN0UGFyYW1ldGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdFB1c2hQcm92aWRlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoQXBpLmxpc3RQdXNoUHJvdmlkZXJzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlUHVzaFByb3ZpZGVyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hBcGkuZGVsZXRlUHVzaFByb3ZpZGVyKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwc2VydFB1c2hQcm92aWRlciA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzaWRlQXBpLnVwc2VydFB1c2hQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgdXBzZXJ0UHVzaFByb3ZpZGVyUmVxdWVzdDogeyBwdXNoX3Byb3ZpZGVyOiByZXF1ZXN0IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGVja1B1c2ggPSAoY2hlY2tQdXNoUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVzdGluZ0FwaS5jaGVja1B1c2goeyBjaGVja1B1c2hSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNyZWF0ZUd1ZXN0ID0gKGd1ZXN0UmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZ3Vlc3RSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGd1ZXN0UmVxdWVzdC51c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5jcmVhdGVHdWVzdCh7IGd1ZXN0UmVxdWVzdCB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUocmVzcG9uc2UudXNlcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhblVzZXIgPSAoYmFuUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgYmFuUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChiYW5SZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgYmFuUmVxdWVzdC5iYW5uZWRfYnkgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKGJhblJlcXVlc3QuYmFubmVkX2J5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmJhbih7IGJhblJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZVVzZXIgPSAoZGVhY3RpdmF0ZVVzZXJSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkuZGVhY3RpdmF0ZVVzZXIoe1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVVc2VyUmVxdWVzdCxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IGRlYWN0aXZhdGVVc2VyUmVxdWVzdC51c2VyX2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlVXNlcnMgPSAoZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkuZGVhY3RpdmF0ZVVzZXJzKHsgZGVhY3RpdmF0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBgZGVsZXRlVXNlcnNgIGluc3RlYWRcbiAgICAgICAgICogQHBhcmFtIGRlbGV0ZVVzZXJzUmVxdWVzdFxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxldGVVc2VyID0gKHJlcXVlc3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy51c2Vyc0FwaS5kZWxldGVVc2VyKHJlcXVlc3QpO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsZXRlVXNlcnMgPSAoZGVsZXRlVXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5kZWxldGVVc2Vycyh7IGRlbGV0ZVVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHBvcnRVc2VyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLmV4cG9ydFVzZXIocmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXhwb3J0VXNlcnMgPSAoZXhwb3J0VXNlcnNSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2Vyc0FwaS5leHBvcnRVc2Vycyh7IGV4cG9ydFVzZXJzUmVxdWVzdCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mbGFnID0gKGZsYWdSZXF1ZXN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICAgICAgZmxhZ1JlcXVlc3QudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQoZmxhZ1JlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkuZmxhZyh7IGZsYWdSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgaWYgKChfYiA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZmxhZy51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKChfYyA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlCYW5uZWRVc2VycyA9IChwYXlsb2FkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHBheWxvYWQudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucXVlcnlCYW5uZWRVc2Vycyh7IHBheWxvYWQgfSk7XG4gICAgICAgICAgICByZXNwb25zZS5iYW5zLmZvckVhY2goKGIpID0+IHtcbiAgICAgICAgICAgICAgICBiLmJhbm5lZF9ieSA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShiLmJhbm5lZF9ieSk7XG4gICAgICAgICAgICAgICAgYi51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKGIudXNlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlVc2VycyA9IChwYXlsb2FkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHBheWxvYWQudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkucXVlcnlVc2Vycyh7IHBheWxvYWQgfSk7XG4gICAgICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlcnMgPSByZXNwb25zZS51c2Vycy5tYXAoKHUpID0+IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZSh1KSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlYWN0aXZhdGVVc2VyID0gKHJlYWN0aXZhdGVVc2VyUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnJlYWN0aXZhdGVVc2VyKHtcbiAgICAgICAgICAgICAgICByZWFjdGl2YXRlVXNlclJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdXNlcklkOiByZWFjdGl2YXRlVXNlclJlcXVlc3QudXNlcl9pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2UudXNlciA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhY3RpdmF0ZVVzZXJzID0gKHJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnJlYWN0aXZhdGVVc2Vycyh7IHJlYWN0aXZhdGVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzdG9yZVVzZXJzID0gKHJlc3RvcmVVc2Vyc1JlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnJlc3RvcmVVc2Vycyh7IHJlc3RvcmVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5iYW5Vc2VyID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJzQXBpLnVuYmFuKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuZmxhZyA9IChmbGFnUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9kO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnVuZmxhZyh7IGZsYWdSZXF1ZXN0IH0pO1xuICAgICAgICAgICAgaWYgKChfZCA9IHJlc3BvbnNlLmZsYWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZmxhZy51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLmZsYWcudXNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwc2VydFVzZXJzID0gKHVwZGF0ZVVzZXJzUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXBkYXRlVXNlcnNSZXF1ZXN0LnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVVc2Vyc1JlcXVlc3QudXNlcnNba2V5XSA9IHRoaXMubWFwQ3VzdG9tRGF0YUJlZm9yZVNlbmQodXBkYXRlVXNlcnNSZXF1ZXN0LnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkudXBkYXRlVXNlcnMoeyB1cGRhdGVVc2Vyc1JlcXVlc3QgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXNwb25zZS51c2VycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UudXNlcnNba2V5XSA9IHRoaXMubWFwQ3VzdG9tRGF0YUFmdGVyUmVjZWl2ZShyZXNwb25zZS51c2Vyc1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVVc2Vyc1BhcnRpYWwgPSAocmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnVzZXJzQXBpLnVwZGF0ZVVzZXJzUGFydGlhbCh7XG4gICAgICAgICAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB1cGRhdGVVc2VyUGFydGlhbFJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3BvbnNlLnVzZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS51c2Vyc1trZXldID0gdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHJlc3BvbnNlLnVzZXJzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11dGVVc2VyID0gKG11dGVVc2VyUmVxdWVzdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9lLCBfZjtcbiAgICAgICAgICAgIG11dGVVc2VyUmVxdWVzdC51c2VyID0gdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZChtdXRlVXNlclJlcXVlc3QudXNlcik7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMudXNlcnNBcGkubXV0ZVVzZXIoeyBtdXRlVXNlclJlcXVlc3QgfSk7XG4gICAgICAgICAgICBpZiAoKF9lID0gcmVzcG9uc2UubXV0ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5tdXRlLnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFBZnRlclJlY2VpdmUoKF9mID0gcmVzcG9uc2UubXV0ZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm11dGVzKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UubXV0ZXMgPSByZXNwb25zZS5tdXRlcy5tYXAoKG0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbSksIHsgdXNlcjogdGhpcy5tYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKG0udXNlcikgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVubXV0ZVVzZXIgPSAodW5tdXRlVXNlclJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHVubXV0ZVVzZXJSZXF1ZXN0LnVzZXIgPSB0aGlzLm1hcEN1c3RvbURhdGFCZWZvcmVTZW5kKHVubXV0ZVVzZXJSZXF1ZXN0LnVzZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlcnNBcGkudW5tdXRlVXNlcih7IHVubXV0ZVVzZXJSZXF1ZXN0IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlbmRDdXN0b21FdmVudFRvVXNlciA9ICh1c2VySWQsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNBcGkuc2VuZFVzZXJDdXN0b21FdmVudCh7XG4gICAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICAgIHNlbmRVc2VyQ3VzdG9tRXZlbnRSZXF1ZXN0OiB7IGV2ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jcmVhdGVSb2xlID0gKGNyZWF0ZVJvbGVSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5jcmVhdGVSb2xlKHsgY3JlYXRlUm9sZVJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVsZXRlUm9sZSA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5kZWxldGVSb2xlKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFBlcm1pc3Npb24gPSAocmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVybWlzc2lvbnNBcGkuZ2V0UGVybWlzc2lvbihyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0UGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5saXN0UGVybWlzc2lvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0Um9sZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc0FwaS5saXN0Um9sZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRBcHBTZXR0aW5ncyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldEFwcCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUFwcFNldHRpbmdzID0gKHVwZGF0ZUFwcFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLnVwZGF0ZUFwcCh7IHVwZGF0ZUFwcFJlcXVlc3QgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmF0ZUxpbWl0cyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzQXBpLmdldFJhdGVMaW1pdHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRUYXNrU3RhdHVzID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhc2tzQXBpLmdldFRhc2socmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmVyaWZ5V2ViaG9vayA9IChyZXF1ZXN0Qm9keSwgeFNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20odGhpcy5zZWNyZXQsICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvXG4gICAgICAgICAgICAgICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGtleSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKHJlcXVlc3RCb2R5KVxuICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnRpbWluZ1NhZmVFcXVhbChCdWZmZXIuZnJvbShoYXNoKSwgQnVmZmVyLmZyb20oeFNpZ25hdHVyZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb25maWd1cmF0aW9uID0gKHByb2R1Y3QgPSAnY2hhdCcpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYXBpS2V5OiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1N0cmVhbS1BdXRoLVR5cGUnOiAnand0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogdGhpcy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdbbmFtZV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXNlUGF0aDogKF9hID0gdGhpcy5vcHRpb25zLmJhc2VQYXRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocHJvZHVjdCA9PT0gJ2NoYXQnXG4gICAgICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vY2hhdC5zdHJlYW0taW8tYXBpLmNvbSdcbiAgICAgICAgICAgICAgICAgICAgOiAnaHR0cHM6Ly92aWRlby5zdHJlYW0taW8tYXBpLmNvbScpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ1gtU3RyZWFtLUNsaWVudCc6ICdzdHJlYW0tbm9kZS0nICsgXCIwLjEuMTJcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pZGRsZXdhcmU6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaW5pdC5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmluaXQuaGVhZGVycyksIHsgJ3gtY2xpZW50LXJlcXVlc3QtaWQnOiB2NCgpLCAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgbGFzdCBwb3N0IG1pZGRsZXdhcmUgYmVjYXVzZSB0aGF0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBGZXRjaCBBUEkgd29uJ3QgdGhyb3cgYW4gZXJyb3IgZm9yIEhUVFAgZXJyb3IgcmVzcG9uc2VzLCB3aGljaCBtZWFucyB0aGUgXCJvbkVycm9yXCIgbWlkZGxld2FyZSB3b24ndCBiZSBjYWxsZWQgc28gd2UgbmVlZCB0byB0aHJvdyBlcnJvciBmcm9tIFwicG9zdFwiIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Q6IChjb250ZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZXh0LnJlc3BvbnNlICYmIGNvbnRleHQucmVzcG9uc2Uuc3RhdHVzIDwgMjAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgSlNPTkFwaVJlc3BvbnNlKGNvbnRleHQucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICh5aWVsZCByZXNwb25zZS52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJlYW0gZXJyb3IgY29kZSAke3ZhbHVlLmNvZGV9OiAke3ZhbHVlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZTogKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmluaXQuc2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dCh0aGlzLm9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY29udGV4dC5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKGVycm9yLCBgVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQgZHVlIHRvIHRvIHRoZSAke3RoaXMub3B0aW9ucy50aW1lb3V0fW1zIHRpbWVvdXQsIHlvdSBjYW4gc2V0IHRoZSB0aW1lb3V0IGluIHRoZSBTdHJlYW1DbGllbnQgY29uc3RydWN0b3JgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vT3BlbkFQSVRvb2xzL29wZW5hcGktZ2VuZXJhdG9yL2lzc3Vlcy8xMzIyMlxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zU3RyaW5naWZ5OiAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXNba10pIHx8IHR5cGVvZiBwYXJhbXNba10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zLnB1c2goYCR7a309JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tdKSl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BhcmFtcy5wdXNoKGAke2t9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1BhcmFtcy5qb2luKCcmJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc2VydmVkS2V5d29yZHMgPSBbXG4gICAgICAgICAgICAnYmFuX2V4cGlyZXMnLFxuICAgICAgICAgICAgJ2Jhbm5lZCcsXG4gICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgJ2ludmlzaWJsZScsXG4gICAgICAgICAgICAnbGFuZ3VhZ2UnLFxuICAgICAgICAgICAgJ3B1c2hfbm90aWZpY2F0aW9ucycsXG4gICAgICAgICAgICAncmV2b2tlX3Rva2Vuc19pc3N1ZWRfYmVmb3JlJyxcbiAgICAgICAgICAgICdyb2xlJyxcbiAgICAgICAgICAgICd0ZWFtcycsXG4gICAgICAgICAgICAnY3JlYXRlZF9hdCcsXG4gICAgICAgICAgICAnZGVhY3RpdmF0ZWRfYXQnLFxuICAgICAgICAgICAgJ2RlbGV0ZWRfYXQnLFxuICAgICAgICAgICAgJ2xhc3RfYWN0aXZlJyxcbiAgICAgICAgICAgICdvbmxpbmUnLFxuICAgICAgICAgICAgJ3VwZGF0ZWRfYXQnLFxuICAgICAgICAgICAgJ3NoYWRvd19iYW5uZWQnLFxuICAgICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5tYXBDdXN0b21EYXRhQmVmb3JlU2VuZCA9ICh1c2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIHVzZXIpO1xuICAgICAgICAgICAgZGVsZXRlIGNvcHkuY3VzdG9tO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weSksIHVzZXIuY3VzdG9tKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b2tlbiA9IEpXVFNlcnZlclRva2VuKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmFzZVBhdGggPSBjb25maWc7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudGltZW91dCA9IFN0cmVhbUNsaWVudC5ERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRpbWVvdXQgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZGVvID0gbmV3IFN0cmVhbVZpZGVvQ2xpZW50KHRoaXMpO1xuICAgICAgICB0aGlzLmNoYXQgPSBuZXcgU3RyZWFtQ2hhdENsaWVudCh0aGlzKTtcbiAgICAgICAgY29uc3QgY2hhdENvbmZpZ3VyYXRpb24gPSB0aGlzLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy51c2Vyc0FwaSA9IG5ldyBVc2Vyc0FwaShjaGF0Q29uZmlndXJhdGlvbik7XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIHRoaXMuZGV2aWNlc0FwaSA9IG5ldyBEZXZpY2VzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy5wdXNoQXBpID0gbmV3IFB1c2hBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnNlcnZlcnNpZGVBcGkgPSBuZXcgU2VydmVyU2lkZUFwaSQxKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICAgICAgLyoqIEB0cy1leHBlY3QtZXJyb3IgKi9cbiAgICAgICAgdGhpcy50ZXN0aW5nQXBpID0gbmV3IFRlc3RpbmdBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zQXBpID0gbmV3IFBlcm1pc3Npb25zVjJBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzQXBpID0gbmV3IFNldHRpbmdzQXBpJDEoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLmV2ZW50c0FwaSA9IG5ldyBFdmVudHNBcGkoY2hhdENvbmZpZ3VyYXRpb24pO1xuICAgICAgICAvKiogQHRzLWV4cGVjdC1lcnJvciAqL1xuICAgICAgICB0aGlzLnRhc2tzQXBpID0gbmV3IFRhc2tzQXBpKGNoYXRDb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcklEXG4gICAgICogQHBhcmFtIGV4cFxuICAgICAqIEBwYXJhbSBpYXQgZGVwcmVjYXRlZCwgdGhlIGRlZmF1bHQgZGF0ZSB3aWxsIGJlIHNldCBpbnRlcm5hbGx5XG4gICAgICogQHBhcmFtIGNhbGxfY2lkcyB0aGlzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIHVzZSBgY3JlYXRlQ2FsbFRva2VuYCBmb3IgY2FsbCB0b2tlbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNyZWF0ZVRva2VuKHVzZXJJRCwgZXhwID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCwgaWF0ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCksIGNhbGxfY2lkcykge1xuICAgICAgICBjb25zdCBleHRyYSA9IHt9O1xuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICBleHRyYS5leHAgPSBleHA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlhdCkge1xuICAgICAgICAgICAgZXh0cmEuaWF0ID0gaWF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsX2NpZHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVXNlIGNyZWF0ZUNhbGxUb2tlbiBtZXRob2QgZm9yIGNyZWF0aW5nIGNhbGwgdG9rZW5zLCB0aGUgXCJjYWxsX2NpZHNcIiBwYXJhbSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgY3JlYXRlVG9rZW4gbWV0aG9kIHdpdGggdmVyc2lvbiAwLjIuMGApO1xuICAgICAgICAgICAgZXh0cmEuY2FsbF9jaWRzID0gY2FsbF9jaWRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VySURcbiAgICAgKiBAcGFyYW0gY2FsbF9jaWRzXG4gICAgICogQHBhcmFtIGV4cFxuICAgICAqIEBwYXJhbSBpYXQgdGhpcyBpcyBkZXByZWNhdGVkLCB0aGUgY3VycmVudCBkYXRlIHdpbGwgYmUgc2V0IGludGVybmFsbHlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNyZWF0ZUNhbGxUb2tlbih1c2VySUQsIGNhbGxfY2lkcywgZXhwID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCwgaWF0ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkpIHtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgZXh0cmEuZXhwID0gZXhwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpYXQpIHtcbiAgICAgICAgICAgIGV4dHJhLmlhdCA9IGlhdDtcbiAgICAgICAgfVxuICAgICAgICBleHRyYS5jYWxsX2NpZHMgPSBjYWxsX2NpZHM7XG4gICAgICAgIHJldHVybiBKV1RVc2VyVG9rZW4odGhpcy5zZWNyZXQsIHVzZXJJRCwgZXh0cmEpO1xuICAgIH1cbiAgICBtYXBDdXN0b21EYXRhQWZ0ZXJSZWNlaXZlKHVzZXIpIHtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1c2VyKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNlcnZlZEtleXdvcmRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5jdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN1c3RvbSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuY3VzdG9tW2tleV0gPSB1c2VyW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHVzZXJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuU3RyZWFtQ2xpZW50LkRFRkFVTFRfVElNRU9VVCA9IDMwMDA7XG5cbmV4cG9ydCB7IEFQTkNvbmZpZ1JlcXVlc3RBdXRoVHlwZUVudW0sIEFwcFNlYXJjaEJhY2tlbmRFbnVtLCBBc3luY01vZGVyYXRpb25DYWxsYmFja0NvbmZpZ1JlcXVlc3RNb2RlRW51bSwgQXVkaW9TZXR0aW5nc0RlZmF1bHREZXZpY2VFbnVtLCBCbG9ja0xpc3RPcHRpb25zQmVoYXZpb3JFbnVtLCBCbG9ja0xpc3RPcHRpb25zUmVxdWVzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdBdXRvbW9kRW51bSwgQ2hhbm5lbENvbmZpZ0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hhbm5lbENvbmZpZ1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb0F1dG9tb2RFbnVtLCBDaGFubmVsQ29uZmlnV2l0aEluZm9CbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RBdXRvbW9kQmVoYXZpb3JFbnVtLCBDaGFubmVsQ29uZmlnV2l0aEluZm9SZXF1ZXN0QXV0b21vZEVudW0sIENoYW5uZWxDb25maWdXaXRoSW5mb1JlcXVlc3RCbG9ja2xpc3RCZWhhdmlvckVudW0sIENoYW5uZWxNZW1iZXJSZXF1ZXN0Um9sZUVudW0sIENoYW5uZWxNZW1iZXJSb2xlRW51bSwgQ2hhbm5lbFR5cGVDb25maWdBdXRvbW9kQmVoYXZpb3JFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0F1dG9tb2RFbnVtLCBDaGFubmVsVHlwZUNvbmZpZ0Jsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ2hlY2tQdXNoUmVxdWVzdFB1c2hQcm92aWRlclR5cGVFbnVtLCBDaGVja1NOU1Jlc3BvbnNlU3RhdHVzRW51bSwgQ2hlY2tTUVNSZXNwb25zZVN0YXR1c0VudW0sIENvbmZpZ0RlZmF1bHRSb2xlRW51bSwgQ29uZmlnUmVxdWVzdERlZmF1bHRSb2xlRW51bSwgQ3JlYXRlQ2FsbFJlcXVlc3RUeXBlRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0sIENyZWF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0sIENyZWF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSwgQ3JlYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSwgQ3JlYXRlRGV2aWNlUmVxdWVzdFB1c2hQcm92aWRlckVudW0sIENyZWF0ZUltcG9ydFJlcXVlc3RNb2RlRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0Q29udmVyc2F0aW9uc0VudW0sIERlbGV0ZVVzZXJzUmVxdWVzdE1lc3NhZ2VzRW51bSwgRGVsZXRlVXNlcnNSZXF1ZXN0VXNlckVudW0sIERldmljZUZpZWxkc1B1c2hQcm92aWRlckVudW0sIERldmljZVB1c2hQcm92aWRlckVudW0sIERldmljZVJlcXVlc3RQdXNoUHJvdmlkZXJFbnVtLCBJbWFnZVNpemVDcm9wRW51bSwgSW1hZ2VTaXplUmVzaXplRW51bSwgTGF5b3V0U2V0dGluZ3NOYW1lRW51bSwgTWVzc2FnZVJlcXVlc3QxVHlwZUVudW0sIE1lc3NhZ2VSZXF1ZXN0VHlwZUVudW0sIE1lc3NhZ2VUeXBlRW51bSwgUGVybWlzc2lvbkxldmVsRW51bSwgUG9saWN5UmVxdWVzdDFBY3Rpb25FbnVtLCBQb2xpY3lSZXF1ZXN0QWN0aW9uRW51bSwgUHVzaENvbmZpZ1JlcXVlc3RWZXJzaW9uRW51bSwgU3RyZWFtQ2FsbCwgU3RyZWFtQ2hhbm5lbCwgU3RyZWFtQ2hhdENsaWVudCwgU3RyZWFtQ2xpZW50LCBTdHJlYW1WaWRlb0NsaWVudCwgVHJhbnNjcmlwdGlvblNldHRpbmdzTW9kZUVudW0sIFRyYW5zbGF0ZU1lc3NhZ2VSZXF1ZXN0TGFuZ3VhZ2VFbnVtLCBVcGRhdGVBcHBSZXF1ZXN0RW5mb3JjZVVuaXF1ZVVzZXJuYW1lc0VudW0sIFVwZGF0ZUFwcFJlcXVlc3RQZXJtaXNzaW9uVmVyc2lvbkVudW0sIFVwZGF0ZUFwcFJlcXVlc3RWaWRlb1Byb3ZpZGVyRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXF1ZXN0QXV0b21vZEVudW0sIFVwZGF0ZUNoYW5uZWxUeXBlUmVxdWVzdEJsb2NrbGlzdEJlaGF2aW9yRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUF1dG9tb2RCZWhhdmlvckVudW0sIFVwZGF0ZUNoYW5uZWxUeXBlUmVzcG9uc2VBdXRvbW9kRW51bSwgVXBkYXRlQ2hhbm5lbFR5cGVSZXNwb25zZUJsb2NrbGlzdEJlaGF2aW9yRW51bSwgVmlkZW9BdWRpb1NldHRpbmdzRGVmYXVsdERldmljZUVudW0sIFZpZGVvQXVkaW9TZXR0aW5nc1JlcXVlc3REZWZhdWx0RGV2aWNlRW51bSwgVmlkZW9DcmVhdGVEZXZpY2VSZXF1ZXN0UHVzaFByb3ZpZGVyRW51bSwgVmlkZW9MYXlvdXRTZXR0aW5nc05hbWVFbnVtLCBWaWRlb0xheW91dFNldHRpbmdzUmVxdWVzdE5hbWVFbnVtLCBWaWRlb093bkNhcGFiaWxpdHksIFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0TW9kZUVudW0sIFZpZGVvUmVjb3JkU2V0dGluZ3NSZXF1ZXN0UXVhbGl0eUVudW0sIFZpZGVvU2V0dGluZ3NDYW1lcmFGYWNpbmdFbnVtLCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc01vZGVFbnVtLCBWaWRlb1RyYW5zY3JpcHRpb25TZXR0aW5nc1JlcXVlc3RNb2RlRW51bSwgVmlkZW9WaWRlb1NldHRpbmdzQ2FtZXJhRmFjaW5nRW51bSwgVmlkZW9WaWRlb1NldHRpbmdzUmVxdWVzdENhbWVyYUZhY2luZ0VudW0gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@stream-io/node-sdk/dist/index.es.js\n");

/***/ })

};
;